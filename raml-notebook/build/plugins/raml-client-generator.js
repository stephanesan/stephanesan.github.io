(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.ramlClientGeneratorPlugin = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){

},{}],2:[function(require,module,exports){
(function (global){
'use strict';

var buffer = require('buffer');
var Buffer = buffer.Buffer;
var SlowBuffer = buffer.SlowBuffer;
var MAX_LEN = buffer.kMaxLength || 2147483647;
exports.alloc = function alloc(size, fill, encoding) {
  if (typeof Buffer.alloc === 'function') {
    return Buffer.alloc(size, fill, encoding);
  }
  if (typeof encoding === 'number') {
    throw new TypeError('encoding must not be number');
  }
  if (typeof size !== 'number') {
    throw new TypeError('size must be a number');
  }
  if (size > MAX_LEN) {
    throw new RangeError('size is too large');
  }
  var enc = encoding;
  var _fill = fill;
  if (_fill === undefined) {
    enc = undefined;
    _fill = 0;
  }
  var buf = new Buffer(size);
  if (typeof _fill === 'string') {
    var fillBuf = new Buffer(_fill, enc);
    var flen = fillBuf.length;
    var i = -1;
    while (++i < size) {
      buf[i] = fillBuf[i % flen];
    }
  } else {
    buf.fill(_fill);
  }
  return buf;
}
exports.allocUnsafe = function allocUnsafe(size) {
  if (typeof Buffer.allocUnsafe === 'function') {
    return Buffer.allocUnsafe(size);
  }
  if (typeof size !== 'number') {
    throw new TypeError('size must be a number');
  }
  if (size > MAX_LEN) {
    throw new RangeError('size is too large');
  }
  return new Buffer(size);
}
exports.from = function from(value, encodingOrOffset, length) {
  if (typeof Buffer.from === 'function' && (!global.Uint8Array || Uint8Array.from !== Buffer.from)) {
    return Buffer.from(value, encodingOrOffset, length);
  }
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof value === 'string') {
    return new Buffer(value, encodingOrOffset);
  }
  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    var offset = encodingOrOffset;
    if (arguments.length === 1) {
      return new Buffer(value);
    }
    if (typeof offset === 'undefined') {
      offset = 0;
    }
    var len = length;
    if (typeof len === 'undefined') {
      len = value.byteLength - offset;
    }
    if (offset >= value.byteLength) {
      throw new RangeError('\'offset\' is out of bounds');
    }
    if (len > value.byteLength - offset) {
      throw new RangeError('\'length\' is out of bounds');
    }
    return new Buffer(value.slice(offset, offset + len));
  }
  if (Buffer.isBuffer(value)) {
    var out = new Buffer(value.length);
    value.copy(out, 0, 0, value.length);
    return out;
  }
  if (value) {
    if (Array.isArray(value) || (typeof ArrayBuffer !== 'undefined' && value.buffer instanceof ArrayBuffer) || 'length' in value) {
      return new Buffer(value);
    }
    if (value.type === 'Buffer' && Array.isArray(value.data)) {
      return new Buffer(value.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ' + 'ArrayBuffer, Array, or array-like object.');
}
exports.allocUnsafeSlow = function allocUnsafeSlow(size) {
  if (typeof Buffer.allocUnsafeSlow === 'function') {
    return Buffer.allocUnsafeSlow(size);
  }
  if (typeof size !== 'number') {
    throw new TypeError('size must be a number');
  }
  if (size >= MAX_LEN) {
    throw new RangeError('size is too large');
  }
  return new SlowBuffer(size);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"buffer":6}],3:[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this,{"isBuffer":require("../../is-buffer/index.js")})

},{"../../is-buffer/index.js":21}],4:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)
	var PLUS_URL_SAFE = '-'.charCodeAt(0)
	var SLASH_URL_SAFE = '_'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS ||
		    code === PLUS_URL_SAFE)
			return 62 // '+'
		if (code === SLASH ||
		    code === SLASH_URL_SAFE)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],5:[function(require,module,exports){
arguments[4][1][0].apply(exports,arguments)
},{"dup":1}],6:[function(require,module,exports){
(function (global){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var rootParent = {}

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
 *     on objects.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

function typedArraySupport () {
  function Bar () {}
  try {
    var arr = new Uint8Array(1)
    arr.foo = function () { return 42 }
    arr.constructor = Bar
    return arr.foo() === 42 && // typed array instances can be augmented
        arr.constructor === Bar && // constructor can be set
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (arg) {
  if (!(this instanceof Buffer)) {
    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
    if (arguments.length > 1) return new Buffer(arg, arguments[1])
    return new Buffer(arg)
  }

  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    this.length = 0
    this.parent = undefined
  }

  // Common case.
  if (typeof arg === 'number') {
    return fromNumber(this, arg)
  }

  // Slightly less common case.
  if (typeof arg === 'string') {
    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
  }

  // Unusual.
  return fromObject(this, arg)
}

function fromNumber (that, length) {
  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < length; i++) {
      that[i] = 0
    }
  }
  return that
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'

  // Assumption: byteLength() return value is always < kMaxLength.
  var length = byteLength(string, encoding) | 0
  that = allocate(that, length)

  that.write(string, encoding)
  return that
}

function fromObject (that, object) {
  if (Buffer.isBuffer(object)) return fromBuffer(that, object)

  if (isArray(object)) return fromArray(that, object)

  if (object == null) {
    throw new TypeError('must start with number, buffer, array or string')
  }

  if (typeof ArrayBuffer !== 'undefined') {
    if (object.buffer instanceof ArrayBuffer) {
      return fromTypedArray(that, object)
    }
    if (object instanceof ArrayBuffer) {
      return fromArrayBuffer(that, object)
    }
  }

  if (object.length) return fromArrayLike(that, object)

  return fromJsonObject(that, object)
}

function fromBuffer (that, buffer) {
  var length = checked(buffer.length) | 0
  that = allocate(that, length)
  buffer.copy(that, 0, 0, length)
  return that
}

function fromArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Duplicate of fromArray() to keep fromArray() monomorphic.
function fromTypedArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  // Truncating the elements is probably not what people expect from typed
  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
  // of the old Buffer constructor.
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    array.byteLength
    that = Buffer._augment(new Uint8Array(array))
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromTypedArray(that, new Uint8Array(array))
  }
  return that
}

function fromArrayLike (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
// Returns a zero-length buffer for inputs that don't conform to the spec.
function fromJsonObject (that, object) {
  var array
  var length = 0

  if (object.type === 'Buffer' && isArray(object.data)) {
    array = object.data
    length = checked(array.length) | 0
  }
  that = allocate(that, length)

  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
} else {
  // pre-set for values that may exist in the future
  Buffer.prototype.length = undefined
  Buffer.prototype.parent = undefined
}

function allocate (that, length) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = Buffer._augment(new Uint8Array(length))
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that.length = length
    that._isBuffer = true
  }

  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
  if (fromPool) that.parent = rootParent

  return that
}

function checked (length) {
  // Note: cannot use `length < kMaxLength` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (subject, encoding) {
  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

  var buf = new Buffer(subject, encoding)
  delete buf.parent
  return buf
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  var i = 0
  var len = Math.min(x, y)
  while (i < len) {
    if (a[i] !== b[i]) break

    ++i
  }

  if (i !== len) {
    x = a[i]
    y = b[i]
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

  if (list.length === 0) {
    return new Buffer(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; i++) {
      length += list[i].length
    }
  }

  var buf = new Buffer(length)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

function byteLength (string, encoding) {
  if (typeof string !== 'string') string = '' + string

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'binary':
      // Deprecated
      case 'raw':
      case 'raws':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  start = start | 0
  end = end === undefined || end === Infinity ? this.length : end | 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return 0
  return Buffer.compare(this, b)
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
  byteOffset >>= 0

  if (this.length === 0) return -1
  if (byteOffset >= this.length) return -1

  // Negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

  if (typeof val === 'string') {
    if (val.length === 0) return -1 // special case: looking for empty string always fails
    return String.prototype.indexOf.call(this, val, byteOffset)
  }
  if (Buffer.isBuffer(val)) {
    return arrayIndexOf(this, val, byteOffset)
  }
  if (typeof val === 'number') {
    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
    }
    return arrayIndexOf(this, [ val ], byteOffset)
  }

  function arrayIndexOf (arr, val, byteOffset) {
    var foundIndex = -1
    for (var i = 0; byteOffset + i < arr.length; i++) {
      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
      } else {
        foundIndex = -1
      }
    }
    return -1
  }

  throw new TypeError('val must be string, number or Buffer')
}

// `get` is deprecated
Buffer.prototype.get = function get (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` is deprecated
Buffer.prototype.set = function set (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) throw new Error('Invalid hex string')
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    var swap = encoding
    encoding = offset
    offset = length | 0
    length = swap
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'binary':
        return binaryWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function binarySlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
  }

  if (newBuf.length) newBuf.parent = this.parent || this

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
  if (offset < 0) throw new RangeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; i--) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; i++) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), targetStart)
  }

  return len
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new RangeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function _augment (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array set method before overwriting
  arr._set = arr.set

  // deprecated
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.indexOf = BP.indexOf
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUIntLE = BP.readUIntLE
  arr.readUIntBE = BP.readUIntBE
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readIntLE = BP.readIntLE
  arr.readIntBE = BP.readIntBE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUIntLE = BP.writeUIntLE
  arr.writeUIntBE = BP.writeUIntBE
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeIntLE = BP.writeIntLE
  arr.writeIntBE = BP.writeIntBE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; i++) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"base64-js":4,"ieee754":17,"isarray":7}],7:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],8:[function(require,module,exports){
module.exports = {
  "100": "Continue",
  "101": "Switching Protocols",
  "102": "Processing",
  "200": "OK",
  "201": "Created",
  "202": "Accepted",
  "203": "Non-Authoritative Information",
  "204": "No Content",
  "205": "Reset Content",
  "206": "Partial Content",
  "207": "Multi-Status",
  "300": "Multiple Choices",
  "301": "Moved Permanently",
  "302": "Moved Temporarily",
  "303": "See Other",
  "304": "Not Modified",
  "305": "Use Proxy",
  "307": "Temporary Redirect",
  "308": "Permanent Redirect",
  "400": "Bad Request",
  "401": "Unauthorized",
  "402": "Payment Required",
  "403": "Forbidden",
  "404": "Not Found",
  "405": "Method Not Allowed",
  "406": "Not Acceptable",
  "407": "Proxy Authentication Required",
  "408": "Request Time-out",
  "409": "Conflict",
  "410": "Gone",
  "411": "Length Required",
  "412": "Precondition Failed",
  "413": "Request Entity Too Large",
  "414": "Request-URI Too Large",
  "415": "Unsupported Media Type",
  "416": "Requested Range Not Satisfiable",
  "417": "Expectation Failed",
  "418": "I'm a teapot",
  "422": "Unprocessable Entity",
  "423": "Locked",
  "424": "Failed Dependency",
  "425": "Unordered Collection",
  "426": "Upgrade Required",
  "428": "Precondition Required",
  "429": "Too Many Requests",
  "431": "Request Header Fields Too Large",
  "500": "Internal Server Error",
  "501": "Not Implemented",
  "502": "Bad Gateway",
  "503": "Service Unavailable",
  "504": "Gateway Time-out",
  "505": "HTTP Version Not Supported",
  "506": "Variant Also Negotiates",
  "507": "Insufficient Storage",
  "509": "Bandwidth Limit Exceeded",
  "510": "Not Extended",
  "511": "Network Authentication Required"
}

},{}],9:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],10:[function(require,module,exports){

var hasOwn = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;

module.exports = function forEach (obj, fn, ctx) {
    if (toString.call(fn) !== '[object Function]') {
        throw new TypeError('iterator must be a function');
    }
    var l = obj.length;
    if (l === +l) {
        for (var i = 0; i < l; i++) {
            fn.call(ctx, obj[i], i, obj);
        }
    } else {
        for (var k in obj) {
            if (hasOwn.call(obj, k)) {
                fn.call(ctx, obj[k], k, obj);
            }
        }
    }
};


},{}],11:[function(require,module,exports){
var ClientRequest = require('./lib/request')
var extend = require('xtend')
var statusCodes = require('builtin-status-codes')
var url = require('url')

var http = exports

http.request = function (opts, cb) {
	if (typeof opts === 'string')
		opts = url.parse(opts)
	else
		opts = extend(opts)

	var protocol = opts.protocol || ''
	var host = opts.hostname || opts.host
	var port = opts.port
	var path = opts.path || '/'

	// Necessary for IPv6 addresses
	if (host && host.indexOf(':') !== -1)
		host = '[' + host + ']'

	// This may be a relative url. The browser should always be able to interpret it correctly.
	opts.url = (host ? (protocol + '//' + host) : '') + (port ? ':' + port : '') + path
	opts.method = (opts.method || 'GET').toUpperCase()
	opts.headers = opts.headers || {}

	// Also valid opts.auth, opts.mode

	var req = new ClientRequest(opts)
	if (cb)
		req.on('response', cb)
	return req
}

http.get = function get (opts, cb) {
	var req = http.request(opts, cb)
	req.end()
	return req
}

http.Agent = function () {}
http.Agent.defaultMaxSockets = 4

http.STATUS_CODES = statusCodes

http.METHODS = [
	'CHECKOUT',
	'CONNECT',
	'COPY',
	'DELETE',
	'GET',
	'HEAD',
	'LOCK',
	'M-SEARCH',
	'MERGE',
	'MKACTIVITY',
	'MKCOL',
	'MOVE',
	'NOTIFY',
	'OPTIONS',
	'PATCH',
	'POST',
	'PROPFIND',
	'PROPPATCH',
	'PURGE',
	'PUT',
	'REPORT',
	'SEARCH',
	'SUBSCRIBE',
	'TRACE',
	'UNLOCK',
	'UNSUBSCRIBE'
]
},{"./lib/request":13,"builtin-status-codes":8,"url":15,"xtend":69}],12:[function(require,module,exports){
(function (global){
exports.fetch = isFunction(global.fetch) && isFunction(global.ReadableByteStream)

exports.blobConstructor = false
try {
	new Blob([new ArrayBuffer(1)])
	exports.blobConstructor = true
} catch (e) {}

var xhr = new global.XMLHttpRequest()
// If location.host is empty, e.g. if this page/worker was loaded
// from a Blob, then use example.com to avoid an error
xhr.open('GET', global.location.host ? '/' : 'https://example.com')

function checkTypeSupport (type) {
	try {
		xhr.responseType = type
		return xhr.responseType === type
	} catch (e) {}
	return false
}

// For some strange reason, Safari 7.0 reports typeof global.ArrayBuffer === 'object'.
// Safari 7.1 appears to have fixed this bug.
var haveArrayBuffer = typeof global.ArrayBuffer !== 'undefined'
var haveSlice = haveArrayBuffer && isFunction(global.ArrayBuffer.prototype.slice)

exports.arraybuffer = haveArrayBuffer && checkTypeSupport('arraybuffer')
// These next two tests unavoidably show warnings in Chrome. Since fetch will always
// be used if it's available, just return false for these to avoid the warnings.
exports.msstream = !exports.fetch && haveSlice && checkTypeSupport('ms-stream')
exports.mozchunkedarraybuffer = !exports.fetch && haveArrayBuffer &&
	checkTypeSupport('moz-chunked-arraybuffer')
exports.overrideMimeType = isFunction(xhr.overrideMimeType)
exports.vbArray = isFunction(global.VBArray)

function isFunction (value) {
  return typeof value === 'function'
}

xhr = null // Help gc

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],13:[function(require,module,exports){
(function (process,global,Buffer){
// var Base64 = require('Base64')
var capability = require('./capability')
var foreach = require('foreach')
var indexOf = require('indexof')
var inherits = require('inherits')
var keys = require('object-keys')
var response = require('./response')
var stream = require('stream')

var IncomingMessage = response.IncomingMessage
var rStates = response.readyStates

function decideMode (preferBinary) {
	if (capability.fetch) {
		return 'fetch'
	} else if (capability.mozchunkedarraybuffer) {
		return 'moz-chunked-arraybuffer'
	} else if (capability.msstream) {
		return 'ms-stream'
	} else if (capability.arraybuffer && preferBinary) {
		return 'arraybuffer'
	} else if (capability.vbArray && preferBinary) {
		return 'text:vbarray'
	} else {
		return 'text'
	}
}

var ClientRequest = module.exports = function (opts) {
	var self = this
	stream.Writable.call(self)

	self._opts = opts
	self._body = []
	self._headers = {}
	if (opts.auth)
		self.setHeader('Authorization', 'Basic ' + new Buffer(opts.auth).toString('base64'))
	foreach(keys(opts.headers), function (name) {
		self.setHeader(name, opts.headers[name])
	})

	var preferBinary
	if (opts.mode === 'prefer-streaming') {
		// If streaming is a high priority but binary compatibility and
		// the accuracy of the 'content-type' header aren't
		preferBinary = false
	} else if (opts.mode === 'allow-wrong-content-type') {
		// If streaming is more important than preserving the 'content-type' header
		preferBinary = !capability.overrideMimeType
	} else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {
		// Use binary if text streaming may corrupt data or the content-type header, or for speed
		preferBinary = true
	} else {
		throw new Error('Invalid value for opts.mode')
	}
	self._mode = decideMode(preferBinary)

	self.on('finish', function () {
		self._onFinish()
	})
}

inherits(ClientRequest, stream.Writable)

ClientRequest.prototype.setHeader = function (name, value) {
	var self = this
	var lowerName = name.toLowerCase()
	// This check is not necessary, but it prevents warnings from browsers about setting unsafe
	// headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but
	// http-browserify did it, so I will too.
	if (indexOf(unsafeHeaders, lowerName) !== -1)
		return

	self._headers[lowerName] = {
		name: name,
		value: value
	}
}

ClientRequest.prototype.getHeader = function (name) {
	var self = this
	return self._headers[name.toLowerCase()].value
}

ClientRequest.prototype.removeHeader = function (name) {
	var self = this
	delete self._headers[name.toLowerCase()]
}

ClientRequest.prototype._onFinish = function () {
	var self = this

	if (self._destroyed)
		return
	var opts = self._opts

	var headersObj = self._headers
	var body
	if (opts.method === 'POST' || opts.method === 'PUT') {
		if (capability.blobConstructor) {
			body = new global.Blob(self._body.map(function (buffer) {
				return buffer.toArrayBuffer()
			}), {
				type: (headersObj['content-type'] || {}).value || ''
			})
		} else {
			// get utf8 string
			body = Buffer.concat(self._body).toString()
		}
	}

	if (self._mode === 'fetch') {
		var headers = keys(headersObj).map(function (name) {
			return [headersObj[name].name, headersObj[name].value]
		})

		global.fetch(self._opts.url, {
			method: self._opts.method,
			headers: headers,
			body: body,
			mode: 'cors',
			credentials: opts.withCredentials ? 'include' : 'same-origin'
		}).then(function (response) {
			self._fetchResponse = response
			self._connect()
		}).then(undefined, function (reason) {
			self.emit('error', reason)
		})
	} else {
		var xhr = self._xhr = new global.XMLHttpRequest()
		try {
			xhr.open(self._opts.method, self._opts.url, true)
		} catch (err) {
			process.nextTick(function () {
				self.emit('error', err)
			})
			return
		}

		// Can't set responseType on really old browsers
		if ('responseType' in xhr)
			xhr.responseType = self._mode.split(':')[0]

		if ('withCredentials' in xhr)
			xhr.withCredentials = !!opts.withCredentials

		if (self._mode === 'text' && 'overrideMimeType' in xhr)
			xhr.overrideMimeType('text/plain; charset=x-user-defined')

		foreach(keys(headersObj), function (name) {
			xhr.setRequestHeader(headersObj[name].name, headersObj[name].value)
		})

		self._response = null
		xhr.onreadystatechange = function () {
			switch (xhr.readyState) {
				case rStates.LOADING:
				case rStates.DONE:
					self._onXHRProgress()
					break
			}
		}
		// Necessary for streaming in Firefox, since xhr.response is ONLY defined
		// in onprogress, not in onreadystatechange with xhr.readyState = 3
		if (self._mode === 'moz-chunked-arraybuffer') {
			xhr.onprogress = function () {
				self._onXHRProgress()
			}
		}

		xhr.onerror = function () {
			if (self._destroyed)
				return
			self.emit('error', new Error('XHR error'))
		}

		try {
			xhr.send(body)
		} catch (err) {
			process.nextTick(function () {
				self.emit('error', err)
			})
			return
		}
	}
}

/**
 * Checks if xhr.status is readable. Even though the spec says it should
 * be available in readyState 3, accessing it throws an exception in IE8
 */
function statusValid (xhr) {
	try {
		return (xhr.status !== null)
	} catch (e) {
		return false
	}
}

ClientRequest.prototype._onXHRProgress = function () {
	var self = this

	if (!statusValid(self._xhr) || self._destroyed)
		return

	if (!self._response)
		self._connect()

	self._response._onXHRProgress()
}

ClientRequest.prototype._connect = function () {
	var self = this

	if (self._destroyed)
		return

	self._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode)
	self.emit('response', self._response)
}

ClientRequest.prototype._write = function (chunk, encoding, cb) {
	var self = this

	self._body.push(chunk)
	cb()
}

ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function () {
	var self = this
	self._destroyed = true
	if (self._response)
		self._response._destroyed = true
	if (self._xhr)
		self._xhr.abort()
	// Currently, there isn't a way to truly abort a fetch.
	// If you like bikeshedding, see https://github.com/whatwg/fetch/issues/27
}

ClientRequest.prototype.end = function (data, encoding, cb) {
	var self = this
	if (typeof data === 'function') {
		cb = data
		data = undefined
	}

	stream.Writable.prototype.end.call(self, data, encoding, cb)
}

ClientRequest.prototype.flushHeaders = function () {}
ClientRequest.prototype.setTimeout = function () {}
ClientRequest.prototype.setNoDelay = function () {}
ClientRequest.prototype.setSocketKeepAlive = function () {}

// Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method
var unsafeHeaders = [
	'accept-charset',
	'accept-encoding',
	'access-control-request-headers',
	'access-control-request-method',
	'connection',
	'content-length',
	'cookie',
	'cookie2',
	'date',
	'dnt',
	'expect',
	'host',
	'keep-alive',
	'origin',
	'referer',
	'te',
	'trailer',
	'transfer-encoding',
	'upgrade',
	'user-agent',
	'via'
]

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)

},{"./capability":12,"./response":14,"_process":27,"buffer":6,"foreach":10,"indexof":18,"inherits":20,"object-keys":24,"stream":64}],14:[function(require,module,exports){
(function (process,global,Buffer){
var capability = require('./capability')
var foreach = require('foreach')
var inherits = require('inherits')
var stream = require('stream')

var rStates = exports.readyStates = {
	UNSENT: 0,
	OPENED: 1,
	HEADERS_RECEIVED: 2,
	LOADING: 3,
	DONE: 4
}

var IncomingMessage = exports.IncomingMessage = function (xhr, response, mode) {
	var self = this
	stream.Readable.call(self)

	self._mode = mode
	self.headers = {}
	self.rawHeaders = []
	self.trailers = {}
	self.rawTrailers = []

	// Fake the 'close' event, but only once 'end' fires
	self.on('end', function () {
		// The nextTick is necessary to prevent the 'request' module from causing an infinite loop
		process.nextTick(function () {
			self.emit('close')
		})
	})

	if (mode === 'fetch') {
		self._fetchResponse = response

		self.statusCode = response.status
		self.statusMessage = response.statusText
		// backwards compatible version of for (<item> of <iterable>):
		// for (var <item>,_i,_it = <iterable>[Symbol.iterator](); <item> = (_i = _it.next()).value,!_i.done;)
		for (var header, _i, _it = response.headers[Symbol.iterator](); header = (_i = _it.next()).value, !_i.done;) {
			self.headers[header[0].toLowerCase()] = header[1]
			self.rawHeaders.push(header[0], header[1])
		}

		// TODO: this doesn't respect backpressure. Once WritableStream is available, this can be fixed
		var reader = response.body.getReader()
		function read () {
			reader.read().then(function (result) {
				if (self._destroyed)
					return
				if (result.done) {
					self.push(null)
					return
				}
				self.push(new Buffer(result.value))
				read()
			})
		}
		read()

	} else {
		self._xhr = xhr
		self._pos = 0

		self.statusCode = xhr.status
		self.statusMessage = xhr.statusText
		var headers = xhr.getAllResponseHeaders().split(/\r?\n/)
		foreach(headers, function (header) {
			var matches = header.match(/^([^:]+):\s*(.*)/)
			if (matches) {
				var key = matches[1].toLowerCase()
				if (self.headers[key] !== undefined)
					self.headers[key] += ', ' + matches[2]
				else
					self.headers[key] = matches[2]
				self.rawHeaders.push(matches[1], matches[2])
			}
		})

		self._charset = 'x-user-defined'
		if (!capability.overrideMimeType) {
			var mimeType = self.rawHeaders['mime-type']
			if (mimeType) {
				var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/)
				if (charsetMatch) {
					self._charset = charsetMatch[1].toLowerCase()
				}
			}
			if (!self._charset)
				self._charset = 'utf-8' // best guess
		}
	}
}

inherits(IncomingMessage, stream.Readable)

IncomingMessage.prototype._read = function () {}

IncomingMessage.prototype._onXHRProgress = function () {
	var self = this

	var xhr = self._xhr

	var response = null
	switch (self._mode) {
		case 'text:vbarray': // For IE9
			if (xhr.readyState !== rStates.DONE)
				break
			try {
				// This fails in IE8
				response = new global.VBArray(xhr.responseBody).toArray()
			} catch (e) {}
			if (response !== null) {
				self.push(new Buffer(response))
				break
			}
			// Falls through in IE8	
		case 'text':
			try { // This will fail when readyState = 3 in IE9. Switch mode and wait for readyState = 4
				response = xhr.responseText
			} catch (e) {
				self._mode = 'text:vbarray'
				break
			}
			if (response.length > self._pos) {
				var newData = response.substr(self._pos)
				if (self._charset === 'x-user-defined') {
					var buffer = new Buffer(newData.length)
					for (var i = 0; i < newData.length; i++)
						buffer[i] = newData.charCodeAt(i) & 0xff

					self.push(buffer)
				} else {
					self.push(newData, self._charset)
				}
				self._pos = response.length
			}
			break
		case 'arraybuffer':
			if (xhr.readyState !== rStates.DONE)
				break
			response = xhr.response
			self.push(new Buffer(new Uint8Array(response)))
			break
		case 'moz-chunked-arraybuffer': // take whole
			response = xhr.response
			if (xhr.readyState !== rStates.LOADING || !response)
				break
			self.push(new Buffer(new Uint8Array(response)))
			break
		case 'ms-stream':
			response = xhr.response
			if (xhr.readyState !== rStates.LOADING)
				break
			var reader = new global.MSStreamReader()
			reader.onprogress = function () {
				if (reader.result.byteLength > self._pos) {
					self.push(new Buffer(new Uint8Array(reader.result.slice(self._pos))))
					self._pos = reader.result.byteLength
				}
			}
			reader.onload = function () {
				self.push(null)
			}
			// reader.onerror = ??? // TODO: this
			reader.readAsArrayBuffer(response)
			break
	}

	// The ms-stream case handles end separately in reader.onload()
	if (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {
		self.push(null)
	}
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)

},{"./capability":12,"_process":27,"buffer":6,"foreach":10,"inherits":20,"stream":64}],15:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var punycode = require('punycode');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a puny coded representation of "domain".
      // It only converts the part of the domain name that
      // has non ASCII characters. I.e. it dosent matter if
      // you call it with a domain that already is in ASCII.
      var domainArray = this.hostname.split('.');
      var newOut = [];
      for (var i = 0; i < domainArray.length; ++i) {
        var s = domainArray[i];
        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
            'xn--' + punycode.encode(s) : s);
      }
      this.hostname = newOut.join('.');
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  Object.keys(this).forEach(function(k) {
    result[k] = this[k];
  }, this);

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    Object.keys(relative).forEach(function(k) {
      if (k !== 'protocol')
        result[k] = relative[k];
    });

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      Object.keys(relative).forEach(function(k) {
        result[k] = relative[k];
      });
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especialy happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!isNull(result.pathname) || !isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host) && (last === '.' || last === '..') ||
      last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last == '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especialy happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!isNull(result.pathname) || !isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

function isString(arg) {
  return typeof arg === "string";
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return  arg == null;
}

},{"punycode":28,"querystring":32}],16:[function(require,module,exports){
var http = require('http');

var https = module.exports;

for (var key in http) {
    if (http.hasOwnProperty(key)) https[key] = http[key];
};

https.request = function (params, cb) {
    if (!params) params = {};
    params.scheme = 'https';
    params.protocol = 'https:';
    return http.request.call(this, params, cb);
}

},{"http":11}],17:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],18:[function(require,module,exports){

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],19:[function(require,module,exports){
/*!
 * inflection
 * Copyright(c) 2011 Ben Lin <ben@dreamerslab.com>
 * MIT Licensed
 *
 * @fileoverview
 * A port of inflection-js to node.js module.
 */

( function ( root, factory ){
  if( typeof define === 'function' && define.amd ){
    define([], factory );
  }else if( typeof exports === 'object' ){
    module.exports = factory();
  }else{
    root.inflection = factory();
  }
}( this, function (){

  /**
   * @description This is a list of nouns that use the same form for both singular and plural.
   *              This list should remain entirely in lower case to correctly match Strings.
   * @private
   */
  var uncountable_words = [
    'equipment', 'information', 'rice', 'money', 'species',
    'series', 'fish', 'sheep', 'moose', 'deer', 'news'
  ];

  /**
   * @description These rules translate from the singular form of a noun to its plural form.
   * @private
   */
  var plural_rules = [

    // do not replace if its already a plural word
    [ new RegExp( '(m)en$',      'gi' )],
    [ new RegExp( '(pe)ople$',   'gi' )],
    [ new RegExp( '(child)ren$', 'gi' )],
    [ new RegExp( '([ti])a$',    'gi' )],
    [ new RegExp( '((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$','gi' )],
    [ new RegExp( '(hive)s$',           'gi' )],
    [ new RegExp( '(tive)s$',           'gi' )],
    [ new RegExp( '(curve)s$',          'gi' )],
    [ new RegExp( '([lr])ves$',         'gi' )],
    [ new RegExp( '([^fo])ves$',        'gi' )],
    [ new RegExp( '([^aeiouy]|qu)ies$', 'gi' )],
    [ new RegExp( '(s)eries$',          'gi' )],
    [ new RegExp( '(m)ovies$',          'gi' )],
    [ new RegExp( '(x|ch|ss|sh)es$',    'gi' )],
    [ new RegExp( '([m|l])ice$',        'gi' )],
    [ new RegExp( '(bus)es$',           'gi' )],
    [ new RegExp( '(o)es$',             'gi' )],
    [ new RegExp( '(shoe)s$',           'gi' )],
    [ new RegExp( '(cris|ax|test)es$',  'gi' )],
    [ new RegExp( '(octop|vir)i$',      'gi' )],
    [ new RegExp( '(alias|status)es$',  'gi' )],
    [ new RegExp( '^(ox)en',            'gi' )],
    [ new RegExp( '(vert|ind)ices$',    'gi' )],
    [ new RegExp( '(matr)ices$',        'gi' )],
    [ new RegExp( '(quiz)zes$',         'gi' )],

    // original rule
    [ new RegExp( '(m)an$', 'gi' ),                 '$1en' ],
    [ new RegExp( '(pe)rson$', 'gi' ),              '$1ople' ],
    [ new RegExp( '(child)$', 'gi' ),               '$1ren' ],
    [ new RegExp( '^(ox)$', 'gi' ),                 '$1en' ],
    [ new RegExp( '(ax|test)is$', 'gi' ),           '$1es' ],
    [ new RegExp( '(octop|vir)us$', 'gi' ),         '$1i' ],
    [ new RegExp( '(alias|status)$', 'gi' ),        '$1es' ],
    [ new RegExp( '(bu)s$', 'gi' ),                 '$1ses' ],
    [ new RegExp( '(buffal|tomat|potat)o$', 'gi' ), '$1oes' ],
    [ new RegExp( '([ti])um$', 'gi' ),              '$1a' ],
    [ new RegExp( 'sis$', 'gi' ),                   'ses' ],
    [ new RegExp( '(?:([^f])fe|([lr])f)$', 'gi' ),  '$1$2ves' ],
    [ new RegExp( '(hive)$', 'gi' ),                '$1s' ],
    [ new RegExp( '([^aeiouy]|qu)y$', 'gi' ),       '$1ies' ],
    [ new RegExp( '(x|ch|ss|sh)$', 'gi' ),          '$1es' ],
    [ new RegExp( '(matr|vert|ind)ix|ex$', 'gi' ),  '$1ices' ],
    [ new RegExp( '([m|l])ouse$', 'gi' ),           '$1ice' ],
    [ new RegExp( '(quiz)$', 'gi' ),                '$1zes' ],

    [ new RegExp( 's$', 'gi' ), 's' ],
    [ new RegExp( '$', 'gi' ),  's' ]
  ];

  /**
   * @description These rules translate from the plural form of a noun to its singular form.
   * @private
   */
  var singular_rules = [

    // do not replace if its already a singular word
    [ new RegExp( '(m)an$',                 'gi' )],
    [ new RegExp( '(pe)rson$',              'gi' )],
    [ new RegExp( '(child)$',               'gi' )],
    [ new RegExp( '^(ox)$',                 'gi' )],
    [ new RegExp( '(ax|test)is$',           'gi' )],
    [ new RegExp( '(octop|vir)us$',         'gi' )],
    [ new RegExp( '(alias|status)$',        'gi' )],
    [ new RegExp( '(bu)s$',                 'gi' )],
    [ new RegExp( '(buffal|tomat|potat)o$', 'gi' )],
    [ new RegExp( '([ti])um$',              'gi' )],
    [ new RegExp( 'sis$',                   'gi' )],
    [ new RegExp( '(?:([^f])fe|([lr])f)$',  'gi' )],
    [ new RegExp( '(hive)$',                'gi' )],
    [ new RegExp( '([^aeiouy]|qu)y$',       'gi' )],
    [ new RegExp( '(x|ch|ss|sh)$',          'gi' )],
    [ new RegExp( '(matr|vert|ind)ix|ex$',  'gi' )],
    [ new RegExp( '([m|l])ouse$',           'gi' )],
    [ new RegExp( '(quiz)$',                'gi' )],

    // original rule
    [ new RegExp( '(m)en$', 'gi' ),                                                       '$1an' ],
    [ new RegExp( '(pe)ople$', 'gi' ),                                                    '$1rson' ],
    [ new RegExp( '(child)ren$', 'gi' ),                                                  '$1' ],
    [ new RegExp( '([ti])a$', 'gi' ),                                                     '$1um' ],
    [ new RegExp( '((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$','gi' ), '$1$2sis' ],
    [ new RegExp( '(hive)s$', 'gi' ),                                                     '$1' ],
    [ new RegExp( '(tive)s$', 'gi' ),                                                     '$1' ],
    [ new RegExp( '(curve)s$', 'gi' ),                                                    '$1' ],
    [ new RegExp( '([lr])ves$', 'gi' ),                                                   '$1f' ],
    [ new RegExp( '([^fo])ves$', 'gi' ),                                                  '$1fe' ],
    [ new RegExp( '(m)ovies$', 'gi' ),                                                    '$1ovie' ],
    [ new RegExp( '([^aeiouy]|qu)ies$', 'gi' ),                                           '$1y' ],
    [ new RegExp( '(s)eries$', 'gi' ),                                                    '$1eries' ],
    [ new RegExp( '(x|ch|ss|sh)es$', 'gi' ),                                              '$1' ],
    [ new RegExp( '([m|l])ice$', 'gi' ),                                                  '$1ouse' ],
    [ new RegExp( '(bus)es$', 'gi' ),                                                     '$1' ],
    [ new RegExp( '(o)es$', 'gi' ),                                                       '$1' ],
    [ new RegExp( '(shoe)s$', 'gi' ),                                                     '$1' ],
    [ new RegExp( '(cris|ax|test)es$', 'gi' ),                                            '$1is' ],
    [ new RegExp( '(octop|vir)i$', 'gi' ),                                                '$1us' ],
    [ new RegExp( '(alias|status)es$', 'gi' ),                                            '$1' ],
    [ new RegExp( '^(ox)en', 'gi' ),                                                      '$1' ],
    [ new RegExp( '(vert|ind)ices$', 'gi' ),                                              '$1ex' ],
    [ new RegExp( '(matr)ices$', 'gi' ),                                                  '$1ix' ],
    [ new RegExp( '(quiz)zes$', 'gi' ),                                                   '$1' ],
    [ new RegExp( 'ss$', 'gi' ),                                                          'ss' ],
    [ new RegExp( 's$', 'gi' ),                                                           '' ]
  ];

  /**
   * @description This is a list of words that should not be capitalized for title case.
   * @private
   */
  var non_titlecased_words = [
    'and', 'or', 'nor', 'a', 'an', 'the', 'so', 'but', 'to', 'of', 'at','by',
    'from', 'into', 'on', 'onto', 'off', 'out', 'in', 'over', 'with', 'for'
  ];

  /**
   * @description These are regular expressions used for converting between String formats.
   * @private
   */
  var id_suffix         = new RegExp( '(_ids|_id)$', 'g' );
  var underbar          = new RegExp( '_', 'g' );
  var space_or_underbar = new RegExp( '[\ _]', 'g' );
  var uppercase         = new RegExp( '([A-Z])', 'g' );
  var underbar_prefix   = new RegExp( '^_' );

  var inflector = {

  /**
   * A helper method that applies rules based replacement to a String.
   * @private
   * @function
   * @param {String} str String to modify and return based on the passed rules.
   * @param {Array: [RegExp, String]} rules Regexp to match paired with String to use for replacement
   * @param {Array: [String]} skip Strings to skip if they match
   * @param {String} override String to return as though this method succeeded (used to conform to APIs)
   * @returns {String} Return passed String modified by passed rules.
   * @example
   *
   *     this._apply_rules( 'cows', singular_rules ); // === 'cow'
   */
    _apply_rules : function ( str, rules, skip, override ){
      if( override ){
        str = override;
      }else{
        var ignore = ( inflector.indexOf( skip, str.toLowerCase()) > -1 );

        if( !ignore ){
          var i = 0;
          var j = rules.length;

          for( ; i < j; i++ ){
            if( str.match( rules[ i ][ 0 ])){
              if( rules[ i ][ 1 ] !== undefined ){
                str = str.replace( rules[ i ][ 0 ], rules[ i ][ 1 ]);
              }
              break;
            }
          }
        }
      }

      return str;
    },



  /**
   * This lets us detect if an Array contains a given element.
   * @public
   * @function
   * @param {Array} arr The subject array.
   * @param {Object} item Object to locate in the Array.
   * @param {Number} from_index Starts checking from this position in the Array.(optional)
   * @param {Function} compare_func Function used to compare Array item vs passed item.(optional)
   * @returns {Number} Return index position in the Array of the passed item.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.indexOf([ 'hi','there' ], 'guys' ); // === -1
   *     inflection.indexOf([ 'hi','there' ], 'hi' ); // === 0
   */
    indexOf : function ( arr, item, from_index, compare_func ){
      if( !from_index ){
        from_index = -1;
      }

      var index = -1;
      var i     = from_index;
      var j     = arr.length;

      for( ; i < j; i++ ){
        if( arr[ i ]  === item || compare_func && compare_func( arr[ i ], item )){
          index = i;
          break;
        }
      }

      return index;
    },



  /**
   * This function adds pluralization support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @param {String} plural Overrides normal output with said String.(optional)
   * @returns {String} Singular English language nouns are returned in plural form.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.pluralize( 'person' ); // === 'people'
   *     inflection.pluralize( 'octopus' ); // === 'octopi'
   *     inflection.pluralize( 'Hat' ); // === 'Hats'
   *     inflection.pluralize( 'person', 'guys' ); // === 'guys'
   */
    pluralize : function ( str, plural ){
      return inflector._apply_rules( str, plural_rules, uncountable_words, plural );
    },



  /**
   * This function adds singularization support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @param {String} singular Overrides normal output with said String.(optional)
   * @returns {String} Plural English language nouns are returned in singular form.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.singularize( 'people' ); // === 'person'
   *     inflection.singularize( 'octopi' ); // === 'octopus'
   *     inflection.singularize( 'Hats' ); // === 'Hat'
   *     inflection.singularize( 'guys', 'person' ); // === 'person'
   */
    singularize : function ( str, singular ){
      return inflector._apply_rules( str, singular_rules, uncountable_words, singular );
    },



  /**
   * This function adds camelization support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @param {Boolean} low_first_letter Default is to capitalize the first letter of the results.(optional)
   *                                 Passing true will lowercase it.
   * @returns {String} Lower case underscored words will be returned in camel case.
   *                  additionally '/' is translated to '::'
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.camelize( 'message_properties' ); // === 'MessageProperties'
   *     inflection.camelize( 'message_properties', true ); // === 'messageProperties'
   */
    camelize : function ( str, low_first_letter ){
      var str_path = str.split( '/' );
      var i        = 0;
      var j        = str_path.length;
      var str_arr, init_x, k, l, first;

      for( ; i < j; i++ ){
        str_arr = str_path[ i ].split( '_' );
        k       = 0;
        l       = str_arr.length;

        for( ; k < l; k++ ){
          if( k !== 0 ){
            str_arr[ k ] = str_arr[ k ].toLowerCase();
          }

          first = str_arr[ k ].charAt( 0 );
          first = low_first_letter && i === 0 && k === 0
            ? first.toLowerCase() : first.toUpperCase();
          str_arr[ k ] = first + str_arr[ k ].substring( 1 );
        }

        str_path[ i ] = str_arr.join( '' );
      }

      return str_path.join( '::' );
    },



  /**
   * This function adds underscore support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @param {Boolean} all_upper_case Default is to lowercase and add underscore prefix.(optional)
   *                  Passing true will return as entered.
   * @returns {String} Camel cased words are returned as lower cased and underscored.
   *                  additionally '::' is translated to '/'.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.underscore( 'MessageProperties' ); // === 'message_properties'
   *     inflection.underscore( 'messageProperties' ); // === 'message_properties'
   *     inflection.underscore( 'MP', true ); // === 'MP'
   */
    underscore : function ( str, all_upper_case ){
      if( all_upper_case && str === str.toUpperCase()) return str;

      var str_path = str.split( '::' );
      var i        = 0;
      var j        = str_path.length;

      for( ; i < j; i++ ){
        str_path[ i ] = str_path[ i ].replace( uppercase, '_$1' );
        str_path[ i ] = str_path[ i ].replace( underbar_prefix, '' );
      }

      return str_path.join( '/' ).toLowerCase();
    },



  /**
   * This function adds humanize support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @param {Boolean} low_first_letter Default is to capitalize the first letter of the results.(optional)
   *                                 Passing true will lowercase it.
   * @returns {String} Lower case underscored words will be returned in humanized form.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.humanize( 'message_properties' ); // === 'Message properties'
   *     inflection.humanize( 'message_properties', true ); // === 'message properties'
   */
    humanize : function ( str, low_first_letter ){
      str = str.toLowerCase();
      str = str.replace( id_suffix, '' );
      str = str.replace( underbar, ' ' );

      if( !low_first_letter ){
        str = inflector.capitalize( str );
      }

      return str;
    },



  /**
   * This function adds capitalization support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @returns {String} All characters will be lower case and the first will be upper.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.capitalize( 'message_properties' ); // === 'Message_properties'
   *     inflection.capitalize( 'message properties', true ); // === 'Message properties'
   */
    capitalize : function ( str ){
      str = str.toLowerCase();

      return str.substring( 0, 1 ).toUpperCase() + str.substring( 1 );
    },



  /**
   * This function adds dasherization support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @returns {String} Replaces all spaces or underbars with dashes.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.dasherize( 'message_properties' ); // === 'message-properties'
   *     inflection.dasherize( 'Message Properties' ); // === 'Message-Properties'
   */
    dasherize : function ( str ){
      return str.replace( space_or_underbar, '-' );
    },



  /**
   * This function adds titleize support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @returns {String} Capitalizes words as you would for a book title.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.titleize( 'message_properties' ); // === 'Message Properties'
   *     inflection.titleize( 'message properties to keep' ); // === 'Message Properties to Keep'
   */
    titleize : function ( str ){
      str         = str.toLowerCase().replace( underbar, ' ' );
      var str_arr = str.split( ' ' );
      var i       = 0;
      var j       = str_arr.length;
      var d, k, l;

      for( ; i < j; i++ ){
        d = str_arr[ i ].split( '-' );
        k = 0;
        l = d.length;

        for( ; k < l; k++){
          if( inflector.indexOf( non_titlecased_words, d[ k ].toLowerCase()) < 0 ){
            d[ k ] = inflector.capitalize( d[ k ]);
          }
        }

        str_arr[ i ] = d.join( '-' );
      }

      str = str_arr.join( ' ' );
      str = str.substring( 0, 1 ).toUpperCase() + str.substring( 1 );

      return str;
    },



  /**
   * This function adds demodulize support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @returns {String} Removes module names leaving only class names.(Ruby style)
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.demodulize( 'Message::Bus::Properties' ); // === 'Properties'
   */
    demodulize : function ( str ){
      var str_arr = str.split( '::' );

      return str_arr[ str_arr.length - 1 ];
    },



  /**
   * This function adds tableize support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @returns {String} Return camel cased words into their underscored plural form.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.tableize( 'MessageBusProperty' ); // === 'message_bus_properties'
   */
    tableize : function ( str ){
      str = inflector.underscore( str );
      str = inflector.pluralize( str );

      return str;
    },



  /**
   * This function adds classification support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @returns {String} Underscored plural nouns become the camel cased singular form.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.classify( 'message_bus_properties' ); // === 'MessageBusProperty'
   */
    classify : function ( str ){
      str = inflector.camelize( str );
      str = inflector.singularize( str );

      return str;
    },



  /**
   * This function adds foreign key support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @param {Boolean} drop_id_ubar Default is to seperate id with an underbar at the end of the class name,
                                 you can pass true to skip it.(optional)
   * @returns {String} Underscored plural nouns become the camel cased singular form.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.foreign_key( 'MessageBusProperty' ); // === 'message_bus_property_id'
   *     inflection.foreign_key( 'MessageBusProperty', true ); // === 'message_bus_propertyid'
   */
    foreign_key : function ( str, drop_id_ubar ){
      str = inflector.demodulize( str );
      str = inflector.underscore( str ) + (( drop_id_ubar ) ? ( '' ) : ( '_' )) + 'id';

      return str;
    },



  /**
   * This function adds ordinalize support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @returns {String} Return all found numbers their sequence like '22nd'.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.ordinalize( 'the 1 pitch' ); // === 'the 1st pitch'
   */
    ordinalize : function ( str ){
      var str_arr = str.split( ' ' );
      var i       = 0;
      var j       = str_arr.length;

      for( ; i < j; i++ ){
        var k = parseInt( str_arr[ i ], 10 );

        if( !isNaN( k )){
          var ltd = str_arr[ i ].substring( str_arr[ i ].length - 2 );
          var ld  = str_arr[ i ].substring( str_arr[ i ].length - 1 );
          var suf = 'th';

          if( ltd != '11' && ltd != '12' && ltd != '13' ){
            if( ld === '1' ){
              suf = 'st';
            }else if( ld === '2' ){
              suf = 'nd';
            }else if( ld === '3' ){
              suf = 'rd';
            }
          }

          str_arr[ i ] += suf;
        }
      }

      return str_arr.join( ' ' );
    },

  /**
   * This function performs multiple inflection methods on a string
   * @public
   * @function
   * @param {String} str The subject string.
   * @param {Array} arr An array of inflection methods.
   * @returns {String}
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.transform( 'all job', [ 'pluralize', 'capitalize', 'dasherize' ]); // === 'All-jobs'
   */
    transform : function ( str, arr ){
      var i = 0;
      var j = arr.length;

      for( ;i < j; i++ ){
        var method = arr[ i ];

        if( this.hasOwnProperty( method )){
          str = this[ method ]( str );
        }
      }

      return str;
    }
  };

/**
 * @public
 */
  inflector.version = '1.3.8';

  return inflector;
}));

},{}],20:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],21:[function(require,module,exports){
/**
 * Determine if an object is Buffer
 *
 * Author:   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * License:  MIT
 *
 * `npm install is-buffer`
 */

module.exports = function (obj) {
  return !!(obj != null &&
    (obj._isBuffer || // For Safari 5-7 (missing Object.prototype.constructor)
      (obj.constructor &&
      typeof obj.constructor.isBuffer === 'function' &&
      obj.constructor.isBuffer(obj))
    ))
}

},{}],22:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],23:[function(require,module,exports){
(function( glob, undefined ) {

var rnumber = /[0-9]/,
	rnewline = /(\r\n|\r|\n)/,
	revidence = /\r\n|\r|\n/,
	rwhitespace = /(\s|\t)/,
	rvalidsolidus = /\\("|\\|\/|b|f|n|r|t|u[0-9]{4})/,
	rE = /^(\-|\+)?[0-9]/;


// Leeeeeeerrrrroooyy Jennkkkiiinnnss
function JSONLint( json, options ) {
	var self = this;

	if ( ! ( self instanceof JSONLint ) ) {
		return new JSONLint( json, options );
	}

	// Argument handling
	self.json = json || '';
	self.options = options || {};
	self.lower = self.json.toLowerCase();

	// Allow comments by default
	if ( ! self.options.hasOwnProperty( 'comments' ) ) {
		self.options.comments = true;
	}

	// Internals
	self.c = '';
	self.i = -1;
	self.length = self.json.length;
	self.line = 1;
	self.character = 0;
	self._evidence = self.json.split( revidence );
	self.endblock = '';
	self.commabreak = false;

	try {
		self.render();
	} catch ( e ) {
		if ( typeof e != 'string' ) {
			throw e;
		}
		self.error = e;
		self.setEvidence();
	}
}


// Meta (Please change contact info for republishing with changes)
JSONLint.contact = "Corey Hart (corey@codenothing.com)";
JSONLint.version = '[VERSION]';
JSONLint.date = '[DATE]';


// Methods
JSONLint.prototype = {

	// Rendering Start
	render: function(){
		var self = this, peek = '', content = false;

		for ( ; ++self.i < self.length; ) {
			self.c = self.json[ self.i ];
			self.character++;

			if ( self.options.comments && self.c == '/' ) {
				peek = self.json[ self.i + 1 ];
				if ( peek == '*' ) {
					self.multicomment();
				}
				else if ( peek == '/' ) {
					self.comment();
				}
				else {
					throw "Unknown character '/', maybe a comment?";
				}
			}
			else if ( rnewline.exec( self.c ) ) {
				self.line++;
				self.character = 0;
			}
			else if ( rwhitespace.exec( self.c ) ) {
				continue;
			}
			else if ( content ) {
				throw "Unknown character '" + self.c + "', expecting end of file.";
			}
			else if ( self.c == '[' ) {
				content = true;
				self.array();
			}
			else if ( self.c == '{' ) {
				content = true;
				self.object();
			}
			else {
				throw "Unknown character '" + self.c + "', expecting opening block '{' or '[', or maybe a comment";
			}
		}

		// Check for pure whitespace
		if ( ! content ) {
			throw "Invalid JSON, no content.";
		}
	},

	// Multi line comment
	multicomment: function(){
		var self = this;

		for ( ; ++self.i < self.length; ) {
			self.c = self.json[ self.i ];
			self.character++;

			if ( self.c == "*" && self.json[ self.i + 1 ] == "/" ) {
				self.i++;
				self.character++;
				break;
			}
			else if ( rnewline.exec( self.c ) ) {
				self.line++;
				self.character = 0;
			}
		}
	},

	// Single line comment
	comment: function(){
		var self = this;

		for ( ; ++self.i < self.length; ) {
			self.c = self.json[ self.i ];
			self.character++;

			if ( rnewline.exec( self.c ) ) {
				self.line++;
				self.character = 0;
				break;
			}
		}
	},

	// Array Block
	array: function(){
		// Keep reference of current endblock
		var self = this,
			_endblock = self.endblock,
			_commabreak = self.commabreak,
			ended = false;

		self.endblock = ']';
		self.commabreak = false;
		while ( ( ended = self.value() ) !== true && self.i < self.length ) {
			// Do nothing, just wait for array values to finish
		}

		if ( ! ended ) {
			throw "EOF Error. Expecting closing ']'";
		}

		// Reset previous endblock
		self.endblock = _endblock;
		self.commabreak = _commabreak;
	},

	// Object Block
	object: function(){
		// Keep reference of current endblock
		var self = this,
			_endblock = self.endblock,
			_commabreak = self.commabreak,
			found = false, peek = '', empty = true;

		self.endblock = '}';
		self.commabreak = false;
		for ( ; ++self.i < self.length; ) {
			self.c = self.json[ self.i ];
			self.character++;

			if ( self.options.comments && self.c == '/' ) {
				peek = self.json[ self.i + 1 ];
				if ( peek == '*' ) {
					self.multicomment();
				}
				else if ( peek == '/' ) {
					self.comment();
				}
				else {
					throw "Unknown character '/', maybe a comment?";
				}
			}
			else if ( rnewline.exec( self.c ) ) {
				self.line++;
				self.character = 0;
			}
			else if ( rwhitespace.exec( self.c ) ) {
				continue;
			}
			else if ( self.c == '"' ) {
				empty = false;
				if ( self.key() === true ) {
					// Reset old endblock
					self.endblock = _endblock;
					self.commabreak = _commabreak;
					found = true;
					break;
				}
			}
			else if ( empty && self.c == '}' ) {
				self.endblock = _endblock;
				self.commabreak = _commabreak;
				found = true;
				break;
			}
			else {
				throw "Unknown Character '" + self.c + "', expecting a string for key statement.";
			}
		}

		if ( ! found ) {
			throw "EOF Error, expecting closing '}'.";
		}
	},

	// Key Statement
	key: function(){
		var self = this;
		self.string();

		for ( var peek = ''; ++self.i < self.length; ) {
			self.c = self.json[ self.i ];
			self.character++;

			if ( self.options.comments && self.c == '/' ) {
				peek = self.json[ self.i + 1 ];
				if ( peek == '*' ) {
					self.multicomment();
				}
				else if ( peek == '/' ) {
					self.comment();
				}
				else {
					throw "Unknown character '/', maybe a comment?";
				}
			}
			else if ( rnewline.exec( self.c ) ) {
				self.line++;
				self.character = 0;
			}
			else if ( rwhitespace.exec( self.c ) ) {
				continue;
			}
			else if ( self.c == ":" ) {
				return self.value();
			}
			else {
				throw "Unknown Character '" + self.c + "', expecting a semicolon.";
			}
		}
	},

	// Value statement
	value: function(){
		var self = this, peek = '';

		for ( ; ++self.i < self.length; ) {
			self.c = self.json[ self.i ];
			self.character++;

			if ( self.options.comments && self.c == '/' ) {
				peek = self.json[ self.i + 1 ];
				if ( peek == '*' ) {
					self.multicomment();
				}
				else if ( peek == '/' ) {
					self.comment();
				}
				else {
					throw "Unknown character '/', maybe a comment?";
				}
			}
			else if ( rnewline.exec( self.c ) ) {
				self.line++;
				self.character = 0;
			}
			else if ( rwhitespace.exec( self.c ) ) {
				continue;
			}
			else if ( self.c == '{' ) {
				self.object();
				return self.endval();
			}
			else if ( self.c == '[' ) {
				self.array();
				return self.endval();
			}
			else if ( self.c == '"' ) {
				self.string();
				return self.endval();
			}
			else if ( self.json.indexOf( 'true', self.i ) === self.i ) {
				self.i += 3;
				self.character += 3;
				return self.endval();
			}
			else if ( self.json.indexOf( 'false', self.i ) === self.i ) {
				self.i += 4;
				self.character += 4;
				return self.endval();
			}
			else if ( self.json.indexOf( 'null', self.i ) === self.i ) {
				self.i += 3;
				self.character += 3;
				return self.endval();
			}
			else if ( self.c == '-' || rnumber.exec( self.c ) ) {
				return self.numeric();
			}
			else if ( self.c == ']' && self.endblock == ']' ) {
				if ( self.commabreak ) {
					throw "Unexpected End Of Array Error. Expecting a value statement.";
				}
				return true;
			}
			else {
				throw "Unknown Character '" + self.c + "', expecting a value.";
			}
		}
	},

	// String statement
	string: function(){
		var self = this, found = false, m;

		for ( ; ++self.i < self.length; ) {
			self.c = self.json[ self.i ];
			self.character++;

			if ( self.c == "\\" ) {
				if ( ( m = rvalidsolidus.exec( self.json.substr( self.i ) ) ) && m.index === 0 ) {
					self.i += m[ 1 ].length;
					self.character += m[ 1 ].length;
				}
				else {
					throw "Invalid Reverse Solidus '\\' declaration.";
				}
			}
			else if ( rnewline.exec( self.c ) ) {
				self.line++;
				self.character = 0;
			}
			else if ( self.c == '"' ) {
				found = true;
				break;
			}
		}

		// Make sure close string is found
		if ( ! found ) {
			throw "EOF: No close string '\"' found.";
		}
	},

	// Numeric Value
	numeric: function(){
		var self = this,
			negative = true,
			decimal = null,
			e = null,
			peek = '';

		// We need to jump back a character to catch the whole number
		self.i--;
		self.character--;
		for ( ; ++self.i < self.length; ) {
			self.c = self.json[ self.i ];
			self.character++;

			// Handle initial negative sign
			if ( negative ) {
				negative = false;
				if ( self.c == '-' ) {
					if ( ! rnumber.exec( self.json[ self.i + 1 ] ) ) {
						throw "Unknown Character '" + self.c + "' following a negative, expecting a numeric value.";
					}
					continue;
				}
			}

			// Only a single decimal is allowed in a numeric value
			if ( decimal && self.c == '.' ) {
				decimal = false;
				e = true;
				continue;
			}
			// Only a single e notation is allowed in a numeric value
			else if ( e && self.c.toLowerCase() == 'e' ) {
				e = false;
				negative = true;
				if ( rE.exec( self.json.substr( self.i + 1, 2 ) ) ) {
					self.character++;
					self.i++;
				}
				else {
					self.character++;
					throw "Unknown Character '" + self.json[ self.i + 1 ] + "' following e notation, expecting a numeric value.";
				}
			}
			// Normal Digit
			else if ( rnumber.exec( self.c ) ) {
				if ( decimal === null ) {
					decimal = true;
				}
			}
			// Assume end of number, and allow endval to handle it
			else {
				// Jump back a character to include the current one
				self.i--;
				self.character--;
				return self.endval();
			}
		}
	},

	// Ending a value statement
	endval: function(){
		var self = this, peek = '';
		self.commabreak = false;

		for ( ; ++self.i < self.length; ) {
			self.c = self.json[ self.i ];
			self.character++;

			if ( self.options.comments && self.c == '/' ) {
				peek = self.json[ self.i + 1 ];
				if ( peek == '*' ) {
					self.multicomment();
				}
				else if ( peek == '/' ) {
					self.comment();
				}
				else {
					throw "Unknown character '/', maybe a comment?";
				}
			}
			else if ( rnewline.exec( self.c ) ) {
				self.line++;
				self.character = 0;
			}
			else if ( rwhitespace.exec( self.c ) ) {
				continue;
			}
			else if ( self.c == ',' ) {
				self.commabreak = true;
				break;
			}
			else if ( self.c == self.endblock ) {
				return true;
			}
			else {
				throw "Unknown Character '" + self.c + "', expecting a comma or a closing '" + self.endblock + "'";
			}
		}
	},

	// Expose line of the error
	setEvidence: function(){
		var self = this, start = self.line - 5, end = start + 8, evidence = '';

		// Min start
		if ( start < 0 ) {
			start = 0;
			end = 8;
		}

		// Max end
		if ( end >= self._evidence.length ) {
			end = self._evidence.length;
		}

		// Evidence display
		for ( ; start < end; start++ ) {
			evidence += ( start === ( self.line - 1 ) ? "-> " : "   " ) +
				( start + 1 ) + '| ' +
				self._evidence[ start ] + "\n";
		}

		// Set the evidence display
		self.evidence = evidence;
	}
};


// Check for nodejs module system
if ( typeof exports == 'object' && typeof module == 'object' ) {
	module.exports = JSONLint;
}
// In a browser
else {
	glob.JSONLint = JSONLint;
}

})( this );

},{}],24:[function(require,module,exports){
'use strict';

// modified from https://github.com/es-shims/es5-shim
var has = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var slice = Array.prototype.slice;
var isArgs = require('./isArguments');
var isEnumerable = Object.prototype.propertyIsEnumerable;
var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
var dontEnums = [
	'toString',
	'toLocaleString',
	'valueOf',
	'hasOwnProperty',
	'isPrototypeOf',
	'propertyIsEnumerable',
	'constructor'
];
var equalsConstructorPrototype = function (o) {
	var ctor = o.constructor;
	return ctor && ctor.prototype === o;
};
var excludedKeys = {
	$console: true,
	$external: true,
	$frame: true,
	$frameElement: true,
	$frames: true,
	$innerHeight: true,
	$innerWidth: true,
	$outerHeight: true,
	$outerWidth: true,
	$pageXOffset: true,
	$pageYOffset: true,
	$parent: true,
	$scrollLeft: true,
	$scrollTop: true,
	$scrollX: true,
	$scrollY: true,
	$self: true,
	$webkitIndexedDB: true,
	$webkitStorageInfo: true,
	$window: true
};
var hasAutomationEqualityBug = (function () {
	/* global window */
	if (typeof window === 'undefined') { return false; }
	for (var k in window) {
		try {
			if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
				try {
					equalsConstructorPrototype(window[k]);
				} catch (e) {
					return true;
				}
			}
		} catch (e) {
			return true;
		}
	}
	return false;
}());
var equalsConstructorPrototypeIfNotBuggy = function (o) {
	/* global window */
	if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
		return equalsConstructorPrototype(o);
	}
	try {
		return equalsConstructorPrototype(o);
	} catch (e) {
		return false;
	}
};

var keysShim = function keys(object) {
	var isObject = object !== null && typeof object === 'object';
	var isFunction = toStr.call(object) === '[object Function]';
	var isArguments = isArgs(object);
	var isString = isObject && toStr.call(object) === '[object String]';
	var theKeys = [];

	if (!isObject && !isFunction && !isArguments) {
		throw new TypeError('Object.keys called on a non-object');
	}

	var skipProto = hasProtoEnumBug && isFunction;
	if (isString && object.length > 0 && !has.call(object, 0)) {
		for (var i = 0; i < object.length; ++i) {
			theKeys.push(String(i));
		}
	}

	if (isArguments && object.length > 0) {
		for (var j = 0; j < object.length; ++j) {
			theKeys.push(String(j));
		}
	} else {
		for (var name in object) {
			if (!(skipProto && name === 'prototype') && has.call(object, name)) {
				theKeys.push(String(name));
			}
		}
	}

	if (hasDontEnumBug) {
		var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

		for (var k = 0; k < dontEnums.length; ++k) {
			if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
				theKeys.push(dontEnums[k]);
			}
		}
	}
	return theKeys;
};

keysShim.shim = function shimObjectKeys() {
	if (Object.keys) {
		var keysWorksWithArguments = (function () {
			// Safari 5.0 bug
			return (Object.keys(arguments) || '').length === 2;
		}(1, 2));
		if (!keysWorksWithArguments) {
			var originalKeys = Object.keys;
			Object.keys = function keys(object) {
				if (isArgs(object)) {
					return originalKeys(slice.call(object));
				} else {
					return originalKeys(object);
				}
			};
		}
	} else {
		Object.keys = keysShim;
	}
	return Object.keys || keysShim;
};

module.exports = keysShim;

},{"./isArguments":25}],25:[function(require,module,exports){
'use strict';

var toStr = Object.prototype.toString;

module.exports = function isArguments(value) {
	var str = toStr.call(value);
	var isArgs = str === '[object Arguments]';
	if (!isArgs) {
		isArgs = str !== '[object Array]' &&
			value !== null &&
			typeof value === 'object' &&
			typeof value.length === 'number' &&
			value.length >= 0 &&
			toStr.call(value.callee) === '[object Function]';
	}
	return isArgs;
};

},{}],26:[function(require,module,exports){
(function (process){
'use strict';

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = nextTick;
} else {
  module.exports = process.nextTick;
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}

}).call(this,require('_process'))

},{"_process":27}],27:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

(function () {
  try {
    cachedSetTimeout = setTimeout;
  } catch (e) {
    cachedSetTimeout = function () {
      throw new Error('setTimeout is not defined');
    }
  }
  try {
    cachedClearTimeout = clearTimeout;
  } catch (e) {
    cachedClearTimeout = function () {
      throw new Error('clearTimeout is not defined');
    }
  }
} ())
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = cachedSetTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    cachedClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        cachedSetTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],28:[function(require,module,exports){
(function (global){
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],29:[function(require,module,exports){
(function (process){
// vim:ts=4:sts=4:sw=4:
/*!
 *
 * Copyright 2009-2012 Kris Kowal under the terms of the MIT
 * license found at http://github.com/kriskowal/q/raw/master/LICENSE
 *
 * With parts by Tyler Close
 * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
 * at http://www.opensource.org/licenses/mit-license.html
 * Forked at ref_send.js version: 2009-05-11
 *
 * With parts by Mark Miller
 * Copyright (C) 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

(function (definition) {
    // Turn off strict mode for this function so we can assign to global.Q
    /* jshint strict: false */

    // This file will function properly as a <script> tag, or a module
    // using CommonJS and NodeJS or RequireJS module formats.  In
    // Common/Node/RequireJS, the module exports the Q API and when
    // executed as a simple <script>, it creates a Q global instead.

    // Montage Require
    if (typeof bootstrap === "function") {
        bootstrap("promise", definition);

    // CommonJS
    } else if (typeof exports === "object") {
        module.exports = definition();

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
        define(definition);

    // SES (Secure EcmaScript)
    } else if (typeof ses !== "undefined") {
        if (!ses.ok()) {
            return;
        } else {
            ses.makeQ = definition;
        }

    // <script>
    } else {
        Q = definition();
    }

})(function () {
"use strict";

var hasStacks = false;
try {
    throw new Error();
} catch (e) {
    hasStacks = !!e.stack;
}

// All code after this point will be filtered from stack traces reported
// by Q.
var qStartingLine = captureLine();
var qFileName;

// shims

// used for fallback in "allResolved"
var noop = function () {};

// Use the fastest possible means to execute a task in a future turn
// of the event loop.
var nextTick =(function () {
    // linked list of tasks (single, with head node)
    var head = {task: void 0, next: null};
    var tail = head;
    var flushing = false;
    var requestTick = void 0;
    var isNodeJS = false;

    function flush() {
        /* jshint loopfunc: true */

        while (head.next) {
            head = head.next;
            var task = head.task;
            head.task = void 0;
            var domain = head.domain;

            if (domain) {
                head.domain = void 0;
                domain.enter();
            }

            try {
                task();

            } catch (e) {
                if (isNodeJS) {
                    // In node, uncaught exceptions are considered fatal errors.
                    // Re-throw them synchronously to interrupt flushing!

                    // Ensure continuation if the uncaught exception is suppressed
                    // listening "uncaughtException" events (as domains does).
                    // Continue in next event to avoid tick recursion.
                    if (domain) {
                        domain.exit();
                    }
                    setTimeout(flush, 0);
                    if (domain) {
                        domain.enter();
                    }

                    throw e;

                } else {
                    // In browsers, uncaught exceptions are not fatal.
                    // Re-throw them asynchronously to avoid slow-downs.
                    setTimeout(function() {
                       throw e;
                    }, 0);
                }
            }

            if (domain) {
                domain.exit();
            }
        }

        flushing = false;
    }

    nextTick = function (task) {
        tail = tail.next = {
            task: task,
            domain: isNodeJS && process.domain,
            next: null
        };

        if (!flushing) {
            flushing = true;
            requestTick();
        }
    };

    if (typeof process !== "undefined" && process.nextTick) {
        // Node.js before 0.9. Note that some fake-Node environments, like the
        // Mocha test runner, introduce a `process` global without a `nextTick`.
        isNodeJS = true;

        requestTick = function () {
            process.nextTick(flush);
        };

    } else if (typeof setImmediate === "function") {
        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
        if (typeof window !== "undefined") {
            requestTick = setImmediate.bind(window, flush);
        } else {
            requestTick = function () {
                setImmediate(flush);
            };
        }

    } else if (typeof MessageChannel !== "undefined") {
        // modern browsers
        // http://www.nonblocking.io/2011/06/windownexttick.html
        var channel = new MessageChannel();
        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
        // working message ports the first time a page loads.
        channel.port1.onmessage = function () {
            requestTick = requestPortTick;
            channel.port1.onmessage = flush;
            flush();
        };
        var requestPortTick = function () {
            // Opera requires us to provide a message payload, regardless of
            // whether we use it.
            channel.port2.postMessage(0);
        };
        requestTick = function () {
            setTimeout(flush, 0);
            requestPortTick();
        };

    } else {
        // old browsers
        requestTick = function () {
            setTimeout(flush, 0);
        };
    }

    return nextTick;
})();

// Attempt to make generics safe in the face of downstream
// modifications.
// There is no situation where this is necessary.
// If you need a security guarantee, these primordials need to be
// deeply frozen anyway, and if you dont need a security guarantee,
// this is just plain paranoid.
// However, this does have the nice side-effect of reducing the size
// of the code by reducing x.call() to merely x(), eliminating many
// hard-to-minify characters.
// See Mark Millers explanation of what this does.
// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
var call = Function.call;
function uncurryThis(f) {
    return function () {
        return call.apply(f, arguments);
    };
}
// This is equivalent, but slower:
// uncurryThis = Function_bind.bind(Function_bind.call);
// http://jsperf.com/uncurrythis

var array_slice = uncurryThis(Array.prototype.slice);

var array_reduce = uncurryThis(
    Array.prototype.reduce || function (callback, basis) {
        var index = 0,
            length = this.length;
        // concerning the initial value, if one is not provided
        if (arguments.length === 1) {
            // seek to the first value in the array, accounting
            // for the possibility that is is a sparse array
            do {
                if (index in this) {
                    basis = this[index++];
                    break;
                }
                if (++index >= length) {
                    throw new TypeError();
                }
            } while (1);
        }
        // reduce
        for (; index < length; index++) {
            // account for the possibility that the array is sparse
            if (index in this) {
                basis = callback(basis, this[index], index);
            }
        }
        return basis;
    }
);

var array_indexOf = uncurryThis(
    Array.prototype.indexOf || function (value) {
        // not a very good shim, but good enough for our one use of it
        for (var i = 0; i < this.length; i++) {
            if (this[i] === value) {
                return i;
            }
        }
        return -1;
    }
);

var array_map = uncurryThis(
    Array.prototype.map || function (callback, thisp) {
        var self = this;
        var collect = [];
        array_reduce(self, function (undefined, value, index) {
            collect.push(callback.call(thisp, value, index, self));
        }, void 0);
        return collect;
    }
);

var object_create = Object.create || function (prototype) {
    function Type() { }
    Type.prototype = prototype;
    return new Type();
};

var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);

var object_keys = Object.keys || function (object) {
    var keys = [];
    for (var key in object) {
        if (object_hasOwnProperty(object, key)) {
            keys.push(key);
        }
    }
    return keys;
};

var object_toString = uncurryThis(Object.prototype.toString);

function isObject(value) {
    return value === Object(value);
}

// generator related shims

// FIXME: Remove this function once ES6 generators are in SpiderMonkey.
function isStopIteration(exception) {
    return (
        object_toString(exception) === "[object StopIteration]" ||
        exception instanceof QReturnValue
    );
}

// FIXME: Remove this helper and Q.return once ES6 generators are in
// SpiderMonkey.
var QReturnValue;
if (typeof ReturnValue !== "undefined") {
    QReturnValue = ReturnValue;
} else {
    QReturnValue = function (value) {
        this.value = value;
    };
}

// Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
// engine that has a deployed base of browsers that support generators.
// However, SM's generators use the Python-inspired semantics of
// outdated ES6 drafts.  We would like to support ES6, but we'd also
// like to make it possible to use generators in deployed browsers, so
// we also support Python-style generators.  At some point we can remove
// this block.
var hasES6Generators;
try {
    /* jshint evil: true, nonew: false */
    new Function("(function* (){ yield 1; })");
    hasES6Generators = true;
} catch (e) {
    hasES6Generators = false;
}

// long stack traces

var STACK_JUMP_SEPARATOR = "From previous event:";

function makeStackTraceLong(error, promise) {
    // If possible, transform the error stack trace by removing Node and Q
    // cruft, then concatenating with the stack trace of `promise`. See #57.
    if (hasStacks &&
        promise.stack &&
        typeof error === "object" &&
        error !== null &&
        error.stack &&
        error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1
    ) {
        var stacks = [];
        for (var p = promise; !!p; p = p.source) {
            if (p.stack) {
                stacks.unshift(p.stack);
            }
        }
        stacks.unshift(error.stack);

        var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
        error.stack = filterStackString(concatedStacks);
    }
}

function filterStackString(stackString) {
    var lines = stackString.split("\n");
    var desiredLines = [];
    for (var i = 0; i < lines.length; ++i) {
        var line = lines[i];

        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
            desiredLines.push(line);
        }
    }
    return desiredLines.join("\n");
}

function isNodeFrame(stackLine) {
    return stackLine.indexOf("(module.js:") !== -1 ||
           stackLine.indexOf("(node.js:") !== -1;
}

function getFileNameAndLineNumber(stackLine) {
    // Named functions: "at functionName (filename:lineNumber:columnNumber)"
    // In IE10 function name can have spaces ("Anonymous function") O_o
    var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
    if (attempt1) {
        return [attempt1[1], Number(attempt1[2])];
    }

    // Anonymous functions: "at filename:lineNumber:columnNumber"
    var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
    if (attempt2) {
        return [attempt2[1], Number(attempt2[2])];
    }

    // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
    var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
    if (attempt3) {
        return [attempt3[1], Number(attempt3[2])];
    }
}

function isInternalFrame(stackLine) {
    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);

    if (!fileNameAndLineNumber) {
        return false;
    }

    var fileName = fileNameAndLineNumber[0];
    var lineNumber = fileNameAndLineNumber[1];

    return fileName === qFileName &&
        lineNumber >= qStartingLine &&
        lineNumber <= qEndingLine;
}

// discover own file name and line number range for filtering stack
// traces
function captureLine() {
    if (!hasStacks) {
        return;
    }

    try {
        throw new Error();
    } catch (e) {
        var lines = e.stack.split("\n");
        var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
        if (!fileNameAndLineNumber) {
            return;
        }

        qFileName = fileNameAndLineNumber[0];
        return fileNameAndLineNumber[1];
    }
}

function deprecate(callback, name, alternative) {
    return function () {
        if (typeof console !== "undefined" &&
            typeof console.warn === "function") {
            console.warn(name + " is deprecated, use " + alternative +
                         " instead.", new Error("").stack);
        }
        return callback.apply(callback, arguments);
    };
}

// end of shims
// beginning of real work

/**
 * Constructs a promise for an immediate reference, passes promises through, or
 * coerces promises from different systems.
 * @param value immediate reference or promise
 */
function Q(value) {
    // If the object is already a Promise, return it directly.  This enables
    // the resolve function to both be used to created references from objects,
    // but to tolerably coerce non-promises to promises.
    if (isPromise(value)) {
        return value;
    }

    // assimilate thenables
    if (isPromiseAlike(value)) {
        return coerce(value);
    } else {
        return fulfill(value);
    }
}
Q.resolve = Q;

/**
 * Performs a task in a future turn of the event loop.
 * @param {Function} task
 */
Q.nextTick = nextTick;

/**
 * Controls whether or not long stack traces will be on
 */
Q.longStackSupport = false;

/**
 * Constructs a {promise, resolve, reject} object.
 *
 * `resolve` is a callback to invoke with a more resolved value for the
 * promise. To fulfill the promise, invoke `resolve` with any value that is
 * not a thenable. To reject the promise, invoke `resolve` with a rejected
 * thenable, or invoke `reject` with the reason directly. To resolve the
 * promise to another thenable, thus putting it in the same state, invoke
 * `resolve` with that other thenable.
 */
Q.defer = defer;
function defer() {
    // if "messages" is an "Array", that indicates that the promise has not yet
    // been resolved.  If it is "undefined", it has been resolved.  Each
    // element of the messages array is itself an array of complete arguments to
    // forward to the resolved promise.  We coerce the resolution value to a
    // promise using the `resolve` function because it handles both fully
    // non-thenable values and other thenables gracefully.
    var messages = [], progressListeners = [], resolvedPromise;

    var deferred = object_create(defer.prototype);
    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, operands) {
        var args = array_slice(arguments);
        if (messages) {
            messages.push(args);
            if (op === "when" && operands[1]) { // progress operand
                progressListeners.push(operands[1]);
            }
        } else {
            nextTick(function () {
                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
            });
        }
    };

    // XXX deprecated
    promise.valueOf = deprecate(function () {
        if (messages) {
            return promise;
        }
        var nearerValue = nearer(resolvedPromise);
        if (isPromise(nearerValue)) {
            resolvedPromise = nearerValue; // shorten chain
        }
        return nearerValue;
    }, "valueOf", "inspect");

    promise.inspect = function () {
        if (!resolvedPromise) {
            return { state: "pending" };
        }
        return resolvedPromise.inspect();
    };

    if (Q.longStackSupport && hasStacks) {
        try {
            throw new Error();
        } catch (e) {
            // NOTE: don't try to use `Error.captureStackTrace` or transfer the
            // accessor around; that causes memory leaks as per GH-111. Just
            // reify the stack trace as a string ASAP.
            //
            // At the same time, cut off the first line; it's always just
            // "[object Promise]\n", as per the `toString`.
            promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
        }
    }

    // NOTE: we do the checks for `resolvedPromise` in each method, instead of
    // consolidating them into `become`, since otherwise we'd create new
    // promises with the lines `become(whatever(value))`. See e.g. GH-252.

    function become(newPromise) {
        resolvedPromise = newPromise;
        promise.source = newPromise;

        array_reduce(messages, function (undefined, message) {
            nextTick(function () {
                newPromise.promiseDispatch.apply(newPromise, message);
            });
        }, void 0);

        messages = void 0;
        progressListeners = void 0;
    }

    deferred.promise = promise;
    deferred.resolve = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(Q(value));
    };

    deferred.fulfill = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(fulfill(value));
    };
    deferred.reject = function (reason) {
        if (resolvedPromise) {
            return;
        }

        become(reject(reason));
    };
    deferred.notify = function (progress) {
        if (resolvedPromise) {
            return;
        }

        array_reduce(progressListeners, function (undefined, progressListener) {
            nextTick(function () {
                progressListener(progress);
            });
        }, void 0);
    };

    return deferred;
}

/**
 * Creates a Node-style callback that will resolve or reject the deferred
 * promise.
 * @returns a nodeback
 */
defer.prototype.makeNodeResolver = function () {
    var self = this;
    return function (error, value) {
        if (error) {
            self.reject(error);
        } else if (arguments.length > 2) {
            self.resolve(array_slice(arguments, 1));
        } else {
            self.resolve(value);
        }
    };
};

/**
 * @param resolver {Function} a function that returns nothing and accepts
 * the resolve, reject, and notify functions for a deferred.
 * @returns a promise that may be resolved with the given resolve and reject
 * functions, or rejected by a thrown exception in resolver
 */
Q.promise = promise;
function promise(resolver) {
    if (typeof resolver !== "function") {
        throw new TypeError("resolver must be a function.");
    }
    var deferred = defer();
    try {
        resolver(deferred.resolve, deferred.reject, deferred.notify);
    } catch (reason) {
        deferred.reject(reason);
    }
    return deferred.promise;
}

// XXX experimental.  This method is a way to denote that a local value is
// serializable and should be immediately dispatched to a remote upon request,
// instead of passing a reference.
Q.passByCopy = function (object) {
    //freeze(object);
    //passByCopies.set(object, true);
    return object;
};

Promise.prototype.passByCopy = function () {
    //freeze(object);
    //passByCopies.set(object, true);
    return this;
};

/**
 * If two promises eventually fulfill to the same value, promises that value,
 * but otherwise rejects.
 * @param x {Any*}
 * @param y {Any*}
 * @returns {Any*} a promise for x and y if they are the same, but a rejection
 * otherwise.
 *
 */
Q.join = function (x, y) {
    return Q(x).join(y);
};

Promise.prototype.join = function (that) {
    return Q([this, that]).spread(function (x, y) {
        if (x === y) {
            // TODO: "===" should be Object.is or equiv
            return x;
        } else {
            throw new Error("Can't join: not the same: " + x + " " + y);
        }
    });
};

/**
 * Returns a promise for the first of an array of promises to become fulfilled.
 * @param answers {Array[Any*]} promises to race
 * @returns {Any*} the first promise to be fulfilled
 */
Q.race = race;
function race(answerPs) {
    return promise(function(resolve, reject) {
        // Switch to this once we can assume at least ES5
        // answerPs.forEach(function(answerP) {
        //     Q(answerP).then(resolve, reject);
        // });
        // Use this in the meantime
        for (var i = 0, len = answerPs.length; i < len; i++) {
            Q(answerPs[i]).then(resolve, reject);
        }
    });
}

Promise.prototype.race = function () {
    return this.then(Q.race);
};

/**
 * Constructs a Promise with a promise descriptor object and optional fallback
 * function.  The descriptor contains methods like when(rejected), get(name),
 * set(name, value), post(name, args), and delete(name), which all
 * return either a value, a promise for a value, or a rejection.  The fallback
 * accepts the operation name, a resolver, and any further arguments that would
 * have been forwarded to the appropriate method above had a method been
 * provided with the proper name.  The API makes no guarantees about the nature
 * of the returned object, apart from that it is usable whereever promises are
 * bought and sold.
 */
Q.makePromise = Promise;
function Promise(descriptor, fallback, inspect) {
    if (fallback === void 0) {
        fallback = function (op) {
            return reject(new Error(
                "Promise does not support operation: " + op
            ));
        };
    }
    if (inspect === void 0) {
        inspect = function () {
            return {state: "unknown"};
        };
    }

    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, args) {
        var result;
        try {
            if (descriptor[op]) {
                result = descriptor[op].apply(promise, args);
            } else {
                result = fallback.call(promise, op, args);
            }
        } catch (exception) {
            result = reject(exception);
        }
        if (resolve) {
            resolve(result);
        }
    };

    promise.inspect = inspect;

    // XXX deprecated `valueOf` and `exception` support
    if (inspect) {
        var inspected = inspect();
        if (inspected.state === "rejected") {
            promise.exception = inspected.reason;
        }

        promise.valueOf = deprecate(function () {
            var inspected = inspect();
            if (inspected.state === "pending" ||
                inspected.state === "rejected") {
                return promise;
            }
            return inspected.value;
        });
    }

    return promise;
}

Promise.prototype.toString = function () {
    return "[object Promise]";
};

Promise.prototype.then = function (fulfilled, rejected, progressed) {
    var self = this;
    var deferred = defer();
    var done = false;   // ensure the untrusted promise makes at most a
                        // single call to one of the callbacks

    function _fulfilled(value) {
        try {
            return typeof fulfilled === "function" ? fulfilled(value) : value;
        } catch (exception) {
            return reject(exception);
        }
    }

    function _rejected(exception) {
        if (typeof rejected === "function") {
            makeStackTraceLong(exception, self);
            try {
                return rejected(exception);
            } catch (newException) {
                return reject(newException);
            }
        }
        return reject(exception);
    }

    function _progressed(value) {
        return typeof progressed === "function" ? progressed(value) : value;
    }

    nextTick(function () {
        self.promiseDispatch(function (value) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_fulfilled(value));
        }, "when", [function (exception) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_rejected(exception));
        }]);
    });

    // Progress propagator need to be attached in the current tick.
    self.promiseDispatch(void 0, "when", [void 0, function (value) {
        var newValue;
        var threw = false;
        try {
            newValue = _progressed(value);
        } catch (e) {
            threw = true;
            if (Q.onerror) {
                Q.onerror(e);
            } else {
                throw e;
            }
        }

        if (!threw) {
            deferred.notify(newValue);
        }
    }]);

    return deferred.promise;
};

/**
 * Registers an observer on a promise.
 *
 * Guarantees:
 *
 * 1. that fulfilled and rejected will be called only once.
 * 2. that either the fulfilled callback or the rejected callback will be
 *    called, but not both.
 * 3. that fulfilled and rejected will not be called in this turn.
 *
 * @param value      promise or immediate reference to observe
 * @param fulfilled  function to be called with the fulfilled value
 * @param rejected   function to be called with the rejection exception
 * @param progressed function to be called on any progress notifications
 * @return promise for the return value from the invoked callback
 */
Q.when = when;
function when(value, fulfilled, rejected, progressed) {
    return Q(value).then(fulfilled, rejected, progressed);
}

Promise.prototype.thenResolve = function (value) {
    return this.then(function () { return value; });
};

Q.thenResolve = function (promise, value) {
    return Q(promise).thenResolve(value);
};

Promise.prototype.thenReject = function (reason) {
    return this.then(function () { throw reason; });
};

Q.thenReject = function (promise, reason) {
    return Q(promise).thenReject(reason);
};

/**
 * If an object is not a promise, it is as "near" as possible.
 * If a promise is rejected, it is as "near" as possible too.
 * If its a fulfilled promise, the fulfillment value is nearer.
 * If its a deferred promise and the deferred has been resolved, the
 * resolution is "nearer".
 * @param object
 * @returns most resolved (nearest) form of the object
 */

// XXX should we re-do this?
Q.nearer = nearer;
function nearer(value) {
    if (isPromise(value)) {
        var inspected = value.inspect();
        if (inspected.state === "fulfilled") {
            return inspected.value;
        }
    }
    return value;
}

/**
 * @returns whether the given object is a promise.
 * Otherwise it is a fulfilled value.
 */
Q.isPromise = isPromise;
function isPromise(object) {
    return isObject(object) &&
        typeof object.promiseDispatch === "function" &&
        typeof object.inspect === "function";
}

Q.isPromiseAlike = isPromiseAlike;
function isPromiseAlike(object) {
    return isObject(object) && typeof object.then === "function";
}

/**
 * @returns whether the given object is a pending promise, meaning not
 * fulfilled or rejected.
 */
Q.isPending = isPending;
function isPending(object) {
    return isPromise(object) && object.inspect().state === "pending";
}

Promise.prototype.isPending = function () {
    return this.inspect().state === "pending";
};

/**
 * @returns whether the given object is a value or fulfilled
 * promise.
 */
Q.isFulfilled = isFulfilled;
function isFulfilled(object) {
    return !isPromise(object) || object.inspect().state === "fulfilled";
}

Promise.prototype.isFulfilled = function () {
    return this.inspect().state === "fulfilled";
};

/**
 * @returns whether the given object is a rejected promise.
 */
Q.isRejected = isRejected;
function isRejected(object) {
    return isPromise(object) && object.inspect().state === "rejected";
}

Promise.prototype.isRejected = function () {
    return this.inspect().state === "rejected";
};

//// BEGIN UNHANDLED REJECTION TRACKING

// This promise library consumes exceptions thrown in handlers so they can be
// handled by a subsequent promise.  The exceptions get added to this array when
// they are created, and removed when they are handled.  Note that in ES6 or
// shimmed environments, this would naturally be a `Set`.
var unhandledReasons = [];
var unhandledRejections = [];
var unhandledReasonsDisplayed = false;
var trackUnhandledRejections = true;
function displayUnhandledReasons() {
    if (
        !unhandledReasonsDisplayed &&
        typeof window !== "undefined" &&
        !window.Touch &&
        window.console
    ) {
        console.warn("[Q] Unhandled rejection reasons (should be empty):",
                     unhandledReasons);
    }

    unhandledReasonsDisplayed = true;
}

function logUnhandledReasons() {
    for (var i = 0; i < unhandledReasons.length; i++) {
        var reason = unhandledReasons[i];
        console.warn("Unhandled rejection reason:", reason);
    }
}

function resetUnhandledRejections() {
    unhandledReasons.length = 0;
    unhandledRejections.length = 0;
    unhandledReasonsDisplayed = false;

    if (!trackUnhandledRejections) {
        trackUnhandledRejections = true;

        // Show unhandled rejection reasons if Node exits without handling an
        // outstanding rejection.  (Note that Browserify presently produces a
        // `process` global without the `EventEmitter` `on` method.)
        if (typeof process !== "undefined" && process.on) {
            process.on("exit", logUnhandledReasons);
        }
    }
}

function trackRejection(promise, reason) {
    if (!trackUnhandledRejections) {
        return;
    }

    unhandledRejections.push(promise);
    if (reason && typeof reason.stack !== "undefined") {
        unhandledReasons.push(reason.stack);
    } else {
        unhandledReasons.push("(no stack) " + reason);
    }
    displayUnhandledReasons();
}

function untrackRejection(promise) {
    if (!trackUnhandledRejections) {
        return;
    }

    var at = array_indexOf(unhandledRejections, promise);
    if (at !== -1) {
        unhandledRejections.splice(at, 1);
        unhandledReasons.splice(at, 1);
    }
}

Q.resetUnhandledRejections = resetUnhandledRejections;

Q.getUnhandledReasons = function () {
    // Make a copy so that consumers can't interfere with our internal state.
    return unhandledReasons.slice();
};

Q.stopUnhandledRejectionTracking = function () {
    resetUnhandledRejections();
    if (typeof process !== "undefined" && process.on) {
        process.removeListener("exit", logUnhandledReasons);
    }
    trackUnhandledRejections = false;
};

resetUnhandledRejections();

//// END UNHANDLED REJECTION TRACKING

/**
 * Constructs a rejected promise.
 * @param reason value describing the failure
 */
Q.reject = reject;
function reject(reason) {
    var rejection = Promise({
        "when": function (rejected) {
            // note that the error has been handled
            if (rejected) {
                untrackRejection(this);
            }
            return rejected ? rejected(reason) : this;
        }
    }, function fallback() {
        return this;
    }, function inspect() {
        return { state: "rejected", reason: reason };
    });

    // Note that the reason has not been handled.
    trackRejection(rejection, reason);

    return rejection;
}

/**
 * Constructs a fulfilled promise for an immediate reference.
 * @param value immediate reference
 */
Q.fulfill = fulfill;
function fulfill(value) {
    return Promise({
        "when": function () {
            return value;
        },
        "get": function (name) {
            return value[name];
        },
        "set": function (name, rhs) {
            value[name] = rhs;
        },
        "delete": function (name) {
            delete value[name];
        },
        "post": function (name, args) {
            // Mark Miller proposes that post with no name should apply a
            // promised function.
            if (name === null || name === void 0) {
                return value.apply(void 0, args);
            } else {
                return value[name].apply(value, args);
            }
        },
        "apply": function (thisp, args) {
            return value.apply(thisp, args);
        },
        "keys": function () {
            return object_keys(value);
        }
    }, void 0, function inspect() {
        return { state: "fulfilled", value: value };
    });
}

/**
 * Converts thenables to Q promises.
 * @param promise thenable promise
 * @returns a Q promise
 */
function coerce(promise) {
    var deferred = defer();
    nextTick(function () {
        try {
            promise.then(deferred.resolve, deferred.reject, deferred.notify);
        } catch (exception) {
            deferred.reject(exception);
        }
    });
    return deferred.promise;
}

/**
 * Annotates an object such that it will never be
 * transferred away from this process over any promise
 * communication channel.
 * @param object
 * @returns promise a wrapping of that object that
 * additionally responds to the "isDef" message
 * without a rejection.
 */
Q.master = master;
function master(object) {
    return Promise({
        "isDef": function () {}
    }, function fallback(op, args) {
        return dispatch(object, op, args);
    }, function () {
        return Q(object).inspect();
    });
}

/**
 * Spreads the values of a promised array of arguments into the
 * fulfillment callback.
 * @param fulfilled callback that receives variadic arguments from the
 * promised array
 * @param rejected callback that receives the exception if the promise
 * is rejected.
 * @returns a promise for the return value or thrown exception of
 * either callback.
 */
Q.spread = spread;
function spread(value, fulfilled, rejected) {
    return Q(value).spread(fulfilled, rejected);
}

Promise.prototype.spread = function (fulfilled, rejected) {
    return this.all().then(function (array) {
        return fulfilled.apply(void 0, array);
    }, rejected);
};

/**
 * The async function is a decorator for generator functions, turning
 * them into asynchronous generators.  Although generators are only part
 * of the newest ECMAScript 6 drafts, this code does not cause syntax
 * errors in older engines.  This code should continue to work and will
 * in fact improve over time as the language improves.
 *
 * ES6 generators are currently part of V8 version 3.19 with the
 * --harmony-generators runtime flag enabled.  SpiderMonkey has had them
 * for longer, but under an older Python-inspired form.  This function
 * works on both kinds of generators.
 *
 * Decorates a generator function such that:
 *  - it may yield promises
 *  - execution will continue when that promise is fulfilled
 *  - the value of the yield expression will be the fulfilled value
 *  - it returns a promise for the return value (when the generator
 *    stops iterating)
 *  - the decorated function returns a promise for the return value
 *    of the generator or the first rejected promise among those
 *    yielded.
 *  - if an error is thrown in the generator, it propagates through
 *    every following yield until it is caught, or until it escapes
 *    the generator function altogether, and is translated into a
 *    rejection for the promise returned by the decorated generator.
 */
Q.async = async;
function async(makeGenerator) {
    return function () {
        // when verb is "send", arg is a value
        // when verb is "throw", arg is an exception
        function continuer(verb, arg) {
            var result;
            if (hasES6Generators) {
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    return reject(exception);
                }
                if (result.done) {
                    return result.value;
                } else {
                    return when(result.value, callback, errback);
                }
            } else {
                // FIXME: Remove this case when SM does ES6 generators.
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    if (isStopIteration(exception)) {
                        return exception.value;
                    } else {
                        return reject(exception);
                    }
                }
                return when(result, callback, errback);
            }
        }
        var generator = makeGenerator.apply(this, arguments);
        var callback = continuer.bind(continuer, "next");
        var errback = continuer.bind(continuer, "throw");
        return callback();
    };
}

/**
 * The spawn function is a small wrapper around async that immediately
 * calls the generator and also ends the promise chain, so that any
 * unhandled errors are thrown instead of forwarded to the error
 * handler. This is useful because it's extremely common to run
 * generators at the top-level to work with libraries.
 */
Q.spawn = spawn;
function spawn(makeGenerator) {
    Q.done(Q.async(makeGenerator)());
}

// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.
/**
 * Throws a ReturnValue exception to stop an asynchronous generator.
 *
 * This interface is a stop-gap measure to support generator return
 * values in older Firefox/SpiderMonkey.  In browsers that support ES6
 * generators like Chromium 29, just use "return" in your generator
 * functions.
 *
 * @param value the return value for the surrounding generator
 * @throws ReturnValue exception with the value.
 * @example
 * // ES6 style
 * Q.async(function* () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      return foo + bar;
 * })
 * // Older SpiderMonkey style
 * Q.async(function () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      Q.return(foo + bar);
 * })
 */
Q["return"] = _return;
function _return(value) {
    throw new QReturnValue(value);
}

/**
 * The promised function decorator ensures that any promise arguments
 * are settled and passed as values (`this` is also settled and passed
 * as a value).  It will also ensure that the result of a function is
 * always a promise.
 *
 * @example
 * var add = Q.promised(function (a, b) {
 *     return a + b;
 * });
 * add(Q(a), Q(B));
 *
 * @param {function} callback The function to decorate
 * @returns {function} a function that has been decorated.
 */
Q.promised = promised;
function promised(callback) {
    return function () {
        return spread([this, all(arguments)], function (self, args) {
            return callback.apply(self, args);
        });
    };
}

/**
 * sends a message to a value in a future turn
 * @param object* the recipient
 * @param op the name of the message operation, e.g., "when",
 * @param args further arguments to be forwarded to the operation
 * @returns result {Promise} a promise for the result of the operation
 */
Q.dispatch = dispatch;
function dispatch(object, op, args) {
    return Q(object).dispatch(op, args);
}

Promise.prototype.dispatch = function (op, args) {
    var self = this;
    var deferred = defer();
    nextTick(function () {
        self.promiseDispatch(deferred.resolve, op, args);
    });
    return deferred.promise;
};

/**
 * Gets the value of a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to get
 * @return promise for the property value
 */
Q.get = function (object, key) {
    return Q(object).dispatch("get", [key]);
};

Promise.prototype.get = function (key) {
    return this.dispatch("get", [key]);
};

/**
 * Sets the value of a property in a future turn.
 * @param object    promise or immediate reference for object object
 * @param name      name of property to set
 * @param value     new value of property
 * @return promise for the return value
 */
Q.set = function (object, key, value) {
    return Q(object).dispatch("set", [key, value]);
};

Promise.prototype.set = function (key, value) {
    return this.dispatch("set", [key, value]);
};

/**
 * Deletes a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to delete
 * @return promise for the return value
 */
Q.del = // XXX legacy
Q["delete"] = function (object, key) {
    return Q(object).dispatch("delete", [key]);
};

Promise.prototype.del = // XXX legacy
Promise.prototype["delete"] = function (key) {
    return this.dispatch("delete", [key]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param value     a value to post, typically an array of
 *                  invocation arguments for promises that
 *                  are ultimately backed with `resolve` values,
 *                  as opposed to those backed with URLs
 *                  wherein the posted value can be any
 *                  JSON serializable object.
 * @return promise for the return value
 */
// bound locally because it is used by other methods
Q.mapply = // XXX As proposed by "Redsandro"
Q.post = function (object, name, args) {
    return Q(object).dispatch("post", [name, args]);
};

Promise.prototype.mapply = // XXX As proposed by "Redsandro"
Promise.prototype.post = function (name, args) {
    return this.dispatch("post", [name, args]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param ...args   array of invocation arguments
 * @return promise for the return value
 */
Q.send = // XXX Mark Miller's proposed parlance
Q.mcall = // XXX As proposed by "Redsandro"
Q.invoke = function (object, name /*...args*/) {
    return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
};

Promise.prototype.send = // XXX Mark Miller's proposed parlance
Promise.prototype.mcall = // XXX As proposed by "Redsandro"
Promise.prototype.invoke = function (name /*...args*/) {
    return this.dispatch("post", [name, array_slice(arguments, 1)]);
};

/**
 * Applies the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param args      array of application arguments
 */
Q.fapply = function (object, args) {
    return Q(object).dispatch("apply", [void 0, args]);
};

Promise.prototype.fapply = function (args) {
    return this.dispatch("apply", [void 0, args]);
};

/**
 * Calls the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q["try"] =
Q.fcall = function (object /* ...args*/) {
    return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
};

Promise.prototype.fcall = function (/*...args*/) {
    return this.dispatch("apply", [void 0, array_slice(arguments)]);
};

/**
 * Binds the promised function, transforming return values into a fulfilled
 * promise and thrown errors into a rejected one.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q.fbind = function (object /*...args*/) {
    var promise = Q(object);
    var args = array_slice(arguments, 1);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};
Promise.prototype.fbind = function (/*...args*/) {
    var promise = this;
    var args = array_slice(arguments);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};

/**
 * Requests the names of the owned properties of a promised
 * object in a future turn.
 * @param object    promise or immediate reference for target object
 * @return promise for the keys of the eventually settled object
 */
Q.keys = function (object) {
    return Q(object).dispatch("keys", []);
};

Promise.prototype.keys = function () {
    return this.dispatch("keys", []);
};

/**
 * Turns an array of promises into a promise for an array.  If any of
 * the promises gets rejected, the whole array is rejected immediately.
 * @param {Array*} an array (or promise for an array) of values (or
 * promises for values)
 * @returns a promise for an array of the corresponding values
 */
// By Mark Miller
// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
Q.all = all;
function all(promises) {
    return when(promises, function (promises) {
        var countDown = 0;
        var deferred = defer();
        array_reduce(promises, function (undefined, promise, index) {
            var snapshot;
            if (
                isPromise(promise) &&
                (snapshot = promise.inspect()).state === "fulfilled"
            ) {
                promises[index] = snapshot.value;
            } else {
                ++countDown;
                when(
                    promise,
                    function (value) {
                        promises[index] = value;
                        if (--countDown === 0) {
                            deferred.resolve(promises);
                        }
                    },
                    deferred.reject,
                    function (progress) {
                        deferred.notify({ index: index, value: progress });
                    }
                );
            }
        }, void 0);
        if (countDown === 0) {
            deferred.resolve(promises);
        }
        return deferred.promise;
    });
}

Promise.prototype.all = function () {
    return all(this);
};

/**
 * Waits for all promises to be settled, either fulfilled or
 * rejected.  This is distinct from `all` since that would stop
 * waiting at the first rejection.  The promise returned by
 * `allResolved` will never be rejected.
 * @param promises a promise for an array (or an array) of promises
 * (or values)
 * @return a promise for an array of promises
 */
Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
function allResolved(promises) {
    return when(promises, function (promises) {
        promises = array_map(promises, Q);
        return when(all(array_map(promises, function (promise) {
            return when(promise, noop, noop);
        })), function () {
            return promises;
        });
    });
}

Promise.prototype.allResolved = function () {
    return allResolved(this);
};

/**
 * @see Promise#allSettled
 */
Q.allSettled = allSettled;
function allSettled(promises) {
    return Q(promises).allSettled();
}

/**
 * Turns an array of promises into a promise for an array of their states (as
 * returned by `inspect`) when they have all settled.
 * @param {Array[Any*]} values an array (or promise for an array) of values (or
 * promises for values)
 * @returns {Array[State]} an array of states for the respective values.
 */
Promise.prototype.allSettled = function () {
    return this.then(function (promises) {
        return all(array_map(promises, function (promise) {
            promise = Q(promise);
            function regardless() {
                return promise.inspect();
            }
            return promise.then(regardless, regardless);
        }));
    });
};

/**
 * Captures the failure of a promise, giving an oportunity to recover
 * with a callback.  If the given promise is fulfilled, the returned
 * promise is fulfilled.
 * @param {Any*} promise for something
 * @param {Function} callback to fulfill the returned promise if the
 * given promise is rejected
 * @returns a promise for the return value of the callback
 */
Q.fail = // XXX legacy
Q["catch"] = function (object, rejected) {
    return Q(object).then(void 0, rejected);
};

Promise.prototype.fail = // XXX legacy
Promise.prototype["catch"] = function (rejected) {
    return this.then(void 0, rejected);
};

/**
 * Attaches a listener that can respond to progress notifications from a
 * promise's originating deferred. This listener receives the exact arguments
 * passed to ``deferred.notify``.
 * @param {Any*} promise for something
 * @param {Function} callback to receive any progress notifications
 * @returns the given promise, unchanged
 */
Q.progress = progress;
function progress(object, progressed) {
    return Q(object).then(void 0, void 0, progressed);
}

Promise.prototype.progress = function (progressed) {
    return this.then(void 0, void 0, progressed);
};

/**
 * Provides an opportunity to observe the settling of a promise,
 * regardless of whether the promise is fulfilled or rejected.  Forwards
 * the resolution to the returned promise when the callback is done.
 * The callback can return a promise to defer completion.
 * @param {Any*} promise
 * @param {Function} callback to observe the resolution of the given
 * promise, takes no arguments.
 * @returns a promise for the resolution of the given promise when
 * ``fin`` is done.
 */
Q.fin = // XXX legacy
Q["finally"] = function (object, callback) {
    return Q(object)["finally"](callback);
};

Promise.prototype.fin = // XXX legacy
Promise.prototype["finally"] = function (callback) {
    callback = Q(callback);
    return this.then(function (value) {
        return callback.fcall().then(function () {
            return value;
        });
    }, function (reason) {
        // TODO attempt to recycle the rejection with "this".
        return callback.fcall().then(function () {
            throw reason;
        });
    });
};

/**
 * Terminates a chain of promises, forcing rejections to be
 * thrown as exceptions.
 * @param {Any*} promise at the end of a chain of promises
 * @returns nothing
 */
Q.done = function (object, fulfilled, rejected, progress) {
    return Q(object).done(fulfilled, rejected, progress);
};

Promise.prototype.done = function (fulfilled, rejected, progress) {
    var onUnhandledError = function (error) {
        // forward to a future turn so that ``when``
        // does not catch it and turn it into a rejection.
        nextTick(function () {
            makeStackTraceLong(error, promise);
            if (Q.onerror) {
                Q.onerror(error);
            } else {
                throw error;
            }
        });
    };

    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
    var promise = fulfilled || rejected || progress ?
        this.then(fulfilled, rejected, progress) :
        this;

    if (typeof process === "object" && process && process.domain) {
        onUnhandledError = process.domain.bind(onUnhandledError);
    }

    promise.then(void 0, onUnhandledError);
};

/**
 * Causes a promise to be rejected if it does not get fulfilled before
 * some milliseconds time out.
 * @param {Any*} promise
 * @param {Number} milliseconds timeout
 * @param {String} custom error message (optional)
 * @returns a promise for the resolution of the given promise if it is
 * fulfilled before the timeout, otherwise rejected.
 */
Q.timeout = function (object, ms, message) {
    return Q(object).timeout(ms, message);
};

Promise.prototype.timeout = function (ms, message) {
    var deferred = defer();
    var timeoutId = setTimeout(function () {
        deferred.reject(new Error(message || "Timed out after " + ms + " ms"));
    }, ms);

    this.then(function (value) {
        clearTimeout(timeoutId);
        deferred.resolve(value);
    }, function (exception) {
        clearTimeout(timeoutId);
        deferred.reject(exception);
    }, deferred.notify);

    return deferred.promise;
};

/**
 * Returns a promise for the given value (or promised value), some
 * milliseconds after it resolved. Passes rejections immediately.
 * @param {Any*} promise
 * @param {Number} milliseconds
 * @returns a promise for the resolution of the given promise after milliseconds
 * time has elapsed since the resolution of the given promise.
 * If the given promise rejects, that is passed immediately.
 */
Q.delay = function (object, timeout) {
    if (timeout === void 0) {
        timeout = object;
        object = void 0;
    }
    return Q(object).delay(timeout);
};

Promise.prototype.delay = function (timeout) {
    return this.then(function (value) {
        var deferred = defer();
        setTimeout(function () {
            deferred.resolve(value);
        }, timeout);
        return deferred.promise;
    });
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided as an array, and returns a promise.
 *
 *      Q.nfapply(FS.readFile, [__filename])
 *      .then(function (content) {
 *      })
 *
 */
Q.nfapply = function (callback, args) {
    return Q(callback).nfapply(args);
};

Promise.prototype.nfapply = function (args) {
    var deferred = defer();
    var nodeArgs = array_slice(args);
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided individually, and returns a promise.
 * @example
 * Q.nfcall(FS.readFile, __filename)
 * .then(function (content) {
 * })
 *
 */
Q.nfcall = function (callback /*...args*/) {
    var args = array_slice(arguments, 1);
    return Q(callback).nfapply(args);
};

Promise.prototype.nfcall = function (/*...args*/) {
    var nodeArgs = array_slice(arguments);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Wraps a NodeJS continuation passing function and returns an equivalent
 * version that returns a promise.
 * @example
 * Q.nfbind(FS.readFile, __filename)("utf-8")
 * .then(console.log)
 * .done()
 */
Q.nfbind =
Q.denodeify = function (callback /*...args*/) {
    var baseArgs = array_slice(arguments, 1);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        Q(callback).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nfbind =
Promise.prototype.denodeify = function (/*...args*/) {
    var args = array_slice(arguments);
    args.unshift(this);
    return Q.denodeify.apply(void 0, args);
};

Q.nbind = function (callback, thisp /*...args*/) {
    var baseArgs = array_slice(arguments, 2);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        function bound() {
            return callback.apply(thisp, arguments);
        }
        Q(bound).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nbind = function (/*thisp, ...args*/) {
    var args = array_slice(arguments, 0);
    args.unshift(this);
    return Q.nbind.apply(void 0, args);
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback with a given array of arguments, plus a provided callback.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param {Array} args arguments to pass to the method; the callback
 * will be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nmapply = // XXX As proposed by "Redsandro"
Q.npost = function (object, name, args) {
    return Q(object).npost(name, args);
};

Promise.prototype.nmapply = // XXX As proposed by "Redsandro"
Promise.prototype.npost = function (name, args) {
    var nodeArgs = array_slice(args || []);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback, forwarding the given variadic arguments, plus a provided
 * callback argument.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param ...args arguments to pass to the method; the callback will
 * be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nsend = // XXX Based on Mark Miller's proposed "send"
Q.nmcall = // XXX Based on "Redsandro's" proposal
Q.ninvoke = function (object, name /*...args*/) {
    var nodeArgs = array_slice(arguments, 2);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

Promise.prototype.nsend = // XXX Based on Mark Miller's proposed "send"
Promise.prototype.nmcall = // XXX Based on "Redsandro's" proposal
Promise.prototype.ninvoke = function (name /*...args*/) {
    var nodeArgs = array_slice(arguments, 1);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * If a function would like to support both Node continuation-passing-style and
 * promise-returning-style, it can end its internal promise chain with
 * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user
 * elects to use a nodeback, the result will be sent there.  If they do not
 * pass a nodeback, they will receive the result promise.
 * @param object a result (or a promise for a result)
 * @param {Function} nodeback a Node.js-style callback
 * @returns either the promise or nothing
 */
Q.nodeify = nodeify;
function nodeify(object, nodeback) {
    return Q(object).nodeify(nodeback);
}

Promise.prototype.nodeify = function (nodeback) {
    if (nodeback) {
        this.then(function (value) {
            nextTick(function () {
                nodeback(null, value);
            });
        }, function (error) {
            nextTick(function () {
                nodeback(error);
            });
        });
    } else {
        return this;
    }
};

// All code before this point will be filtered from stack traces.
var qEndingLine = captureLine();

return Q;

});

}).call(this,require('_process'))

},{"_process":27}],30:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],31:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],32:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":30,"./encode":31}],33:[function(require,module,exports){
(function() {
  var MarkedYAMLError, events, nodes, raml, util, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  events = require('./events');

  MarkedYAMLError = require('./errors').MarkedYAMLError;

  nodes = require('./nodes');

  raml = require('./raml');

  util = require('./util');

  this.ComposerError = (function(_super) {
    __extends(ComposerError, _super);

    function ComposerError() {
      _ref = ComposerError.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return ComposerError;

  })(MarkedYAMLError);

  this.Composer = (function() {
    function Composer() {
      this.composeRamlTree = __bind(this.composeRamlTree, this);
      this.anchors = {};
      this.filesToRead = [];
    }

    Composer.prototype.check_node = function() {
      if (this.check_event(events.StreamStartEvent)) {
        this.get_event();
      }
      return !this.check_event(events.StreamEndEvent);
    };

    /*
    Get the root node of the next document.
    */


    Composer.prototype.get_node = function() {
      if (!this.check_event(events.StreamEndEvent)) {
        return this.compose_document();
      }
    };

    Composer.prototype.getYamlRoot = function() {
      var document, event;
      this.get_event();
      document = null;
      if (!this.check_event(events.StreamEndEvent)) {
        document = this.compose_document();
      }
      if (!this.check_event(events.StreamEndEvent)) {
        event = this.get_event();
        throw new exports.ComposerError('document scan', document.start_mark, 'expected a single document in the stream but found another document', event.start_mark);
      }
      this.get_event();
      return document;
    };

    Composer.prototype.composeRamlTree = function(node, settings) {
      if (settings.validate || settings.transform) {
        this.load_schemas(node);
        this.load_traits(node);
        this.load_types(node);
        this.load_security_schemes(node);
      }
      if (settings.validate) {
        this.validate_document(node);
      }
      if (settings.transform) {
        this.apply_types(node);
        this.apply_traits(node);
        this.apply_schemas(node);
        this.apply_protocols(node);
        this.join_resources(node);
      }
      return node;
    };

    Composer.prototype.compose_document = function() {
      var node;
      this.get_event();
      node = this.compose_node();
      this.get_event();
      this.anchors = {};
      return node;
    };

    Composer.prototype.getPendingFilesList = function() {
      return this.filesToRead;
    };

    Composer.prototype.compose_node = function(parent, index) {
      var anchor, event, node;
      if (this.check_event(events.AliasEvent)) {
        event = this.get_event();
        anchor = event.anchor;
        if (!(anchor in this.anchors)) {
          throw new exports.ComposerError(null, null, "found undefined alias " + anchor, event.start_mark);
        }
        return this.anchors[anchor].clone();
      }
      event = this.peek_event();
      anchor = event.anchor;
      if (anchor !== null && anchor in this.anchors) {
        throw new exports.ComposerError("found duplicate anchor " + anchor + "; first occurence", this.anchors[anchor].start_mark, 'second occurrence', event.start_mark);
      }
      this.descend_resolver(parent, index);
      if (this.check_event(events.ScalarEvent)) {
        node = this.compose_scalar_node(anchor, parent, index);
      } else if (this.check_event(events.SequenceStartEvent)) {
        node = this.compose_sequence_node(anchor);
      } else if (this.check_event(events.MappingStartEvent)) {
        node = this.compose_mapping_node(anchor);
      }
      this.ascend_resolver();
      return node;
    };

    Composer.prototype.compose_fixed_scalar_node = function(anchor, value) {
      var event, node;
      event = this.get_event();
      node = new nodes.ScalarNode('tag:yaml.org,2002:str', value, event.start_mark, event.end_mark, event.style);
      if (anchor !== null) {
        this.anchors[anchor] = node;
      }
      return node;
    };

    Composer.prototype.compose_scalar_node = function(anchor, parent, key) {
      var event, extension, fileType, node, tag;
      event = this.get_event();
      tag = event.tag;
      node = {};
      if (tag === null || tag === '!') {
        tag = this.resolve(nodes.ScalarNode, event.value, event.implicit);
      }
      if (event.tag === '!include') {
        if (event.value.match(/^\s*$/)) {
          throw new exports.ComposerError('while composing scalar out of !include', null, "file name/URL cannot be null", event.start_mark);
        }
        extension = event.value.split('.').pop();
        if (extension === 'yaml' || extension === 'yml' || extension === 'raml') {
          fileType = 'fragment';
        } else {
          fileType = 'scalar';
        }
        this.filesToRead.push({
          targetUri: event.value,
          type: fileType,
          parentNode: parent,
          parentKey: key,
          event: event,
          includingContext: this.src,
          targetFileUri: event.value
        });
        node = void 0;
      } else {
        node = new nodes.ScalarNode(tag, event.value, event.start_mark, event.end_mark, event.style);
      }
      if (anchor && node) {
        this.anchors[anchor] = node;
      }
      return node;
    };

    Composer.prototype.compose_sequence_node = function(anchor) {
      var end_event, index, node, start_event, tag, value;
      start_event = this.get_event();
      tag = start_event.tag;
      if (tag === null || tag === '!') {
        tag = this.resolve(nodes.SequenceNode, null, start_event.implicit);
      }
      node = new nodes.SequenceNode(tag, [], start_event.start_mark, null, start_event.flow_style);
      index = 0;
      if (anchor) {
        this.anchors[anchor] = node;
      }
      while (!this.check_event(events.SequenceEndEvent)) {
        if (value = this.compose_node(node, index)) {
          node.value[index] = value;
        }
        index++;
      }
      end_event = this.get_event();
      node.end_mark = end_event.end_mark;
      return node;
    };

    Composer.prototype.compose_mapping_node = function(anchor) {
      var end_event, item_key, item_value, node, start_event, tag;
      start_event = this.get_event();
      tag = start_event.tag;
      if (tag === null || tag === '!') {
        tag = this.resolve(nodes.MappingNode, null, start_event.implicit);
      }
      node = new nodes.MappingNode(tag, [], start_event.start_mark, null, start_event.flow_style);
      if (anchor !== null) {
        this.anchors[anchor] = node;
      }
      while (!this.check_event(events.MappingEndEvent)) {
        item_key = this.compose_node(node);
        if (!util.isScalar(item_key)) {
          throw new exports.ComposerError('while composing mapping key', null, "only scalar map keys are allowed in RAML", item_key.start_mark);
        }
        if (item_value = this.compose_node(node, item_key)) {
          node.value.push([item_key, item_value]);
        }
      }
      end_event = this.get_event();
      node.end_mark = end_event.end_mark;
      return node;
    };

    return Composer;

  })();

}).call(this);

},{"./errors":35,"./events":36,"./nodes":39,"./raml":42,"./util":52}],34:[function(require,module,exports){
(function (Buffer){
(function() {
  var MarkedYAMLError, nodes, util, _ref, _ref1,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  MarkedYAMLError = require('./errors').MarkedYAMLError;

  nodes = require('./nodes');

  util = require('./util');

  this.ConstructorError = (function(_super) {
    __extends(ConstructorError, _super);

    function ConstructorError() {
      _ref = ConstructorError.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return ConstructorError;

  })(MarkedYAMLError);

  this.BaseConstructor = (function() {
    BaseConstructor.prototype.yaml_constructors = {};

    BaseConstructor.prototype.yaml_multi_constructors = {};

    BaseConstructor.add_constructor = function(tag, constructor) {
      if (!this.prototype.hasOwnProperty('yaml_constructors')) {
        this.prototype.yaml_constructors = util.extend({}, this.prototype.yaml_constructors);
      }
      return this.prototype.yaml_constructors[tag] = constructor;
    };

    BaseConstructor.add_multi_constructor = function(tag_prefix, multi_constructor) {
      if (!this.prototype.hasOwnProperty('yaml_multi_constructors')) {
        this.prototype.yaml_multi_constructors = util.extend({}, this.prototype.yaml_multi_constructors);
      }
      return this.prototype.yaml_multi_constructors[tag_prefix] = multi_constructor;
    };

    function BaseConstructor() {
      this.constructed_objects = {};
      this.constructing_nodes = [];
      this.deferred_constructors = [];
    }

    BaseConstructor.prototype.construct_document = function(node) {
      var data;
      this.applyAstTransformations(node);
      data = this.construct_object(node);
      while (!util.is_empty(this.deferred_constructors)) {
        this.deferred_constructors.pop()();
      }
      this.applyTransformations(data);
      return data;
    };

    BaseConstructor.prototype.defer = function(f) {
      return this.deferred_constructors.push(f);
    };

    BaseConstructor.prototype.construct_object = function(node) {
      var constructor, object, tag_prefix, tag_suffix, _ref1;
      if (node.unique_id in this.constructed_objects) {
        return this.constructed_objects[node.unique_id];
      }
      if (_ref1 = node.unique_id, __indexOf.call(this.constructing_nodes, _ref1) >= 0) {
        throw new exports.ConstructorError(null, null, 'found unconstructable recursive node', node.start_mark);
      }
      this.constructing_nodes.push(node.unique_id);
      constructor = null;
      tag_suffix = null;
      if (node.tag in this.yaml_constructors) {
        constructor = this.yaml_constructors[node.tag];
      } else {
        for (tag_prefix in this.yaml_multi_constructors) {
          if (node.tag.indexOf(tag_prefix === 0)) {
            tag_suffix = node.tag.slice(tag_prefix.length);
            constructor = this.yaml_multi_constructors[tag_prefix];
            break;
          }
        }
        if (constructor == null) {
          if (null in this.yaml_multi_constructors) {
            tag_suffix = node.tag;
            constructor = this.yaml_multi_constructors[null];
          } else if (null in this.yaml_constructors) {
            constructor = this.yaml_constructors[null];
          } else if (node instanceof nodes.ScalarNode) {
            constructor = this.construct_scalar;
          } else if (node instanceof nodes.SequenceNode) {
            constructor = this.construct_sequence;
          } else if (node instanceof nodes.MappingNode) {
            constructor = this.construct_mapping;
          }
        }
      }
      object = constructor.call(this, tag_suffix != null ? tag_suffix : node, node);
      this.constructed_objects[node.unique_id] = object;
      this.constructing_nodes.pop();
      return object;
    };

    BaseConstructor.prototype.construct_scalar = function(node) {
      if (!(node instanceof nodes.ScalarNode)) {
        throw new exports.ConstructorError(null, null, "expected a scalar node but found " + node.id, node.start_mark);
      }
      return node.value;
    };

    BaseConstructor.prototype.construct_sequence = function(node) {
      var child, _i, _len, _ref1, _results;
      if (!(node instanceof nodes.SequenceNode)) {
        throw new exports.ConstructorError(null, null, "expected an array node but found " + node.id, node.start_mark);
      }
      _ref1 = node.value;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        child = _ref1[_i];
        _results.push(this.construct_object(child));
      }
      return _results;
    };

    BaseConstructor.prototype.construct_mapping = function(node) {
      var key, key_item, key_item_value, key_node, mapping, value, value_node, _i, _j, _len, _len1, _ref1, _ref2, _ref3;
      if (!(node instanceof nodes.MappingNode)) {
        throw new exports.ConstructorError(null, null, "expected a map node but found " + node.id, node.start_mark);
      }
      mapping = {};
      _ref1 = node.value;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        _ref2 = _ref1[_i], key_node = _ref2[0], value_node = _ref2[1];
        key = this.construct_object(key_node);
        value = this.construct_object(value_node);
        if (typeof key === 'object' && key_node.tag === 'tag:yaml.org,2002:seq') {
          _ref3 = key_node.value;
          for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
            key_item = _ref3[_j];
            key_item_value = this.construct_object(key_item);
            mapping[key_item_value] = value;
          }
        } else if (typeof key === 'object') {
          throw new exports.ConstructorError('while constructing a map', node.start_mark, 'found unhashable key', key_node.start_mark);
        } else {
          mapping[key] = value;
        }
      }
      return mapping;
    };

    BaseConstructor.prototype.construct_pairs = function(node) {
      var key, key_node, pairs, value, value_node, _i, _len, _ref1, _ref2;
      if (!(node instanceof nodes.MappingNode)) {
        throw new exports.ConstructorError(null, null, "expected a map node but found " + node.id, node.start_mark);
      }
      pairs = [];
      _ref1 = node.value;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        _ref2 = _ref1[_i], key_node = _ref2[0], value_node = _ref2[1];
        key = this.construct_object(key_node);
        value = this.construct_object(value_node);
        pairs.push([key, value]);
      }
      return pairs;
    };

    return BaseConstructor;

  })();

  this.Constructor = (function(_super) {
    var BOOL_VALUES, TIMESTAMP_PARTS, TIMESTAMP_REGEX;

    __extends(Constructor, _super);

    function Constructor() {
      _ref1 = Constructor.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    BOOL_VALUES = {
      "true": true,
      "false": false
    };

    TIMESTAMP_REGEX = /^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:(?:[Tt]|[\x20\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\.([0-9]*))?(?:[\x20\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?)?$/;

    TIMESTAMP_PARTS = {
      year: 1,
      month: 2,
      day: 3,
      hour: 4,
      minute: 5,
      second: 6,
      fraction: 7,
      tz: 8,
      tz_sign: 9,
      tz_hour: 10,
      tz_minute: 11
    };

    Constructor.prototype.yaml_constructors = {};

    Constructor.prototype.yaml_multi_constructors = {};

    Constructor.prototype.construct_scalar = function(node) {
      var key_node, value_node, _i, _len, _ref2, _ref3;
      if (node instanceof nodes.MappingNode) {
        _ref2 = node.value;
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          _ref3 = _ref2[_i], key_node = _ref3[0], value_node = _ref3[1];
          if (key_node.tag === 'tag:yaml.org,2002:value') {
            return this.construct_scalar(value_node);
          }
        }
      }
      return Constructor.__super__.construct_scalar.call(this, node);
    };

    Constructor.prototype.flatten_mapping = function(node) {
      var index, key_node, merge, submerge, subnode, value, value_node, _i, _j, _len, _len1, _ref2, _ref3;
      merge = [];
      index = 0;
      while (index < node.value.length) {
        _ref2 = node.value[index], key_node = _ref2[0], value_node = _ref2[1];
        if (key_node.tag === 'tag:yaml.org,2002:merge') {
          node.value.splice(index, 1);
          if (value_node instanceof nodes.MappingNode) {
            this.flatten_mapping(value_node);
            merge = merge.concat(value_node.value);
          } else if (value_node instanceof nodes.SequenceNode) {
            submerge = [];
            _ref3 = value_node.value;
            for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
              subnode = _ref3[_i];
              if (!(subnode instanceof nodes.MappingNode)) {
                throw new exports.ConstructorError('while constructing a map', node.start_mark, "expected a map for merging, but found " + subnode.id, subnode.start_mark);
              }
              this.flatten_mapping(subnode);
              submerge.push(subnode.value);
            }
            submerge.reverse();
            for (_j = 0, _len1 = submerge.length; _j < _len1; _j++) {
              value = submerge[_j];
              merge = merge.concat(value);
            }
          } else {
            throw new exports.ConstructorError('while constructing a map', node.start_mark, "expected a map or an array of maps for            merging but found " + value_node.id, value_node.start_mark);
          }
        } else if (key_node.tag === 'tag:yaml.org,2002:value') {
          key_node.tag = 'tag:yaml.org,2002:str';
          index++;
        } else {
          index++;
        }
      }
      if (merge.length) {
        return node.value = merge.concat(node.value);
      }
    };

    Constructor.prototype.construct_mapping = function(node) {
      if (node instanceof nodes.MappingNode) {
        this.flatten_mapping(node);
      }
      return Constructor.__super__.construct_mapping.call(this, node);
    };

    Constructor.prototype.construct_yaml_null = function(node) {
      this.construct_scalar(node);
      return null;
    };

    Constructor.prototype.construct_yaml_bool = function(node) {
      var value;
      value = this.construct_scalar(node);
      return BOOL_VALUES[value.toLowerCase()];
    };

    Constructor.prototype.construct_yaml_int = function(node) {
      var base, digit, digits, part, sign, value, _i, _len, _ref2;
      value = this.construct_scalar(node);
      value = value.replace(/_/g, '');
      sign = value[0] === '-' ? -1 : 1;
      if (_ref2 = value[0], __indexOf.call('+-', _ref2) >= 0) {
        value = value.slice(1);
      }
      if (value === '0') {
        return 0;
      } else if (value.indexOf('0b') === 0) {
        return sign * parseInt(value.slice(2), 2);
      } else if (value.indexOf('0x') === 0) {
        return sign * parseInt(value.slice(2), 16);
      } else if (value.indexOf('0o') === 0) {
        return sign * parseInt(value.slice(2), 8);
      } else if (value[0] === '0') {
        return sign * parseInt(value, 8);
      } else if (__indexOf.call(value, ':') >= 0) {
        digits = (function() {
          var _i, _len, _ref3, _results;
          _ref3 = value.split(/:/g);
          _results = [];
          for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
            part = _ref3[_i];
            _results.push(parseInt(part));
          }
          return _results;
        })();
        digits.reverse();
        base = 1;
        value = 0;
        for (_i = 0, _len = digits.length; _i < _len; _i++) {
          digit = digits[_i];
          value += digit * base;
          base *= 60;
        }
        return sign * value;
      } else {
        return sign * parseInt(value);
      }
    };

    Constructor.prototype.construct_yaml_float = function(node) {
      var base, digit, digits, part, sign, value, _i, _len, _ref2;
      value = this.construct_scalar(node);
      value = value.replace(/_/g, '').toLowerCase();
      sign = value[0] === '-' ? -1 : 1;
      if (_ref2 = value[0], __indexOf.call('+-', _ref2) >= 0) {
        value = value.slice(1);
      }
      if (value === '.inf') {
        return sign * Infinity;
      } else if (value === '.nan') {
        return NaN;
      } else if (__indexOf.call(value, ':') >= 0) {
        digits = (function() {
          var _i, _len, _ref3, _results;
          _ref3 = value.split(/:/g);
          _results = [];
          for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
            part = _ref3[_i];
            _results.push(parseFloat(part));
          }
          return _results;
        })();
        digits.reverse();
        base = 1;
        value = 0.0;
        for (_i = 0, _len = digits.length; _i < _len; _i++) {
          digit = digits[_i];
          value += digit * base;
          base *= 60;
        }
        return sign * value;
      } else {
        return sign * parseFloat(value);
      }
    };

    Constructor.prototype.construct_yaml_binary = function(node) {
      var error, value;
      value = this.construct_scalar(node);
      try {
        if (typeof window !== "undefined" && window !== null) {
          return atob(value);
        }
        return new Buffer(value, 'base64').toString('ascii');
      } catch (_error) {
        error = _error;
        throw new exports.ConstructorError(null, null, "failed to decode base64 data: " + error, node.start_mark);
      }
    };

    Constructor.prototype.construct_yaml_timestamp = function(node) {
      var date, day, fraction, hour, index, key, match, millisecond, minute, month, second, tz_hour, tz_minute, tz_sign, value, values, year;
      value = this.construct_scalar(node);
      match = node.value.match(TIMESTAMP_REGEX);
      values = {};
      for (key in TIMESTAMP_PARTS) {
        index = TIMESTAMP_PARTS[key];
        values[key] = match[index];
      }
      year = parseInt(values.year);
      month = parseInt(values.month) - 1;
      day = parseInt(values.day);
      if (!values.hour) {
        return new Date(Date.UTC(year, month, day));
      }
      hour = parseInt(values.hour);
      minute = parseInt(values.minute);
      second = parseInt(values.second);
      millisecond = 0;
      if (values.fraction) {
        fraction = values.fraction.slice(0, 6);
        while (fraction.length < 6) {
          fraction += '0';
        }
        fraction = parseInt(fraction);
        millisecond = Math.round(fraction / 1000);
      }
      if (values.tz_sign) {
        tz_sign = values.tz_sign === '-' ? 1 : -1;
        if (tz_hour = parseInt(values.tz_hour)) {
          hour += tz_sign * tz_hour;
        }
        if (tz_minute = parseInt(values.tz_minute)) {
          minute += tz_sign * tz_minute;
        }
      }
      date = new Date(Date.UTC(year, month, day, hour, minute, second, millisecond));
      return date;
    };

    Constructor.prototype.construct_yaml_pair_list = function(type, node) {
      var list,
        _this = this;
      list = [];
      if (!(node instanceof nodes.SequenceNode)) {
        throw new exports.ConstructorError("while constructing " + type, node.start_mark, "expected an array but found " + node.id, node.start_mark);
      }
      this.defer(function() {
        var key, key_node, subnode, value, value_node, _i, _len, _ref2, _ref3, _results;
        _ref2 = node.value;
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          subnode = _ref2[_i];
          if (!(subnode instanceof nodes.MappingNode)) {
            throw new exports.ConstructorError("while constructing " + type, node.start_mark, "expected a map of length 1 but found " + subnode.id, subnode.start_mark);
          }
          if (subnode.value.length !== 1) {
            throw new exports.ConstructorError("while constructing " + type, node.start_mark, "expected a map of length 1 but found " + subnode.id, subnode.start_mark);
          }
          _ref3 = subnode.value[0], key_node = _ref3[0], value_node = _ref3[1];
          key = _this.construct_object(key_node);
          value = _this.construct_object(value_node);
          _results.push(list.push([key, value]));
        }
        return _results;
      });
      return list;
    };

    Constructor.prototype.construct_yaml_omap = function(node) {
      return this.construct_yaml_pair_list('an ordered map', node);
    };

    Constructor.prototype.construct_yaml_pairs = function(node) {
      return this.construct_yaml_pair_list('pairs', node);
    };

    Constructor.prototype.construct_yaml_set = function(node) {
      var data,
        _this = this;
      data = [];
      this.defer(function() {
        var item, _results;
        _results = [];
        for (item in _this.construct_mapping(node)) {
          _results.push(data.push(item));
        }
        return _results;
      });
      return data;
    };

    Constructor.prototype.construct_yaml_str = function(node) {
      return this.construct_scalar(node);
    };

    Constructor.prototype.construct_yaml_seq = function(node) {
      var data,
        _this = this;
      data = [];
      this.defer(function() {
        var item, _i, _len, _ref2, _results;
        _ref2 = _this.construct_sequence(node);
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          item = _ref2[_i];
          _results.push(data.push(item));
        }
        return _results;
      });
      return data;
    };

    Constructor.prototype.construct_yaml_map = function(node) {
      var data,
        _this = this;
      data = {};
      this.defer(function() {
        var key, value, _ref2, _results;
        _ref2 = _this.construct_mapping(node);
        _results = [];
        for (key in _ref2) {
          value = _ref2[key];
          _results.push(data[key] = value);
        }
        return _results;
      });
      return data;
    };

    Constructor.prototype.construct_yaml_object = function(node, klass) {
      var data,
        _this = this;
      data = new klass;
      this.defer(function() {
        var key, value, _ref2, _results;
        _ref2 = _this.construct_mapping(node, true);
        _results = [];
        for (key in _ref2) {
          value = _ref2[key];
          _results.push(data[key] = value);
        }
        return _results;
      });
      return data;
    };

    Constructor.prototype.construct_undefined = function(node) {
      throw new exports.ConstructorError(null, null, "could not determine a constructor for the tag " + node.tag, node.start_mark);
    };

    return Constructor;

  })(this.BaseConstructor);

  this.Constructor.add_constructor('tag:yaml.org,2002:null', this.Constructor.prototype.construct_yaml_null);

  this.Constructor.add_constructor('tag:yaml.org,2002:bool', this.Constructor.prototype.construct_yaml_bool);

  this.Constructor.add_constructor('tag:yaml.org,2002:int', this.Constructor.prototype.construct_yaml_int);

  this.Constructor.add_constructor('tag:yaml.org,2002:float', this.Constructor.prototype.construct_yaml_float);

  this.Constructor.add_constructor('tag:yaml.org,2002:binary', this.Constructor.prototype.construct_yaml_binary);

  this.Constructor.add_constructor('tag:yaml.org,2002:timestamp', this.Constructor.prototype.construct_yaml_timestamp);

  this.Constructor.add_constructor('tag:yaml.org,2002:omap', this.Constructor.prototype.construct_yaml_omap);

  this.Constructor.add_constructor('tag:yaml.org,2002:pairs', this.Constructor.prototype.construct_yaml_pairs);

  this.Constructor.add_constructor('tag:yaml.org,2002:set', this.Constructor.prototype.construct_yaml_set);

  this.Constructor.add_constructor('tag:yaml.org,2002:str', this.Constructor.prototype.construct_yaml_str);

  this.Constructor.add_constructor('tag:yaml.org,2002:seq', this.Constructor.prototype.construct_yaml_seq);

  this.Constructor.add_constructor('tag:yaml.org,2002:map', this.Constructor.prototype.construct_yaml_map);

  this.Constructor.add_constructor(null, this.Constructor.prototype.construct_undefined);

  module.exports.Constructor = this.Constructor;

  module.exports.ConstructorError = this.ConstructorError;

}).call(this);

}).call(this,require("buffer").Buffer)

},{"./errors":35,"./nodes":39,"./util":52,"buffer":6}],35:[function(require,module,exports){
(function() {
  var _ref,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  this.Mark = (function() {
    function Mark(name, line, column, buffer, pointer) {
      this.name = name;
      this.line = line;
      this.column = column;
      this.buffer = buffer;
      this.pointer = pointer;
    }

    Mark.prototype.get_snippet = function(indent, max_length) {
      var break_chars, end, head, start, tail, _ref, _ref1;
      if (indent == null) {
        indent = 4;
      }
      if (max_length == null) {
        max_length = 75;
      }
      if (this.buffer == null) {
        return null;
      }
      break_chars = '\x00\r\n\x85\u2028\u2029';
      head = '';
      start = this.pointer;
      while (start > 0 && (_ref = this.buffer[start - 1], __indexOf.call(break_chars, _ref) < 0)) {
        start--;
        if (this.pointer - start > max_length / 2 - 1) {
          head = ' ... ';
          start += 5;
          break;
        }
      }
      tail = '';
      end = this.pointer;
      while (end < this.buffer.length && (_ref1 = this.buffer[end], __indexOf.call(break_chars, _ref1) < 0)) {
        end++;
        if (end - this.pointer > max_length / 2 - 1) {
          tail = ' ... ';
          end -= 5;
          break;
        }
      }
      return "" + ((new Array(indent)).join(' ')) + head + this.buffer.slice(start, end) + tail + "\n" + ((new Array(indent + this.pointer - start + head.length)).join(' ')) + "^";
    };

    Mark.prototype.toString = function() {
      var snippet, where;
      snippet = this.get_snippet();
      where = "  in \"" + this.name + "\", line " + (this.line + 1) + ", column " + (this.column + 1);
      if (snippet) {
        return where;
      } else {
        return "" + where + ":\n" + snippet;
      }
    };

    return Mark;

  })();

  this.YAMLError = (function(_super) {
    __extends(YAMLError, _super);

    function YAMLError() {
      YAMLError.__super__.constructor.call(this);
    }

    return YAMLError;

  })(Error);

  this.MarkedYAMLError = (function(_super) {
    __extends(MarkedYAMLError, _super);

    function MarkedYAMLError(context, context_mark, message, problem_mark, note) {
      this.context = context;
      this.context_mark = context_mark;
      this.message = message;
      this.problem_mark = problem_mark;
      this.note = note;
      MarkedYAMLError.__super__.constructor.call(this);
      if (!this.message) {
        this.message = this.context;
      }
      if (!this.problem_mark) {
        this.problem_mark = this.context_mark;
      }
    }

    MarkedYAMLError.prototype.toString = function() {
      var lines;
      lines = [];
      if (this.context != null) {
        lines.push(this.context);
      }
      if ((this.context_mark != null) && ((this.message == null) || (this.problem_mark == null) || this.context_mark.name !== this.problem_mark.name || this.context_mark.line !== this.problem_mark.line || this.context_mark.column !== this.problem_mark.column)) {
        lines.push(this.context_mark.toString());
      }
      if (this.message != null) {
        lines.push(this.message);
      }
      if (this.problem_mark != null) {
        lines.push(this.problem_mark.toString());
      }
      if (this.note != null) {
        lines.push(this.note);
      }
      return lines.join('\n');
    };

    return MarkedYAMLError;

  })(this.YAMLError);

  /*
  The Validator throws these.
  */


  this.ValidationError = (function(_super) {
    __extends(ValidationError, _super);

    function ValidationError() {
      _ref = ValidationError.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return ValidationError;

  })(this.MarkedYAMLError);

}).call(this);

},{}],36:[function(require,module,exports){
(function() {
  var _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  this.Event = (function() {
    function Event(start_mark, end_mark) {
      this.start_mark = start_mark;
      this.end_mark = end_mark;
    }

    return Event;

  })();

  this.NodeEvent = (function(_super) {
    __extends(NodeEvent, _super);

    function NodeEvent(anchor, start_mark, end_mark) {
      this.anchor = anchor;
      this.start_mark = start_mark;
      this.end_mark = end_mark;
    }

    return NodeEvent;

  })(this.Event);

  this.CollectionStartEvent = (function(_super) {
    __extends(CollectionStartEvent, _super);

    function CollectionStartEvent(anchor, tag, implicit, start_mark, end_mark) {
      this.anchor = anchor;
      this.tag = tag;
      this.implicit = implicit;
      this.start_mark = start_mark;
      this.end_mark = end_mark;
    }

    return CollectionStartEvent;

  })(this.NodeEvent);

  this.CollectionEndEvent = (function(_super) {
    __extends(CollectionEndEvent, _super);

    function CollectionEndEvent() {
      _ref = CollectionEndEvent.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return CollectionEndEvent;

  })(this.Event);

  this.StreamStartEvent = (function(_super) {
    __extends(StreamStartEvent, _super);

    function StreamStartEvent(start_mark, end_mark, explicit, version, tags) {
      this.start_mark = start_mark;
      this.end_mark = end_mark;
      this.explicit = explicit;
      this.version = version;
      this.tags = tags;
    }

    return StreamStartEvent;

  })(this.Event);

  this.StreamEndEvent = (function(_super) {
    __extends(StreamEndEvent, _super);

    function StreamEndEvent() {
      _ref1 = StreamEndEvent.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    return StreamEndEvent;

  })(this.Event);

  this.DocumentStartEvent = (function(_super) {
    __extends(DocumentStartEvent, _super);

    function DocumentStartEvent(start_mark, end_mark, explicit, version, tags) {
      this.start_mark = start_mark;
      this.end_mark = end_mark;
      this.explicit = explicit;
      this.version = version;
      this.tags = tags;
    }

    return DocumentStartEvent;

  })(this.Event);

  this.DocumentEndEvent = (function(_super) {
    __extends(DocumentEndEvent, _super);

    function DocumentEndEvent(start_mark, end_mark, explicit) {
      this.start_mark = start_mark;
      this.end_mark = end_mark;
      this.explicit = explicit;
    }

    return DocumentEndEvent;

  })(this.Event);

  this.AliasEvent = (function(_super) {
    __extends(AliasEvent, _super);

    function AliasEvent() {
      _ref2 = AliasEvent.__super__.constructor.apply(this, arguments);
      return _ref2;
    }

    return AliasEvent;

  })(this.NodeEvent);

  this.ScalarEvent = (function(_super) {
    __extends(ScalarEvent, _super);

    function ScalarEvent(anchor, tag, implicit, value, start_mark, end_mark, style) {
      this.anchor = anchor;
      this.tag = tag;
      this.implicit = implicit;
      this.value = value;
      this.start_mark = start_mark;
      this.end_mark = end_mark;
      this.style = style;
    }

    return ScalarEvent;

  })(this.NodeEvent);

  this.SequenceStartEvent = (function(_super) {
    __extends(SequenceStartEvent, _super);

    function SequenceStartEvent() {
      _ref3 = SequenceStartEvent.__super__.constructor.apply(this, arguments);
      return _ref3;
    }

    return SequenceStartEvent;

  })(this.CollectionStartEvent);

  this.SequenceEndEvent = (function(_super) {
    __extends(SequenceEndEvent, _super);

    function SequenceEndEvent() {
      _ref4 = SequenceEndEvent.__super__.constructor.apply(this, arguments);
      return _ref4;
    }

    return SequenceEndEvent;

  })(this.CollectionEndEvent);

  this.MappingStartEvent = (function(_super) {
    __extends(MappingStartEvent, _super);

    function MappingStartEvent() {
      _ref5 = MappingStartEvent.__super__.constructor.apply(this, arguments);
      return _ref5;
    }

    return MappingStartEvent;

  })(this.CollectionStartEvent);

  this.MappingEndEvent = (function(_super) {
    __extends(MappingEndEvent, _super);

    function MappingEndEvent() {
      _ref6 = MappingEndEvent.__super__.constructor.apply(this, arguments);
      return _ref6;
    }

    return MappingEndEvent;

  })(this.CollectionEndEvent);

}).call(this);

},{}],37:[function(require,module,exports){
(function() {
  var MarkedYAMLError, nodes, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  MarkedYAMLError = require('./errors').MarkedYAMLError;

  nodes = require('./nodes');

  /*
  The Traits throws these.
  */


  this.JoinError = (function(_super) {
    __extends(JoinError, _super);

    function JoinError() {
      _ref = JoinError.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return JoinError;

  })(MarkedYAMLError);

  /*
  The Joiner class groups resources under resource property and groups methods under operations property
  */


  this.Joiner = (function() {
    function Joiner() {}

    Joiner.prototype.join_resources = function(node, call) {
      var resources, resourcesArray, resourcesName, resourcesValue,
        _this = this;
      if (call == null) {
        call = 0;
      }
      resources = [];
      if (node != null ? node.value : void 0) {
        resources = node.value.filter(function(childNode) {
          var _ref1;
          return (_ref1 = childNode[0]) != null ? _ref1.value.match(/^\//) : void 0;
        });
      }
      resourcesArray = [];
      if (resources.length > 0) {
        if (node != null ? node.value : void 0) {
          node.value = node.value.filter(function(childNode) {
            return !childNode[0].value.match(/^\//);
          });
        }
        resourcesName = new nodes.ScalarNode('tag:yaml.org,2002:str', 'resources', resources[0][0].start_mark, resources[resources.length - 1][1].end_mark);
        resources.forEach(function(resource) {
          var relativeUriName, relativeUriValue;
          relativeUriName = new nodes.ScalarNode('tag:yaml.org,2002:str', 'relativeUri', resource[0].start_mark, resource[1].end_mark);
          relativeUriValue = new nodes.ScalarNode('tag:yaml.org,2002:str', resource[0].value, resource[0].start_mark, resource[1].end_mark);
          if (resource[1].tag === "tag:yaml.org,2002:null") {
            resource[1] = new nodes.MappingNode('tag:yaml.org,2002:map', [], resource[0].start_mark, resource[1].end_mark);
          }
          resource[1].value.push([relativeUriName, relativeUriValue]);
          resourcesArray.push(resource[1]);
          _this.join_methods(resource[1]);
          return _this.join_resources(resource[1], ++call);
        });
        resourcesValue = new nodes.SequenceNode('tag:yaml.org,2002:seq', resourcesArray, resources[0][0].start_mark, resources[resources.length - 1][1].end_mark);
        return node.value.push([resourcesName, resourcesValue]);
      }
    };

    Joiner.prototype.join_methods = function(node) {
      var methods, methodsArray, methodsName, methodsValue,
        _this = this;
      methods = [];
      if (node && node.value) {
        methods = node.value.filter(function(childNode) {
          var _ref1;
          return _this.isHttpMethod((_ref1 = childNode[0]) != null ? _ref1.value : void 0);
        });
      }
      methodsArray = [];
      if (methods.length > 0) {
        node.value = node.value.filter(function(childNode) {
          return !_this.isHttpMethod(childNode[0].value);
        });
        methodsName = new nodes.ScalarNode('tag:yaml.org,2002:str', 'methods', methods[0][0].start_mark, methods[methods.length - 1][1].end_mark);
        methods.forEach(function(method) {
          var methodName, methodValue;
          methodName = new nodes.ScalarNode('tag:yaml.org,2002:str', 'method', method[0].start_mark, method[1].end_mark);
          methodValue = new nodes.ScalarNode('tag:yaml.org,2002:str', method[0].value, method[0].start_mark, method[1].end_mark);
          if (method[1].tag === 'tag:yaml.org,2002:null') {
            method[1] = new nodes.MappingNode('tag:yaml.org,2002:map', [], method[1].start_mark, method[1].end_mark);
          }
          method[1].value.push([methodName, methodValue]);
          return methodsArray.push(method[1]);
        });
        methodsValue = new nodes.SequenceNode('tag:yaml.org,2002:seq', methodsArray, methods[0][0].start_mark, methods[methods.length - 1][1].end_mark);
        return node.value.push([methodsName, methodsValue]);
      }
    };

    return Joiner;

  })();

}).call(this);

},{"./errors":35,"./nodes":39}],38:[function(require,module,exports){
(function() {
  var composer, construct, joiner, parser, protocols, reader, resolver, scanner, schemas, securitySchemes, traits, transformations, types, util, validator;

  util = require('./util');

  reader = require('./reader');

  scanner = require('./scanner');

  parser = require('./parser');

  composer = require('./composer');

  resolver = require('./resolver');

  construct = require('./construct');

  validator = require('./validator');

  joiner = require('./joiner');

  traits = require('./traits');

  types = require('./resourceTypes');

  schemas = require('./schemas');

  protocols = require('./protocols');

  securitySchemes = require('./securitySchemes');

  transformations = require('./transformations');

  this.make_loader = function(Reader, Scanner, Parser, Composer, Resolver, Validator, ResourceTypes, Traits, Schemas, Protocols, Joiner, SecuritySchemes, Constructor, Transformations) {
    if (Reader == null) {
      Reader = reader.Reader;
    }
    if (Scanner == null) {
      Scanner = scanner.Scanner;
    }
    if (Parser == null) {
      Parser = parser.Parser;
    }
    if (Composer == null) {
      Composer = composer.Composer;
    }
    if (Resolver == null) {
      Resolver = resolver.Resolver;
    }
    if (Validator == null) {
      Validator = validator.Validator;
    }
    if (ResourceTypes == null) {
      ResourceTypes = types.ResourceTypes;
    }
    if (Traits == null) {
      Traits = traits.Traits;
    }
    if (Schemas == null) {
      Schemas = schemas.Schemas;
    }
    if (Protocols == null) {
      Protocols = protocols.Protocols;
    }
    if (Joiner == null) {
      Joiner = joiner.Joiner;
    }
    if (SecuritySchemes == null) {
      SecuritySchemes = securitySchemes.SecuritySchemes;
    }
    if (Constructor == null) {
      Constructor = construct.Constructor;
    }
    if (Transformations == null) {
      Transformations = transformations.Transformations;
    }
    return (function() {
      var component, components;

      components = [Reader, Scanner, Composer, Transformations, Parser, Resolver, Validator, Traits, ResourceTypes, Schemas, Protocols, Joiner, Constructor, SecuritySchemes];

      util.extend.apply(util, [_Class.prototype].concat((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = components.length; _i < _len; _i++) {
          component = components[_i];
          _results.push(component.prototype);
        }
        return _results;
      })()));

      function _Class(stream, location, settings, parent) {
        var _i, _len, _ref;
        this.parent = parent != null ? parent : null;
        components[0].call(this, stream, location);
        components[1].call(this, settings);
        components[2].call(this, settings);
        components[3].call(this, settings);
        _ref = components.slice(4);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          component = _ref[_i];
          component.call(this);
        }
      }

      return _Class;

    })();
  };

  this.Loader = this.make_loader();

}).call(this);

},{"./composer":33,"./construct":34,"./joiner":37,"./parser":40,"./protocols":41,"./reader":43,"./resolver":44,"./resourceTypes":45,"./scanner":46,"./schemas":47,"./securitySchemes":48,"./traits":50,"./transformations":51,"./util":52,"./validator":53}],39:[function(require,module,exports){
(function() {
  var MarkedYAMLError, unique_id, _ref, _ref1, _ref2,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  MarkedYAMLError = require('./errors').MarkedYAMLError;

  unique_id = 0;

  this.ApplicationError = (function(_super) {
    __extends(ApplicationError, _super);

    function ApplicationError() {
      _ref = ApplicationError.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return ApplicationError;

  })(MarkedYAMLError);

  this.Node = (function() {
    function Node(tag, value, start_mark, end_mark) {
      this.tag = tag;
      this.value = value;
      this.start_mark = start_mark;
      this.end_mark = end_mark;
      this.unique_id = "node_" + (unique_id++);
    }

    Node.prototype.clone = function() {
      var temp;
      temp = new this.constructor(this.tag, this.value, this.start_mark, this.end_mark);
      return temp;
    };

    return Node;

  })();

  this.ScalarNode = (function(_super) {
    __extends(ScalarNode, _super);

    ScalarNode.prototype.id = 'scalar';

    function ScalarNode(tag, value, start_mark, end_mark, style) {
      this.tag = tag;
      this.value = value;
      this.start_mark = start_mark;
      this.end_mark = end_mark;
      this.style = style;
      ScalarNode.__super__.constructor.apply(this, arguments);
    }

    ScalarNode.prototype.clone = function() {
      var temp;
      temp = new this.constructor(this.tag, this.value, this.start_mark, this.end_mark, this.style);
      return temp;
    };

    ScalarNode.prototype.cloneRemoveIs = function() {
      return this.clone();
    };

    ScalarNode.prototype.combine = function(node) {
      if (this.tag === 'tag:yaml.org,2002:null' && node.tag === 'tag:yaml.org,2002:map') {
        this.value = new exports.MappingNode('tag:yaml.org,2002:map', [], node.start_mark, node.end_mark);
        return this.value.combine(node);
      } else if (!(node instanceof exports.ScalarNode)) {
        throw new exports.ApplicationError('while applying node', null, 'different YAML structures', this.start_mark);
      }
      return this.value = node.value;
    };

    ScalarNode.prototype.remove_question_mark_properties = function() {};

    return ScalarNode;

  })(this.Node);

  this.CollectionNode = (function(_super) {
    __extends(CollectionNode, _super);

    function CollectionNode(tag, value, start_mark, end_mark, flow_style) {
      this.tag = tag;
      this.value = value;
      this.start_mark = start_mark;
      this.end_mark = end_mark;
      this.flow_style = flow_style;
      CollectionNode.__super__.constructor.apply(this, arguments);
    }

    return CollectionNode;

  })(this.Node);

  this.SequenceNode = (function(_super) {
    __extends(SequenceNode, _super);

    function SequenceNode() {
      _ref1 = SequenceNode.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    SequenceNode.prototype.id = 'sequence';

    SequenceNode.prototype.clone = function() {
      var item, items, temp, value, _i, _len, _ref2;
      items = [];
      _ref2 = this.value;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        item = _ref2[_i];
        value = item.clone();
        items.push(value);
      }
      temp = new this.constructor(this.tag, items, this.start_mark, this.end_mark, this.flow_style);
      return temp;
    };

    SequenceNode.prototype.cloneRemoveIs = function() {
      return this.clone();
    };

    SequenceNode.prototype.combine = function(node) {
      var property, value, _i, _len, _ref2, _results;
      if (!(node instanceof exports.SequenceNode)) {
        throw new exports.ApplicationError('while applying node', null, 'different YAML structures', this.start_mark);
      }
      _ref2 = node.value;
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        property = _ref2[_i];
        value = property.clone();
        _results.push(this.value.push(value));
      }
      return _results;
    };

    SequenceNode.prototype.remove_question_mark_properties = function() {
      var item, _i, _len, _ref2, _results;
      _ref2 = this.value;
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        item = _ref2[_i];
        _results.push(item.remove_question_mark_properties());
      }
      return _results;
    };

    return SequenceNode;

  })(this.CollectionNode);

  this.MappingNode = (function(_super) {
    __extends(MappingNode, _super);

    function MappingNode() {
      _ref2 = MappingNode.__super__.constructor.apply(this, arguments);
      return _ref2;
    }

    MappingNode.prototype.id = 'mapping';

    MappingNode.prototype.clone = function() {
      var name, properties, property, temp, value, _i, _len, _ref3;
      properties = [];
      _ref3 = this.value;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        property = _ref3[_i];
        name = property[0].clone();
        value = property[1].clone();
        properties.push([name, value]);
      }
      temp = new this.constructor(this.tag, properties, this.start_mark, this.end_mark, this.flow_style);
      return temp;
    };

    MappingNode.prototype.cloneRemoveIs = function() {
      var name, properties, property, temp, value, _i, _len, _ref3, _ref4;
      properties = [];
      _ref3 = this.value;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        property = _ref3[_i];
        name = property[0].cloneRemoveIs();
        value = property[1].cloneRemoveIs();
        if ((_ref4 = name.value) !== 'is') {
          properties.push([name, value]);
        }
      }
      temp = new this.constructor(this.tag, properties, this.start_mark, this.end_mark, this.flow_style);
      return temp;
    };

    MappingNode.prototype.cloneForTrait = function() {
      var name, properties, property, temp, value, _i, _len, _ref3, _ref4;
      properties = [];
      _ref3 = this.value;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        property = _ref3[_i];
        name = property[0].clone();
        value = property[1].clone();
        if ((_ref4 = name.value) !== 'usage' && _ref4 !== 'displayName') {
          properties.push([name, value]);
        }
      }
      temp = new this.constructor(this.tag, properties, this.start_mark, this.end_mark, this.flow_style);
      return temp;
    };

    MappingNode.prototype.cloneForResourceType = function() {
      var name, properties, property, temp, value, _i, _len, _ref3, _ref4;
      properties = [];
      _ref3 = this.value;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        property = _ref3[_i];
        name = property[0].cloneRemoveIs();
        value = property[1].cloneRemoveIs();
        if ((_ref4 = name.value) !== 'is' && _ref4 !== 'type' && _ref4 !== 'usage' && _ref4 !== 'displayName') {
          properties.push([name, value]);
        }
      }
      temp = new this.constructor(this.tag, properties, this.start_mark, this.end_mark, this.flow_style);
      return temp;
    };

    MappingNode.prototype.combine = function(resourceNode) {
      var name, node_has_property, nonNullNode, ownNodeProperty, ownNodePropertyName, resourceProperty, _i, _len, _ref3, _results;
      if (resourceNode.tag === 'tag:yaml.org,2002:null') {
        resourceNode = new exports.MappingNode('tag:yaml.org,2002:map', [], resourceNode.start_mark, resourceNode.end_mark);
      }
      if (!(resourceNode instanceof exports.MappingNode)) {
        throw new exports.ApplicationError('while applying node', null, 'different YAML structures', this.start_mark);
      }
      _ref3 = resourceNode.value;
      _results = [];
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        resourceProperty = _ref3[_i];
        name = resourceProperty[0].value;
        node_has_property = this.value.some(function(someProperty) {
          return (someProperty[0].value === name) || ((someProperty[0].value + '?') === name) || (someProperty[0].value === (name + '?'));
        });
        if (node_has_property) {
          _results.push((function() {
            var _j, _len1, _ref4, _results1;
            _ref4 = this.value;
            _results1 = [];
            for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
              ownNodeProperty = _ref4[_j];
              ownNodePropertyName = ownNodeProperty[0].value;
              if ((ownNodePropertyName === name) || ((ownNodePropertyName + '?') === name) || (ownNodePropertyName === (name + '?'))) {
                if ((ownNodeProperty[1].tag === 'tag:yaml.org,2002:null') && (resourceProperty[1].tag === 'tag:yaml.org,2002:map')) {
                  nonNullNode = new exports.MappingNode('tag:yaml.org,2002:map', [], ownNodeProperty[1].start_mark, ownNodeProperty[1].end_mark);
                  ownNodeProperty[1] = nonNullNode;
                }
                ownNodeProperty[1].combine(resourceProperty[1]);
                if (!((ownNodeProperty[0].value.slice(-1) === '?') && (resourceProperty[0].value.slice(-1) === '?'))) {
                  if (ownNodeProperty[0].value.slice(-1) === '?') {
                    _results1.push(ownNodeProperty[0].value = ownNodeProperty[0].value.slice(0, -1));
                  } else {
                    _results1.push(void 0);
                  }
                } else {
                  _results1.push(void 0);
                }
              } else {
                _results1.push(void 0);
              }
            }
            return _results1;
          }).call(this));
        } else {
          _results.push(this.value.push([resourceProperty[0].clone(), resourceProperty[1].clone()]));
        }
      }
      return _results;
    };

    MappingNode.prototype.remove_question_mark_properties = function() {
      var property, _i, _len, _ref3, _results;
      this.value = this.value.filter(function(property) {
        return property[0].value.slice(-1) !== '?';
      });
      _ref3 = this.value;
      _results = [];
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        property = _ref3[_i];
        _results.push(property[1].remove_question_mark_properties());
      }
      return _results;
    };

    return MappingNode;

  })(this.CollectionNode);

}).call(this);

},{"./errors":35}],40:[function(require,module,exports){
(function() {
  var MarkedYAMLError, events, tokens, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  events = require('./events');

  MarkedYAMLError = require('./errors').MarkedYAMLError;

  tokens = require('./tokens');

  this.ParserError = (function(_super) {
    __extends(ParserError, _super);

    function ParserError() {
      _ref = ParserError.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return ParserError;

  })(MarkedYAMLError);

  this.Parser = (function() {
    var DEFAULT_TAGS;

    DEFAULT_TAGS = {
      '!': '!',
      '!!': 'tag:yaml.org,2002:'
    };

    function Parser() {
      this.current_event = null;
      this.yaml_version = null;
      this.tag_handles = {};
      this.states = [];
      this.marks = [];
      this.state = 'parse_stream_start';
    }

    /*
    Reset the state attributes.
    */


    Parser.prototype.dispose = function() {
      this.states = [];
      return this.state = null;
    };

    /*
    Check the type of the next event.
    */


    Parser.prototype.check_event = function() {
      var choice, choices, _i, _len;
      choices = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (this.current_event === null) {
        if (this.state != null) {
          this.current_event = this[this.state]();
        }
      }
      if (this.current_event !== null) {
        if (choices.length === 0) {
          return true;
        }
        for (_i = 0, _len = choices.length; _i < _len; _i++) {
          choice = choices[_i];
          if (this.current_event instanceof choice) {
            return true;
          }
        }
      }
      return false;
    };

    /*
    Get the next event.
    */


    Parser.prototype.peek_event = function() {
      if (this.current_event === null && (this.state != null)) {
        this.current_event = this[this.state]();
      }
      return this.current_event;
    };

    /*
    Get the event and proceed further.
    */


    Parser.prototype.get_event = function() {
      var event;
      if (this.current_event === null && (this.state != null)) {
        this.current_event = this[this.state]();
      }
      event = this.current_event;
      this.current_event = null;
      return event;
    };

    /*
    Parse the stream start.
    */


    Parser.prototype.parse_stream_start = function() {
      var event, token;
      token = this.get_token();
      event = new events.StreamStartEvent(token.start_mark, token.end_mark);
      this.state = 'parse_implicit_document_start';
      return event;
    };

    /*
    Parse an implicit document.
    */


    Parser.prototype.parse_implicit_document_start = function() {
      var end_mark, event, start_mark, token;
      if (!this.check_token(tokens.DirectiveToken, tokens.DocumentStartToken, tokens.StreamEndToken)) {
        this.tag_handles = DEFAULT_TAGS;
        token = this.peek_token();
        start_mark = end_mark = token.start_mark;
        event = new events.DocumentStartEvent(start_mark, end_mark, false);
        this.states.push('parse_document_end');
        this.state = 'parse_block_node';
        return event;
      } else {
        return this.parse_document_start();
      }
    };

    /*
    Parse an explicit document.
    */


    Parser.prototype.parse_document_start = function() {
      var end_mark, event, start_mark, tags, token, version, _ref1;
      while (this.check_token(tokens.DocumentEndToken)) {
        this.get_token();
      }
      if (!this.check_token(tokens.StreamEndToken)) {
        start_mark = this.peek_token().start_mark;
        _ref1 = this.process_directives(), version = _ref1[0], tags = _ref1[1];
        if (!this.check_token(tokens.DocumentStartToken)) {
          throw new exports.ParserError("expected '<document start>', but found " + (this.peek_token().id), this.peek_token().start_mark);
        }
        token = this.get_token();
        end_mark = token.end_mark;
        event = new events.DocumentStartEvent(start_mark, end_mark, true, version, tags);
        this.states.push('parse_document_end');
        this.state = 'parse_document_content';
      } else {
        token = this.get_token();
        event = new events.StreamEndEvent(token.start_mark, token.end_mark);
        if (this.states.length !== 0) {
          throw new Error('assertion error, states should be empty');
        }
        if (this.marks.length !== 0) {
          throw new Error('assertion error, marks should be empty');
        }
        this.state = null;
      }
      return event;
    };

    /*
    Parse the document end.
    */


    Parser.prototype.parse_document_end = function() {
      var end_mark, event, explicit, start_mark, token;
      token = this.peek_token();
      start_mark = end_mark = token.start_mark;
      explicit = false;
      if (this.check_token(tokens.DocumentEndToken)) {
        token = this.get_token();
        end_mark = token.end_mark;
        explicit = true;
      }
      event = new events.DocumentEndEvent(start_mark, end_mark, explicit);
      this.state = 'parse_document_start';
      return event;
    };

    Parser.prototype.parse_document_content = function() {
      var event;
      if (this.check_token(tokens.DirectiveToken, tokens.DocumentStartToken, tokens.DocumentEndToken, tokens.StreamEndToken)) {
        event = this.process_empty_scalar(this.peek_token().start_mark);
        this.state = this.states.pop();
        return event;
      } else {
        return this.parse_block_node();
      }
    };

    Parser.prototype.process_directives = function() {
      var handle, major, minor, prefix, tag_handles_copy, token, value, _ref1, _ref2, _ref3;
      this.yaml_version = null;
      this.tag_handles = {};
      while (this.check_token(tokens.DirectiveToken)) {
        token = this.get_token();
        if (token.name === 'YAML') {
          if (this.yaml_version !== null) {
            throw new exports.ParserError(null, null, 'found duplicate YAML directive', token.start_mark);
          }
          _ref1 = token.value, major = _ref1[0], minor = _ref1[1];
          if (major !== 1 || minor !== 2) {
            throw new exports.ParserError(null, null, 'found incompatible YAML document (version 1.2 is required)', token.start_mark);
          }
          this.yaml_version = token.value;
        } else if (token.name === 'TAG') {
          _ref2 = token.value, handle = _ref2[0], prefix = _ref2[1];
          if (handle in this.tag_handles) {
            throw new exports.ParserError(null, null, "duplicate tag handle " + handle, token.start_mark);
          }
          this.tag_handles[handle] = prefix;
        }
      }
      tag_handles_copy = null;
      _ref3 = this.tag_handles;
      for (handle in _ref3) {
        if (!__hasProp.call(_ref3, handle)) continue;
        prefix = _ref3[handle];
        if (tag_handles_copy == null) {
          tag_handles_copy = {};
        }
        tag_handles_copy[handle] = prefix;
      }
      value = [this.yaml_version, tag_handles_copy];
      for (handle in DEFAULT_TAGS) {
        if (!__hasProp.call(DEFAULT_TAGS, handle)) continue;
        prefix = DEFAULT_TAGS[handle];
        if (!(prefix in this.tag_handles)) {
          this.tag_handles[handle] = prefix;
        }
      }
      return value;
    };

    Parser.prototype.parse_block_node = function() {
      return this.parse_node(true);
    };

    Parser.prototype.parse_flow_node = function() {
      return this.parse_node();
    };

    Parser.prototype.parse_block_node_or_indentless_sequence = function() {
      return this.parse_node(true, true);
    };

    Parser.prototype.parse_node = function(block, indentless_sequence) {
      var anchor, end_mark, event, handle, implicit, node, start_mark, suffix, tag, tag_mark, token;
      if (block == null) {
        block = false;
      }
      if (indentless_sequence == null) {
        indentless_sequence = false;
      }
      if (this.check_token(tokens.AliasToken)) {
        token = this.get_token();
        event = new events.AliasEvent(token.value, token.start_mark, token.end_mark);
        this.state = this.states.pop();
      } else {
        anchor = null;
        tag = null;
        start_mark = end_mark = tag_mark = null;
        if (this.check_token(tokens.AnchorToken)) {
          token = this.get_token();
          start_mark = token.start_mark;
          end_mark = token.end_mark;
          anchor = token.value;
          if (this.check_token(tokens.TagToken)) {
            token = this.get_token();
            tag_mark = token.start_mark;
            end_mark = token.end_mark;
            tag = token.value;
          }
        } else if (this.check_token(tokens.TagToken)) {
          token = this.get_token();
          start_mark = tag_mark = token.start_mark;
          end_mark = token.end_mark;
          tag = token.value;
          if (this.check_token(tokens.AnchorToken)) {
            token = this.get_token();
            end_mark = token.end_mark;
            anchor = token.value;
          }
        }
        if (tag !== null) {
          handle = tag[0], suffix = tag[1];
          if (handle !== null) {
            if (!(handle in this.tag_handles)) {
              throw new exports.ParserError('while parsing a node', start_mark, "found undefined tag handle " + handle, tag_mark);
            }
            tag = this.tag_handles[handle] + suffix;
          } else {
            tag = suffix;
          }
        }
        if (start_mark === null) {
          start_mark = end_mark = this.peek_token().start_mark;
        }
        event = null;
        implicit = tag === null || tag === '!';
        if (indentless_sequence && this.check_token(tokens.BlockEntryToken)) {
          end_mark = this.peek_token().end_mark;
          event = new events.SequenceStartEvent(anchor, tag, implicit, start_mark, end_mark);
          this.state = 'parse_indentless_sequence_entry';
        } else {
          if (this.check_token(tokens.ScalarToken)) {
            token = this.get_token();
            end_mark = token.end_mark;
            if ((token.plain && tag === null) || tag === '!') {
              implicit = [true, false];
            } else if (tag === null) {
              implicit = [false, true];
            } else {
              implicit = [false, false];
            }
            event = new events.ScalarEvent(anchor, tag, implicit, token.value, start_mark, end_mark, token.style);
            this.state = this.states.pop();
          } else if (this.check_token(tokens.FlowSequenceStartToken)) {
            end_mark = this.peek_token().end_mark;
            event = new events.SequenceStartEvent(anchor, tag, implicit, start_mark, end_mark, true);
            this.state = 'parse_flow_sequence_first_entry';
          } else if (this.check_token(tokens.FlowMappingStartToken)) {
            end_mark = this.peek_token().end_mark;
            event = new events.MappingStartEvent(anchor, tag, implicit, start_mark, end_mark, true);
            this.state = 'parse_flow_mapping_first_key';
          } else if (block && this.check_token(tokens.BlockSequenceStartToken)) {
            end_mark = this.peek_token().end_mark;
            event = new events.SequenceStartEvent(anchor, tag, implicit, start_mark, end_mark, false);
            this.state = 'parse_block_sequence_first_entry';
          } else if (block && this.check_token(tokens.BlockMappingStartToken)) {
            end_mark = this.peek_token().end_mark;
            event = new events.MappingStartEvent(anchor, tag, implicit, start_mark, end_mark, false);
            this.state = 'parse_block_mapping_first_key';
          } else if (anchor !== null || tag !== null) {
            event = new events.ScalarEvent(anchor, tag, [implicit, false], '', start_mark, end_mark);
            this.state = this.states.pop();
          } else {
            if (block) {
              node = 'block';
            } else {
              node = 'flow';
            }
            token = this.peek_token();
            throw new exports.ParserError("while parsing a " + node + " node", start_mark, "expected the node content, but found " + token.id, token.start_mark);
          }
        }
      }
      return event;
    };

    Parser.prototype.parse_block_sequence_first_entry = function() {
      var token;
      token = this.get_token();
      this.marks.push(token.start_mark);
      return this.parse_block_sequence_entry();
    };

    Parser.prototype.parse_block_sequence_entry = function() {
      var event, token;
      if (this.check_token(tokens.BlockEntryToken)) {
        token = this.get_token();
        if (!this.check_token(tokens.BlockEntryToken, tokens.BlockEndToken)) {
          this.states.push('parse_block_sequence_entry');
          return this.parse_block_node();
        } else {
          this.state = 'parse_block_sequence_entry';
          return this.process_empty_scalar(token.end_mark);
        }
      }
      if (!this.check_token(tokens.BlockEndToken)) {
        token = this.peek_token();
        throw new exports.ParserError('while parsing a block collection', this.marks.slice(-1)[0], "expected <block end>, but found " + token.id, token.start_mark);
      }
      token = this.get_token();
      event = new events.SequenceEndEvent(token.start_mark, token.end_mark);
      this.state = this.states.pop();
      this.marks.pop();
      return event;
    };

    Parser.prototype.parse_indentless_sequence_entry = function() {
      var event, token;
      if (this.check_token(tokens.BlockEntryToken)) {
        token = this.get_token();
        if (!this.check_token(tokens.BlockEntryToken, tokens.KeyToken, tokens.ValueToken, tokens.BlockEndToken)) {
          this.states.push('parse_indentless_sequence_entry');
          return this.parse_block_node();
        } else {
          this.state = 'parse_indentless_sequence_entry';
          return this.process_empty_scalar(token.end_mark);
        }
      }
      token = this.peek_token();
      event = new events.SequenceEndEvent(token.start_mark, token.start_mark);
      this.state = this.states.pop();
      return event;
    };

    Parser.prototype.parse_block_mapping_first_key = function() {
      var token;
      token = this.get_token();
      this.marks.push(token.start_mark);
      return this.parse_block_mapping_key();
    };

    Parser.prototype.parse_block_mapping_key = function() {
      var event, token;
      if (this.check_token(tokens.KeyToken)) {
        token = this.get_token();
        if (!this.check_token(tokens.KeyToken, tokens.ValueToken, tokens.BlockEndToken)) {
          this.states.push('parse_block_mapping_value');
          return this.parse_block_node_or_indentless_sequence();
        } else {
          this.state = 'parse_block_mapping_value';
          return this.process_empty_scalar(token.end_mark);
        }
      }
      if (!this.check_token(tokens.BlockEndToken)) {
        token = this.peek_token();
        throw new exports.ParserError('while parsing a block mapping', this.marks.slice(-1)[0], "expected <block end>, but found " + token.id, token.start_mark);
      }
      token = this.get_token();
      event = new events.MappingEndEvent(token.start_mark, token.end_mark);
      this.state = this.states.pop();
      this.marks.pop();
      return event;
    };

    Parser.prototype.parse_block_mapping_value = function() {
      var token;
      if (this.check_token(tokens.ValueToken)) {
        token = this.get_token();
        if (!this.check_token(tokens.KeyToken, tokens.ValueToken, tokens.BlockEndToken)) {
          this.states.push('parse_block_mapping_key');
          return this.parse_block_node_or_indentless_sequence();
        } else {
          this.state = 'parse_block_mapping_key';
          return this.process_empty_scalar(token.end_mark);
        }
      } else {
        this.state = 'parse_block_mapping_key';
        token = this.peek_token();
        return this.process_empty_scalar(token.start_mark);
      }
    };

    Parser.prototype.parse_flow_sequence_first_entry = function() {
      var token;
      token = this.get_token();
      this.marks.push(token.start_mark);
      return this.parse_flow_sequence_entry(true);
    };

    Parser.prototype.parse_flow_sequence_entry = function(first) {
      var event, token;
      if (first == null) {
        first = false;
      }
      if (!this.check_token(tokens.FlowSequenceEndToken)) {
        if (!first) {
          if (this.check_token(tokens.FlowEntryToken)) {
            this.get_token();
          } else {
            token = this.peek_token();
            throw new exports.ParserError('while parsing a flow sequence', this.marks.slice(-1)[0], "expected ',' or ']', but got " + token.id, token.start_mark);
          }
        }
        if (this.check_token(tokens.KeyToken)) {
          token = this.peek_token();
          event = new events.MappingStartEvent(null, null, true, token.start_mark, token.end_mark, true);
          this.state = 'parse_flow_sequence_entry_mapping_key';
          return event;
        } else if (!this.check_token(tokens.FlowSequenceEndToken)) {
          this.states.push('parse_flow_sequence_entry');
          return this.parse_flow_node();
        }
      }
      token = this.get_token();
      event = new events.SequenceEndEvent(token.start_mark, token.end_mark);
      this.state = this.states.pop();
      this.marks.pop();
      return event;
    };

    Parser.prototype.parse_flow_sequence_entry_mapping_key = function() {
      var token;
      token = this.get_token();
      if (!this.check_token(tokens.ValueToken, tokens.FlowEntryToken, tokens.FlowSequenceEndToken)) {
        this.states.push('parse_flow_sequence_entry_mapping_value');
        return this.parse_flow_node();
      } else {
        this.state = 'parse_flow_sequence_entry_mapping_value';
        return this.process_empty_scalar(token.end_mark);
      }
    };

    Parser.prototype.parse_flow_sequence_entry_mapping_value = function() {
      var token;
      if (this.check_token(tokens.ValueToken)) {
        token = this.get_token();
        if (!this.check_token(tokens.FlowEntryToken, tokens.FlowSequenceEndToken)) {
          this.states.push('parse_flow_sequence_entry_mapping_end');
          return this.parse_flow_node();
        } else {
          this.state = 'parse_flow_sequence_entry_mapping_end';
          return this.process_empty_scalar(token.end_mark);
        }
      } else {
        this.state = 'parse_flow_sequence_entry_mapping_end';
        token = this.peek_token();
        return this.process_empty_scalar(token.start_mark);
      }
    };

    Parser.prototype.parse_flow_sequence_entry_mapping_end = function() {
      var token;
      this.state = 'parse_flow_sequence_entry';
      token = this.peek_token();
      return new events.MappingEndEvent(token.start_mark, token.start_mark);
    };

    Parser.prototype.parse_flow_mapping_first_key = function() {
      var token;
      token = this.get_token();
      this.marks.push(token.start_mark);
      return this.parse_flow_mapping_key(true);
    };

    Parser.prototype.parse_flow_mapping_key = function(first) {
      var event, token;
      if (first == null) {
        first = false;
      }
      if (!this.check_token(tokens.FlowMappingEndToken)) {
        if (!first) {
          if (this.check_token(tokens.FlowEntryToken)) {
            this.get_token();
          } else {
            token = this.peek_token();
            throw new exports.ParserError('while parsing a flow mapping', this.marks.slice(-1)[0], "expected ',' or '}', but got " + token.id, token.start_mark);
          }
        }
        if (this.check_token(tokens.KeyToken)) {
          token = this.get_token();
          if (!this.check_token(tokens.ValueToken, tokens.FlowEntryToken, tokens.FlowMappingEndToken)) {
            this.states.push('parse_flow_mapping_value');
            return this.parse_flow_node();
          } else {
            this.state = 'parse_flow_mapping_value';
            return this.process_empty_scalar(token.end_mark);
          }
        } else if (!this.check_token(tokens.FlowMappingEndToken)) {
          this.states.push('parse_flow_mapping_empty_value');
          return this.parse_flow_node();
        }
      }
      token = this.get_token();
      event = new events.MappingEndEvent(token.start_mark, token.end_mark);
      this.state = this.states.pop();
      this.marks.pop();
      return event;
    };

    Parser.prototype.parse_flow_mapping_value = function() {
      var token;
      if (this.check_token(tokens.ValueToken)) {
        token = this.get_token();
        if (!this.check_token(tokens.FlowEntryToken, tokens.FlowMappingEndToken)) {
          this.states.push('parse_flow_mapping_key');
          return this.parse_flow_node();
        } else {
          this.state = 'parse_flow_mapping_key';
          return this.process_empty_scalar(token.end_mark);
        }
      } else {
        this.state = 'parse_flow_mapping_key';
        token = this.peek_token();
        return this.process_empty_scalar(token.start_mark);
      }
    };

    Parser.prototype.parse_flow_mapping_empty_value = function() {
      this.state = 'parse_flow_mapping_key';
      return this.process_empty_scalar(this.peek_token().start_mark);
    };

    Parser.prototype.process_empty_scalar = function(mark) {
      return new events.ScalarEvent(null, null, [true, false], '', mark, mark);
    };

    return Parser;

  })();

}).call(this);

},{"./errors":35,"./events":36,"./tokens":49}],41:[function(require,module,exports){
(function() {
  var MarkedYAMLError, nodes, url, util,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  url = require('url');

  MarkedYAMLError = require('./errors').MarkedYAMLError;

  nodes = require('./nodes');

  util = require('./util');

  /*
  The Protocols class deals with applying protocols to methods according to the spec
  */


  this.Protocols = (function() {
    function Protocols() {
      this.apply_protocols = __bind(this.apply_protocols, this);
    }

    Protocols.prototype.apply_protocols = function(node) {
      var protocols;
      if (protocols = this.apply_protocols_to_root(node)) {
        return this.apply_protocols_to_resources(node, protocols);
      }
    };

    Protocols.prototype.apply_protocols_to_root = function(node) {
      var baseUri, parsedBaseUri, protocol, protocols;
      if (this.has_property(node, 'protocols')) {
        return this.get_property(node, 'protocols');
      }
      if (!(baseUri = this.property_value(node, 'baseUri'))) {
        return;
      }
      parsedBaseUri = url.parse(baseUri);
      protocol = (parsedBaseUri.protocol || 'http:').slice(0, -1).toUpperCase();
      protocols = [new nodes.ScalarNode('tag:yaml.org,2002:str', 'protocols', node.start_mark, node.end_mark), new nodes.SequenceNode('tag:yaml.org,2002:seq', [new nodes.ScalarNode('tag:yaml.org,2002:str', protocol, node.start_mark, node.end_mark)], node.start_mark, node.end_mark)];
      node.value.push(protocols);
      return protocols[1];
    };

    Protocols.prototype.apply_protocols_to_resources = function(node, protocols) {
      var resource, _i, _len, _ref, _results;
      _ref = this.child_resources(node);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        resource = _ref[_i];
        this.apply_protocols_to_resources(resource, protocols);
        _results.push(this.apply_protocols_to_methods(resource, protocols));
      }
      return _results;
    };

    Protocols.prototype.apply_protocols_to_methods = function(node, protocols) {
      var method, _i, _len, _ref, _results;
      _ref = this.child_methods(node[1]);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        method = _ref[_i];
        if (!this.has_property(method[1], 'protocols')) {
          if (!util.isMapping(method[1])) {
            method[1] = new nodes.MappingNode('tag:yaml.org,2002:map', [], method[1].start_mark, method[1].end_mark);
          }
          _results.push(method[1].value.push([new nodes.ScalarNode('tag:yaml.org,2002:str', 'protocols', method[0].start_mark, method[0].end_mark), protocols.clone()]));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    return Protocols;

  })();

}).call(this);

},{"./errors":35,"./nodes":39,"./util":52,"url":15}],42:[function(require,module,exports){
(function() {
  var defaultSettings, util, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  this.errors = require('./errors');

  this.loader = require('./loader');

  util = require('./util');

  this.FileError = (function(_super) {
    __extends(FileError, _super);

    function FileError() {
      _ref = FileError.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return FileError;

  })(this.errors.MarkedYAMLError);

  this.FileReader = (function() {
    function FileReader(readFileAsyncOverride) {
      this.q = require('q');
      this.url = require('url');
      if (readFileAsyncOverride) {
        this.readFileAsyncOverride = readFileAsyncOverride;
      }
    }

    /*
    Read file either locally or from the network.
    */


    FileReader.prototype.readFileAsync = function(file) {
      var targerUrl;
      if (this.readFileAsyncOverride) {
        return this.readFileAsyncOverride(file);
      }
      targerUrl = this.url.parse(file);
      if (targerUrl.protocol != null) {
        if (!targerUrl.protocol.match(/^https?/i)) {
          throw new exports.FileError("while reading " + file, null, "unknown protocol " + targerUrl.protocol, this.start_mark);
        } else {
          return this.fetchFileAsync(file);
        }
      } else {
        if (typeof window !== "undefined" && window !== null) {
          return this.fetchFileAsync(file);
        } else {
          return this.fetchLocalFileAsync(file);
        }
      }
    };

    /*
    Read file from the disk.
    */


    FileReader.prototype.fetchLocalFileAsync = function(file) {
      var deferred,
        _this = this;
      deferred = this.q.defer();
      require('fs').readFile(file, function(err, data) {
        if (err) {
          return deferred.reject(new exports.FileError("while reading " + file, null, "cannot read " + file + " (" + err + ")", _this.start_mark));
        } else {
          return deferred.resolve(data.toString());
        }
      });
      return deferred.promise;
    };

    /*
    Read file from the network.
    */


    FileReader.prototype.fetchFileAsync = function(file) {
      var deferred, error, xhr,
        _this = this;
      deferred = this.q.defer();
      if (typeof window !== "undefined" && window !== null) {
        xhr = new XMLHttpRequest();
      } else {
        xhr = new (require('xmlhttprequest').XMLHttpRequest)();
      }
      try {
        xhr.open('GET', file, false);
        xhr.setRequestHeader('Accept', 'application/raml+yaml, */*');
        xhr.onreadystatechange = function() {
          if (xhr.readyState === 4) {
            if ((typeof xhr.status === 'number' && xhr.status === 200) || (typeof xhr.status === 'string' && xhr.status.match(/^200/i))) {
              return deferred.resolve(xhr.responseText);
            } else {
              return deferred.reject(new exports.FileError("while fetching " + file, null, "cannot fetch " + file + " (" + xhr.statusText + ")", _this.start_mark));
            }
          }
        };
        xhr.send(null);
        return deferred.promise;
      } catch (_error) {
        error = _error;
        throw new exports.FileError("while fetching " + file, null, "cannot fetch " + file + " (" + error + "), check that the server is up and that CORS is enabled", this.start_mark);
      }
    };

    return FileReader;

  })();

  /*
  OO version of the parser, static functions will be removed after consumers move on to use the OO version
  OO will offer caching
  */


  this.RamlParser = (function() {
    function RamlParser(settings) {
      this.settings = settings != null ? settings : defaultSettings;
      this.q = require('q');
      this.url = require('url');
      this.nodes = require('./nodes');
      this.loadDefaultSettings(settings);
    }

    RamlParser.prototype.loadDefaultSettings = function(settings) {
      var _this = this;
      return Object.keys(defaultSettings).forEach(function(settingName) {
        if (!(settingName in settings)) {
          return settings[settingName] = defaultSettings[settingName];
        }
      });
    };

    RamlParser.prototype.loadFile = function(file, settings) {
      var error,
        _this = this;
      if (settings == null) {
        settings = this.settings;
      }
      try {
        return settings.reader.readFileAsync(file).then(function(stream) {
          return _this.load(stream, file, settings);
        });
      } catch (_error) {
        error = _error;
        return this.q.fcall(function() {
          throw new exports.FileError("while fetching " + file, null, "cannot fetch " + file + " (" + error + ")", null);
        });
      }
    };

    RamlParser.prototype.composeFile = function(file, settings, parent) {
      var error,
        _this = this;
      if (settings == null) {
        settings = this.settings;
      }
      try {
        return settings.reader.readFileAsync(file).then(function(stream) {
          return _this.compose(stream, file, settings, parent);
        });
      } catch (_error) {
        error = _error;
        return this.q.fcall(function() {
          throw new exports.FileError("while fetching " + file, null, "cannot fetch " + file + " (" + error + ")", null);
        });
      }
    };

    RamlParser.prototype.compose = function(stream, location, settings, parent) {
      if (settings == null) {
        settings = this.settings;
      }
      if (parent == null) {
        parent = {
          src: location
        };
      }
      settings.compose = false;
      return this.parseStream(stream, location, settings, parent);
    };

    RamlParser.prototype.load = function(stream, location, settings) {
      if (settings == null) {
        settings = this.settings;
      }
      settings.compose = true;
      return this.parseStream(stream, location, settings, {
        src: location
      });
    };

    RamlParser.prototype.parseStream = function(stream, location, settings, parent) {
      var loader,
        _this = this;
      if (settings == null) {
        settings = this.settings;
      }
      loader = new exports.loader.Loader(stream, location, settings, parent);
      return this.q.fcall(function() {
        return loader.getYamlRoot();
      }).then(function(partialTree) {
        var files;
        files = loader.getPendingFilesList();
        return _this.getPendingFiles(loader, partialTree, files);
      }).then(function(fullyAssembledTree) {
        loader.composeRamlTree(fullyAssembledTree, settings);
        if (settings.compose) {
          if (fullyAssembledTree != null) {
            return loader.construct_document(fullyAssembledTree);
          } else {
            return null;
          }
        } else {
          return fullyAssembledTree;
        }
      });
    };

    RamlParser.prototype.getPendingFiles = function(loader, node, files) {
      var file, lastVisitedNode, loc, _i, _len,
        _this = this;
      loc = [];
      lastVisitedNode = void 0;
      for (_i = 0, _len = files.length; _i < _len; _i++) {
        file = files[_i];
        loc.push(this.getPendingFile(loader, file).then(function(overwritingnode) {
          if (overwritingnode && !lastVisitedNode) {
            return lastVisitedNode = overwritingnode;
          }
        }));
      }
      return this.q.all(loc).then(function() {
        if (lastVisitedNode) {
          return lastVisitedNode;
        } else {
          return node;
        }
      });
    };

    RamlParser.prototype.getPendingFile = function(loader, fileInfo) {
      var error, event, fileUri, key, node,
        _this = this;
      node = fileInfo.parentNode;
      event = fileInfo.event;
      key = fileInfo.parentKey;
      fileUri = fileInfo.targetFileUri;
      if (fileInfo.includingContext) {
        fileUri = this.url.resolve(fileInfo.includingContext, fileInfo.targetFileUri);
      }
      if (loader.parent && this.isInIncludeTagsStack(fileUri, loader)) {
        throw new exports.FileError('while composing scalar out of !include', null, "detected circular !include of " + event.value, event.start_mark);
      }
      try {
        if (fileInfo.type === 'fragment') {
          return this.settings.reader.readFileAsync(fileUri).then(function(result) {
            return _this.compose(result, fileUri, {
              validate: false,
              transform: false,
              compose: true
            }, loader);
          }).then(function(value) {
            return _this.appendNewNodeToParent(node, key, value);
          })["catch"](function(error) {
            return _this.addContextToError(error, event);
          });
        } else {
          return this.settings.reader.readFileAsync(fileUri).then(function(result) {
            var value;
            value = new _this.nodes.ScalarNode('tag:yaml.org,2002:str', result, event.start_mark, event.end_mark, event.style);
            return _this.appendNewNodeToParent(node, key, value);
          })["catch"](function(error) {
            return _this.addContextToError(error, event);
          });
        }
      } catch (_error) {
        error = _error;
        return this.addContextToError(error, event);
      }
    };

    RamlParser.prototype.addContextToError = function(error, event) {
      if (error.constructor.name === "FileError") {
        if (!error.problem_mark) {
          error.problem_mark = event.start_mark;
        }
        throw error;
      } else {
        throw new exports.FileError('while reading file', null, "error: " + error, event.start_mark);
      }
    };

    RamlParser.prototype.isInIncludeTagsStack = function(include, parent) {
      while (parent = parent.parent) {
        if (parent.src === include) {
          return true;
        }
      }
      return false;
    };

    RamlParser.prototype.appendNewNodeToParent = function(node, key, value) {
      if (node) {
        if (util.isSequence(node)) {
          node.value[key] = value;
        } else {
          node.value.push([key, value]);
        }
        return null;
      } else {
        return value;
      }
    };

    return RamlParser;

  })();

  /*
    validate controls whether the stream must be processed as a
  */


  defaultSettings = {
    validate: true,
    transform: true,
    compose: true,
    reader: new exports.FileReader(null)
  };

  /*
  Parse the first RAML document in a stream and produce the corresponding
  Javascript object.
  */


  this.loadFile = function(file, settings) {
    var parser;
    if (settings == null) {
      settings = defaultSettings;
    }
    parser = new exports.RamlParser(settings);
    return parser.loadFile(file, settings);
  };

  /*
  Parse the first RAML document in a file and produce the corresponding
  representation tree.
  */


  this.composeFile = function(file, settings, parent) {
    var parser;
    if (settings == null) {
      settings = defaultSettings;
    }
    if (parent == null) {
      parent = file;
    }
    parser = new exports.RamlParser(settings);
    return parser.composeFile(file, settings, parent);
  };

  /*
  Parse the first RAML document in a stream and produce the corresponding
  representation tree.
  */


  this.compose = function(stream, location, settings, parent) {
    var parser;
    if (settings == null) {
      settings = defaultSettings;
    }
    if (parent == null) {
      parent = location;
    }
    parser = new exports.RamlParser(settings);
    return parser.compose(stream, location, settings, parent);
  };

  /*
  Parse the first RAML document in a stream and produce the corresponding
  Javascript object.
  */


  this.load = function(stream, location, settings) {
    var parser;
    if (settings == null) {
      settings = defaultSettings;
    }
    parser = new exports.RamlParser(settings);
    return parser.load(stream, location, settings, null);
  };

}).call(this);

},{"./errors":35,"./loader":38,"./nodes":39,"./util":52,"fs":5,"q":29,"url":15,"xmlhttprequest":68}],43:[function(require,module,exports){
(function() {
  var Mark, MarkedYAMLError, _ref, _ref1,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ref = require('./errors'), Mark = _ref.Mark, MarkedYAMLError = _ref.MarkedYAMLError;

  this.ReaderError = (function(_super) {
    __extends(ReaderError, _super);

    function ReaderError() {
      _ref1 = ReaderError.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    return ReaderError;

  })(MarkedYAMLError);

  /*
  Reader:
    checks if characters are within the allowed range
    add '\x00' to the end
  */


  this.Reader = (function() {
    var NON_PRINTABLE;

    NON_PRINTABLE = /[^\x09\x0A\x0D\x20-\x7E\x85\xA0-\uD7FF\uE000-\uFFFD]/;

    function Reader(string, src) {
      this.string = string;
      this.src = src;
      this.line = 0;
      this.column = 0;
      this.index = 0;
      this.string += '\x00';
    }

    Reader.prototype.peek = function(index) {
      if (index == null) {
        index = 0;
      }
      return this.string[this.index + index];
    };

    Reader.prototype.prefix = function(length) {
      if (length == null) {
        length = 1;
      }
      return this.string.slice(this.index, this.index + length);
    };

    Reader.prototype.forward = function(length) {
      var char, _results;
      if (length == null) {
        length = 1;
      }
      _results = [];
      while (length) {
        char = this.string[this.index];
        this.index++;
        if (__indexOf.call('\n\x85\u2082\u2029', char) >= 0 || (char === '\r' && this.string[this.index] !== '\n')) {
          this.line++;
          this.column = 0;
        } else {
          this.check_printable(char);
          this.column++;
        }
        _results.push(length--);
      }
      return _results;
    };

    Reader.prototype.create_mark = function(line, column) {
      if (line == null) {
        line = this.line;
      }
      if (column == null) {
        column = this.column;
      }
      return new Mark(this.src, line, column, this.string, this.index);
    };

    Reader.prototype.get_mark = function() {
      return this.create_mark();
    };

    Reader.prototype.check_printable = function(char) {
      if (NON_PRINTABLE.exec(char)) {
        throw new exports.ReaderError('while reading file', null, "non printable characters are not allowed column: " + (this.get_mark().column), this.get_mark());
      }
    };

    return Reader;

  })();

}).call(this);

},{"./errors":35}],44:[function(require,module,exports){
(function() {
  var YAMLError, nodes, util, _ref, _ref1,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  nodes = require('./nodes');

  util = require('./util');

  YAMLError = require('./errors').YAMLError;

  this.ResolverError = (function(_super) {
    __extends(ResolverError, _super);

    function ResolverError() {
      _ref = ResolverError.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return ResolverError;

  })(YAMLError);

  this.BaseResolver = (function() {
    var DEFAULT_MAPPING_TAG, DEFAULT_SCALAR_TAG, DEFAULT_SEQUENCE_TAG;

    DEFAULT_SCALAR_TAG = 'tag:yaml.org,2002:str';

    DEFAULT_SEQUENCE_TAG = 'tag:yaml.org,2002:seq';

    DEFAULT_MAPPING_TAG = 'tag:yaml.org,2002:map';

    BaseResolver.prototype.yaml_implicit_resolvers = {};

    BaseResolver.prototype.yaml_path_resolvers = {};

    BaseResolver.add_implicit_resolver = function(tag, regexp, first) {
      var char, _base, _i, _len, _results;
      if (first == null) {
        first = [null];
      }
      if (!this.prototype.hasOwnProperty('yaml_implicit_resolvers')) {
        this.prototype.yaml_implicit_resolvers = util.extend({}, this.prototype.yaml_implicit_resolvers);
      }
      _results = [];
      for (_i = 0, _len = first.length; _i < _len; _i++) {
        char = first[_i];
        _results.push(((_base = this.prototype.yaml_implicit_resolvers)[char] != null ? (_base = this.prototype.yaml_implicit_resolvers)[char] : _base[char] = []).push([tag, regexp]));
      }
      return _results;
    };

    function BaseResolver() {
      this.resolver_exact_paths = [];
      this.resolver_prefix_paths = [];
    }

    BaseResolver.prototype.descend_resolver = function(current_node, current_index) {
      var depth, exact_paths, kind, path, prefix_paths, _i, _j, _len, _len1, _ref1, _ref2, _ref3, _ref4;
      if (util.is_empty(this.yaml_path_resolvers)) {
        return;
      }
      exact_paths = {};
      prefix_paths = [];
      if (current_node) {
        depth = this.resolver_prefix_paths.length;
        _ref1 = this.resolver_prefix_paths.slice(-1)[0];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          _ref2 = _ref1[_i], path = _ref2[0], kind = _ref2[1];
          if (this.check_resolver_prefix(depth, path, kind, current_node, current_index)) {
            if (path.length > depth) {
              prefix_paths.push([path, kind]);
            } else {
              exact_paths[kind] = this.yaml_path_resolvers[path][kind];
            }
          }
        }
      } else {
        _ref3 = this.yaml_path_resolvers;
        for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
          _ref4 = _ref3[_j], path = _ref4[0], kind = _ref4[1];
          if (!path) {
            exact_paths[kind] = this.yaml_path_resolvers[path][kind];
          } else {
            prefix_paths.push([path, kind]);
          }
        }
      }
      this.resolver_exact_paths.push(exact_paths);
      return this.resolver_prefix_paths.push(prefix_paths);
    };

    BaseResolver.prototype.ascend_resolver = function() {
      if (util.is_empty(this.yaml_path_resolvers)) {
        return;
      }
      this.resolver_exact_paths.pop();
      return this.resolver_prefix_paths.pop();
    };

    BaseResolver.prototype.check_resolver_prefix = function(depth, path, kind, current_node, current_index) {
      var index_check, node_check, _ref1;
      _ref1 = path[depth - 1], node_check = _ref1[0], index_check = _ref1[1];
      if (typeof node_check === 'string') {
        if (current_node.tag !== node_check) {
          return;
        }
      } else if (node_check !== null) {
        if (!(current_node instanceof node_check)) {
          return;
        }
      }
      if (index_check === true && current_index !== null) {
        return;
      }
      if ((index_check === false || index_check === null) && current_index === null) {
        return;
      }
      if (typeof index_check === 'string') {
        if (!(current_index instanceof nodes.ScalarNode) && index_check === current_index.value) {
          return;
        }
      } else if (typeof index_check === 'number') {
        if (index_check !== current_index) {
          return;
        }
      }
      return true;
    };

    BaseResolver.prototype.resolve = function(kind, value, implicit) {
      var empty, exact_paths, k, regexp, resolvers, tag, _i, _len, _ref1, _ref2, _ref3, _ref4;
      if (kind === nodes.ScalarNode && implicit[0]) {
        if (value === '') {
          resolvers = (_ref1 = this.yaml_implicit_resolvers['']) != null ? _ref1 : [];
        } else {
          resolvers = (_ref2 = this.yaml_implicit_resolvers[value[0]]) != null ? _ref2 : [];
        }
        resolvers = resolvers.concat((_ref3 = this.yaml_implicit_resolvers[null]) != null ? _ref3 : []);
        for (_i = 0, _len = resolvers.length; _i < _len; _i++) {
          _ref4 = resolvers[_i], tag = _ref4[0], regexp = _ref4[1];
          if (value.match(regexp)) {
            return tag;
          }
        }
        implicit = implicit[1];
      }
      empty = true;
      for (k in this.yaml_path_resolvers) {
        if ({}[k] == null) {
          empty = false;
        }
      }
      if (!empty) {
        exact_paths = this.resolver_exact_paths.slice(-1)[0];
        if (__indexOf.call(exact_paths, kind) >= 0) {
          return exact_paths[kind];
        }
        if (__indexOf.call(exact_paths, null) >= 0) {
          return exact_paths[null];
        }
      }
      if (kind === nodes.ScalarNode) {
        return DEFAULT_SCALAR_TAG;
      }
      if (kind === nodes.SequenceNode) {
        return DEFAULT_SEQUENCE_TAG;
      }
      if (kind === nodes.MappingNode) {
        return DEFAULT_MAPPING_TAG;
      }
    };

    return BaseResolver;

  })();

  this.Resolver = (function(_super) {
    __extends(Resolver, _super);

    function Resolver() {
      _ref1 = Resolver.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    return Resolver;

  })(this.BaseResolver);

  this.Resolver.add_implicit_resolver('tag:yaml.org,2002:bool', /^(?:true|True|TRUE|false|False|FALSE)$/, 'tTfF');

  this.Resolver.add_implicit_resolver('tag:yaml.org,2002:float', /^(?:[-+]?(?:[0-9][0-9_]*)\.[0-9_]*(?:[eE][-+][0-9]+)?|\.[0-9_]+(?:[eE][-+][0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*|[-+]?\.(?:inf|Inf|INF)|\.(?:nan|NaN|NAN))$/, '-+0123456789.');

  this.Resolver.add_implicit_resolver('tag:yaml.org,2002:int', /^(?:[-+]?0b[01_]+|[-+]?0[0-7_]+|[-+]?(?:0|[1-9][0-9_]*)|[-+]?0x[0-9a-fA-F_]+|[-+]?0o[0-7_]+|[-+]?[1-9][0-9_]*(?::[0-5]?[0-9])+)$/, '-+0123456789');

  this.Resolver.add_implicit_resolver('tag:yaml.org,2002:merge', /^(?:<<)$/, '<');

  this.Resolver.add_implicit_resolver('tag:yaml.org,2002:null', /^(?:~|null|Null|NULL|)$/, ['~', 'n', 'N', '']);

  this.Resolver.add_implicit_resolver('tag:yaml.org,2002:timestamp', /^(?:[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]|[0-9][0-9][0-9][0-9]-[0-9][0-9]?-[0-9][0-9]?(?:[Tt]|[\x20\t]+)[0-9][0-9]?:[0-9][0-9]:[0-9][0-9](?:\.[0-9]*)?(?:[\x20\t]*(?:Z|[-+][0-9][0-9]?(?::[0-9][0-9])?))?)$/, '0123456789');

  this.Resolver.add_implicit_resolver('tag:yaml.org,2002:value', /^(?:=)$/, '=');

  this.Resolver.add_implicit_resolver('tag:yaml.org,2002:yaml', /^(?:!|&|\*)$/, '!&*');

}).call(this);

},{"./errors":35,"./nodes":39,"./util":52}],45:[function(require,module,exports){
(function() {
  var MarkedYAMLError, nodes, util, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  MarkedYAMLError = require('./errors').MarkedYAMLError;

  nodes = require('./nodes');

  util = require('./util');

  /*
  The ResourceTypes throws these.
  */


  this.ResourceTypeError = (function(_super) {
    __extends(ResourceTypeError, _super);

    function ResourceTypeError() {
      _ref = ResourceTypeError.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return ResourceTypeError;

  })(MarkedYAMLError);

  /*
  The ResourceTypes class deals with applying ResourceTypes to resources according to the spec
  */


  this.ResourceTypes = (function() {
    function ResourceTypes() {
      this.apply_parameters_to_type = __bind(this.apply_parameters_to_type, this);
      this.apply_type = __bind(this.apply_type, this);
      this.apply_types = __bind(this.apply_types, this);
      this.get_type = __bind(this.get_type, this);
      this.has_types = __bind(this.has_types, this);
      this.load_types = __bind(this.load_types, this);
      this.declaredTypes = {};
    }

    ResourceTypes.prototype.load_types = function(node) {
      var allTypes,
        _this = this;
      this.load_default_media_type(node);
      if (this.has_property(node, 'resourceTypes')) {
        allTypes = this.property_value(node, 'resourceTypes');
        if (allTypes && typeof allTypes === 'object') {
          return allTypes.forEach(function(type_item) {
            if (type_item && typeof type_item === 'object' && typeof type_item.value === 'object') {
              return type_item.value.forEach(function(type) {
                return _this.declaredTypes[type[0].value] = type;
              });
            }
          });
        }
      }
    };

    ResourceTypes.prototype.has_types = function(node) {
      if (Object.keys(this.declaredTypes).length === 0 && this.has_property(node, 'resourceTypes')) {
        this.load_types(node);
      }
      return Object.keys(this.declaredTypes).length > 0;
    };

    ResourceTypes.prototype.get_type = function(typeName) {
      return this.declaredTypes[typeName];
    };

    ResourceTypes.prototype.apply_types = function(node, resourceUri) {
      var resources,
        _this = this;
      if (resourceUri == null) {
        resourceUri = "";
      }
      if (!util.isMapping(node)) {
        return;
      }
      if (this.has_types(node)) {
        resources = this.child_resources(node);
        return resources.forEach(function(resource) {
          var type;
          _this.apply_default_media_type_to_resource(resource[1]);
          if (_this.has_property(resource[1], 'type')) {
            type = _this.get_property(resource[1], 'type');
            _this.apply_type(resourceUri + resource[0].value, resource, type);
          }
          return _this.apply_types(resource[1], resourceUri + resource[0].value);
        });
      } else {
        resources = this.child_resources(node);
        return resources.forEach(function(resource) {
          return _this.apply_default_media_type_to_resource(resource[1]);
        });
      }
    };

    ResourceTypes.prototype.apply_type = function(resourceUri, resource, typeKey) {
      var tempType;
      tempType = this.resolve_inheritance_chain(resourceUri, typeKey);
      tempType.combine(resource[1]);
      resource[1] = tempType;
      return resource[1].remove_question_mark_properties();
    };

    ResourceTypes.prototype.resolve_inheritance_chain = function(resourceUri, typeKey) {
      var baseType, childType, childTypeName, childTypeProperty, compiledTypes, inheritsFrom, parentType, parentTypeName, pathToCircularRef, result, rootType, typesToApply;
      childTypeName = this.key_or_value(typeKey);
      childType = this.apply_parameters_to_type(resourceUri, childTypeName, typeKey);
      typesToApply = [childTypeName];
      compiledTypes = {};
      compiledTypes[childTypeName] = childType;
      this.apply_default_media_type_to_resource(childType);
      this.apply_traits_to_resource(resourceUri, childType, false);
      while (this.has_property(childType, 'type')) {
        typeKey = this.get_property(childType, 'type');
        parentTypeName = this.key_or_value(typeKey);
        if (parentTypeName in compiledTypes) {
          pathToCircularRef = typesToApply.concat(parentTypeName).join(' -> ');
          childTypeProperty = this.get_type(childTypeName)[0];
          throw new exports.ResourceTypeError('while applying resourceTypes', null, "circular reference of \"" + parentTypeName + "\" has been detected: " + pathToCircularRef, childTypeProperty.start_mark);
        }
        parentType = this.apply_parameters_to_type(resourceUri, parentTypeName, typeKey);
        this.apply_default_media_type_to_resource(parentType);
        this.apply_traits_to_resource(resourceUri, parentType, false);
        childTypeName = parentTypeName;
        childType = parentType;
        compiledTypes[childTypeName] = childType;
        typesToApply.push(childTypeName);
      }
      rootType = typesToApply.pop();
      baseType = compiledTypes[rootType].cloneForResourceType();
      result = baseType;
      while (inheritsFrom = typesToApply.pop()) {
        baseType = compiledTypes[inheritsFrom].cloneForResourceType();
        result.combine(baseType);
      }
      return result;
    };

    ResourceTypes.prototype.apply_parameters_to_type = function(resourceUri, typeName, typeKey) {
      var parameters, type;
      if (!(typeName != null ? typeName.trim() : void 0)) {
        throw new exports.ResourceTypeError('while applying resource type', null, 'resource type name must be provided', typeKey.start_mark);
      }
      if (!(type = this.get_type(typeName))) {
        throw new exports.ResourceTypeError('while applying resource type', null, "there is no resource type named " + typeName, typeKey.start_mark);
      }
      type = type[1].clone();
      parameters = this._get_parameters_from_type_key(resourceUri, typeKey);
      this.apply_parameters(type, parameters, typeKey);
      return type;
    };

    ResourceTypes.prototype._get_parameters_from_type_key = function(resourceUri, typeKey) {
      var parameter, parameters, reserved, result, _i, _len, _ref1;
      result = {};
      reserved = {
        resourcePath: resourceUri.replace(/\/\/*/g, '/'),
        resourcePathName: this.extractResourcePathName(resourceUri)
      };
      if (util.isMapping(typeKey)) {
        parameters = this.value_or_undefined(typeKey);
        if (util.isMapping(parameters[0][1])) {
          _ref1 = parameters[0][1].value;
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            parameter = _ref1[_i];
            if (parameter[0].value in reserved) {
              throw new exports.ResourceTypeError('while applying parameters', null, "invalid parameter name: " + parameter[0].value + " is reserved", parameter[0].start_mark);
            }
            result[parameter[0].value] = parameter[1].value;
          }
        }
      }
      return util.extend(result, reserved);
    };

    return ResourceTypes;

  })();

}).call(this);

},{"./errors":35,"./nodes":39,"./util":52}],46:[function(require,module,exports){
(function() {
  var MarkedYAMLError, SimpleKey, tokens, util, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  MarkedYAMLError = require('./errors').MarkedYAMLError;

  tokens = require('./tokens');

  util = require('./util');

  /*
  The Scanner throws these.
  */


  this.ScannerError = (function(_super) {
    __extends(ScannerError, _super);

    function ScannerError() {
      _ref = ScannerError.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return ScannerError;

  })(MarkedYAMLError);

  /*
  Represents a possible simple key.
  */


  SimpleKey = (function() {
    function SimpleKey(token_number, required, index, line, column, mark) {
      this.token_number = token_number;
      this.required = required;
      this.index = index;
      this.line = line;
      this.column = column;
      this.mark = mark;
    }

    return SimpleKey;

  })();

  /*
  The Scanner class deals with converting a YAML stream into a token stream.
  */


  this.Scanner = (function() {
    var C_LB, C_NUMBERS, C_WS, ESCAPE_CODES, ESCAPE_REPLACEMENTS, RAML_VERSION, RAML_VERSION_RE;

    C_LB = '\r\n\x85\u2028\u2029';

    C_WS = '\t ';

    C_NUMBERS = '0123456789';

    ESCAPE_REPLACEMENTS = {
      '0': '\x00',
      'a': '\x07',
      'b': '\x08',
      't': '\x09',
      '\t': '\x09',
      'n': '\x0A',
      'v': '\x0B',
      'f': '\x0C',
      'r': '\x0D',
      'e': '\x1B',
      ' ': '\x20',
      '"': '"',
      '\\': '\\',
      'N': '\x85',
      '_': '\xA0',
      'L': '\u2028',
      'P': '\u2029'
    };

    ESCAPE_CODES = {
      'x': 2,
      'u': 4,
      'U': 8
    };

    RAML_VERSION = '#%RAML 0.8';

    RAML_VERSION_RE = /^#%RAML .+$/;

    /*
    Initialise the Scanner
    */


    function Scanner(settings) {
      this.settings = settings;
      this.done = false;
      this.ramlHeaderFound = !this.settings.validate;
      this.flow_level = 0;
      this.tokens = [];
      this.fetch_stream_start();
      this.tokens_taken = 0;
      this.indent = -1;
      this.indents = [];
      this.allow_simple_key = true;
      this.possible_simple_keys = {};
    }

    /*
    Check if the next token is one of the given types.
    */


    Scanner.prototype.check_token = function() {
      var choice, choices, _i, _len;
      choices = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      while (this.need_more_tokens()) {
        this.fetch_more_tokens();
      }
      if (this.tokens.length !== 0) {
        if (choices.length === 0) {
          return true;
        }
        for (_i = 0, _len = choices.length; _i < _len; _i++) {
          choice = choices[_i];
          if (this.tokens[0] instanceof choice) {
            return true;
          }
        }
      }
      return false;
    };

    /*
    Return the next token, but do not delete it from the queue.
    */


    Scanner.prototype.peek_token = function() {
      while (this.need_more_tokens()) {
        this.fetch_more_tokens();
      }
      if (this.tokens.length !== 0) {
        return this.tokens[0];
      }
    };

    /*
    Return the next token, and remove it from the queue.
    */


    Scanner.prototype.get_token = function() {
      while (this.need_more_tokens()) {
        this.fetch_more_tokens();
      }
      if (this.tokens.length !== 0) {
        this.tokens_taken++;
        return this.tokens.shift();
      }
    };

    Scanner.prototype.need_more_tokens = function() {
      if (this.done) {
        return false;
      }
      if (this.tokens.length === 0) {
        return true;
      }
      this.stale_possible_simple_keys();
      if (this.next_possible_simple_key() === this.tokens_taken) {
        return true;
      }
      return false;
    };

    Scanner.prototype.fetch_more_tokens = function() {
      var char;
      this.scan_to_next_token();
      this.stale_possible_simple_keys();
      this.unwind_indent(this.column);
      char = this.peek();
      if (char === '\x00') {
        return this.fetch_stream_end();
      }
      if (char === '%' && this.check_directive()) {
        return this.fetch_directive();
      }
      if (char === '-' && this.check_document_start()) {
        return this.fetch_document_start();
      }
      if (char === '.' && this.check_document_end()) {
        return this.fetch_document_end();
      }
      if (char === '[') {
        return this.fetch_flow_sequence_start();
      }
      if (char === '{') {
        return this.fetch_flow_mapping_start();
      }
      if (char === ']') {
        return this.fetch_flow_sequence_end();
      }
      if (char === '}') {
        return this.fetch_flow_mapping_end();
      }
      if (char === ',') {
        return this.fetch_flow_entry();
      }
      if (char === '-' && this.check_block_entry()) {
        return this.fetch_block_entry();
      }
      if (char === '?' && this.check_key()) {
        return this.fetch_key();
      }
      if (char === ':' && this.check_value()) {
        return this.fetch_value();
      }
      if (char === '*') {
        return this.fetch_alias();
      }
      if (char === '&') {
        return this.fetch_anchor();
      }
      if (char === '!') {
        return this.fetch_tag();
      }
      if (char === '|' && this.flow_level === 0) {
        return this.fetch_literal();
      }
      if (char === '>' && this.flow_level === 0) {
        return this.fetch_folded();
      }
      if (char === '\'') {
        return this.fetch_single();
      }
      if (char === '"') {
        return this.fetch_double();
      }
      if (this.check_plain()) {
        return this.fetch_plain();
      }
      throw new exports.ScannerError('while scanning for the next token', null, "found character " + char + " that cannot start any token", this.get_mark());
    };

    /*
    Return the number of the nearest possible simple key.
    */


    Scanner.prototype.next_possible_simple_key = function() {
      var key, level, min_token_number, _ref1;
      min_token_number = null;
      _ref1 = this.possible_simple_keys;
      for (level in _ref1) {
        if (!__hasProp.call(_ref1, level)) continue;
        key = _ref1[level];
        if (min_token_number === null || key.token_number < min_token_number) {
          min_token_number = key.token_number;
        }
      }
      return min_token_number;
    };

    /*
    Remove entries that are no longer possible simple keys.  According to the
    YAML spec, simple keys:
      should be limited to a single line
      should be no longer than 1024 characters
    Disabling this procedure will allow simple keys of any length and height
    (may cause problems if indentation is broken though).
    */


    Scanner.prototype.stale_possible_simple_keys = function() {
      var key, level, _ref1, _results;
      _ref1 = this.possible_simple_keys;
      _results = [];
      for (level in _ref1) {
        if (!__hasProp.call(_ref1, level)) continue;
        key = _ref1[level];
        if (key.line === this.line && this.index - key.index <= 1024) {
          continue;
        }
        if (!key.required) {
          _results.push(delete this.possible_simple_keys[level]);
        } else {
          throw new exports.ScannerError('while scanning a simple key', key.mark, 'could not find expected \':\'', this.get_mark());
        }
      }
      return _results;
    };

    /*
    The next token may start a simple key.  We check if it's possible and save
    its position.  This function is called for ALIAS, ANCHOR, TAG,
    SCALAR (flow),'[' and '{'.
    */


    Scanner.prototype.save_possible_simple_key = function() {
      var required, token_number;
      required = this.flow_level === 0 && this.indent === this.column;
      if (required && !this.allow_simple_key) {
        throw new Error('logic failure');
      }
      if (!this.allow_simple_key) {
        return;
      }
      this.remove_possible_simple_key();
      token_number = this.tokens_taken + this.tokens.length;
      return this.possible_simple_keys[this.flow_level] = new SimpleKey(token_number, required, this.index, this.line, this.column, this.get_mark());
    };

    /*
    Remove the saved possible simple key at the current flow level.
    */


    Scanner.prototype.remove_possible_simple_key = function() {
      var key;
      if (!(key = this.possible_simple_keys[this.flow_level])) {
        return;
      }
      if (!key.required) {
        return delete this.possible_simple_keys[this.flow_level];
      } else {
        throw new exports.ScannerError('while scanning a simple key', key.mark, 'could not find expected \':\'', this.get_mark());
      }
    };

    /*
    In flow context, tokens should respect indentation.
    Actually the condition should be `self.indent >= column` according to
    the spec. But this condition will prohibit intuitively correct
    constructions such as
      key : {
      }
    */


    Scanner.prototype.unwind_indent = function(column) {
      var mark, _results;
      if (this.flow_level !== 0) {
        return;
      }
      _results = [];
      while (this.indent > column) {
        mark = this.get_mark();
        this.indent = this.indents.pop();
        _results.push(this.tokens.push(new tokens.BlockEndToken(mark, mark)));
      }
      return _results;
    };

    /*
    Check if we need to increase indentation.
    */


    Scanner.prototype.add_indent = function(column) {
      if (!(column > this.indent)) {
        return false;
      }
      this.indents.push(this.indent);
      this.indent = column;
      return true;
    };

    Scanner.prototype.fetch_stream_start = function() {
      var mark;
      mark = this.get_mark();
      return this.tokens.push(new tokens.StreamStartToken(mark, mark, this.encoding));
    };

    Scanner.prototype.fetch_stream_end = function() {
      var mark;
      this.unwind_indent(-1);
      this.remove_possible_simple_key();
      this.allow_possible_simple_key = false;
      this.possible_simple_keys = {};
      mark = this.get_mark();
      this.tokens.push(new tokens.StreamEndToken(mark, mark));
      return this.done = true;
    };

    Scanner.prototype.fetch_directive = function() {
      this.unwind_indent(-1);
      this.remove_possible_simple_key();
      this.allow_simple_key = false;
      return this.tokens.push(this.scan_directive());
    };

    Scanner.prototype.fetch_document_start = function() {
      return this.fetch_document_indicator(tokens.DocumentStartToken);
    };

    Scanner.prototype.fetch_document_end = function() {
      return this.fetch_document_indicator(tokens.DocumentEndToken);
    };

    Scanner.prototype.fetch_document_indicator = function(TokenClass) {
      var start_mark;
      this.unwind_indent(-1);
      this.remove_possible_simple_key();
      this.allow_simple_key = false;
      start_mark = this.get_mark();
      this.forward(3);
      return this.tokens.push(new TokenClass(start_mark, this.get_mark()));
    };

    Scanner.prototype.fetch_flow_sequence_start = function() {
      return this.fetch_flow_collection_start(tokens.FlowSequenceStartToken);
    };

    Scanner.prototype.fetch_flow_mapping_start = function() {
      return this.fetch_flow_collection_start(tokens.FlowMappingStartToken);
    };

    Scanner.prototype.fetch_flow_collection_start = function(TokenClass) {
      var start_mark;
      this.save_possible_simple_key();
      this.flow_level++;
      this.allow_simple_key = true;
      start_mark = this.get_mark();
      this.forward();
      return this.tokens.push(new TokenClass(start_mark, this.get_mark()));
    };

    Scanner.prototype.fetch_flow_sequence_end = function() {
      return this.fetch_flow_collection_end(tokens.FlowSequenceEndToken);
    };

    Scanner.prototype.fetch_flow_mapping_end = function() {
      return this.fetch_flow_collection_end(tokens.FlowMappingEndToken);
    };

    Scanner.prototype.fetch_flow_collection_end = function(TokenClass) {
      var start_mark;
      this.remove_possible_simple_key();
      this.flow_level--;
      this.allow_simple_key = false;
      start_mark = this.get_mark();
      this.forward();
      return this.tokens.push(new TokenClass(start_mark, this.get_mark()));
    };

    Scanner.prototype.fetch_flow_entry = function() {
      var start_mark;
      this.allow_simple_key = true;
      this.remove_possible_simple_key();
      start_mark = this.get_mark();
      this.forward();
      return this.tokens.push(new tokens.FlowEntryToken(start_mark, this.get_mark()));
    };

    Scanner.prototype.fetch_block_entry = function() {
      var mark, start_mark;
      if (this.flow_level === 0) {
        if (!this.allow_simple_key) {
          throw new exports.ScannerError(null, null, 'sequence entries are not allowed here', this.get_mark());
        }
        if (this.add_indent(this.column)) {
          mark = this.get_mark();
          this.tokens.push(new tokens.BlockSequenceStartToken(mark, mark));
        }
      }
      this.allow_simple_key = true;
      this.remove_possible_simple_key();
      start_mark = this.get_mark();
      this.forward();
      return this.tokens.push(new tokens.BlockEntryToken(start_mark, this.get_mark()));
    };

    Scanner.prototype.fetch_key = function() {
      var mark, start_mark;
      if (this.flow_level === 0) {
        if (!this.allow_simple_key) {
          throw new exports.ScannerError(null, null, 'mapping keys are not allowed here', this.get_mark());
        }
        if (this.add_indent(this.column)) {
          mark = this.get_mark();
          this.tokens.push(new tokens.BlockMappingStartToken(mark, mark));
        }
      }
      this.allow_simple_key = !this.flow_level;
      this.remove_possible_simple_key();
      start_mark = this.get_mark();
      this.forward();
      return this.tokens.push(new tokens.KeyToken(start_mark, this.get_mark()));
    };

    Scanner.prototype.fetch_value = function() {
      var key, mark, start_mark;
      if (key = this.possible_simple_keys[this.flow_level]) {
        delete this.possible_simple_keys[this.flow_level];
        this.tokens.splice(key.token_number - this.tokens_taken, 0, new tokens.KeyToken(key.mark, key.mark));
        if (this.flow_level === 0) {
          if (this.add_indent(key.column)) {
            this.tokens.splice(key.token_number - this.tokens_taken, 0, new tokens.BlockMappingStartToken(key.mark, key.mark));
          }
        }
        this.allow_simple_key = false;
      } else {
        if (this.flow_level === 0) {
          if (!this.allow_simple_key) {
            throw new exports.ScannerError(null, null, 'mapping values are not allowed here', this.get_mark());
          }
          if (this.add_indent(this.column)) {
            mark = this.get_mark();
            this.tokens.push(new tokens.BlockMappingStartToken(mark, mark));
          }
        }
        this.allow_simple_key = !this.flow_level;
        this.remove_possible_simple_key();
      }
      start_mark = this.get_mark();
      this.forward();
      return this.tokens.push(new tokens.ValueToken(start_mark, this.get_mark()));
    };

    Scanner.prototype.fetch_alias = function() {
      this.save_possible_simple_key();
      this.allow_simple_key = false;
      return this.tokens.push(this.scan_anchor(tokens.AliasToken));
    };

    Scanner.prototype.fetch_anchor = function() {
      this.save_possible_simple_key();
      this.allow_simple_key = false;
      return this.tokens.push(this.scan_anchor(tokens.AnchorToken));
    };

    Scanner.prototype.fetch_tag = function() {
      this.save_possible_simple_key();
      this.allow_simple_key = false;
      return this.tokens.push(this.scan_tag());
    };

    Scanner.prototype.fetch_literal = function() {
      return this.fetch_block_scalar('|');
    };

    Scanner.prototype.fetch_folded = function() {
      return this.fetch_block_scalar('>');
    };

    Scanner.prototype.fetch_block_scalar = function(style) {
      this.allow_simple_key = true;
      this.remove_possible_simple_key();
      return this.tokens.push(this.scan_block_scalar(style));
    };

    Scanner.prototype.fetch_single = function() {
      return this.fetch_flow_scalar('\'');
    };

    Scanner.prototype.fetch_double = function() {
      return this.fetch_flow_scalar('"');
    };

    Scanner.prototype.fetch_flow_scalar = function(style) {
      this.save_possible_simple_key();
      this.allow_simple_key = false;
      return this.tokens.push(this.scan_flow_scalar(style));
    };

    Scanner.prototype.fetch_plain = function() {
      this.save_possible_simple_key();
      this.allow_simple_key = false;
      return this.tokens.push(this.scan_plain());
    };

    /*
    DIRECTIVE: ^ '%'
    */


    Scanner.prototype.check_directive = function() {
      if (this.column === 0) {
        return true;
      }
      return false;
    };

    /*
    DOCUMENT-START: ^ '---' (' '|'\n')
    */


    Scanner.prototype.check_document_start = function() {
      var _ref1;
      if (this.column === 0 && this.prefix(3) === '---' && (_ref1 = this.peek(3), __indexOf.call(C_LB + C_WS + '\x00', _ref1) >= 0)) {
        return true;
      }
      return false;
    };

    /*
    DOCUMENT-END: ^ '...' (' '|'\n')
    */


    Scanner.prototype.check_document_end = function() {
      var _ref1;
      if (this.column === 0 && this.prefix(3) === '...' && (_ref1 = this.peek(3), __indexOf.call(C_LB + C_WS + '\x00', _ref1) >= 0)) {
        return true;
      }
      return false;
    };

    /*
    BLOCK-ENTRY: '-' (' '|'\n')
    */


    Scanner.prototype.check_block_entry = function() {
      var _ref1;
      return _ref1 = this.peek(1), __indexOf.call(C_LB + C_WS + '\x00', _ref1) >= 0;
    };

    /*
    KEY (flow context):  '?'
    KEY (block context): '?' (' '|'\n')
    */


    Scanner.prototype.check_key = function() {
      var _ref1;
      if (this.flow_level !== 0) {
        return true;
      }
      return _ref1 = this.peek(1), __indexOf.call(C_LB + C_WS + '\x00', _ref1) >= 0;
    };

    /*
    VALUE (flow context):  ':'
    VALUE (block context): ':' (' '|'\n')
    */


    Scanner.prototype.check_value = function() {
      var _ref1;
      if (this.flow_level !== 0) {
        return true;
      }
      return _ref1 = this.peek(1), __indexOf.call(C_LB + C_WS + '\x00', _ref1) >= 0;
    };

    /*
    A plain scalar may start with any non-space character except:
      '-', '?', ':', ',', '[', ']', '{', '}',
      '#', '&', '*', '!', '|', '>', '\'', '"',
      '%', '@', '`'.
    
    It may also start with
      '-', '?', ':'
    if it is followed by a non-space character.
    
    Note that we limit the last rule to the block context (except the '-'
    character) because we want the flow context to be space independent.
    */


    Scanner.prototype.check_plain = function() {
      var char, _ref1;
      char = this.peek();
      return __indexOf.call(C_LB + C_WS + '\x00-?:,[]{}#&*!|>\'"%@`', char) < 0 || ((_ref1 = this.peek(1), __indexOf.call(C_LB + C_WS + '\x00', _ref1) < 0) && (char === '-' || (this.flow_level === 0 && __indexOf.call('?:', char) >= 0)));
    };

    /*
    We ignore spaces, line breaks and comments.
    If we find a line break in the block context, we set the flag
    `allow_simple_key` on.
    The byte order mark is stripped if it's the first character in the stream.
    We do not yet support BOM inside the stream as the specification requires.
    Any such mark will be considered as a part of the document.
    
    TODO: We need to make tab handling rules more sane.  A good rule is
      Tabs cannot precede tokens BLOCK-SEQUENCE-START, BLOCK-MAPPING-START,
      BLOCK-END, KEY (block context), VALUE (block context), BLOCK-ENTRY
    So the tab checking code is
      @allow_simple_key = off if <TAB>
    We also need to add the check for `allow_simple_key is on` to
    `unwind_indent` before issuing BLOCK-END.  Scanners for block, flow and
    plain scalars need to be modified.
    */


    Scanner.prototype.scan_to_next_token = function() {
      var comment, found, trimmedComment, _ref1, _results;
      if (this.index === 0 && this.peek() === '\uFEFF') {
        this.forward();
      }
      found = false;
      _results = [];
      while (!found) {
        while (this.peek() === ' ') {
          this.forward();
        }
        comment = '';
        if (this.peek() === '#') {
          while (_ref1 = this.peek(), __indexOf.call(C_LB + '\x00', _ref1) < 0) {
            if (!this.ramlHeaderFound) {
              comment += this.peek();
            }
            this.forward();
          }
        }
        if (!this.ramlHeaderFound) {
          trimmedComment = comment.trim();
          if (trimmedComment && RAML_VERSION_RE.test(trimmedComment)) {
            if (trimmedComment === RAML_VERSION) {
              this.ramlHeaderFound = true;
            } else {
              throw new exports.ScannerError('version validation', null, "Unsupported RAML version: '" + comment + "'", this.create_mark(0, 0));
            }
          } else {
            throw new exports.ScannerError('version validation', null, "The first line must be: '" + RAML_VERSION + "'", this.create_mark(0, 0));
          }
        }
        if (this.scan_line_break()) {
          if (this.flow_level === 0) {
            _results.push(this.allow_simple_key = true);
          } else {
            _results.push(void 0);
          }
        } else {
          _results.push(found = true);
        }
      }
      return _results;
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_directive = function() {
      var end_mark, name, start_mark, value, _ref1;
      start_mark = this.get_mark();
      this.forward();
      name = this.scan_directive_name(start_mark);
      value = null;
      if (name === 'YAML') {
        value = this.scan_yaml_directive_value(start_mark);
        end_mark = this.get_mark();
      } else if (name === 'TAG') {
        value = this.scan_tag_directive_value(start_mark);
        end_mark = this.get_mark();
      } else {
        end_mark = this.get_mark();
        while (_ref1 = this.peek(), __indexOf.call(C_LB + '\x00', _ref1) < 0) {
          this.forward();
        }
      }
      this.scan_directive_ignored_line(start_mark);
      return new tokens.DirectiveToken(name, value, start_mark, end_mark);
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_directive_name = function(start_mark) {
      var char, length, value;
      length = 0;
      char = this.peek(length);
      while (('0' <= char && char <= '9') || ('A' <= char && char <= 'Z') || ('a' <= char && char <= 'z') || __indexOf.call('-_', char) >= 0) {
        length++;
        char = this.peek(length);
      }
      if (length === 0) {
        throw new exports.ScannerError('while scanning a directive', start_mark, "expected alphanumeric or numeric character but found " + char, this.get_mark());
      }
      value = this.prefix(length);
      this.forward(length);
      char = this.peek();
      if (__indexOf.call(C_LB + '\x00 ', char) < 0) {
        throw new exports.ScannerError('while scanning a directive', start_mark, "expected alphanumeric or numeric character but found " + char, this.get_mark());
      }
      return value;
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_yaml_directive_value = function(start_mark) {
      var major, minor, _ref1;
      while (this.peek() === ' ') {
        this.forward();
      }
      major = this.scan_yaml_directive_number(start_mark);
      if (this.peek() !== '.') {
        throw new exports.ScannerError('while scanning a directive', start_mark, "expected a digit or '.' but found " + (this.peek()), this.get_mark());
      }
      this.forward();
      minor = this.scan_yaml_directive_number(start_mark);
      if (_ref1 = this.peek(), __indexOf.call(C_LB + '\x00 ', _ref1) < 0) {
        throw new exports.ScannerError('while scanning a directive', start_mark, "expected a digit or ' ' but found " + (this.peek()), this.get_mark());
      }
      return [major, minor];
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_yaml_directive_number = function(start_mark) {
      var char, length, value, _ref1;
      char = this.peek();
      if (!(('0' <= char && char <= '9'))) {
        throw new exports.ScannerError('while scanning a directive', start_mark, "expected a digit but found " + char, this.get_mark());
      }
      length = 0;
      while (('0' <= (_ref1 = this.peek(length)) && _ref1 <= '9')) {
        length++;
      }
      value = parseInt(this.prefix(length));
      this.forward(length);
      return value;
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_tag_directive_value = function(start_mark) {
      var handle, prefix;
      while (this.peek() === ' ') {
        this.forward();
      }
      handle = this.scan_tag_directive_handle(start_mark);
      while (this.peek() === ' ') {
        this.forward();
      }
      prefix = this.scan_tag_directive_prefix(start_mark);
      return [handle, prefix];
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_tag_directive_handle = function(start_mark) {
      var char, value;
      value = this.scan_tag_handle('directive', start_mark);
      char = this.peek();
      if (char !== ' ') {
        throw new exports.ScannerError('while scanning a directive', start_mark, "expected ' ' but found " + char, this.get_mark());
      }
      return value;
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_tag_directive_prefix = function(start_mark) {
      var char, value;
      value = this.scan_tag_uri('directive', start_mark);
      char = this.peek();
      if (__indexOf.call(C_LB + '\x00 ', char) < 0) {
        throw new exports.ScannerError('while scanning a directive', start_mark, "expected ' ' but found " + char, this.get_mark());
      }
      return value;
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_directive_ignored_line = function(start_mark) {
      var char, _ref1;
      while (this.peek() === ' ') {
        this.forward();
      }
      if (this.peek() === '#') {
        while (_ref1 = this.peek(), __indexOf.call(C_LB + '\x00', _ref1) < 0) {
          this.forward();
        }
      }
      char = this.peek();
      if (__indexOf.call(C_LB + '\x00', char) < 0) {
        throw new exports.ScannerError('while scanning a directive', start_mark, "expected a comment or a line break but found " + char, this.get_mark());
      }
      return this.scan_line_break();
    };

    /*
    The specification does not restrict characters for anchors and aliases.
    This may lead to problems, for instance, the document:
      [ *alias, value ]
    can be interpteted in two ways, as
      [ "value" ]
    and
      [ *alias , "value" ]
    Therefore we restrict aliases to numbers and ASCII letters.
    */


    Scanner.prototype.scan_anchor = function(TokenClass) {
      var char, indicator, length, name, start_mark, value;
      start_mark = this.get_mark();
      indicator = this.peek();
      if (indicator === '*') {
        name = 'alias';
      } else {
        name = 'anchor';
      }
      this.forward();
      length = 0;
      char = this.peek(length);
      while (('0' <= char && char <= '9') || ('A' <= char && char <= 'Z') || ('a' <= char && char <= 'z') || __indexOf.call('-_', char) >= 0) {
        length++;
        char = this.peek(length);
      }
      if (length === 0) {
        throw new exports.ScannerError("while scanning an " + name, start_mark, "expected alphabetic or numeric character but found '" + char + "'", this.get_mark());
      }
      value = this.prefix(length);
      this.forward(length);
      char = this.peek();
      if (__indexOf.call(C_LB + C_WS + '\x00' + '?:,]}%@`', char) < 0) {
        throw new exports.ScannerError("while scanning an " + name, start_mark, "expected alphabetic or numeric character but found '" + char + "'", this.get_mark());
      }
      return new TokenClass(value, start_mark, this.get_mark());
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_tag = function() {
      var char, handle, length, start_mark, suffix, use_handle;
      start_mark = this.get_mark();
      char = this.peek(1);
      if (char === '<') {
        handle = null;
        this.forward(2);
        suffix = this.scan_tag_uri('tag', start_mark);
        if (this.peek() !== '>') {
          throw new exports.ScannerError('while parsing a tag', start_mark, "expected '>' but found " + (this.peek()), this.get_mark());
        }
        this.forward();
      } else if (__indexOf.call(C_LB + C_WS + '\x00', char) >= 0) {
        handle = null;
        suffix = '!';
        this.forward();
      } else {
        length = 1;
        use_handle = false;
        while (__indexOf.call(C_LB + '\x00 ', char) < 0) {
          if (char === '!') {
            use_handle = true;
            break;
          }
          length++;
          char = this.peek(length);
        }
        if (use_handle) {
          handle = this.scan_tag_handle('tag', start_mark);
        } else {
          handle = '!';
          this.forward();
        }
        suffix = this.scan_tag_uri('tag', start_mark);
      }
      char = this.peek();
      if (__indexOf.call(C_LB + '\x00 ', char) < 0) {
        throw new exports.ScannerError('while scanning a tag', start_mark, "expected ' ' but found " + char, this.get_mark());
      }
      return new tokens.TagToken([handle, suffix], start_mark, this.get_mark());
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_block_scalar = function(style) {
      var breaks, chomping, chunks, end_mark, folded, increment, indent, leading_non_space, length, line_break, max_indent, min_indent, start_mark, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
      folded = style === '>';
      chunks = [];
      start_mark = this.get_mark();
      this.forward();
      _ref1 = this.scan_block_scalar_indicators(start_mark), chomping = _ref1[0], increment = _ref1[1];
      this.scan_block_scalar_ignored_line(start_mark);
      min_indent = this.indent + 1;
      if (min_indent < 1) {
        min_indent = 1;
      }
      if (increment == null) {
        _ref2 = this.scan_block_scalar_indentation(), breaks = _ref2[0], max_indent = _ref2[1], end_mark = _ref2[2];
        indent = Math.max(min_indent, max_indent);
      } else {
        indent = min_indent + increment - 1;
        _ref3 = this.scan_block_scalar_breaks(indent), breaks = _ref3[0], end_mark = _ref3[1];
      }
      line_break = '';
      while (this.column === indent && this.peek() !== '\x00') {
        chunks = chunks.concat(breaks);
        leading_non_space = (_ref4 = this.peek(), __indexOf.call(' \t', _ref4) < 0);
        length = 0;
        while (_ref5 = this.peek(length), __indexOf.call(C_LB + '\x00', _ref5) < 0) {
          length++;
        }
        chunks.push(this.prefix(length));
        this.forward(length);
        line_break = this.scan_line_break();
        _ref6 = this.scan_block_scalar_breaks(indent), breaks = _ref6[0], end_mark = _ref6[1];
        if (this.column === indent && this.peek() !== '\x00') {
          if (folded && line_break === '\n' && leading_non_space && (_ref7 = this.peek(), __indexOf.call(' \t', _ref7) < 0)) {
            if (util.is_empty(breaks)) {
              chunks.push(' ');
            }
          } else {
            chunks.push(line_break);
          }
        } else {
          break;
        }
      }
      if (chomping !== false) {
        chunks.push(line_break);
      }
      if (chomping === true) {
        chunks = chunks.concat(breaks);
      }
      return new tokens.ScalarToken(chunks.join(''), false, start_mark, end_mark, style);
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_block_scalar_indicators = function(start_mark) {
      var char, chomping, increment;
      chomping = null;
      increment = null;
      char = this.peek();
      if (__indexOf.call('+-', char) >= 0) {
        chomping = char === '+';
        this.forward();
        char = this.peek();
        if (__indexOf.call(C_NUMBERS, char) >= 0) {
          increment = parseInt(char);
          if (increment === 0) {
            throw new exports.ScannerError('while scanning a block scalar', start_mark, 'expected indentation indicator in the range 1-9 but found 0', this.get_mark());
          }
          this.forward();
        }
      } else if (__indexOf.call(C_NUMBERS, char) >= 0) {
        increment = parseInt(char);
        if (increment === 0) {
          throw new exports.ScannerError('while scanning a block scalar', start_mark, 'expected indentation indicator in the range 1-9 but found 0', this.get_mark());
        }
        this.forward();
        char = this.peek();
        if (__indexOf.call('+-', char) >= 0) {
          chomping = char === '+';
          this.forward();
        }
      }
      char = this.peek();
      if (__indexOf.call(C_LB + '\x00 ', char) < 0) {
        throw new exports.ScannerError('while scanning a block scalar', start_mark, "expected chomping or indentation indicators, but found " + char, this.get_mark());
      }
      return [chomping, increment];
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_block_scalar_ignored_line = function(start_mark) {
      var char, _ref1;
      while (this.peek() === ' ') {
        this.forward();
      }
      if (this.peek() === '#') {
        while (_ref1 = this.peek(), __indexOf.call(C_LB + '\x00', _ref1) < 0) {
          this.forward();
        }
      }
      char = this.peek();
      if (__indexOf.call(C_LB + '\x00', char) < 0) {
        throw new exports.ScannerError('while scanning a block scalar', start_mark, "expected a comment or a line break but found " + char, this.get_mark());
      }
      return this.scan_line_break();
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_block_scalar_indentation = function() {
      var chunks, end_mark, max_indent, _ref1;
      chunks = [];
      max_indent = 0;
      end_mark = this.get_mark();
      while (_ref1 = this.peek(), __indexOf.call(C_LB + ' ', _ref1) >= 0) {
        if (this.peek() !== ' ') {
          chunks.push(this.scan_line_break());
          end_mark = this.get_mark();
        } else {
          this.forward();
          if (this.column > max_indent) {
            max_indent = this.column;
          }
        }
      }
      return [chunks, max_indent, end_mark];
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_block_scalar_breaks = function(indent) {
      var chunks, end_mark, _ref1;
      chunks = [];
      end_mark = this.get_mark();
      while (this.column < indent && this.peek() === ' ') {
        this.forward();
      }
      while (_ref1 = this.peek(), __indexOf.call(C_LB, _ref1) >= 0) {
        chunks.push(this.scan_line_break());
        end_mark = this.get_mark();
        while (this.column < indent && this.peek() === ' ') {
          this.forward();
        }
      }
      return [chunks, end_mark];
    };

    /*
    See the specification for details.
    Note that we loose indentation rules for quoted scalars. Quoted scalars
    don't need to adhere indentation because " and ' clearly mark the beginning
    and the end of them. Therefore we are less restrictive than the
    specification requires. We only need to check that document separators are
    not included in scalars.
    */


    Scanner.prototype.scan_flow_scalar = function(style) {
      var chunks, double, quote, start_mark;
      double = style === '"';
      chunks = [];
      start_mark = this.get_mark();
      quote = this.peek();
      this.forward();
      chunks = chunks.concat(this.scan_flow_scalar_non_spaces(double, start_mark));
      while (this.peek() !== quote) {
        chunks = chunks.concat(this.scan_flow_scalar_spaces(double, start_mark));
        chunks = chunks.concat(this.scan_flow_scalar_non_spaces(double, start_mark));
      }
      this.forward();
      return new tokens.ScalarToken(chunks.join(''), false, start_mark, this.get_mark(), style);
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_flow_scalar_non_spaces = function(double, start_mark) {
      var char, chunks, code, k, length, _i, _ref1, _ref2;
      chunks = [];
      while (true) {
        length = 0;
        while (_ref1 = this.peek(length), __indexOf.call(C_LB + C_WS + '\'"\\\x00', _ref1) < 0) {
          length++;
        }
        if (length !== 0) {
          chunks.push(this.prefix(length));
          this.forward(length);
        }
        char = this.peek();
        if (!double && char === '\'' && this.peek(1) === '\'') {
          chunks.push('\'');
          this.forward(2);
        } else if ((double && char === '\'') || (!double && __indexOf.call('"\\', char) >= 0)) {
          chunks.push(char);
          this.forward();
        } else if (double && char === '\\') {
          this.forward();
          char = this.peek();
          if (char in ESCAPE_REPLACEMENTS) {
            chunks.push(ESCAPE_REPLACEMENTS[char]);
            this.forward();
          } else if (char in ESCAPE_CODES) {
            length = ESCAPE_CODES[char];
            this.forward();
            for (k = _i = 0; 0 <= length ? _i < length : _i > length; k = 0 <= length ? ++_i : --_i) {
              if (_ref2 = this.peek(k), __indexOf.call(C_NUMBERS + 'ABCDEFabcdef', _ref2) < 0) {
                throw new exports.ScannerError('while scanning a double-quoted scalar', start_mark, "expected escape sequence of " + length + " hexadecimal numbers, but found " + (this.peek(k)), this.get_mark());
              }
            }
            code = parseInt(this.prefix(length), 16);
            chunks.push(String.fromCharCode(code));
            this.forward(length);
          } else if (__indexOf.call(C_LB, char) >= 0) {
            this.scan_line_break();
            chunks = chunks.concat(this.scan_flow_scalar_breaks(double, start_mark));
          } else {
            throw new exports.ScannerError('while scanning a double-quoted scalar', start_mark, "found unknown escape character " + char, this.get_mark());
          }
        } else {
          return chunks;
        }
      }
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_flow_scalar_spaces = function(double, start_mark) {
      var breaks, char, chunks, length, line_break, whitespaces, _ref1;
      chunks = [];
      length = 0;
      while (_ref1 = this.peek(length), __indexOf.call(C_WS, _ref1) >= 0) {
        length++;
      }
      whitespaces = this.prefix(length);
      this.forward(length);
      char = this.peek();
      if (char === '\x00') {
        throw new exports.ScannerError('while scanning a quoted scalar', start_mark, 'found unexpected end of stream', this.get_mark());
      }
      if (__indexOf.call(C_LB, char) >= 0) {
        line_break = this.scan_line_break();
        breaks = this.scan_flow_scalar_breaks(double, start_mark);
        if (line_break !== '\n') {
          chunks.push(line_break);
        } else if (!breaks) {
          chunks.push(' ');
        }
        chunks = chunks.concat(breaks);
      } else {
        chunks.push(whitespaces);
      }
      return chunks;
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_flow_scalar_breaks = function(double, start_mark) {
      var chunks, prefix, _ref1, _ref2, _ref3;
      chunks = [];
      while (true) {
        prefix = this.prefix(3);
        if (prefix === '---' || prefix === '...' && (_ref1 = this.peek(3), __indexOf.call(C_LB + C_WS + '\x00', _ref1) >= 0)) {
          throw new exports.ScannerError('while scanning a quoted scalar', start_mark, 'found unexpected document separator', this.get_mark());
        }
        while (_ref2 = this.peek(), __indexOf.call(C_WS, _ref2) >= 0) {
          this.forward();
        }
        if (_ref3 = this.peek(), __indexOf.call(C_LB, _ref3) >= 0) {
          chunks.push(this.scan_line_break());
        } else {
          return chunks;
        }
      }
    };

    /*
    See the specification for details.
    We add an additional restriction for the flow context:
      plain scalars in the flow context cannot contain ',', ':' and '?'.
    We also keep track of the `allow_simple_key` flag here.
    Indentation rules are loosed for the flow context.
    */


    Scanner.prototype.scan_plain = function() {
      var char, chunks, end_mark, indent, length, spaces, start_mark, _ref1, _ref2;
      chunks = [];
      start_mark = end_mark = this.get_mark();
      indent = this.indent + 1;
      spaces = [];
      while (true) {
        length = 0;
        if (this.peek() === '#') {
          break;
        }
        while (true) {
          char = this.peek(length);
          if (__indexOf.call(C_LB + C_WS + '\x00', char) >= 0 || (this.flow_level === 0 && char === ':' && (_ref1 = this.peek(length + 1), __indexOf.call(C_LB + C_WS + '\x00', _ref1) >= 0)) || (this.flow_level !== 0 && __indexOf.call(',:?[]{}', char) >= 0)) {
            break;
          }
          length++;
        }
        if (this.flow_level !== 0 && char === ':' && (_ref2 = this.peek(length + 1), __indexOf.call(C_LB + C_WS + '\x00,[]{}', _ref2) < 0)) {
          this.forward(length);
          throw new exports.ScannerError('while scanning a plain scalar', start_mark, 'found unexpected \':\'', this.get_mark(), 'Please check http://pyyaml.org/wiki/YAMLColonInFlowContext');
        }
        if (length === 0) {
          break;
        }
        this.allow_simple_key = false;
        chunks = chunks.concat(spaces);
        chunks.push(this.prefix(length));
        this.forward(length);
        end_mark = this.get_mark();
        spaces = this.scan_plain_spaces(indent, start_mark);
        if ((spaces == null) || spaces.length === 0 || this.peek() === '#' || (this.flow_level === 0 && this.column < indent)) {
          break;
        }
      }
      return new tokens.ScalarToken(chunks.join(''), true, start_mark, end_mark);
    };

    /*
    See the specification for details.
    The specification is really confusing about tabs in plain scalars.
    We just forbid them completely. Do not use tabs in YAML!
    */


    Scanner.prototype.scan_plain_spaces = function(indent, start_mark) {
      var breaks, char, chunks, length, line_break, prefix, whitespaces, _ref1, _ref2;
      chunks = [];
      length = 0;
      while (_ref1 = this.peek(length), __indexOf.call(' ', _ref1) >= 0) {
        length++;
      }
      whitespaces = this.prefix(length);
      this.forward(length);
      char = this.peek();
      if (__indexOf.call(C_LB, char) >= 0) {
        line_break = this.scan_line_break();
        this.allow_simple_key = true;
        prefix = this.prefix(3);
        if (prefix === '---' || prefix === '...' && this.peek(__indexOf.call(C_LB + C_WS + '\x00', 3) >= 0)) {
          return;
        }
        breaks = [];
        while (_ref2 = this.peek(), __indexOf.call(C_LB + ' ', _ref2) >= 0) {
          if (this.peek() === ' ') {
            this.forward();
          } else {
            breaks.push(this.scan_line_break());
            prefix = this.prefix(3);
            if (prefix === '---' || prefix === '...' && this.peek(__indexOf.call(C_LB + C_WS + '\x00', 3) >= 0)) {
              return;
            }
          }
        }
        if (line_break !== '\n') {
          chunks.push(line_break);
        } else if (breaks.length === 0) {
          chunks.push(' ');
        }
        chunks = chunks.concat(breaks);
      } else if (whitespaces) {
        chunks.push(whitespaces);
      }
      return chunks;
    };

    /*
    See the specification for details.
    For some strange reasons, the specification does not allow '_' in tag
    handles. I have allowed it anyway.
    */


    Scanner.prototype.scan_tag_handle = function(name, start_mark) {
      var char, length, value;
      char = this.peek();
      if (char !== '!') {
        throw new exports.ScannerError("while scanning a " + name, start_mark, "expected '!' but found " + char, this.get_mark());
      }
      length = 1;
      char = this.peek(length);
      if (char !== ' ') {
        while (('0' <= char && char <= '9') || ('A' <= char && char <= 'Z') || ('a' <= char && char <= 'z') || __indexOf.call('-_', char) >= 0) {
          length++;
          char = this.peek(length);
        }
        if (char !== '!') {
          this.forward(length);
          throw new exports.ScannerError("while scanning a " + name, start_mark, "expected '!' but found " + char, this.get_mark());
        }
        length++;
      }
      value = this.prefix(length);
      this.forward(length);
      return value;
    };

    /*
    See the specification for details.
    Note: we do not check if URI is well-formed.
    */


    Scanner.prototype.scan_tag_uri = function(name, start_mark) {
      var char, chunks, length;
      chunks = [];
      length = 0;
      char = this.peek(length);
      while (('0' <= char && char <= '9') || ('A' <= char && char <= 'Z') || ('a' <= char && char <= 'z') || __indexOf.call('-;/?:@&=+$,_.!~*\'()[]%', char) >= 0) {
        if (char === '%') {
          chunks.push(this.prefix(length));
          this.forward(length);
          length = 0;
          chunks.push(this.scan_uri_escapes(name, start_mark));
        } else {
          length++;
        }
        char = this.peek(length);
      }
      if (length !== 0) {
        chunks.push(this.prefix(length));
        this.forward(length);
        length = 0;
      }
      if (chunks.length === 0) {
        throw new exports.ScannerError("while parsing a " + name, start_mark, "expected URI but found " + char, this.get_mark());
      }
      return chunks.join('');
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_uri_escapes = function(name, start_mark) {
      var bytes, k, mark, _i;
      bytes = [];
      mark = this.get_mark();
      while (this.peek() === '%') {
        this.forward();
        for (k = _i = 0; _i <= 2; k = ++_i) {
          throw new exports.ScannerError("while scanning a " + name, start_mark, "expected URI escape sequence of 2 hexadecimal numbers but found          " + (this.peek(k)), this.get_mark());
        }
        bytes.push(String.fromCharCode(parseInt(this.prefix(2), 16)));
        this.forward(2);
      }
      return bytes.join('');
    };

    /*
    Transforms:
      '\r\n'      :   '\n'
      '\r'        :   '\n'
      '\n'        :   '\n'
      '\x85'      :   '\n'
      '\u2028'    :   '\u2028'
      '\u2029     :   '\u2029'
      default     :   ''
    */


    Scanner.prototype.scan_line_break = function() {
      var char;
      char = this.peek();
      if (__indexOf.call('\r\n\x85', char) >= 0) {
        if (this.prefix(2) === '\r\n') {
          this.forward(2);
        } else {
          this.forward();
        }
        return '\n';
      } else if (__indexOf.call('\u2028\u2029', char) >= 0) {
        this.forward();
        return char;
      }
      return '';
    };

    return Scanner;

  })();

}).call(this);

},{"./errors":35,"./tokens":49,"./util":52}],47:[function(require,module,exports){
(function() {
  var MarkedYAMLError, nodes, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  MarkedYAMLError = require('./errors').MarkedYAMLError;

  nodes = require('./nodes');

  /*
  The Schemas throws these.
  */


  this.SchemaError = (function(_super) {
    __extends(SchemaError, _super);

    function SchemaError() {
      _ref = SchemaError.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return SchemaError;

  })(MarkedYAMLError);

  /*
    The Schemas class deals with applying schemas to resources according to the spec
  */


  this.Schemas = (function() {
    function Schemas() {
      this.get_schemas_used = __bind(this.get_schemas_used, this);
      this.apply_schemas = __bind(this.apply_schemas, this);
      this.get_all_schemas = __bind(this.get_all_schemas, this);
      this.has_schemas = __bind(this.has_schemas, this);
      this.load_schemas = __bind(this.load_schemas, this);
      this.declaredSchemas = {};
    }

    Schemas.prototype.load_schemas = function(node) {
      var allSchemas,
        _this = this;
      if (this.has_property(node, "schemas")) {
        allSchemas = this.property_value(node, 'schemas');
        if (allSchemas && typeof allSchemas === "object") {
          return allSchemas.forEach(function(schema_entry) {
            if (schema_entry && typeof schema_entry === "object" && typeof schema_entry.value === "object") {
              return schema_entry.value.forEach(function(schema) {
                return _this.declaredSchemas[schema[0].value] = schema;
              });
            }
          });
        }
      }
    };

    Schemas.prototype.has_schemas = function(node) {
      if (this.declaredSchemas.length === 0 && this.has_property(node, "schemas")) {
        this.load_schemas(node);
      }
      return Object.keys(this.declaredSchemas).length > 0;
    };

    Schemas.prototype.get_all_schemas = function() {
      return this.declaredSchemas;
    };

    Schemas.prototype.apply_schemas = function(node) {
      var resources, schemas,
        _this = this;
      resources = this.child_resources(node);
      schemas = this.get_schemas_used(resources);
      return schemas.forEach(function(schema) {
        if (schema[1].value in _this.declaredSchemas) {
          return schema[1].value = _this.declaredSchemas[schema[1].value][1].value;
        }
      });
    };

    Schemas.prototype.get_schemas_used = function(resources) {
      var schemas,
        _this = this;
      schemas = [];
      resources.forEach(function(resource) {
        var properties;
        properties = _this.get_properties(resource[1], "schema");
        return schemas = schemas.concat(properties);
      });
      return schemas;
    };

    return Schemas;

  })();

}).call(this);

},{"./errors":35,"./nodes":39}],48:[function(require,module,exports){
(function() {
  var MarkedYAMLError, nodes, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  MarkedYAMLError = require('./errors').MarkedYAMLError;

  nodes = require('./nodes');

  /*
  The Schemas throws these.
  */


  this.SecuritySchemeError = (function(_super) {
    __extends(SecuritySchemeError, _super);

    /*
      The Schemas class deals with applying schemas to resources according to the spec
    */


    function SecuritySchemeError() {
      _ref = SecuritySchemeError.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return SecuritySchemeError;

  })(MarkedYAMLError);

  this.SecuritySchemes = (function() {
    function SecuritySchemes() {
      this.get_security_scheme = __bind(this.get_security_scheme, this);
      this.get_all_schemes = __bind(this.get_all_schemes, this);
      this.load_security_schemes = __bind(this.load_security_schemes, this);
      this.declaredSchemes = {};
    }

    SecuritySchemes.prototype.load_security_schemes = function(node) {
      var allschemes,
        _this = this;
      if (this.has_property(node, "securitySchemes")) {
        allschemes = this.property_value(node, 'securitySchemes');
        if (allschemes && typeof allschemes === "object") {
          return allschemes.forEach(function(scheme_entry) {
            if (scheme_entry.tag === 'tag:yaml.org,2002:map') {
              return scheme_entry.value.forEach(function(scheme) {
                return _this.declaredSchemes[scheme[0].value] = scheme[1].value;
              });
            }
          });
        }
      }
    };

    SecuritySchemes.prototype.get_all_schemes = function() {
      return this.declaredSchemes;
    };

    SecuritySchemes.prototype.get_security_scheme = function(schemaName) {
      return this.declaredSchemes[schemaName];
    };

    return SecuritySchemes;

  })();

}).call(this);

},{"./errors":35,"./nodes":39}],49:[function(require,module,exports){
(function() {
  var _ref, _ref1, _ref10, _ref11, _ref12, _ref13, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  this.Token = (function() {
    function Token(start_mark, end_mark) {
      this.start_mark = start_mark;
      this.end_mark = end_mark;
    }

    return Token;

  })();

  this.DirectiveToken = (function(_super) {
    __extends(DirectiveToken, _super);

    DirectiveToken.prototype.id = '<directive>';

    function DirectiveToken(name, value, start_mark, end_mark) {
      this.name = name;
      this.value = value;
      this.start_mark = start_mark;
      this.end_mark = end_mark;
    }

    return DirectiveToken;

  })(this.Token);

  this.DocumentStartToken = (function(_super) {
    __extends(DocumentStartToken, _super);

    function DocumentStartToken() {
      _ref = DocumentStartToken.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    DocumentStartToken.prototype.id = '<document start>';

    return DocumentStartToken;

  })(this.Token);

  this.DocumentEndToken = (function(_super) {
    __extends(DocumentEndToken, _super);

    function DocumentEndToken() {
      _ref1 = DocumentEndToken.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    DocumentEndToken.prototype.id = '<document end>';

    return DocumentEndToken;

  })(this.Token);

  this.StreamStartToken = (function(_super) {
    __extends(StreamStartToken, _super);

    StreamStartToken.prototype.id = '<stream start>';

    function StreamStartToken(start_mark, end_mark, encoding) {
      this.start_mark = start_mark;
      this.end_mark = end_mark;
      this.encoding = encoding;
    }

    return StreamStartToken;

  })(this.Token);

  this.StreamEndToken = (function(_super) {
    __extends(StreamEndToken, _super);

    function StreamEndToken() {
      _ref2 = StreamEndToken.__super__.constructor.apply(this, arguments);
      return _ref2;
    }

    StreamEndToken.prototype.id = '<stream end>';

    return StreamEndToken;

  })(this.Token);

  this.BlockSequenceStartToken = (function(_super) {
    __extends(BlockSequenceStartToken, _super);

    function BlockSequenceStartToken() {
      _ref3 = BlockSequenceStartToken.__super__.constructor.apply(this, arguments);
      return _ref3;
    }

    BlockSequenceStartToken.prototype.id = '<block sequence start>';

    return BlockSequenceStartToken;

  })(this.Token);

  this.BlockMappingStartToken = (function(_super) {
    __extends(BlockMappingStartToken, _super);

    function BlockMappingStartToken() {
      _ref4 = BlockMappingStartToken.__super__.constructor.apply(this, arguments);
      return _ref4;
    }

    BlockMappingStartToken.prototype.id = '<block mapping end>';

    return BlockMappingStartToken;

  })(this.Token);

  this.BlockEndToken = (function(_super) {
    __extends(BlockEndToken, _super);

    function BlockEndToken() {
      _ref5 = BlockEndToken.__super__.constructor.apply(this, arguments);
      return _ref5;
    }

    BlockEndToken.prototype.id = '<block end>';

    return BlockEndToken;

  })(this.Token);

  this.FlowSequenceStartToken = (function(_super) {
    __extends(FlowSequenceStartToken, _super);

    function FlowSequenceStartToken() {
      _ref6 = FlowSequenceStartToken.__super__.constructor.apply(this, arguments);
      return _ref6;
    }

    FlowSequenceStartToken.prototype.id = '[';

    return FlowSequenceStartToken;

  })(this.Token);

  this.FlowMappingStartToken = (function(_super) {
    __extends(FlowMappingStartToken, _super);

    function FlowMappingStartToken() {
      _ref7 = FlowMappingStartToken.__super__.constructor.apply(this, arguments);
      return _ref7;
    }

    FlowMappingStartToken.prototype.id = '{';

    return FlowMappingStartToken;

  })(this.Token);

  this.FlowSequenceEndToken = (function(_super) {
    __extends(FlowSequenceEndToken, _super);

    function FlowSequenceEndToken() {
      _ref8 = FlowSequenceEndToken.__super__.constructor.apply(this, arguments);
      return _ref8;
    }

    FlowSequenceEndToken.prototype.id = ']';

    return FlowSequenceEndToken;

  })(this.Token);

  this.FlowMappingEndToken = (function(_super) {
    __extends(FlowMappingEndToken, _super);

    function FlowMappingEndToken() {
      _ref9 = FlowMappingEndToken.__super__.constructor.apply(this, arguments);
      return _ref9;
    }

    FlowMappingEndToken.prototype.id = '}';

    return FlowMappingEndToken;

  })(this.Token);

  this.KeyToken = (function(_super) {
    __extends(KeyToken, _super);

    function KeyToken() {
      _ref10 = KeyToken.__super__.constructor.apply(this, arguments);
      return _ref10;
    }

    KeyToken.prototype.id = '?';

    return KeyToken;

  })(this.Token);

  this.ValueToken = (function(_super) {
    __extends(ValueToken, _super);

    function ValueToken() {
      _ref11 = ValueToken.__super__.constructor.apply(this, arguments);
      return _ref11;
    }

    ValueToken.prototype.id = ':';

    return ValueToken;

  })(this.Token);

  this.BlockEntryToken = (function(_super) {
    __extends(BlockEntryToken, _super);

    function BlockEntryToken() {
      _ref12 = BlockEntryToken.__super__.constructor.apply(this, arguments);
      return _ref12;
    }

    BlockEntryToken.prototype.id = '-';

    return BlockEntryToken;

  })(this.Token);

  this.FlowEntryToken = (function(_super) {
    __extends(FlowEntryToken, _super);

    function FlowEntryToken() {
      _ref13 = FlowEntryToken.__super__.constructor.apply(this, arguments);
      return _ref13;
    }

    FlowEntryToken.prototype.id = ',';

    return FlowEntryToken;

  })(this.Token);

  this.AliasToken = (function(_super) {
    __extends(AliasToken, _super);

    AliasToken.prototype.id = '<alias>';

    function AliasToken(value, start_mark, end_mark) {
      this.value = value;
      this.start_mark = start_mark;
      this.end_mark = end_mark;
    }

    return AliasToken;

  })(this.Token);

  this.AnchorToken = (function(_super) {
    __extends(AnchorToken, _super);

    AnchorToken.prototype.id = '<anchor>';

    function AnchorToken(value, start_mark, end_mark) {
      this.value = value;
      this.start_mark = start_mark;
      this.end_mark = end_mark;
    }

    return AnchorToken;

  })(this.Token);

  this.TagToken = (function(_super) {
    __extends(TagToken, _super);

    TagToken.prototype.id = '<tag>';

    function TagToken(value, start_mark, end_mark) {
      this.value = value;
      this.start_mark = start_mark;
      this.end_mark = end_mark;
    }

    return TagToken;

  })(this.Token);

  this.ScalarToken = (function(_super) {
    __extends(ScalarToken, _super);

    ScalarToken.prototype.id = '<scalar>';

    function ScalarToken(value, plain, start_mark, end_mark, style) {
      this.value = value;
      this.plain = plain;
      this.start_mark = start_mark;
      this.end_mark = end_mark;
      this.style = style;
    }

    return ScalarToken;

  })(this.Token);

}).call(this);

},{}],50:[function(require,module,exports){
(function() {
  var MarkedYAMLError, inflection, nodes, util, _ref, _ref1,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  MarkedYAMLError = require('./errors').MarkedYAMLError;

  nodes = require('./nodes');

  inflection = require('inflection');

  util = require('./util');

  /*
  The Traits throws these.
  */


  this.TraitError = (function(_super) {
    __extends(TraitError, _super);

    function TraitError() {
      _ref = TraitError.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return TraitError;

  })(MarkedYAMLError);

  /*
  */


  this.ParameterError = (function(_super) {
    __extends(ParameterError, _super);

    function ParameterError() {
      _ref1 = ParameterError.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    return ParameterError;

  })(MarkedYAMLError);

  /*
  The Traits class deals with applying traits to resources according to the spec
  */


  this.Traits = (function() {
    function Traits() {
      this.declaredTraits = {};
    }

    Traits.prototype.load_traits = function(node) {
      var allTraits,
        _this = this;
      if (this.has_property(node, 'traits')) {
        allTraits = this.property_value(node, 'traits');
        if (allTraits && typeof allTraits === "object") {
          return allTraits.forEach(function(trait_item) {
            if (trait_item && typeof trait_item === "object" && typeof trait_item.value === "object") {
              return trait_item.value.forEach(function(trait) {
                return _this.declaredTraits[trait[0].value] = trait;
              });
            }
          });
        }
      }
    };

    Traits.prototype.has_traits = function(node) {
      if (this.declaredTraits.length === 0 && this.has_property(node, 'traits')) {
        this.load_traits(node);
      }
      return Object.keys(this.declaredTraits).length > 0;
    };

    Traits.prototype.get_trait = function(traitName) {
      if (traitName in this.declaredTraits) {
        return this.declaredTraits[traitName][1];
      }
      return null;
    };

    Traits.prototype.apply_traits = function(node, resourceUri, removeQs) {
      var resources,
        _this = this;
      if (resourceUri == null) {
        resourceUri = "";
      }
      if (removeQs == null) {
        removeQs = true;
      }
      if (!util.isMapping(node)) {
        return;
      }
      if (this.has_traits(node)) {
        resources = this.child_resources(node);
        return resources.forEach(function(resource) {
          return _this.apply_traits_to_resource(resourceUri + resource[0].value, resource[1], removeQs);
        });
      }
    };

    Traits.prototype.apply_traits_to_resource = function(resourceUri, resource, removeQs) {
      var methods, uses,
        _this = this;
      if (!util.isMapping(resource)) {
        return;
      }
      methods = this.child_methods(resource);
      if (this.has_property(resource, 'is')) {
        uses = this.property_value(resource, 'is');
        uses.forEach(function(use) {
          return methods.forEach(function(method) {
            return _this.apply_trait(resourceUri, method, use);
          });
        });
      }
      methods.forEach(function(method) {
        if (_this.has_property(method[1], 'is')) {
          uses = _this.property_value(method[1], 'is');
          return uses.forEach(function(use) {
            return _this.apply_trait(resourceUri, method, use);
          });
        }
      });
      if (removeQs) {
        resource.remove_question_mark_properties();
      }
      return this.apply_traits(resource, resourceUri, removeQs);
    };

    Traits.prototype.apply_trait = function(resourceUri, method, useKey) {
      var plainParameters, temp, trait, traitName;
      traitName = this.key_or_value(useKey);
      if (!(traitName != null ? traitName.trim() : void 0)) {
        throw new exports.TraitError('while applying trait', null, 'trait name must be provided', useKey.start_mark);
      }
      if (!(trait = this.get_trait(traitName))) {
        throw new exports.TraitError('while applying trait', null, "there is no trait named " + traitName, useKey.start_mark);
      }
      plainParameters = this.get_parameters_from_is_key(resourceUri, method[0].value, useKey);
      temp = trait.cloneForTrait();
      this.apply_parameters(temp, plainParameters, useKey);
      this.apply_default_media_type_to_method(temp);
      temp.combine(method[1]);
      return method[1] = temp;
    };

    Traits.prototype.apply_parameters = function(resource, parameters, useKey) {
      var parameterName, usedParameters, _results;
      this._apply_parameters(resource, parameters, useKey, usedParameters = {
        resourcePath: true,
        resourcePathName: true,
        methodName: true
      });
      _results = [];
      for (parameterName in parameters) {
        if (!usedParameters[parameterName]) {
          throw new exports.ParameterError('while applying parameters', null, "unused parameter: " + parameterName, useKey.start_mark);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Traits.prototype._apply_parameters = function(resource, parameters, useKey, usedParameters) {
      var parameterUse,
        _this = this;
      if (!resource) {
        return;
      }
      if (util.isString(resource)) {
        if (parameterUse = resource.value.match(/<<\s*([^\|\s>]+)\s*(\|.*)?\s*>>/g)) {
          parameterUse.forEach(function(parameter) {
            var method, parameterName, value, _ref2, _ref3;
            parameterName = parameter != null ? (_ref2 = parameter.trim()) != null ? _ref2.replace(/[<>]+/g, '').trim() : void 0 : void 0;
            _ref3 = parameterName.split(/\s*\|\s*/), parameterName = _ref3[0], method = _ref3[1];
            if (!(parameterName in parameters)) {
              throw new exports.ParameterError('while applying parameters', null, "value was not provided for parameter: " + parameterName, useKey.start_mark);
            }
            value = parameters[parameterName];
            usedParameters[parameterName] = true;
            if (method) {
              if (method.match(/!\s*singularize/)) {
                value = inflection.singularize(value);
              } else if (method.match(/!\s*pluralize/)) {
                value = inflection.pluralize(value);
              } else {
                throw new exports.ParameterError('while validating parameter', null, 'unknown function applied to parameter', resource.start_mark);
              }
            }
            return resource.value = resource.value.replace(parameter, value);
          });
        }
        return;
      }
      if (util.isSequence(resource)) {
        resource.value.forEach(function(node) {
          return _this._apply_parameters(node, parameters, useKey, usedParameters);
        });
        return;
      }
      if (util.isMapping(resource)) {
        resource.value.forEach(function(property) {
          _this._apply_parameters(property[0], parameters, useKey, usedParameters);
          return _this._apply_parameters(property[1], parameters, useKey, usedParameters);
        });
      }
    };

    Traits.prototype.get_parameters_from_is_key = function(resourceUri, methodName, typeKey) {
      var parameter, parameters, reserved, result, _i, _len, _ref2;
      result = {};
      reserved = {
        methodName: methodName,
        resourcePath: resourceUri.replace(/\/\/*/g, '/'),
        resourcePathName: this.extractResourcePathName(resourceUri)
      };
      if (util.isMapping(typeKey)) {
        parameters = this.value_or_undefined(typeKey);
        if (util.isMapping(parameters[0][1])) {
          _ref2 = parameters[0][1].value;
          for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
            parameter = _ref2[_i];
            if (parameter[0].value in reserved) {
              throw new exports.TraitError('while applying parameters', null, "invalid parameter name: " + parameter[0].value + " is reserved", parameter[0].start_mark);
            }
            result[parameter[0].value] = parameter[1].value;
          }
        }
      }
      return util.extend(result, reserved);
    };

    Traits.prototype.extractResourcePathName = function(resourceUri) {
      var pathSegments, segment;
      pathSegments = resourceUri.split(/\//);
      while (segment = pathSegments.pop()) {
        if (!(typeof segment !== "undefined" && segment !== null ? segment.match(/[{}]/) : void 0)) {
          return segment;
        }
      }
      return "";
    };

    return Traits;

  })();

}).call(this);

},{"./errors":35,"./nodes":39,"./util":52,"inflection":19}],51:[function(require,module,exports){
(function() {
  var nodes, uritemplate, util,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  uritemplate = require('uritemplate');

  nodes = require('./nodes');

  util = require('./util');

  /*
     Applies transformations to the RAML
  */


  this.Transformations = (function() {
    function Transformations(settings) {
      this.settings = settings;
      this.isContentTypeString = __bind(this.isContentTypeString, this);
      this.add_key_value_to_node = __bind(this.add_key_value_to_node, this);
      this.apply_default_media_type_to_resource = __bind(this.apply_default_media_type_to_resource, this);
      this.get_media_type = __bind(this.get_media_type, this);
      this.load_default_media_type = __bind(this.load_default_media_type, this);
      this.applyAstTransformations = __bind(this.applyAstTransformations, this);
      this.applyTransformations = __bind(this.applyTransformations, this);
      this.declaredSchemas = {};
    }

    Transformations.prototype.applyTransformations = function(rootObject) {
      var resources;
      if (this.settings.transform) {
        this.applyTransformationsToRoot(rootObject);
        resources = rootObject.resources;
        return this.applyTransformationsToResources(rootObject, resources);
      }
    };

    Transformations.prototype.applyAstTransformations = function(document) {
      if (this.settings.transform) {
        return this.transform_document(document);
      }
    };

    Transformations.prototype.load_default_media_type = function(node) {
      if (!util.isMapping(node || (node != null ? node.value : void 0))) {
        return;
      }
      return this.mediaType = this.property_value(node, 'mediaType');
    };

    Transformations.prototype.get_media_type = function() {
      return this.mediaType;
    };

    Transformations.prototype.applyTransformationsToRoot = function(rootObject) {
      var expressions, template;
      if (rootObject.baseUri) {
        template = uritemplate.parse(rootObject.baseUri);
        expressions = template.expressions.filter(function(expr) {
          return 'templateText' in expr;
        }).map(function(expression) {
          return expression.templateText;
        });
        if (expressions.length) {
          if (!rootObject.baseUriParameters) {
            rootObject.baseUriParameters = {};
          }
        }
        return expressions.forEach(function(parameterName) {
          if (!(parameterName in rootObject.baseUriParameters)) {
            rootObject.baseUriParameters[parameterName] = {
              type: "string",
              required: true,
              displayName: parameterName
            };
            if (parameterName === "version") {
              return rootObject.baseUriParameters[parameterName]["enum"] = [rootObject.version];
            }
          }
        });
      }
    };

    Transformations.prototype.applyTransformationsToResources = function(rootObject, resources) {
      var expressions, inheritedSecScheme, method, parameterName, pathParts, resource, template, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _results;
      if (resources != null ? resources.length : void 0) {
        _results = [];
        for (_i = 0, _len = resources.length; _i < _len; _i++) {
          resource = resources[_i];
          inheritedSecScheme = resource.securedBy ? resource.securedBy : rootObject != null ? rootObject.securedBy : void 0;
          if ((_ref = resource.methods) != null ? _ref.length : void 0) {
            _ref1 = resource.methods;
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              method = _ref1[_j];
              if (!("securedBy" in method)) {
                if (inheritedSecScheme) {
                  method.securedBy = inheritedSecScheme;
                }
              }
            }
          }
          pathParts = resource.relativeUri.split('\/');
          while (!pathParts[0] && pathParts.length) {
            pathParts.shift();
          }
          resource.relativeUriPathSegments = pathParts;
          template = uritemplate.parse(resource.relativeUri);
          expressions = template.expressions.filter(function(expr) {
            return 'templateText' in expr;
          }).map(function(expression) {
            return expression.templateText;
          });
          if (expressions.length) {
            if (!resource.uriParameters) {
              resource.uriParameters = {};
            }
          }
          for (_k = 0, _len2 = expressions.length; _k < _len2; _k++) {
            parameterName = expressions[_k];
            if (!(parameterName in resource.uriParameters)) {
              resource.uriParameters[parameterName] = {
                type: "string",
                required: true,
                displayName: parameterName
              };
            }
          }
          _results.push(this.applyTransformationsToResources(rootObject, resource.resources));
        }
        return _results;
      }
    };

    /*
    Media Type pivot when using default mediaType property
    */


    Transformations.prototype.apply_default_media_type_to_resource = function(resource) {
      var childResource, method, _i, _j, _len, _len1, _ref, _ref1, _results;
      if (!this.mediaType) {
        return;
      }
      if (!util.isMapping(resource)) {
        return;
      }
      _ref = this.child_resources(resource);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        childResource = _ref[_i];
        this.apply_default_media_type_to_resource(childResource[1]);
      }
      _ref1 = this.child_methods(resource);
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        method = _ref1[_j];
        _results.push(this.apply_default_media_type_to_method(method[1]));
      }
      return _results;
    };

    Transformations.prototype.apply_default_media_type_to_method = function(method) {
      var responses,
        _this = this;
      if (!this.mediaType) {
        return;
      }
      if (!util.isMapping(method)) {
        return;
      }
      if (this.has_property(method, 'body')) {
        this.apply_default_media_type_to_body(this.get_property(method, 'body'));
      }
      if (this.has_property(method, 'responses')) {
        responses = this.get_property(method, 'responses');
        if (!(responses && responses.value)) {
          return;
        }
        return responses.value.forEach(function(response) {
          if (_this.has_property(response[1], 'body')) {
            return _this.apply_default_media_type_to_body(_this.get_property(response[1], 'body'));
          }
        });
      }
    };

    Transformations.prototype.apply_default_media_type_to_body = function(body) {
      var key, responseType, responseTypeKey, _ref, _ref1, _ref2;
      if (!util.isMapping(body)) {
        return;
      }
      if (body != null ? (_ref = body.value) != null ? (_ref1 = _ref[0]) != null ? (_ref2 = _ref1[0]) != null ? _ref2.value : void 0 : void 0 : void 0 : void 0) {
        key = body.value[0][0].value;
        if (!key.match(/\//)) {
          responseType = new nodes.MappingNode('tag:yaml.org,2002:map', [], body.start_mark, body.end_mark);
          responseTypeKey = new nodes.ScalarNode('tag:yaml.org,2002:str', this.mediaType, body.start_mark, body.end_mark);
          responseType.value.push([responseTypeKey, body.clone()]);
          return body.value = responseType.value;
        }
      }
    };

    Transformations.prototype.noop = function() {};

    Transformations.prototype.transform_types = function(typeProperty) {
      var types,
        _this = this;
      types = typeProperty.value;
      return types.forEach(function(type_entry) {
        return type_entry.value.forEach(function(type) {
          return _this.transform_resource(type, true);
        });
      });
    };

    Transformations.prototype.transform_traits = function(traitProperty) {
      var traits,
        _this = this;
      traits = traitProperty.value;
      return traits.forEach(function(trait_entry) {
        return trait_entry.value.forEach(function(trait) {
          return _this.transform_method(trait[1], true);
        });
      });
    };

    Transformations.prototype.transform_named_params = function(property, allowParameterKeys, requiredByDefault) {
      var _this = this;
      if (requiredByDefault == null) {
        requiredByDefault = true;
      }
      if (util.isNull(property[1])) {
        return;
      }
      return property[1].value.forEach(function(param) {
        if (util.isNull(param[1])) {
          param[1] = new nodes.MappingNode('tag:yaml.org,2002:map', [], param[1].start_mark, param[1].end_mark);
        }
        return _this.transform_common_parameter_properties(param[0].value, param[1], allowParameterKeys, requiredByDefault);
      });
    };

    Transformations.prototype.transform_common_parameter_properties = function(parameterName, node, allowParameterKeys, requiredByDefault) {
      var _this = this;
      if (util.isSequence(node)) {
        return node.value.forEach(function(parameter) {
          return _this.transform_named_parameter(parameterName, parameter, allowParameterKeys, requiredByDefault);
        });
      } else {
        return this.transform_named_parameter(parameterName, node, allowParameterKeys, requiredByDefault);
      }
    };

    Transformations.prototype.transform_named_parameter = function(parameterName, node, allowParameterKeys, requiredByDefault) {
      var hasDisplayName, hasRequired, hasType,
        _this = this;
      hasDisplayName = false;
      hasRequired = false;
      hasType = false;
      node.value.forEach(function(childNode) {
        var canonicalPropertyName;
        if (allowParameterKeys && _this.isParameterKey(childNode)) {
          return;
        }
        canonicalPropertyName = _this.canonicalizePropertyName(childNode[0].value, allowParameterKeys);
        switch (canonicalPropertyName) {
          case "pattern":
            return _this.noop();
          case "default":
            return _this.noop();
          case "enum":
            return _this.noop();
          case "description":
            return _this.noop();
          case "example":
            return _this.noop();
          case "minLength":
            return _this.noop();
          case "maxLength":
            return _this.noop();
          case "minimum":
            return _this.noop();
          case "maximum":
            return _this.noop();
          case "repeat":
            return _this.noop();
          case "displayName":
            return hasDisplayName = true;
          case "type":
            return hasType = true;
          case "required":
            return hasRequired = true;
          default:
            return _this.noop();
        }
      });
      if (!hasDisplayName) {
        this.add_key_value_to_node(node, 'displayName', 'tag:yaml.org,2002:str', this.canonicalizePropertyName(parameterName, allowParameterKeys));
      }
      if (!hasRequired) {
        if (requiredByDefault) {
          this.add_key_value_to_node(node, 'required', 'tag:yaml.org,2002:bool', 'true');
        }
      }
      if (!hasType) {
        return this.add_key_value_to_node(node, 'type', 'tag:yaml.org,2002:str', 'string');
      }
    };

    Transformations.prototype.add_key_value_to_node = function(node, keyName, valueTag, value) {
      var propertyName, propertyValue;
      propertyName = new nodes.ScalarNode('tag:yaml.org,2002:str', keyName, node.start_mark, node.end_mark);
      propertyValue = new nodes.ScalarNode(valueTag, value, node.start_mark, node.end_mark);
      return node.value.push([propertyName, propertyValue]);
    };

    Transformations.prototype.transform_document = function(node) {
      var _this = this;
      if (node != null ? node.value : void 0) {
        return node.value.forEach(function(property) {
          var _ref;
          switch (property[0].value) {
            case "title":
              return _this.noop();
            case "securitySchemes":
              return _this.noop();
            case "schemas":
              return _this.noop();
            case "version":
              return _this.noop();
            case "documentation":
              return _this.noop();
            case "mediaType":
              return _this.noop();
            case "securedBy":
              return _this.noop();
            case "baseUri":
              return _this.noop();
            case "traits":
              return _this.transform_traits(property[1]);
            case "baseUriParameters":
              return _this.transform_named_params(property, false);
            case "resourceTypes":
              return _this.transform_types(property[1]);
            case "resources":
              return (_ref = property[1]) != null ? _ref.value.forEach(function(resource) {
                return _this.transform_resource(resource);
              }) : void 0;
            default:
              return _this.noop();
          }
        });
      }
    };

    Transformations.prototype.transform_resource = function(resource, allowParameterKeys) {
      var _this = this;
      if (allowParameterKeys == null) {
        allowParameterKeys = false;
      }
      if (resource.value) {
        return resource.value.forEach(function(property) {
          var canonicalKey, isKnownCommonProperty, _ref, _ref1;
          isKnownCommonProperty = _this.transform_common_properties(property, allowParameterKeys);
          if (!isKnownCommonProperty) {
            if (_this.isHttpMethod(property[0].value, allowParameterKeys)) {
              return _this.transform_method(property[1], allowParameterKeys);
            } else {
              canonicalKey = _this.canonicalizePropertyName(property[0].value, allowParameterKeys);
              switch (canonicalKey) {
                case "type":
                  return _this.noop();
                case "usage":
                  return _this.noop();
                case "securedBy":
                  return _this.noop();
                case "uriParameters":
                  return _this.transform_named_params(property, allowParameterKeys);
                case "baseUriParameters":
                  return _this.transform_named_params(property, allowParameterKeys);
                case "resources":
                  return (_ref = property[1]) != null ? _ref.value.forEach(function(resource) {
                    return _this.transform_resource(resource);
                  }) : void 0;
                case "methods":
                  return (_ref1 = property[1]) != null ? _ref1.value.forEach(function(method) {
                    return _this.transform_method(method, allowParameterKeys);
                  }) : void 0;
                default:
                  return _this.noop();
              }
            }
          }
        });
      }
    };

    Transformations.prototype.transform_method = function(method, allowParameterKeys) {
      var _this = this;
      if (util.isNull(method)) {
        return;
      }
      return method.value.forEach(function(property) {
        var canonicalKey;
        if (_this.transform_common_properties(property, allowParameterKeys)) {
          return;
        }
        canonicalKey = _this.canonicalizePropertyName(property[0].value, allowParameterKeys);
        switch (canonicalKey) {
          case "securedBy":
            return _this.noop();
          case "usage":
            return _this.noop();
          case "headers":
            return _this.transform_named_params(property, allowParameterKeys, false);
          case "queryParameters":
            return _this.transform_named_params(property, allowParameterKeys, false);
          case "baseUriParameters":
            return _this.transform_named_params(property, allowParameterKeys);
          case "body":
            return _this.transform_body(property, allowParameterKeys);
          case "responses":
            return _this.transform_responses(property, allowParameterKeys);
          default:
            return _this.noop();
        }
      });
    };

    Transformations.prototype.transform_responses = function(responses, allowParameterKeys) {
      var _this = this;
      if (util.isNull(responses[1])) {
        return;
      }
      return responses[1].value.forEach(function(response) {
        return _this.transform_response(response, allowParameterKeys);
      });
    };

    Transformations.prototype.transform_response = function(response, allowParameterKeys) {
      var _this = this;
      if (util.isMapping(response[1])) {
        return response[1].value.forEach(function(property) {
          var canonicalKey;
          canonicalKey = _this.canonicalizePropertyName(property[0].value, allowParameterKeys);
          switch (canonicalKey) {
            case "description":
              return _this.noop();
            case "body":
              return _this.transform_body(property, allowParameterKeys);
            case "headers":
              return _this.transform_named_params(property, allowParameterKeys, false);
            default:
              return _this.noop();
          }
        });
      }
    };

    Transformations.prototype.isContentTypeString = function(value) {
      return value != null ? value.match(/^[^\/]+\/[^\/]+$/) : void 0;
    };

    Transformations.prototype.transform_body = function(property, allowParameterKeys) {
      var _ref,
        _this = this;
      if (util.isNull(property[1])) {
        return;
      }
      return (_ref = property[1].value) != null ? _ref.forEach(function(bodyProperty) {
        var canonicalProperty;
        if (_this.isParameterKey(bodyProperty)) {
          return _this.noop();
        } else if (_this.isContentTypeString(bodyProperty[0].value)) {
          return _this.transform_body(bodyProperty, allowParameterKeys);
        } else {
          canonicalProperty = _this.canonicalizePropertyName(bodyProperty[0].value, allowParameterKeys);
          switch (canonicalProperty) {
            case "example":
              return _this.noop();
            case "schema":
              return _this.noop();
            case "formParameters":
              return _this.transform_named_params(bodyProperty, allowParameterKeys, false);
            default:
              return _this.noop();
          }
        }
      }) : void 0;
    };

    Transformations.prototype.transform_common_properties = function(property, allowParameterKeys) {
      var canonicalProperty;
      if (this.isParameterKey(property)) {
        return true;
      } else {
        canonicalProperty = this.canonicalizePropertyName(property[0].value, allowParameterKeys);
        switch (canonicalProperty) {
          case "displayName":
            return true;
          case "description":
            return true;
          case "is":
            return true;
          default:
            this.noop();
        }
      }
      return false;
    };

    return Transformations;

  })();

}).call(this);

},{"./nodes":39,"./util":52,"uritemplate":66}],52:[function(require,module,exports){
(function() {
  var __slice = [].slice,
    __hasProp = {}.hasOwnProperty;

  this.extend = function() {
    var destination, k, source, sources, v, _i, _len;
    destination = arguments[0], sources = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    for (_i = 0, _len = sources.length; _i < _len; _i++) {
      source = sources[_i];
      for (k in source) {
        v = source[k];
        destination[k] = v;
      }
    }
    return destination;
  };

  this.is_empty = function(obj) {
    var key;
    if (Array.isArray(obj) || typeof obj === 'string') {
      return obj.length === 0;
    }
    for (key in obj) {
      if (!__hasProp.call(obj, key)) continue;
      return false;
    }
    return true;
  };

  this.isNoop = function(node) {
    return node;
  };

  this.isMapping = function(node) {
    return (node != null ? node.tag : void 0) === "tag:yaml.org,2002:map";
  };

  this.isNull = function(node) {
    return (node != null ? node.tag : void 0) === "tag:yaml.org,2002:null";
  };

  this.isSequence = function(node) {
    return (node != null ? node.tag : void 0) === "tag:yaml.org,2002:seq";
  };

  this.isString = function(node) {
    return (node != null ? node.tag : void 0) === "tag:yaml.org,2002:str";
  };

  this.isInteger = function(node) {
    return (node != null ? node.tag : void 0) === "tag:yaml.org,2002:int";
  };

  this.isNullableMapping = function(node) {
    return this.isMapping(node) || this.isNull(node);
  };

  this.isNullableString = function(node) {
    return this.isString(node) || this.isNull(node);
  };

  this.isNullableSequence = function(node) {
    return this.isSequence(node) || this.isNull(node);
  };

  this.isNumber = function(node) {
    return (node != null ? node.tag : void 0) === 'tag:yaml.org,2002:int' || (node != null ? node.tag : void 0) === 'tag:yaml.org,2002:float';
  };

  this.isScalar = function(node) {
    return (node != null ? node.tag : void 0) === 'tag:yaml.org,2002:null' || (node != null ? node.tag : void 0) === 'tag:yaml.org,2002:bool' || (node != null ? node.tag : void 0) === 'tag:yaml.org,2002:int' || (node != null ? node.tag : void 0) === 'tag:yaml.org,2002:float' || (node != null ? node.tag : void 0) === 'tag:yaml.org,2002:binary' || (node != null ? node.tag : void 0) === 'tag:yaml.org,2002:timestamp' || (node != null ? node.tag : void 0) === 'tag:yaml.org,2002:str';
  };

  this.isCollection = function(node) {
    return (node != null ? node.tag : void 0) === 'tag:yaml.org,2002:omap' || (node != null ? node.tag : void 0) === 'tag:yaml.org,2002:pairs' || (node != null ? node.tag : void 0) === 'tag:yaml.org,2002:set' || (node != null ? node.tag : void 0) === 'tag:yaml.org,2002:seq' || (node != null ? node.tag : void 0) === 'tag:yaml.org,2002:map';
  };

}).call(this);

},{}],53:[function(require,module,exports){
(function() {
  var MarkedYAMLError, jsonlint, nodes, traits, uritemplate, url, util, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  url = require('url');

  uritemplate = require('uritemplate');

  MarkedYAMLError = require('./errors').MarkedYAMLError;

  nodes = require('./nodes');

  traits = require('./traits');

  util = require('./util');

  jsonlint = require('json-lint');

  /*
  The Validator throws these.
  */


  this.ValidationError = (function(_super) {
    __extends(ValidationError, _super);

    function ValidationError() {
      _ref = ValidationError.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return ValidationError;

  })(MarkedYAMLError);

  /*
  A collection of multiple validation errors
  */


  this.ValidationErrors = (function(_super) {
    __extends(ValidationErrors, _super);

    function ValidationErrors(validation_errors) {
      this.validation_errors = validation_errors;
    }

    ValidationErrors.prototype.get_validation_errors = function() {
      return this.validation_errors;
    };

    return ValidationErrors;

  })(MarkedYAMLError);

  /*
  The Validator class deals with validating a YAML file according to the spec
  */


  this.Validator = (function() {
    function Validator() {
      this.get_properties = __bind(this.get_properties, this);
      this.get_list_values = __bind(this.get_list_values, this);
      this.validations = [this.validate_root, this.validate_root_properties, this.validate_base_uri_parameters, this.valid_absolute_uris];
    }

    Validator.prototype.validate_document = function(node) {
      var validation, _i, _len, _ref1;
      _ref1 = this.validations;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        validation = _ref1[_i];
        validation.call(this, node);
      }
      return true;
    };

    Validator.prototype.validate_security_schemes = function(schemesProperty) {
      var scheme, scheme_entry, _i, _len, _ref1, _results;
      if (!util.isSequence(schemesProperty)) {
        throw new exports.ValidationError('while validating securitySchemes', null, 'invalid security schemes property, it must be an array', schemesProperty.start_mark);
      }
      _ref1 = schemesProperty.value;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        scheme_entry = _ref1[_i];
        if (!util.isMapping(scheme_entry)) {
          throw new exports.ValidationError('while validating securitySchemes', null, 'invalid security scheme property, it must be a map', scheme_entry.start_mark);
        }
        _results.push((function() {
          var _j, _len1, _ref2, _results1;
          _ref2 = scheme_entry.value;
          _results1 = [];
          for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
            scheme = _ref2[_j];
            if (!util.isMapping(scheme[1])) {
              throw new exports.ValidationError('while validating securitySchemes', null, 'invalid security scheme property, it must be a map', scheme[0].start_mark);
            }
            _results1.push(this.validate_security_scheme(scheme[1]));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Validator.prototype.trackRepeatedProperties = function(properties, key, property, section, errorMessage) {
      if (section == null) {
        section = "RAML";
      }
      if (errorMessage == null) {
        errorMessage = "a property with the same name already exists";
      }
      if (key in properties) {
        throw new exports.ValidationError("while validating " + section, null, "" + errorMessage + ": '" + key + "'", property.start_mark);
      }
      return properties[key] = property;
    };

    Validator.prototype.validate_security_scheme = function(scheme) {
      var property, schemeProperties, settings, type, _i, _len, _ref1;
      type = null;
      settings = null;
      schemeProperties = {};
      _ref1 = scheme.value;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        property = _ref1[_i];
        this.trackRepeatedProperties(schemeProperties, property[0].value, property[0], 'while validating security scheme', "property already used in security scheme");
        switch (property[0].value) {
          case "description":
            if (!util.isScalar(property[1])) {
              throw new exports.ValidationError('while validating security scheme', null, 'schemes description must be a string', property[1].start_mark);
            }
            break;
          case "type":
            type = property[1].value;
            if (!(util.isString(property[1]) && type.match(/^(OAuth 1.0|OAuth 2.0|Basic Authentication|Digest Authentication|x-.+)$/))) {
              throw new exports.ValidationError('while validating security scheme', null, 'schemes type must be any of: "OAuth 1.0", "OAuth 2.0", "Basic Authentication", "Digest Authentication", "x-\{.+\}"', property[1].start_mark);
            }
            break;
          case "describedBy":
            this.validate_method(property, true, "security scheme");
            break;
          case "settings":
            settings = property;
            if (!util.isNullableMapping(property[1])) {
              throw new exports.ValidationError('while validating security scheme', null, 'schemes settings must be a map', property[1].start_mark);
            }
            break;
          default:
            throw new exports.ValidationError('while validating security scheme', null, "property: '" + property[0].value + "' is invalid in a security scheme", property[0].start_mark);
        }
      }
      if (!type) {
        throw new exports.ValidationError('while validating security scheme', null, 'schemes type must be any of: "OAuth 1.0", "OAuth 2.0", "Basic Authentication", "Digest Authentication", "x-\{.+\}"', scheme.start_mark);
      } else if (type === "OAuth 2.0") {
        if (!settings) {
          throw new exports.ValidationError('while validating security scheme', null, 'for OAuth 2.0 settings must be a map', scheme.start_mark);
        }
        return this.validate_oauth2_settings(settings);
      } else if (type === "OAuth 1.0") {
        if (!settings) {
          throw new exports.ValidationError('while validating security scheme', null, 'for OAuth 1.0 settings must be a map', scheme.start_mark);
        }
        return this.validate_oauth1_settings(settings);
      }
    };

    Validator.prototype.validate_oauth2_settings = function(settings) {
      var property, propertyName, settingProperties, _i, _j, _len, _len1, _ref1, _ref2, _results;
      settingProperties = {};
      _ref1 = settings[1].value;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        property = _ref1[_i];
        this.trackRepeatedProperties(settingProperties, property[0].value, property[0], 'while validating security scheme', "setting with the same name already exists");
        switch (property[0].value) {
          case "authorizationUri":
            if (!util.isString(property[1])) {
              throw new exports.ValidationError('while validating security scheme', null, 'authorizationUri must be a URL', property[0].start_mark);
            }
            break;
          case "accessTokenUri":
            if (!util.isString(property[1])) {
              throw new exports.ValidationError('while validating security scheme', null, 'accessTokenUri must be a URL', property[0].start_mark);
            }
        }
      }
      _ref2 = ['accessTokenUri', 'authorizationUri'];
      _results = [];
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        propertyName = _ref2[_j];
        if (!(propertyName in settingProperties)) {
          throw new exports.ValidationError('while validating security scheme', null, "OAuth 2.0 settings must have " + propertyName + " property", settings[0].start_mark);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Validator.prototype.validate_oauth1_settings = function(settings) {
      var property, propertyName, settingProperties, _i, _j, _len, _len1, _ref1, _ref2, _results;
      settingProperties = {};
      _ref1 = settings[1].value;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        property = _ref1[_i];
        this.trackRepeatedProperties(settingProperties, property[0].value, property[0], 'while validating security scheme', "setting with the same name already exists");
        switch (property[0].value) {
          case "requestTokenUri":
            if (!util.isString(property[1])) {
              throw new exports.ValidationError('while validating security scheme', null, 'requestTokenUri must be a URL', property[0].start_mark);
            }
            break;
          case "authorizationUri":
            if (!util.isString(property[1])) {
              throw new exports.ValidationError('while validating security scheme', null, 'authorizationUri must be a URL', property[0].start_mark);
            }
            break;
          case "tokenCredentialsUri":
            if (!util.isString(property[1])) {
              throw new exports.ValidationError('while validating security scheme', null, 'tokenCredentialsUri must be a URL', property[0].start_mark);
            }
        }
      }
      _ref2 = ['requestTokenUri', 'authorizationUri', 'tokenCredentialsUri'];
      _results = [];
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        propertyName = _ref2[_j];
        if (!(propertyName in settingProperties)) {
          throw new exports.ValidationError('while validating security scheme', null, "OAuth 1.0 settings must have " + propertyName + " property", settings[0].start_mark);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Validator.prototype.validate_root_schemas = function(schemas) {
      var schema, schemaList, schemaName, _results;
      if (!util.isSequence(schemas)) {
        throw new exports.ValidationError('while validating schemas', null, 'schemas property must be an array', schemas.start_mark);
      }
      schemaList = this.get_all_schemas();
      _results = [];
      for (schemaName in schemaList) {
        schema = schemaList[schemaName];
        if (!(schema[1].tag && util.isString(schema[1]))) {
          throw new exports.ValidationError('while validating schemas', null, 'schema ' + schemaName + ' must be a string', schema[0].start_mark);
        }
        _results.push(this.validateSchema(schema[1]));
      }
      return _results;
    };

    Validator.prototype.validate_root = function(node) {
      if (!(node || util.isNull(node))) {
        throw new exports.ValidationError('while validating root', null, 'empty document', node != null ? node.start_mark : void 0);
      }
      if (!util.isMapping(node)) {
        throw new exports.ValidationError('while validating root', null, 'document must be a map', node.start_mark);
      }
    };

    Validator.prototype.validate_base_uri_parameters = function() {
      if (!this.baseUriParameters) {
        return;
      }
      if (!this.baseUri) {
        throw new exports.ValidationError('while validating uri parameters', null, 'uri parameters defined when there is no baseUri', this.baseUriParameters.start_mark);
      }
      if (!util.isNullableMapping(this.baseUriParameters)) {
        throw new exports.ValidationError('while validating uri parameters', null, 'base uri parameters must be a map', this.baseUriParameters.start_mark);
      }
      return this.validate_uri_parameters(this.baseUri, this.baseUriParameters, false, false, ["version"]);
    };

    Validator.prototype.validate_uri_parameters = function(uri, uriProperty, allowParameterKeys, skipParameterUseCheck, reservedNames) {
      var err, expressions, parameterName, template, uriParameter, uriParameters, _i, _len, _ref1, _ref2, _results;
      if (reservedNames == null) {
        reservedNames = [];
      }
      try {
        template = uritemplate.parse(uri);
      } catch (_error) {
        err = _error;
        throw new exports.ValidationError('while validating uri parameters', null, err != null ? (_ref1 = err.options) != null ? _ref1.message : void 0 : void 0, uriProperty.start_mark);
      }
      expressions = template.expressions.filter(function(expr) {
        return "templateText" in expr;
      }).map(function(expression) {
        return expression.templateText;
      });
      uriParameters = {};
      if (typeof uriProperty.value === "object") {
        _ref2 = uriProperty.value;
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          uriParameter = _ref2[_i];
          parameterName = this.canonicalizePropertyName(uriParameter[0].value, allowParameterKeys);
          this.trackRepeatedProperties(uriParameters, parameterName, uriProperty, 'while validating URI parameters', "URI parameter with the same name already exists");
          if (__indexOf.call(reservedNames, parameterName) >= 0) {
            throw new exports.ValidationError('while validating baseUri', null, uriParameter[0].value + ' parameter not allowed here', uriParameter[0].start_mark);
          }
          if (!(util.isNullableMapping(uriParameter[1], allowParameterKeys) || util.isNullableSequence(uriParameter[1], allowParameterKeys))) {
            throw new exports.ValidationError('while validating baseUri', null, 'URI parameter must be a map', uriParameter[0].start_mark);
          }
          if (!util.isNull(uriParameter[1])) {
            this.valid_common_parameter_properties(uriParameter[1], allowParameterKeys);
          }
          if (!(skipParameterUseCheck || this.isParameterKey(uriParameter) || __indexOf.call(expressions, parameterName) >= 0)) {
            throw new exports.ValidationError('while validating baseUri', null, uriParameter[0].value + ' uri parameter unused', uriParameter[0].start_mark);
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    };

    Validator.prototype.validate_types = function(typeProperty) {
      var type, type_entry, types, _i, _len, _results;
      types = typeProperty.value;
      if (!util.isSequence(typeProperty)) {
        throw new exports.ValidationError('while validating resource types', null, 'invalid resourceTypes definition, it must be an array', typeProperty.start_mark);
      }
      _results = [];
      for (_i = 0, _len = types.length; _i < _len; _i++) {
        type_entry = types[_i];
        if (!util.isMapping(type_entry)) {
          throw new exports.ValidationError('while validating resource types', null, 'invalid resourceType definition, it must be a map', type_entry.start_mark);
        }
        _results.push((function() {
          var _j, _len1, _ref1, _results1;
          _ref1 = type_entry.value;
          _results1 = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            type = _ref1[_j];
            if (this.isParameterKey(type)) {
              throw new exports.ValidationError('while validating resource types', null, 'parameter key cannot be used as a resource type name', type[0].start_mark);
            }
            if (!util.isMapping(type[1])) {
              throw new exports.ValidationError('while validating resource types', null, 'invalid resourceType definition, it must be a map', type[1].start_mark);
            }
            _results1.push(this.validate_resource(type, true, 'resource type'));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Validator.prototype.validate_traits = function(traitProperty) {
      var trait, trait_entry, _i, _len, _results;
      traits = traitProperty.value;
      if (!Array.isArray(traits)) {
        throw new exports.ValidationError('while validating traits', null, 'invalid traits definition, it must be an array', traitProperty.start_mark);
      }
      _results = [];
      for (_i = 0, _len = traits.length; _i < _len; _i++) {
        trait_entry = traits[_i];
        if (!Array.isArray(trait_entry.value)) {
          throw new exports.ValidationError('while validating traits', null, 'invalid traits definition, it must be an array', traitProperty.start_mark);
        }
        _results.push((function() {
          var _j, _len1, _ref1, _results1;
          _ref1 = trait_entry.value;
          _results1 = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            trait = _ref1[_j];
            if (this.isParameterKey(trait)) {
              throw new exports.ValidationError('while validating traits', null, 'parameter key cannot be used as a trait name', trait[0].start_mark);
            }
            if (!util.isMapping(trait[1])) {
              throw new exports.ValidationError('while validating traits', null, 'invalid trait definition, it must be a map', trait[1].start_mark);
            }
            _results1.push(this.valid_traits_properties(trait));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Validator.prototype.valid_traits_properties = function(node) {
      var invalid;
      if (!node[1].value) {
        return;
      }
      if (!util.isMapping(node[1])) {
        return;
      }
      invalid = node[1].value.filter(function(childNode) {
        return childNode[0].value === "is" || childNode[0].value === "type";
      });
      if (invalid.length > 0) {
        throw new exports.ValidationError('while validating trait properties', null, "property: '" + invalid[0][0].value + "' is invalid in a trait", invalid[0][0].start_mark);
      }
      return this.validate_method(node, true, 'trait');
    };

    Validator.prototype.canonicalizePropertyName = function(propertyName, mustRemoveQuestionMark) {
      if (mustRemoveQuestionMark && propertyName.slice(-1) === '?') {
        return propertyName.slice(0, -1);
      }
      return propertyName;
    };

    Validator.prototype.valid_common_parameter_properties = function(node, allowParameterKeys) {
      var parameter, _i, _len, _ref1, _results;
      if (!node.value) {
        return;
      }
      if (util.isSequence(node)) {
        if (node.value.length === 0) {
          throw new exports.ValidationError('while validating parameter properties', null, 'named parameter needs at least one type', node.start_mark);
        }
        if (!(node.value.length > 1)) {
          throw new exports.ValidationError('while validating parameter properties', null, 'single type for variably typed parameter', node.start_mark);
        }
        _ref1 = node.value;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          parameter = _ref1[_i];
          _results.push(this.validate_named_parameter(parameter, allowParameterKeys));
        }
        return _results;
      } else {
        return this.validate_named_parameter(node, allowParameterKeys);
      }
    };

    Validator.prototype.validate_named_parameter = function(node, allowParameterKeys) {
      var booleanValues, canonicalPropertyName, childNode, enumValues, parameterProperties, parameterType, propertyName, propertyValue, unusableProperty, valid, validTypes, _i, _j, _k, _len, _len1, _len2, _ref1, _ref2, _ref3, _results;
      parameterProperties = {};
      parameterType = "string";
      _ref1 = node.value;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        childNode = _ref1[_i];
        propertyName = childNode[0].value;
        propertyValue = childNode[1].value;
        this.trackRepeatedProperties(parameterProperties, this.canonicalizePropertyName(childNode[0].value, true), childNode[0], 'while validating parameter properties', "parameter property already used");
        booleanValues = ["true", "false"];
        if (allowParameterKeys) {
          if (this.isParameterKey(childNode) || this.isParameterValue(childNode)) {
            continue;
          }
        }
        canonicalPropertyName = this.canonicalizePropertyName(propertyName, allowParameterKeys);
        valid = true;
        switch (propertyName) {
          case "displayName":
            if (!util.isScalar(childNode[1])) {
              throw new exports.ValidationError('while validating parameter properties', null, 'the value of displayName must be a scalar', childNode[1].start_mark);
            }
            break;
          case "pattern":
            if (!util.isScalar(childNode[1])) {
              throw new exports.ValidationError('while validating parameter properties', null, 'the value of pattern must be a scalar', childNode[1].start_mark);
            }
            break;
          case "default":
            if (!util.isScalar(childNode[1])) {
              throw new exports.ValidationError('while validating parameter properties', null, 'the value of default must be a scalar', childNode[1].start_mark);
            }
            break;
          case "description":
            if (!util.isScalar(childNode[1])) {
              throw new exports.ValidationError('while validating parameter properties', null, 'the value of description must be a scalar', childNode[1].start_mark);
            }
            break;
          case "example":
            if (!util.isScalar(childNode[1])) {
              throw new exports.ValidationError('while validating parameter properties', null, 'the value of example must be a scalar', childNode[1].start_mark);
            }
            break;
          case "minLength":
            if (isNaN(propertyValue)) {
              throw new exports.ValidationError('while validating parameter properties', null, 'the value of minLength must be a number', childNode[1].start_mark);
            }
            break;
          case "maxLength":
            if (isNaN(propertyValue)) {
              throw new exports.ValidationError('while validating parameter properties', null, 'the value of maxLength must be a number', childNode[1].start_mark);
            }
            break;
          case "minimum":
            if (isNaN(propertyValue)) {
              throw new exports.ValidationError('while validating parameter properties', null, 'the value of minimum must be a number', childNode[1].start_mark);
            }
            break;
          case "maximum":
            if (isNaN(propertyValue)) {
              throw new exports.ValidationError('while validating parameter properties', null, 'the value of maximum must be a number', childNode[1].start_mark);
            }
            break;
          case "type":
            parameterType = propertyValue;
            validTypes = ['string', 'number', 'integer', 'date', 'boolean', 'file'];
            if (__indexOf.call(validTypes, propertyValue) < 0) {
              throw new exports.ValidationError('while validating parameter properties', null, 'type can be either of: string, number, integer, file, date or boolean ', childNode[1].start_mark);
            }
            break;
          case "required":
            if (__indexOf.call(booleanValues, propertyValue) < 0) {
              throw new exports.ValidationError('while validating parameter properties', null, 'required can be any either true or false', childNode[1].start_mark);
            }
            break;
          case "repeat":
            if (__indexOf.call(booleanValues, propertyValue) < 0) {
              throw new exports.ValidationError('while validating parameter properties', null, 'repeat can be any either true or false', childNode[1].start_mark);
            }
            break;
          default:
            valid = false;
        }
        switch (canonicalPropertyName) {
          case "enum":
            if (!util.isNullableSequence(childNode[1])) {
              throw new exports.ValidationError('while validating parameter properties', null, 'the value of enum must be an array', childNode[1].start_mark);
            }
            if (!childNode[1].value.length) {
              throw new exports.ValidationError('while validating parameter properties', null, 'enum is empty', childNode[1].start_mark);
            }
            enumValues = this.get_list_values(childNode[1].value);
            if (this.hasDuplicates(enumValues)) {
              throw new exports.ValidationError('while validating parameter properties', null, 'enum contains duplicated values', childNode[1].start_mark);
            }
            break;
          default:
            if (!valid) {
              throw new exports.ValidationError('while validating parameter properties', null, "unknown property " + propertyName, childNode[0].start_mark);
            }
        }
      }
      if (parameterType !== "string") {
        _ref2 = ['enum', 'pattern', 'minLength', 'maxLength'];
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          unusableProperty = _ref2[_j];
          if (unusableProperty in parameterProperties) {
            throw new exports.ValidationError('while validating parameter properties', null, "property " + unusableProperty + " can only be used if type is 'string'", parameterProperties[unusableProperty].start_mark);
          }
        }
      }
      if (!(parameterType === "number" || parameterType === "integer")) {
        _ref3 = ['minimum', 'maximum'];
        _results = [];
        for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
          unusableProperty = _ref3[_k];
          if (unusableProperty in parameterProperties) {
            throw new exports.ValidationError('while validating parameter properties', null, "property " + unusableProperty + " can only be used if type is 'number' or 'integer'", parameterProperties[unusableProperty].start_mark);
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    };

    Validator.prototype.get_list_values = function(node) {
      var _this = this;
      return node.map(function(item) {
        return item.value;
      });
    };

    Validator.prototype.validate_root_properties = function(node) {
      var checkVersion, property, rootProperties, _i, _len, _ref1;
      checkVersion = false;
      rootProperties = {};
      if (node != null ? node.value : void 0) {
        _ref1 = node.value;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          property = _ref1[_i];
          if (property[0].value.match(/^\//)) {
            this.trackRepeatedProperties(rootProperties, this.canonicalizePropertyName(property[0].value, true), property[0], 'while validating root properties', "resource already declared");
          } else {
            this.trackRepeatedProperties(rootProperties, property[0].value, property[0], 'while validating root properties', 'root property already used');
          }
          switch (property[0].value) {
            case 'title':
              if (!util.isScalar(property[1])) {
                throw new exports.ValidationError('while validating root properties', null, 'title must be a string', property[0].start_mark);
              }
              break;
            case 'baseUri':
              if (!util.isScalar(property[1])) {
                throw new exports.ValidationError('while validating root properties', null, 'baseUri must be a string', property[0].start_mark);
              }
              this.baseUri = property[1].value;
              checkVersion = this.validate_base_uri(property[1]);
              break;
            case 'securitySchemes':
              this.validate_security_schemes(property[1]);
              break;
            case 'schemas':
              this.validate_root_schemas(property[1]);
              break;
            case 'version':
              if (!util.isScalar(property[1])) {
                throw new exports.ValidationError('while validating root properties', null, 'version must be a string', property[0].start_mark);
              }
              if (!util.isNull(property[1])) {
                property[1].tag = 'tag:yaml.org,2002:str';
              }
              break;
            case 'traits':
              this.validate_traits(property[1]);
              break;
            case 'documentation':
              if (!util.isSequence(property[1])) {
                throw new exports.ValidationError('while validating root properties', null, 'documentation must be an array', property[0].start_mark);
              }
              this.validate_documentation(property[1]);
              break;
            case 'mediaType':
              if (!util.isString(property[1])) {
                throw new exports.ValidationError('while validating root properties', null, 'mediaType must be a scalar', property[0].start_mark);
              }
              break;
            case 'baseUriParameters':
              this.baseUriParameters = property[1];
              util.isNoop(property[1]);
              break;
            case 'resourceTypes':
              this.validate_types(property[1]);
              break;
            case 'securedBy':
              this.validate_secured_by(property);
              break;
            case 'protocols':
              this.validate_protocols_property(property);
              break;
            default:
              if (property[0].value.match(/^\//)) {
                this.validate_resource(property);
              } else {
                throw new exports.ValidationError('while validating root properties', null, "unknown property " + property[0].value, property[0].start_mark);
              }
          }
        }
      }
      if (!('title' in rootProperties)) {
        throw new exports.ValidationError('while validating root properties', null, 'missing title', node.start_mark);
      }
      if (checkVersion && !('version' in rootProperties)) {
        throw new exports.ValidationError('while validating version', null, 'missing version', node.start_mark);
      }
    };

    Validator.prototype.validate_documentation = function(documentation_property) {
      var docSection, _i, _len, _ref1, _results;
      if (!documentation_property.value.length) {
        throw new exports.ValidationError('while validating documentation section', null, 'there must be at least one document in the documentation section', documentation_property.start_mark);
      }
      _ref1 = documentation_property.value;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        docSection = _ref1[_i];
        _results.push(this.validate_doc_section(docSection));
      }
      return _results;
    };

    Validator.prototype.validate_doc_section = function(docSection) {
      var docProperties, property, _i, _len, _ref1;
      if (!util.isMapping(docSection)) {
        throw new exports.ValidationError('while validating documentation section', null, 'each documentation section must be a map', docSection.start_mark);
      }
      docProperties = {};
      _ref1 = docSection.value;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        property = _ref1[_i];
        this.trackRepeatedProperties(docProperties, property[0].value, property[0], 'while validating documentation section', "property already used");
        switch (property[0].value) {
          case "title":
            if (!(util.isScalar(property[1]) && !util.isNull(property[1]))) {
              throw new exports.ValidationError('while validating documentation section', null, 'title must be a string', property[0].start_mark);
            }
            break;
          case "content":
            if (!(util.isScalar(property[1]) && !util.isNull(property[1]))) {
              throw new exports.ValidationError('while validating documentation section', null, 'content must be a string', property[0].start_mark);
            }
            break;
          default:
            throw new exports.ValidationError('while validating root properties', null, 'unknown property ' + property[0].value, property[0].start_mark);
        }
      }
      if (!("content" in docProperties)) {
        throw new exports.ValidationError('while validating documentation section', null, 'a documentation entry must have content property', docSection.start_mark);
      }
      if (!("title" in docProperties)) {
        throw new exports.ValidationError('while validating documentation section', null, 'a documentation entry must have title property', docSection.start_mark);
      }
    };

    Validator.prototype.child_resources = function(node) {
      if (node && util.isMapping(node)) {
        return node.value.filter(function(childNode) {
          return childNode[0].value.match(/^\//);
        });
      }
      return [];
    };

    Validator.prototype.validate_resource = function(resource, allowParameterKeys, context) {
      var canonicalKey, err, key, property, resourceProperties, template, valid, _i, _len, _ref1, _ref2, _results;
      if (allowParameterKeys == null) {
        allowParameterKeys = false;
      }
      if (context == null) {
        context = "resource";
      }
      if (!(resource[1] && util.isNullableMapping(resource[1]))) {
        throw new exports.ValidationError('while validating resources', null, 'resource is not a map', resource[1].start_mark);
      }
      if (resource[0].value) {
        try {
          template = uritemplate.parse(resource[0].value);
        } catch (_error) {
          err = _error;
          throw new exports.ValidationError('while validating resource', null, "Resource name is invalid: " + (err != null ? (_ref1 = err.options) != null ? _ref1.message : void 0 : void 0), resource[0].start_mark);
        }
      }
      if (util.isNull(resource[1])) {
        return;
      }
      if (resource[1].value) {
        resourceProperties = {};
        _ref2 = resource[1].value;
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          property = _ref2[_i];
          if (property[0].value.match(/^\//)) {
            this.trackRepeatedProperties(resourceProperties, this.canonicalizePropertyName(property[0].value, true), property[0], 'while validating resource', "resource already declared");
          } else if (this.isHttpMethod(property[0].value, allowParameterKeys)) {
            this.trackRepeatedProperties(resourceProperties, this.canonicalizePropertyName(property[0].value, true), property[0], 'while validating resource', "method already declared");
          } else {
            this.trackRepeatedProperties(resourceProperties, this.canonicalizePropertyName(property[0].value, true), property[0], 'while validating resource', "property already used");
          }
          if (!this.validate_common_properties(property, allowParameterKeys)) {
            if (property[0].value.match(/^\//)) {
              if (allowParameterKeys) {
                throw new exports.ValidationError('while validating trait properties', null, 'resource type cannot define child resources', property[0].start_mark);
              }
              _results.push(this.validate_resource(property, allowParameterKeys));
            } else if (this.isHttpMethod(property[0].value, allowParameterKeys)) {
              _results.push(this.validate_method(property, allowParameterKeys, 'method'));
            } else {
              key = property[0].value;
              canonicalKey = this.canonicalizePropertyName(key, allowParameterKeys);
              valid = true;
              switch (canonicalKey) {
                case "uriParameters":
                  if (!util.isNullableMapping(property[1])) {
                    throw new exports.ValidationError('while validating uri parameters', null, 'uri parameters must be a map', property[0].start_mark);
                  }
                  this.validate_uri_parameters(resource[0].value, property[1], allowParameterKeys, allowParameterKeys);
                  break;
                case "baseUriParameters":
                  if (!this.baseUri) {
                    throw new exports.ValidationError('while validating uri parameters', null, 'base uri parameters defined when there is no baseUri', property[0].start_mark);
                  }
                  if (!util.isNullableMapping(property[1])) {
                    throw new exports.ValidationError('while validating uri parameters', null, 'base uri parameters must be a map', property[0].start_mark);
                  }
                  this.validate_uri_parameters(this.baseUri, property[1], allowParameterKeys);
                  break;
                default:
                  valid = false;
              }
              switch (key) {
                case "type":
                  _results.push(this.validate_type_property(property, allowParameterKeys));
                  break;
                case "usage":
                  if (!allowParameterKeys) {
                    throw new exports.ValidationError('while validating resources', null, "property: '" + property[0].value + "' is invalid in a resource", property[0].start_mark);
                  } else {
                    _results.push(void 0);
                  }
                  break;
                case "securedBy":
                  _results.push(this.validate_secured_by(property));
                  break;
                default:
                  if (!valid) {
                    throw new exports.ValidationError('while validating resources', null, "property: '" + property[0].value + ("' is invalid in a " + context), property[0].start_mark);
                  } else {
                    _results.push(void 0);
                  }
              }
            }
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    };

    Validator.prototype.validate_secured_by = function(property) {
      var secScheme, secSchemes, securitySchemeName, _i, _len, _ref1, _results;
      if (!util.isSequence(property[1])) {
        throw new exports.ValidationError('while validating securityScheme', null, "property 'securedBy' must be an array", property[0].start_mark);
      }
      secSchemes = this.get_list_values(property[1].value);
      if (this.hasDuplicates(secSchemes)) {
        throw new exports.ValidationError('while validating securityScheme consumption', null, 'securitySchemes can only be referenced once in a securedBy property', property[0].start_mark);
      }
      _ref1 = property[1].value;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        secScheme = _ref1[_i];
        if (util.isSequence(secScheme)) {
          throw new exports.ValidationError('while validating securityScheme consumption', null, 'securityScheme reference cannot be an array', secScheme.start_mark);
        }
        if (!util.isNull(secScheme)) {
          securitySchemeName = this.key_or_value(secScheme);
          if (!this.get_security_scheme(securitySchemeName)) {
            throw new exports.ValidationError('while validating securityScheme consumption', null, 'there is no securityScheme named ' + securitySchemeName, secScheme.start_mark);
          } else {
            _results.push(void 0);
          }
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Validator.prototype.validate_protocols_property = function(property) {
      var protocol, _i, _len, _ref1, _ref2, _results;
      if (!util.isSequence(property[1])) {
        throw new exports.ValidationError('while validating protocols', null, 'property must be an array', property[0].start_mark);
      }
      _ref1 = property[1].value;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        protocol = _ref1[_i];
        if (!util.isString(protocol)) {
          throw new exports.ValidationError('while validating protocols', null, 'value must be a string', protocol.start_mark);
        }
        if ((_ref2 = protocol.value) !== 'HTTP' && _ref2 !== 'HTTPS') {
          throw new exports.ValidationError('while validating protocols', null, 'only HTTP and HTTPS values are allowed', protocol.start_mark);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Validator.prototype.validate_type_property = function(property) {
      var parameter, typeName, _i, _len, _ref1, _results;
      if (!(util.isMapping(property[1]) || util.isString(property[1]))) {
        throw new exports.ValidationError('while validating resource types', null, "property 'type' must be a string or a map", property[0].start_mark);
      }
      if (util.isMapping(property[1])) {
        if (property[1].value.length > 1) {
          throw new exports.ValidationError('while validating resource types', null, 'a resource or resourceType can inherit from a single resourceType', property[0].start_mark);
        }
      }
      typeName = this.key_or_value(property[1]);
      if (!(typeName != null ? typeName.trim() : void 0)) {
        throw new exports.ValidationError('while validating resource type consumption', null, 'resource type name must be provided', property[1].start_mark);
      }
      if (!(this.isParameterKeyValue(typeName) || this.get_type(typeName))) {
        throw new exports.ValidationError('while validating resource type consumption', null, "there is no resource type named " + typeName, property[1].start_mark);
      }
      if (util.isMapping(property[1])) {
        _ref1 = property[1].value;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          parameter = _ref1[_i];
          if (!(util.isNull(parameter[1]) || util.isMapping(parameter[1]))) {
            throw new exports.ValidationError('while validating resource consumption', null, 'resource type parameters must be in a map', parameter[1].start_mark);
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    };

    Validator.prototype.validate_method = function(method, allowParameterKeys, context) {
      var canonicalKey, key, methodProperties, property, valid, _i, _len, _ref1, _results;
      if (context == null) {
        context = 'method';
      }
      if (util.isNull(method[1])) {
        return;
      }
      if (!util.isMapping(method[1])) {
        throw new exports.ValidationError('while validating methods', null, "method must be a map", method[0].start_mark);
      }
      methodProperties = {};
      _ref1 = method[1].value;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        property = _ref1[_i];
        this.trackRepeatedProperties(methodProperties, this.canonicalizePropertyName(property[0].value, true), property[0], 'while validating method', "property already used");
        if (this.validate_common_properties(property, allowParameterKeys, context)) {
          continue;
        }
        key = property[0].value;
        canonicalKey = this.canonicalizePropertyName(key, allowParameterKeys);
        valid = true;
        switch (canonicalKey) {
          case 'headers':
            this.validate_headers(property, allowParameterKeys);
            break;
          case 'queryParameters':
            this.validate_query_params(property, allowParameterKeys);
            break;
          case 'body':
            this.validate_body(property, allowParameterKeys, null, false);
            break;
          case 'responses':
            this.validate_responses(property, allowParameterKeys);
            break;
          case 'baseUriParameters':
            if (!this.baseUri) {
              throw new exports.ValidationError('while validating uri parameters', null, 'base uri parameters defined when there is no baseUri', property[0].start_mark);
            }
            if (!util.isNullableMapping(property[1])) {
              throw new exports.ValidationError('while validating uri parameters', null, 'base uri parameters must be a map', property[0].start_mark);
            }
            this.validate_uri_parameters(this.baseUri, property[1], allowParameterKeys);
            break;
          case 'protocols':
            this.validate_protocols_property(property);
            break;
          default:
            valid = false;
        }
        switch (key) {
          case 'securedBy':
            _results.push(this.validate_secured_by(property));
            break;
          case 'usage':
            if (!(allowParameterKeys && context === 'trait')) {
              throw new exports.ValidationError('while validating resources', null, "property: 'usage' is invalid in a " + context, property[0].start_mark);
            } else {
              _results.push(void 0);
            }
            break;
          default:
            if (!valid) {
              throw new exports.ValidationError('while validating resources', null, "property: '" + property[0].value + "' is invalid in a " + context, property[0].start_mark);
            } else {
              _results.push(void 0);
            }
        }
      }
      return _results;
    };

    Validator.prototype.validate_responses = function(responses, allowParameterKeys) {
      var response, responseValues, _i, _len, _ref1, _results;
      if (util.isNull(responses[1])) {
        return;
      }
      if (!util.isMapping(responses[1])) {
        throw new exports.ValidationError('while validating responses', null, "property: 'responses' must be a map", responses[0].start_mark);
      }
      responseValues = {};
      _ref1 = responses[1].value;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        response = _ref1[_i];
        if (!util.isNullableMapping(response[1])) {
          throw new exports.ValidationError('while validating responses', null, 'each response must be a map', response[1].start_mark);
        }
        this.trackRepeatedProperties(responseValues, this.canonicalizePropertyName(response[0].value, true), response[0], 'while validating responses', "response code already used");
        _results.push(this.validate_response(response, allowParameterKeys));
      }
      return _results;
    };

    Validator.prototype.validate_query_params = function(property, allowParameterKeys) {
      var param, queryParameters, _i, _len, _ref1, _results;
      if (util.isNull(property[1])) {
        return;
      }
      if (!util.isMapping(property[1])) {
        throw new exports.ValidationError('while validating query parameters', null, "property: 'queryParameters' must be a map", property[0].start_mark);
      }
      queryParameters = {};
      _ref1 = property[1].value;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        param = _ref1[_i];
        if (!(util.isNullableMapping(param[1]) || util.isNullableSequence(param[1]))) {
          throw new exports.ValidationError('while validating query parameters', null, "each query parameter must be a map", param[1].start_mark);
        }
        this.trackRepeatedProperties(queryParameters, this.canonicalizePropertyName(param[0].value, true), param[0], 'while validating query parameter', "parameter name already used");
        _results.push(this.valid_common_parameter_properties(param[1], allowParameterKeys));
      }
      return _results;
    };

    Validator.prototype.validate_form_params = function(property, allowParameterKeys) {
      var formParameters, param, _i, _len, _ref1, _results;
      if (util.isNull(property[1])) {
        return;
      }
      if (!util.isMapping(property[1])) {
        throw new exports.ValidationError('while validating query parameters', null, "property: 'formParameters' must be a map", property[0].start_mark);
      }
      formParameters = {};
      _ref1 = property[1].value;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        param = _ref1[_i];
        if (!(util.isNullableMapping(param[1]) || util.isNullableSequence(param[1]))) {
          throw new exports.ValidationError('while validating query parameters', null, 'each form parameter must be a map', param[1].start_mark);
        }
        this.trackRepeatedProperties(formParameters, this.canonicalizePropertyName(param[0].value, true), param[0], 'while validating form parameter', "parameter name already used");
        _results.push(this.valid_common_parameter_properties(param[1], allowParameterKeys));
      }
      return _results;
    };

    Validator.prototype.validate_headers = function(property, allowParameterKeys) {
      var headerNames, param, _i, _len, _ref1, _results;
      if (util.isNull(property[1])) {
        return;
      }
      if (!util.isMapping(property[1])) {
        throw new exports.ValidationError('while validating headers', null, "property: 'headers' must be a map", property[0].start_mark);
      }
      headerNames = {};
      _ref1 = property[1].value;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        param = _ref1[_i];
        if (!(util.isNullableMapping(param[1]) || util.isNullableSequence(param[1]))) {
          throw new exports.ValidationError('while validating query parameters', null, "each header must be a map", param[1].start_mark);
        }
        this.trackRepeatedProperties(headerNames, this.canonicalizePropertyName(param[0].value, true), param[0], 'while validating headers', "header name already used");
        _results.push(this.valid_common_parameter_properties(param[1], allowParameterKeys));
      }
      return _results;
    };

    Validator.prototype.validate_response = function(response, allowParameterKeys) {
      var canonicalKey, property, responseCode, responseProperties, valid, _i, _j, _len, _len1, _ref1, _ref2, _results;
      if (util.isSequence(response[0])) {
        if (!response[0].value.length) {
          throw new exports.ValidationError('while validating responses', null, 'there must be at least one response code', response[0].start_mark);
        }
        _ref1 = response[0].value;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          responseCode = _ref1[_i];
          if (!(this.isParameterKey(responseCode) || util.isInteger(responseCode) || !isNaN(this.canonicalizePropertyName(responseCode, allowParameterKeys)))) {
            throw new exports.ValidationError('while validating responses', null, "each response key must be an integer", responseCode.start_mark);
          }
        }
      } else if (!(this.isParameterKey(response) || util.isInteger(response[0]) || !isNaN(this.canonicalizePropertyName(response[0].value, allowParameterKeys)))) {
        throw new exports.ValidationError('while validating responses', null, "each response key must be an integer", response[0].start_mark);
      }
      if (!util.isNullableMapping(response[1])) {
        throw new exports.ValidationError('while validating responses', null, "each response property must be a map", response[0].start_mark);
      }
      if (util.isMapping(response[1])) {
        responseProperties = {};
        _ref2 = response[1].value;
        _results = [];
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          property = _ref2[_j];
          canonicalKey = this.canonicalizePropertyName(property[0].value, allowParameterKeys);
          this.trackRepeatedProperties(responseProperties, canonicalKey, property[0], 'while validating responses', "property already used");
          valid = true;
          if (!this.isParameterKey(property)) {
            switch (property[0].value) {
              case "description":
                if (!util.isScalar(property[1])) {
                  throw new exports.ValidationError('while validating responses', null, 'property description must be a string', response[0].start_mark);
                }
                break;
              default:
                valid = false;
            }
            switch (canonicalKey) {
              case "body":
                _results.push(this.validate_body(property, allowParameterKeys, null, true));
                break;
              case "headers":
                if (!util.isNullableMapping(property[1])) {
                  throw new exports.ValidationError('while validating resources', null, "property 'headers' must be a map", property[0].start_mark);
                }
                _results.push(this.validate_headers(property));
                break;
              default:
                if (!valid) {
                  throw new exports.ValidationError('while validating response', null, "property: '" + property[0].value + "' is invalid in a response", property[0].start_mark);
                } else {
                  _results.push(void 0);
                }
            }
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    };

    Validator.prototype.isHttpMethod = function(value, allowParameterKeys) {
      var _ref1;
      if (allowParameterKeys == null) {
        allowParameterKeys = false;
      }
      if (value) {
        value = this.canonicalizePropertyName(value, allowParameterKeys);
        return (_ref1 = value.toLowerCase()) === 'options' || _ref1 === 'get' || _ref1 === 'head' || _ref1 === 'post' || _ref1 === 'put' || _ref1 === 'delete' || _ref1 === 'trace' || _ref1 === 'connect' || _ref1 === 'patch';
      }
      return false;
    };

    Validator.prototype.isParameterValue = function(property) {
      return this.isParameterKey(property, false);
    };

    Validator.prototype.isParameterKey = function(property, checkKey) {
      var offset;
      if (checkKey == null) {
        checkKey = true;
      }
      offset = checkKey ? 0 : 1;
      if (!(checkKey || util.isScalar(property[1]))) {
        return false;
      }
      if (this.isParameterKeyValue(property[offset].value)) {
        return true;
      } else if (property[offset].value.match(/<<\s*([^\|\s>]+)\s*\|.*\s*>>/g)) {
        throw new exports.ValidationError('while validating parameter', null, "unknown function applied to property name", property[0].start_mark);
      }
      return false;
    };

    Validator.prototype.isParameterKeyValue = function(value) {
      if (value.match(/<<\s*([^\|\s>]+)\s*>>/g) || value.match(/<<\s*([^\|\s>]+)\s*(\|\s*\!\s*(singularize|pluralize))?\s*>>/g)) {
        return true;
      }
      return false;
    };

    Validator.prototype.validate_body = function(property, allowParameterKeys, bodyMode, isResponseBody) {
      var bodyProperties, bodyProperty, canonicalProperty, implicitMode, key, start_mark, valid, _i, _len, _ref1;
      if (bodyMode == null) {
        bodyMode = null;
      }
      if (util.isNull(property[1])) {
        return;
      }
      if (!util.isMapping(property[1])) {
        throw new exports.ValidationError('while validating body', null, "property: body specification must be a map", property[0].start_mark);
      }
      implicitMode = ["implicit", "forcedImplicit"];
      bodyProperties = {};
      _ref1 = property[1].value;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        bodyProperty = _ref1[_i];
        this.trackRepeatedProperties(bodyProperties, this.canonicalizePropertyName(bodyProperty[0].value, true), bodyProperty[0], 'while validating body', "property already used");
        if (this.isParameterKey(bodyProperty)) {
          if (!allowParameterKeys) {
            throw new exports.ValidationError('while validating body', null, "property '" + bodyProperty[0].value + "' is invalid in a resource", bodyProperty[0].start_mark);
          }
        } else if (bodyProperty[0].value.match(/^[^\/]+\/[^\/]+$/)) {
          if (bodyMode && bodyMode !== "explicit") {
            throw new exports.ValidationError('while validating body', null, "not compatible with implicit default Media Type", bodyProperty[0].start_mark);
          }
          bodyMode = "explicit";
          this.validate_body(bodyProperty, allowParameterKeys, "forcedImplicit", isResponseBody);
        } else {
          key = bodyProperty[0].value;
          canonicalProperty = this.canonicalizePropertyName(key, allowParameterKeys);
          valid = true;
          switch (canonicalProperty) {
            case "formParameters":
              if (bodyMode && __indexOf.call(implicitMode, bodyMode) < 0) {
                throw new exports.ValidationError('while validating body', null, "not compatible with explicit Media Type", bodyProperty[0].start_mark);
              }
              if (bodyMode == null) {
                bodyMode = "implicit";
              }
              this.validate_form_params(bodyProperty, allowParameterKeys);
              break;
            default:
              valid = false;
          }
          switch (key) {
            case "example":
              if (bodyMode && __indexOf.call(implicitMode, bodyMode) < 0) {
                throw new exports.ValidationError('while validating body', null, "not compatible with explicit Media Type", bodyProperty[0].start_mark);
              }
              if (bodyMode == null) {
                bodyMode = "implicit";
              }
              if (!util.isScalar(bodyProperty[1])) {
                throw new exports.ValidationError('while validating body', null, "example must be a string", bodyProperty[0].start_mark);
              }
              break;
            case "schema":
              if (bodyMode && __indexOf.call(implicitMode, bodyMode) < 0) {
                throw new exports.ValidationError('while validating body', null, "not compatible with explicit Media Type", bodyProperty[0].start_mark);
              }
              if (bodyMode == null) {
                bodyMode = "implicit";
              }
              if (!util.isScalar(bodyProperty[1])) {
                throw new exports.ValidationError('while validating body', null, "schema must be a string", bodyProperty[0].start_mark);
              }
              this.validateSchema(bodyProperty[1]);
              break;
            default:
              if (!valid) {
                throw new exports.ValidationError('while validating body', null, "property: '" + bodyProperty[0].value + "' is invalid in a body", bodyProperty[0].start_mark);
              }
          }
        }
      }
      if ("formParameters" in bodyProperties) {
        start_mark = bodyProperties.formParameters.start_mark;
        if (isResponseBody) {
          throw new exports.ValidationError('while validating body', null, "formParameters cannot be used to describe response bodies", start_mark);
        }
        if ("schema" in bodyProperties || "example" in bodyProperties) {
          throw new exports.ValidationError('while validating body', null, "formParameters cannot be used together with the example or schema properties", start_mark);
        }
      }
      if (bodyMode === "implicit") {
        if (!this.get_media_type()) {
          throw new exports.ValidationError('while validating body', null, "body tries to use default Media Type, but mediaType is null", property[0].start_mark);
        }
      }
    };

    Validator.prototype.validateSchema = function(property) {
      var error, lint, mark, schema;
      if (this.isXmlSchema(property.value)) {
        return void 0;
      } else if (this.isJsonSchema(property.value)) {
        lint = jsonlint(property.value);
        if (lint.error) {
          mark = this.create_mark(property.start_mark.line + lint.line, 0);
          if (property.end_mark.line === mark.line && property.end_mark.column === 0) {
            mark.line--;
          }
          throw new exports.ValidationError('while validating body', null, "schema is not valid JSON error: '" + lint.error + "'", mark);
        }
        try {
          return schema = JSON.parse(property.value);
        } catch (_error) {
          error = _error;
          throw new exports.ValidationError('while validating body', null, "schema is not valid JSON error: '" + error + "'", property.start_mark);
        }
      }
    };

    Validator.prototype.isJsonSchema = function(string) {
      return string != null ? string.match(/^\s*\{/) : void 0;
    };

    Validator.prototype.isXmlSchema = function(string) {
      return string != null ? string.match(/^\s*(<\?xml[^>]+>)?[\s\n]*<xs:schema/) : void 0;
    };

    Validator.prototype.validate_common_properties = function(property, allowParameterKeys, context) {
      var use, _i, _len, _ref1;
      if (this.isParameterKey(property)) {
        if (!allowParameterKeys) {
          throw new exports.ValidationError('while validating resources', null, "property '" + property[0].value + "' is invalid in a resource", property[0].start_mark);
        }
        return true;
      } else {
        switch (property[0].value) {
          case "displayName":
            if (context === 'method') {
              return false;
            }
            if (!util.isScalar(property[1])) {
              throw new exports.ValidationError('while validating resources', null, "property 'displayName' must be a string", property[0].start_mark);
            }
            return true;
          case "description":
            if (!util.isScalar(property[1])) {
              throw new exports.ValidationError('while validating resources', null, "property 'description' must be a string", property[0].start_mark);
            }
            return true;
          case "is":
            if (!util.isSequence(property[1])) {
              throw new exports.ValidationError('while validating resources', null, "property 'is' must be an array", property[0].start_mark);
            }
            _ref1 = property[1].value;
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              use = _ref1[_i];
              this.validate_trait_use(use);
            }
            return true;
        }
      }
      return false;
    };

    Validator.prototype.validate_trait_use = function(node) {
      var parameter, traitName, traitValue, _i, _len, _ref1, _results;
      if (!(util.isScalar(node) || util.isMapping(node))) {
        throw new exports.ValidationError('while validating trait consumption', null, 'trait must be a string or a map', node.start_mark);
      }
      traitName = this.key_or_value(node);
      if (!(traitName != null ? traitName.trim() : void 0)) {
        throw new exports.ValidationError('while validating trait consumption', null, 'trait name must be provided', node.start_mark);
      }
      if (!(this.isParameterKeyValue(traitName) || this.get_trait(traitName))) {
        throw new exports.ValidationError('while validating trait consumption', null, "there is no trait named " + traitName, node.start_mark);
      }
      if (util.isScalar(node)) {
        return;
      }
      traitValue = node.value[0][1];
      if (!(util.isNull(traitValue) || util.isMapping(traitValue))) {
        throw new exports.ValidationError('while validating trait consumption', null, 'trait must be a map', traitValue.start_mark);
      }
      if (util.isNull(traitValue)) {
        return;
      }
      _ref1 = traitValue.value;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        parameter = _ref1[_i];
        if (!util.isScalar(parameter[1])) {
          throw new exports.ValidationError('while validating trait consumption', null, 'parameter value must be a scalar', parameter[1].start_mark);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Validator.prototype.child_methods = function(node) {
      var _this = this;
      if (!(node && util.isMapping(node))) {
        return [];
      }
      return node.value.filter(function(childNode) {
        return _this.isHttpMethod(childNode[0].value);
      });
    };

    Validator.prototype.has_property = function(node, property) {
      if (node && util.isMapping(node)) {
        return node.value.some(function(childNode) {
          return childNode[0].value && typeof childNode[0].value !== "object" && childNode[0].value === property;
        });
      }
      return false;
    };

    Validator.prototype.property_value = function(node, property) {
      var filteredNodes;
      filteredNodes = node.value.filter(function(childNode) {
        return typeof childNode[0].value !== "object" && childNode[0].value === property;
      });
      if (filteredNodes.length) {
        return filteredNodes[0][1].value;
      }
    };

    Validator.prototype.get_property = function(node, property) {
      var filteredNodes,
        _this = this;
      if (node && util.isMapping(node)) {
        filteredNodes = node.value.filter(function(childNode) {
          return util.isString(childNode[0]) && childNode[0].value === property;
        });
        if (filteredNodes.length > 0) {
          if (filteredNodes[0].length > 0) {
            return filteredNodes[0][1];
          }
        }
      }
      return [];
    };

    Validator.prototype.get_properties = function(node, property) {
      var prop, properties, _i, _len, _ref1;
      properties = [];
      if (node && util.isMapping(node)) {
        _ref1 = node.value;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          prop = _ref1[_i];
          if (util.isString(prop[0]) && prop[0].value === property) {
            properties.push(prop);
          } else {
            properties = properties.concat(this.get_properties(prop[1], property));
          }
        }
      }
      return properties;
    };

    Validator.prototype.valid_absolute_uris = function(node) {
      var repeatedUri, uris;
      uris = this.get_absolute_uris(node);
      if (repeatedUri = this.hasDuplicatesUris(uris)) {
        throw new exports.ValidationError('while validating trait consumption', null, "two resources share same URI " + repeatedUri.uri, repeatedUri.mark);
      }
    };

    Validator.prototype.get_absolute_uris = function(node, parentPath) {
      var childResource, child_resources, response, uri, _i, _len;
      response = [];
      if (!util.isNullableMapping(node)) {
        throw new exports.ValidationError('while validating resources', null, 'resource is not a map', node.start_mark);
      }
      child_resources = this.child_resources(node);
      for (_i = 0, _len = child_resources.length; _i < _len; _i++) {
        childResource = child_resources[_i];
        if (parentPath != null) {
          uri = parentPath + childResource[0].value;
        } else {
          uri = childResource[0].value;
        }
        response.push({
          uri: uri,
          mark: childResource[0].start_mark
        });
        response = response.concat(this.get_absolute_uris(childResource[1], uri));
      }
      return response;
    };

    Validator.prototype.key_or_value = function(node) {
      var possibleKeyName, _ref1, _ref2, _ref3;
      if (node instanceof nodes.ScalarNode) {
        return node.value;
      }
      if (node instanceof nodes.MappingNode) {
        possibleKeyName = node != null ? (_ref1 = node.value) != null ? (_ref2 = _ref1[0]) != null ? (_ref3 = _ref2[0]) != null ? _ref3.value : void 0 : void 0 : void 0 : void 0;
        if (possibleKeyName) {
          return possibleKeyName;
        }
      }
      return null;
    };

    Validator.prototype.value_or_undefined = function(node) {
      if (node instanceof nodes.MappingNode) {
        return node.value;
      }
      return void 0;
    };

    Validator.prototype.validate_base_uri = function(baseUriNode) {
      var baseUri, err, expressions, protocol, template, _ref1, _ref2;
      baseUri = (_ref1 = baseUriNode.value) != null ? _ref1.trim() : void 0;
      if (!baseUri) {
        throw new exports.ValidationError('while validating baseUri', null, 'baseUri must have a value', baseUriNode.start_mark);
      }
      protocol = ((url.parse(baseUri)).protocol || 'http:').slice(0, -1).toUpperCase();
      if (protocol !== 'HTTP' && protocol !== 'HTTPS') {
        throw new exports.ValidationError('while validating baseUri', null, 'baseUri protocol must be either HTTP or HTTPS', baseUriNode.start_mark);
      }
      try {
        template = uritemplate.parse(baseUri);
      } catch (_error) {
        err = _error;
        throw new exports.ValidationError('while validating baseUri', null, err != null ? (_ref2 = err.options) != null ? _ref2.message : void 0 : void 0, baseUriNode.start_mark);
      }
      expressions = template.expressions.filter(function(expr) {
        return 'templateText' in expr;
      }).map(function(expression) {
        return expression.templateText;
      });
      if (__indexOf.call(expressions, 'version') >= 0) {
        return true;
      }
    };

    Validator.prototype.get_validation_errors = function() {
      return this.validation_errors;
    };

    Validator.prototype.is_valid = function() {
      return this.validation_errors.length === 0;
    };

    Validator.prototype.hasDuplicatesUris = function(array) {
      var item, output, _i, _len;
      output = {};
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        item = array[_i];
        if (item.uri in output) {
          return item;
        }
        output[item.uri] = item;
      }
      return false;
    };

    Validator.prototype.hasDuplicates = function(array) {
      var item, output, _i, _len;
      output = {};
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        item = array[_i];
        if (item in output) {
          return true;
        }
        output[item] = true;
      }
      return false;
    };

    return Validator;

  })();

}).call(this);

},{"./errors":35,"./nodes":39,"./traits":50,"./util":52,"json-lint":23,"uritemplate":66,"url":15}],54:[function(require,module,exports){
module.exports = require("./lib/_stream_duplex.js")

},{"./lib/_stream_duplex.js":55}],55:[function(require,module,exports){
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

var keys = objectKeys(Writable.prototype);
for (var v = 0; v < keys.length; v++) {
  var method = keys[v];
  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  processNextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}
},{"./_stream_readable":57,"./_stream_writable":59,"core-util-is":3,"inherits":20,"process-nextick-args":26}],56:[function(require,module,exports){
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":58,"core-util-is":3,"inherits":20}],57:[function(require,module,exports){
(function (process){
'use strict';

module.exports = Readable;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream;
(function () {
  try {
    Stream = require('st' + 'ream');
  } catch (_) {} finally {
    if (!Stream) Stream = require('events').EventEmitter;
  }
})();
/*</replacement>*/

var Buffer = require('buffer').Buffer;
/*<replacement>*/
var bufferShim = require('buffer-shims');
/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var StringDecoder;

util.inherits(Readable, Stream);

var hasPrependListener = typeof EE.prototype.prependListener === 'function';

function prependListener(emitter, event, fn) {
  if (hasPrependListener) return emitter.prependListener(event, fn);

  // This is a brutally ugly hack to make sure that our error handler
  // is attached before any userland ones.  NEVER DO THIS. This is here
  // only because this code needs to continue to work with older versions
  // of Node.js that do not include the prependListener() method. The goal
  // is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

var Duplex;
function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~ ~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

var Duplex;
function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options && typeof options.read === 'function') this._read = options.read;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;

  if (!state.objectMode && typeof chunk === 'string') {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = bufferShim.from(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var _e = new Error('stream.unshift() after end event');
      stream.emit('error', _e);
    } else {
      var skipAdd;
      if (state.decoder && !addToFront && !encoding) {
        chunk = state.decoder.write(chunk);
        skipAdd = !state.objectMode && chunk.length === 0;
      }

      if (!addToFront) state.reading = false;

      // Don't add to the buffer if we've decoded to an empty string chunk and
      // we're not in object mode
      if (!skipAdd) {
        // if we want the data now, just emit it.
        if (state.flowing && state.length === 0 && !state.sync) {
          stream.emit('data', chunk);
          stream.read(0);
        } else {
          // update the buffer info.
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

          if (state.needReadable) emitReadable(stream);
        }
      }

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended) return 0;

  if (state.objectMode) return n === 0 ? 0 : 1;

  if (n === null || isNaN(n)) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length) return state.buffer[0].length;else return state.length;
  }

  if (n <= 0) return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else {
      return state.length;
    }
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  var state = this._readableState;
  var nOrig = n;

  if (typeof n !== 'number' || n > 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  }

  if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read pushed data synchronously, then `reading` will be false,
  // and we need to re-evaluate how much data we can return to the user.
  if (doRead && !state.reading) n = howMuchToRead(nOrig, state);

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended) state.needReadable = true;

  // If we tried to read() past the EOF, then emit end on the next tick.
  if (nOrig !== n && state.ended && state.length === 0) endReadable(this);

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    processNextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    debug('onunpipe');
    if (readable === src) {
      cleanup();
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    if (false === ret) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var _i = 0; _i < len; _i++) {
      dests[_i].emit('unpipe', this);
    }return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1) return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  // If listening to data, and it has not explicitly been paused,
  // then call resume to start the flow of data on the next tick.
  if (ev === 'data' && false !== this._readableState.flowing) {
    this.resume();
  }

  if (ev === 'readable' && !this._readableState.endEmitted) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        processNextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    processNextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  if (state.flowing) {
    do {
      var chunk = stream.read();
    } while (null !== chunk && state.flowing);
  }
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function (ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0) return null;

  if (length === 0) ret = null;else if (objectMode) ret = list.shift();else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode) ret = list.join('');else if (list.length === 1) ret = list[0];else ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode) ret = '';else ret = bufferShim.allocUnsafe(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var _buf = list[0];
        var cpy = Math.min(n - c, _buf.length);

        if (stringMode) ret += _buf.slice(0, cpy);else _buf.copy(ret, c, 0, cpy);

        if (cpy < _buf.length) list[0] = _buf.slice(cpy);else list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    processNextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this,require('_process'))

},{"./_stream_duplex":55,"_process":27,"buffer":6,"buffer-shims":2,"core-util-is":3,"events":9,"inherits":20,"isarray":22,"process-nextick-args":26,"string_decoder/":65,"util":1}],58:[function(require,module,exports){
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function TransformState(stream) {
  this.afterTransform = function (er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined) stream.push(data);

  cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  this.once('prefinish', function () {
    if (typeof this._flush === 'function') this._flush(function (er) {
      done(stream, er);
    });else done(stream);
  });
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('Not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

function done(stream, er) {
  if (er) return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;

  if (ws.length) throw new Error('Calling transform done when ws.length != 0');

  if (ts.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":55,"core-util-is":3,"inherits":20}],59:[function(require,module,exports){
(function (process){
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

module.exports = Writable;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream;
(function () {
  try {
    Stream = require('st' + 'ream');
  } catch (_) {} finally {
    if (!Stream) Stream = require('events').EventEmitter;
  }
})();
/*</replacement>*/

var Buffer = require('buffer').Buffer;
/*<replacement>*/
var bufferShim = require('buffer-shims');
/*</replacement>*/

util.inherits(Writable, Stream);

function nop() {}

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

var Duplex;
function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~ ~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function writableStateGetBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
    });
  } catch (_) {}
})();

var Duplex;
function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  processNextTick(cb, er);
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;
  // Always throw error if a null is written
  // if we are not in object mode then throw
  // if it is not a buffer, string, or undefined.
  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    processNextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = bufferShim.from(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);

  if (Buffer.isBuffer(chunk)) encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync) processNextTick(cb, er);else cb(er);

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
        afterWrite(stream, state, finished, cb);
      }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    while (entry) {
      buffer[count] = entry;
      entry = entry.next;
      count += 1;
    }

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit('prefinish');
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit('finish');
    } else {
      prefinish(stream, state);
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) processNextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function (err) {
    var entry = _this.entry;
    _this.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    if (state.corkedRequestsFree) {
      state.corkedRequestsFree.next = _this;
    } else {
      state.corkedRequestsFree = _this;
    }
  };
}
}).call(this,require('_process'))

},{"./_stream_duplex":55,"_process":27,"buffer":6,"buffer-shims":2,"core-util-is":3,"events":9,"inherits":20,"process-nextick-args":26,"util-deprecate":67}],60:[function(require,module,exports){
module.exports = require("./lib/_stream_passthrough.js")

},{"./lib/_stream_passthrough.js":56}],61:[function(require,module,exports){
(function (process){
var Stream = (function (){
  try {
    return require('st' + 'ream'); // hack to fix a circular dependency issue when used with browserify
  } catch(_){}
}());
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = Stream || exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

if (!process.browser && process.env.READABLE_STREAM === 'disable' && Stream) {
  module.exports = Stream;
}

}).call(this,require('_process'))

},{"./lib/_stream_duplex.js":55,"./lib/_stream_passthrough.js":56,"./lib/_stream_readable.js":57,"./lib/_stream_transform.js":58,"./lib/_stream_writable.js":59,"_process":27}],62:[function(require,module,exports){
module.exports = require("./lib/_stream_transform.js")

},{"./lib/_stream_transform.js":58}],63:[function(require,module,exports){
module.exports = require("./lib/_stream_writable.js")

},{"./lib/_stream_writable.js":59}],64:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":9,"inherits":20,"readable-stream/duplex.js":54,"readable-stream/passthrough.js":60,"readable-stream/readable.js":61,"readable-stream/transform.js":62,"readable-stream/writable.js":63}],65:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

},{"buffer":6}],66:[function(require,module,exports){
(function (global){
/*global unescape, module, define, window, global*/

/*
 UriTemplate Copyright (c) 2012-2013 Franz Antesberger. All Rights Reserved.
 Available via the MIT license.
*/

(function (exportCallback) {
    "use strict";

var UriTemplateError = (function () {

    function UriTemplateError (options) {
        this.options = options;
    }

    UriTemplateError.prototype.toString = function () {
        if (JSON && JSON.stringify) {
            return JSON.stringify(this.options);
        }
        else {
            return this.options;
        }
    };

    return UriTemplateError;
}());

var objectHelper = (function () {
    function isArray (value) {
        return Object.prototype.toString.apply(value) === '[object Array]';
    }

    function isString (value) {
        return Object.prototype.toString.apply(value) === '[object String]';
    }
    
    function isNumber (value) {
        return Object.prototype.toString.apply(value) === '[object Number]';
    }
    
    function isBoolean (value) {
        return Object.prototype.toString.apply(value) === '[object Boolean]';
    }
    
    function join (arr, separator) {
        var
            result = '',
            first = true,
            index;
        for (index = 0; index < arr.length; index += 1) {
            if (first) {
                first = false;
            }
            else {
                result += separator;
            }
            result += arr[index];
        }
        return result;
    }

    function map (arr, mapper) {
        var
            result = [],
            index = 0;
        for (; index < arr.length; index += 1) {
            result.push(mapper(arr[index]));
        }
        return result;
    }

    function filter (arr, predicate) {
        var
            result = [],
            index = 0;
        for (; index < arr.length; index += 1) {
            if (predicate(arr[index])) {
                result.push(arr[index]);
            }
        }
        return result;
    }

    function deepFreezeUsingObjectFreeze (object) {
        if (typeof object !== "object" || object === null) {
            return object;
        }
        Object.freeze(object);
        var property, propertyName;
        for (propertyName in object) {
            if (object.hasOwnProperty(propertyName)) {
                property = object[propertyName];
                // be aware, arrays are 'object', too
                if (typeof property === "object") {
                    deepFreeze(property);
                }
            }
        }
        return object;
    }

    function deepFreeze (object) {
        if (typeof Object.freeze === 'function') {
            return deepFreezeUsingObjectFreeze(object);
        }
        return object;
    }


    return {
        isArray: isArray,
        isString: isString,
        isNumber: isNumber,
        isBoolean: isBoolean,
        join: join,
        map: map,
        filter: filter,
        deepFreeze: deepFreeze
    };
}());

var charHelper = (function () {

    function isAlpha (chr) {
        return (chr >= 'a' && chr <= 'z') || ((chr >= 'A' && chr <= 'Z'));
    }

    function isDigit (chr) {
        return chr >= '0' && chr <= '9';
    }

    function isHexDigit (chr) {
        return isDigit(chr) || (chr >= 'a' && chr <= 'f') || (chr >= 'A' && chr <= 'F');
    }

    return {
        isAlpha: isAlpha,
        isDigit: isDigit,
        isHexDigit: isHexDigit
    };
}());

var pctEncoder = (function () {
    var utf8 = {
        encode: function (chr) {
            // see http://ecmanaut.blogspot.de/2006/07/encoding-decoding-utf8-in-javascript.html
            return unescape(encodeURIComponent(chr));
        },
        numBytes: function (firstCharCode) {
            if (firstCharCode <= 0x7F) {
                return 1;
            }
            else if (0xC2 <= firstCharCode && firstCharCode <= 0xDF) {
                return 2;
            }
            else if (0xE0 <= firstCharCode && firstCharCode <= 0xEF) {
                return 3;
            }
            else if (0xF0 <= firstCharCode && firstCharCode <= 0xF4) {
                return 4;
            }
            // no valid first octet
            return 0;
        },
        isValidFollowingCharCode: function (charCode) {
            return 0x80 <= charCode && charCode <= 0xBF;
        }
    };

    /**
     * encodes a character, if needed or not.
     * @param chr
     * @return pct-encoded character
     */
    function encodeCharacter (chr) {
        var
            result = '',
            octets = utf8.encode(chr),
            octet,
            index;
        for (index = 0; index < octets.length; index += 1) {
            octet = octets.charCodeAt(index);
            result += '%' + (octet < 0x10 ? '0' : '') + octet.toString(16).toUpperCase();
        }
        return result;
    }

    /**
     * Returns, whether the given text at start is in the form 'percent hex-digit hex-digit', like '%3F'
     * @param text
     * @param start
     * @return {boolean|*|*}
     */
    function isPercentDigitDigit (text, start) {
        return text.charAt(start) === '%' && charHelper.isHexDigit(text.charAt(start + 1)) && charHelper.isHexDigit(text.charAt(start + 2));
    }

    /**
     * Parses a hex number from start with length 2.
     * @param text a string
     * @param start the start index of the 2-digit hex number
     * @return {Number}
     */
    function parseHex2 (text, start) {
        return parseInt(text.substr(start, 2), 16);
    }

    /**
     * Returns whether or not the given char sequence is a correctly pct-encoded sequence.
     * @param chr
     * @return {boolean}
     */
    function isPctEncoded (chr) {
        if (!isPercentDigitDigit(chr, 0)) {
            return false;
        }
        var firstCharCode = parseHex2(chr, 1);
        var numBytes = utf8.numBytes(firstCharCode);
        if (numBytes === 0) {
            return false;
        }
        for (var byteNumber = 1; byteNumber < numBytes; byteNumber += 1) {
            if (!isPercentDigitDigit(chr, 3*byteNumber) || !utf8.isValidFollowingCharCode(parseHex2(chr, 3*byteNumber + 1))) {
                return false;
            }
        }
        return true;
    }

    /**
     * Reads as much as needed from the text, e.g. '%20' or '%C3%B6'. It does not decode!
     * @param text
     * @param startIndex
     * @return the character or pct-string of the text at startIndex
     */
    function pctCharAt(text, startIndex) {
        var chr = text.charAt(startIndex);
        if (!isPercentDigitDigit(text, startIndex)) {
            return chr;
        }
        var utf8CharCode = parseHex2(text, startIndex + 1);
        var numBytes = utf8.numBytes(utf8CharCode);
        if (numBytes === 0) {
            return chr;
        }
        for (var byteNumber = 1; byteNumber < numBytes; byteNumber += 1) {
            if (!isPercentDigitDigit(text, startIndex + 3 * byteNumber) || !utf8.isValidFollowingCharCode(parseHex2(text, startIndex + 3 * byteNumber + 1))) {
                return chr;
            }
        }
        return text.substr(startIndex, 3 * numBytes);
    }

    return {
        encodeCharacter: encodeCharacter,
        isPctEncoded: isPctEncoded,
        pctCharAt: pctCharAt
    };
}());

var rfcCharHelper = (function () {

    /**
     * Returns if an character is an varchar character according 2.3 of rfc 6570
     * @param chr
     * @return (Boolean)
     */
    function isVarchar (chr) {
        return charHelper.isAlpha(chr) || charHelper.isDigit(chr) || chr === '_' || pctEncoder.isPctEncoded(chr);
    }

    /**
     * Returns if chr is an unreserved character according 1.5 of rfc 6570
     * @param chr
     * @return {Boolean}
     */
    function isUnreserved (chr) {
        return charHelper.isAlpha(chr) || charHelper.isDigit(chr) || chr === '-' || chr === '.' || chr === '_' || chr === '~';
    }

    /**
     * Returns if chr is an reserved character according 1.5 of rfc 6570
     * or the percent character mentioned in 3.2.1.
     * @param chr
     * @return {Boolean}
     */
    function isReserved (chr) {
        return chr === ':' || chr === '/' || chr === '?' || chr === '#' || chr === '[' || chr === ']' || chr === '@' || chr === '!' || chr === '$' || chr === '&' || chr === '(' ||
            chr === ')' || chr === '*' || chr === '+' || chr === ',' || chr === ';' || chr === '=' || chr === "'";
    }

    return {
        isVarchar: isVarchar,
        isUnreserved: isUnreserved,
        isReserved: isReserved
    };

}());

/**
 * encoding of rfc 6570
 */
var encodingHelper = (function () {

    function encode (text, passReserved) {
        var
            result = '',
            index,
            chr = '';
        if (typeof text === "number" || typeof text === "boolean") {
            text = text.toString();
        }
        for (index = 0; index < text.length; index += chr.length) {
            chr = text.charAt(index);
            result += rfcCharHelper.isUnreserved(chr) || (passReserved && rfcCharHelper.isReserved(chr)) ? chr : pctEncoder.encodeCharacter(chr);
        }
        return result;
    }

    function encodePassReserved (text) {
        return encode(text, true);
    }

    function encodeLiteralCharacter (literal, index) {
        var chr = pctEncoder.pctCharAt(literal, index);
        if (chr.length > 1) {
            return chr;
        }
        else {
            return rfcCharHelper.isReserved(chr) || rfcCharHelper.isUnreserved(chr) ? chr : pctEncoder.encodeCharacter(chr);
        }
    }

    function encodeLiteral (literal) {
        var
            result = '',
            index,
            chr = '';
        for (index = 0; index < literal.length; index += chr.length) {
            chr = pctEncoder.pctCharAt(literal, index);
            if (chr.length > 1) {
                result += chr;
            }
            else {
                result += rfcCharHelper.isReserved(chr) || rfcCharHelper.isUnreserved(chr) ? chr : pctEncoder.encodeCharacter(chr);
            }
        }
        return result;
    }

    return {
        encode: encode,
        encodePassReserved: encodePassReserved,
        encodeLiteral: encodeLiteral,
        encodeLiteralCharacter: encodeLiteralCharacter
    };

}());


// the operators defined by rfc 6570
var operators = (function () {

    var
        bySymbol = {};

    function create (symbol) {
        bySymbol[symbol] = {
            symbol: symbol,
            separator: (symbol === '?') ? '&' : (symbol === '' || symbol === '+' || symbol === '#') ? ',' : symbol,
            named: symbol === ';' || symbol === '&' || symbol === '?',
            ifEmpty: (symbol === '&' || symbol === '?') ? '=' : '',
            first: (symbol === '+' ) ? '' : symbol,
            encode: (symbol === '+' || symbol === '#') ? encodingHelper.encodePassReserved : encodingHelper.encode,
            toString: function () {
                return this.symbol;
            }
        };
    }

    create('');
    create('+');
    create('#');
    create('.');
    create('/');
    create(';');
    create('?');
    create('&');
    return {
        valueOf: function (chr) {
            if (bySymbol[chr]) {
                return bySymbol[chr];
            }
            if ("=,!@|".indexOf(chr) >= 0) {
                return null;
            }
            return bySymbol[''];
        }
    };
}());


/**
 * Detects, whether a given element is defined in the sense of rfc 6570
 * Section 2.3 of the RFC makes clear defintions:
 * * undefined and null are not defined.
 * * the empty string is defined
 * * an array ("list") is defined, if it is not empty (even if all elements are not defined)
 * * an object ("map") is defined, if it contains at least one property with defined value
 * @param object
 * @return {Boolean}
 */
function isDefined (object) {
    var
        propertyName;
    if (object === null || object === undefined) {
        return false;
    }
    if (objectHelper.isArray(object)) {
        // Section 2.3: A variable defined as a list value is considered undefined if the list contains zero members
        return object.length > 0;
    }
    if (typeof object === "string" || typeof object === "number" || typeof object === "boolean") {
        // falsy values like empty strings, false or 0 are "defined"
        return true;
    }
    // else Object
    for (propertyName in object) {
        if (object.hasOwnProperty(propertyName) && isDefined(object[propertyName])) {
            return true;
        }
    }
    return false;
}

var LiteralExpression = (function () {
    function LiteralExpression (literal) {
        this.literal = encodingHelper.encodeLiteral(literal);
    }

    LiteralExpression.prototype.expand = function () {
        return this.literal;
    };

    LiteralExpression.prototype.toString = LiteralExpression.prototype.expand;

    return LiteralExpression;
}());

var parse = (function () {

    function parseExpression (expressionText) {
        var
            operator,
            varspecs = [],
            varspec = null,
            varnameStart = null,
            maxLengthStart = null,
            index,
            chr = '';

        function closeVarname () {
            var varname = expressionText.substring(varnameStart, index);
            if (varname.length === 0) {
                throw new UriTemplateError({expressionText: expressionText, message: "a varname must be specified", position: index});
            }
            varspec = {varname: varname, exploded: false, maxLength: null};
            varnameStart = null;
        }

        function closeMaxLength () {
            if (maxLengthStart === index) {
                throw new UriTemplateError({expressionText: expressionText, message: "after a ':' you have to specify the length", position: index});
            }
            varspec.maxLength = parseInt(expressionText.substring(maxLengthStart, index), 10);
            maxLengthStart = null;
        }

        operator = (function (operatorText) {
            var op = operators.valueOf(operatorText);
            if (op === null) {
                throw new UriTemplateError({expressionText: expressionText, message: "illegal use of reserved operator", position: index, operator: operatorText});
            }
            return op;
        }(expressionText.charAt(0)));
        index = operator.symbol.length;

        varnameStart = index;

        for (; index < expressionText.length; index += chr.length) {
            chr = pctEncoder.pctCharAt(expressionText, index);

            if (varnameStart !== null) {
                // the spec says: varname =  varchar *( ["."] varchar )
                // so a dot is allowed except for the first char
                if (chr === '.') {
                    if (varnameStart === index) {
                        throw new UriTemplateError({expressionText: expressionText, message: "a varname MUST NOT start with a dot", position: index});
                    }
                    continue;
                }
                if (rfcCharHelper.isVarchar(chr)) {
                    continue;
                }
                closeVarname();
            }
            if (maxLengthStart !== null) {
                if (index === maxLengthStart && chr === '0') {
                    throw new UriTemplateError({expressionText: expressionText, message: "A :prefix must not start with digit 0", position: index});
                }
                if (charHelper.isDigit(chr)) {
                    if (index - maxLengthStart >= 4) {
                        throw new UriTemplateError({expressionText: expressionText, message: "A :prefix must have max 4 digits", position: index});
                    }
                    continue;
                }
                closeMaxLength();
            }
            if (chr === ':') {
                if (varspec.maxLength !== null) {
                    throw new UriTemplateError({expressionText: expressionText, message: "only one :maxLength is allowed per varspec", position: index});
                }
                if (varspec.exploded) {
                    throw new UriTemplateError({expressionText: expressionText, message: "an exploeded varspec MUST NOT be varspeced", position: index});
                }
                maxLengthStart = index + 1;
                continue;
            }
            if (chr === '*') {
                if (varspec === null) {
                    throw new UriTemplateError({expressionText: expressionText, message: "exploded without varspec", position: index});
                }
                if (varspec.exploded) {
                    throw new UriTemplateError({expressionText: expressionText, message: "exploded twice", position: index});
                }
                if (varspec.maxLength) {
                    throw new UriTemplateError({expressionText: expressionText, message: "an explode (*) MUST NOT follow to a prefix", position: index});
                }
                varspec.exploded = true;
                continue;
            }
            // the only legal character now is the comma
            if (chr === ',') {
                varspecs.push(varspec);
                varspec = null;
                varnameStart = index + 1;
                continue;
            }
            throw new UriTemplateError({expressionText: expressionText, message: "illegal character", character: chr, position: index});
        } // for chr
        if (varnameStart !== null) {
            closeVarname();
        }
        if (maxLengthStart !== null) {
            closeMaxLength();
        }
        varspecs.push(varspec);
        return new VariableExpression(expressionText, operator, varspecs);
    }

    function parse (uriTemplateText) {
        // assert filled string
        var
            index,
            chr,
            expressions = [],
            braceOpenIndex = null,
            literalStart = 0;
        for (index = 0; index < uriTemplateText.length; index += 1) {
            chr = uriTemplateText.charAt(index);
            if (literalStart !== null) {
                if (chr === '}') {
                    throw new UriTemplateError({templateText: uriTemplateText, message: "unopened brace closed", position: index});
                }
                if (chr === '{') {
                    if (literalStart < index) {
                        expressions.push(new LiteralExpression(uriTemplateText.substring(literalStart, index)));
                    }
                    literalStart = null;
                    braceOpenIndex = index;
                }
                continue;
            }

            if (braceOpenIndex !== null) {
                // here just { is forbidden
                if (chr === '{') {
                    throw new UriTemplateError({templateText: uriTemplateText, message: "brace already opened", position: index});
                }
                if (chr === '}') {
                    if (braceOpenIndex + 1 === index) {
                        throw new UriTemplateError({templateText: uriTemplateText, message: "empty braces", position: braceOpenIndex});
                    }
                    try {
                        expressions.push(parseExpression(uriTemplateText.substring(braceOpenIndex + 1, index)));
                    }
                    catch (error) {
                        if (error.prototype === UriTemplateError.prototype) {
                            throw new UriTemplateError({templateText: uriTemplateText, message: error.options.message, position: braceOpenIndex + error.options.position, details: error.options});
                        }
                        throw error;
                    }
                    braceOpenIndex = null;
                    literalStart = index + 1;
                }
                continue;
            }
            throw new Error('reached unreachable code');
        }
        if (braceOpenIndex !== null) {
            throw new UriTemplateError({templateText: uriTemplateText, message: "unclosed brace", position: braceOpenIndex});
        }
        if (literalStart < uriTemplateText.length) {
            expressions.push(new LiteralExpression(uriTemplateText.substr(literalStart)));
        }
        return new UriTemplate(uriTemplateText, expressions);
    }

    return parse;
}());

var VariableExpression = (function () {
    // helper function if JSON is not available
    function prettyPrint (value) {
        return (JSON && JSON.stringify) ? JSON.stringify(value) : value;
    }

    function isEmpty (value) {
        if (!isDefined(value)) {
            return true;
        }
        if (objectHelper.isString(value)) {
            return value === '';
        }
        if (objectHelper.isNumber(value) || objectHelper.isBoolean(value)) {
            return false;
        }
        if (objectHelper.isArray(value)) {
            return value.length === 0;
        }
        for (var propertyName in value) {
            if (value.hasOwnProperty(propertyName)) {
                return false;
            }
        }
        return true;
    }

    function propertyArray (object) {
        var
            result = [],
            propertyName;
        for (propertyName in object) {
            if (object.hasOwnProperty(propertyName)) {
                result.push({name: propertyName, value: object[propertyName]});
            }
        }
        return result;
    }

    function VariableExpression (templateText, operator, varspecs) {
        this.templateText = templateText;
        this.operator = operator;
        this.varspecs = varspecs;
    }

    VariableExpression.prototype.toString = function () {
        return this.templateText;
    };

    function expandSimpleValue(varspec, operator, value) {
        var result = '';
        value = value.toString();
        if (operator.named) {
            result += encodingHelper.encodeLiteral(varspec.varname);
            if (value === '') {
                result += operator.ifEmpty;
                return result;
            }
            result += '=';
        }
        if (varspec.maxLength !== null) {
            value = value.substr(0, varspec.maxLength);
        }
        result += operator.encode(value);
        return result;
    }

    function valueDefined (nameValue) {
        return isDefined(nameValue.value);
    }

    function expandNotExploded(varspec, operator, value) {
        var
            arr = [],
            result = '';
        if (operator.named) {
            result += encodingHelper.encodeLiteral(varspec.varname);
            if (isEmpty(value)) {
                result += operator.ifEmpty;
                return result;
            }
            result += '=';
        }
        if (objectHelper.isArray(value)) {
            arr = value;
            arr = objectHelper.filter(arr, isDefined);
            arr = objectHelper.map(arr, operator.encode);
            result += objectHelper.join(arr, ',');
        }
        else {
            arr = propertyArray(value);
            arr = objectHelper.filter(arr, valueDefined);
            arr = objectHelper.map(arr, function (nameValue) {
                return operator.encode(nameValue.name) + ',' + operator.encode(nameValue.value);
            });
            result += objectHelper.join(arr, ',');
        }
        return result;
    }

    function expandExplodedNamed (varspec, operator, value) {
        var
            isArray = objectHelper.isArray(value),
            arr = [];
        if (isArray) {
            arr = value;
            arr = objectHelper.filter(arr, isDefined);
            arr = objectHelper.map(arr, function (listElement) {
                var tmp = encodingHelper.encodeLiteral(varspec.varname);
                if (isEmpty(listElement)) {
                    tmp += operator.ifEmpty;
                }
                else {
                    tmp += '=' + operator.encode(listElement);
                }
                return tmp;
            });
        }
        else {
            arr = propertyArray(value);
            arr = objectHelper.filter(arr, valueDefined);
            arr = objectHelper.map(arr, function (nameValue) {
                var tmp = encodingHelper.encodeLiteral(nameValue.name);
                if (isEmpty(nameValue.value)) {
                    tmp += operator.ifEmpty;
                }
                else {
                    tmp += '=' + operator.encode(nameValue.value);
                }
                return tmp;
            });
        }
        return objectHelper.join(arr, operator.separator);
    }

    function expandExplodedUnnamed (operator, value) {
        var
            arr = [],
            result = '';
        if (objectHelper.isArray(value)) {
            arr = value;
            arr = objectHelper.filter(arr, isDefined);
            arr = objectHelper.map(arr, operator.encode);
            result += objectHelper.join(arr, operator.separator);
        }
        else {
            arr = propertyArray(value);
            arr = objectHelper.filter(arr, function (nameValue) {
                return isDefined(nameValue.value);
            });
            arr = objectHelper.map(arr, function (nameValue) {
                return operator.encode(nameValue.name) + '=' + operator.encode(nameValue.value);
            });
            result += objectHelper.join(arr, operator.separator);
        }
        return result;
    }


    VariableExpression.prototype.expand = function (variables) {
        var
            expanded = [],
            index,
            varspec,
            value,
            valueIsArr,
            oneExploded = false,
            operator = this.operator;

        // expand each varspec and join with operator's separator
        for (index = 0; index < this.varspecs.length; index += 1) {
            varspec = this.varspecs[index];
            value = variables[varspec.varname];
            // if (!isDefined(value)) {
            // if (variables.hasOwnProperty(varspec.name)) {
            if (value === null || value === undefined) {
                continue;
            }
            if (varspec.exploded) {
                oneExploded = true;
            }
            valueIsArr = objectHelper.isArray(value);
            if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
                expanded.push(expandSimpleValue(varspec, operator, value));
            }
            else if (varspec.maxLength && isDefined(value)) {
                // 2.4.1 of the spec says: "Prefix modifiers are not applicable to variables that have composite values."
                throw new Error('Prefix modifiers are not applicable to variables that have composite values. You tried to expand ' + this + " with " + prettyPrint(value));
            }
            else if (!varspec.exploded) {
                if (operator.named || !isEmpty(value)) {
                    expanded.push(expandNotExploded(varspec, operator, value));
                }
            }
            else if (isDefined(value)) {
                if (operator.named) {
                    expanded.push(expandExplodedNamed(varspec, operator, value));
                }
                else {
                    expanded.push(expandExplodedUnnamed(operator, value));
                }
            }
        }

        if (expanded.length === 0) {
            return "";
        }
        else {
            return operator.first + objectHelper.join(expanded, operator.separator);
        }
    };

    return VariableExpression;
}());

var UriTemplate = (function () {
    function UriTemplate (templateText, expressions) {
        this.templateText = templateText;
        this.expressions = expressions;
        objectHelper.deepFreeze(this);
    }

    UriTemplate.prototype.toString = function () {
        return this.templateText;
    };

    UriTemplate.prototype.expand = function (variables) {
        // this.expressions.map(function (expression) {return expression.expand(variables);}).join('');
        var
            index,
            result = '';
        for (index = 0; index < this.expressions.length; index += 1) {
            result += this.expressions[index].expand(variables);
        }
        return result;
    };

    UriTemplate.parse = parse;
    UriTemplate.UriTemplateError = UriTemplateError;
    return UriTemplate;
}());

    exportCallback(UriTemplate);

}(function (UriTemplate) {
        "use strict";
        // export UriTemplate, when module is present, or pass it to window or global
        if (typeof module !== "undefined") {
            module.exports = UriTemplate;
        }
        else if (typeof define === "function") {
            define([],function() {
                return UriTemplate;
            });
        }
        else if (typeof window !== "undefined") {
            window.UriTemplate = UriTemplate;
        }
        else {
            global.UriTemplate = UriTemplate;
        }
    }
));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],67:[function(require,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],68:[function(require,module,exports){
(function (process,Buffer){
/**
 * Wrapper for built-in http.js to emulate the browser XMLHttpRequest object.
 *
 * This can be used with JS designed for browsers to improve reuse of code and
 * allow the use of existing libraries.
 *
 * Usage: include("XMLHttpRequest.js") and use XMLHttpRequest per W3C specs.
 *
 * @author Dan DeFelippi <dan@driverdan.com>
 * @contributor David Ellis <d.f.ellis@ieee.org>
 * @license MIT
 */

var Url = require("url")
  , spawn = require("child_process").spawn
  , fs = require('fs');

exports.XMLHttpRequest = function() {
  /**
   * Private variables
   */
  var self = this;
  var http = require('http');
  var https = require('https');

  // Holds http.js objects
  var request;
  var response;

  // Request settings
  var settings = {};

  // Disable header blacklist.
  // Not part of XHR specs.
  var disableHeaderCheck = false;

  // Set some default headers
  var defaultHeaders = {
    "User-Agent": "node-XMLHttpRequest",
    "Accept": "*/*",
  };

  var headers = defaultHeaders;

  // These headers are not user setable.
  // The following are allowed but banned in the spec:
  // * user-agent
  var forbiddenRequestHeaders = [
    "accept-charset",
    "accept-encoding",
    "access-control-request-headers",
    "access-control-request-method",
    "connection",
    "content-length",
    "content-transfer-encoding",
    "cookie",
    "cookie2",
    "date",
    "expect",
    "host",
    "keep-alive",
    "origin",
    "referer",
    "te",
    "trailer",
    "transfer-encoding",
    "upgrade",
    "via"
  ];

  // These request methods are not allowed
  var forbiddenRequestMethods = [
    "TRACE",
    "TRACK",
    "CONNECT"
  ];

  // Send flag
  var sendFlag = false;
  // Error flag, used when errors occur or abort is called
  var errorFlag = false;

  // Event listeners
  var listeners = {};

  /**
   * Constants
   */

  this.UNSENT = 0;
  this.OPENED = 1;
  this.HEADERS_RECEIVED = 2;
  this.LOADING = 3;
  this.DONE = 4;

  /**
   * Public vars
   */

  // Current state
  this.readyState = this.UNSENT;

  // default ready state change handler in case one is not set or is set late
  this.onreadystatechange = null;

  // Result & response
  this.responseText = "";
  this.responseXML = "";
  this.status = null;
  this.statusText = null;

  /**
   * Private methods
   */

  /**
   * Check if the specified header is allowed.
   *
   * @param string header Header to validate
   * @return boolean False if not allowed, otherwise true
   */
  var isAllowedHttpHeader = function(header) {
    return disableHeaderCheck || (header && forbiddenRequestHeaders.indexOf(header.toLowerCase()) === -1);
  };

  /**
   * Check if the specified method is allowed.
   *
   * @param string method Request method to validate
   * @return boolean False if not allowed, otherwise true
   */
  var isAllowedHttpMethod = function(method) {
    return (method && forbiddenRequestMethods.indexOf(method) === -1);
  };

  /**
   * Public methods
   */

  /**
   * Open the connection. Currently supports local server requests.
   *
   * @param string method Connection method (eg GET, POST)
   * @param string url URL for the connection.
   * @param boolean async Asynchronous connection. Default is true.
   * @param string user Username for basic authentication (optional)
   * @param string password Password for basic authentication (optional)
   */
  this.open = function(method, url, async, user, password) {
    this.abort();
    errorFlag = false;

    // Check for valid request method
    if (!isAllowedHttpMethod(method)) {
      throw "SecurityError: Request method not allowed";
    }

    settings = {
      "method": method,
      "url": url.toString(),
      "async": (typeof async !== "boolean" ? true : async),
      "user": user || null,
      "password": password || null
    };

    setState(this.OPENED);
  };

  /**
   * Disables or enables isAllowedHttpHeader() check the request. Enabled by default.
   * This does not conform to the W3C spec.
   *
   * @param boolean state Enable or disable header checking.
   */
  this.setDisableHeaderCheck = function(state) {
    disableHeaderCheck = state;
  };

  /**
   * Sets a header for the request.
   *
   * @param string header Header name
   * @param string value Header value
   */
  this.setRequestHeader = function(header, value) {
    if (this.readyState != this.OPENED) {
      throw "INVALID_STATE_ERR: setRequestHeader can only be called when state is OPEN";
    }
    if (!isAllowedHttpHeader(header)) {
      console.warn('Refused to set unsafe header "' + header + '"');
      return;
    }
    if (sendFlag) {
      throw "INVALID_STATE_ERR: send flag is true";
    }
    headers[header] = value;
  };

  /**
   * Gets a header from the server response.
   *
   * @param string header Name of header to get.
   * @return string Text of the header or null if it doesn't exist.
   */
  this.getResponseHeader = function(header) {
    if (typeof header === "string"
      && this.readyState > this.OPENED
      && response.headers[header.toLowerCase()]
      && !errorFlag
    ) {
      return response.headers[header.toLowerCase()];
    }

    return null;
  };

  /**
   * Gets all the response headers.
   *
   * @return string A string with all response headers separated by CR+LF
   */
  this.getAllResponseHeaders = function() {
    if (this.readyState < this.HEADERS_RECEIVED || errorFlag) {
      return "";
    }
    var result = "";

    for (var i in response.headers) {
      // Cookie headers are excluded
      if (i !== "set-cookie" && i !== "set-cookie2") {
        result += i + ": " + response.headers[i] + "\r\n";
      }
    }
    return result.substr(0, result.length - 2);
  };

  /**
   * Gets a request header
   *
   * @param string name Name of header to get
   * @return string Returns the request header or empty string if not set
   */
  this.getRequestHeader = function(name) {
    // @TODO Make this case insensitive
    if (typeof name === "string" && headers[name]) {
      return headers[name];
    }

    return "";
  };

  /**
   * Sends the request to the server.
   *
   * @param string data Optional data to send as request body.
   */
  this.send = function(data) {
    if (this.readyState != this.OPENED) {
      throw "INVALID_STATE_ERR: connection must be opened before send() is called";
    }

    if (sendFlag) {
      throw "INVALID_STATE_ERR: send has already been called";
    }

    var ssl = false, local = false;
    var url = Url.parse(settings.url);
    var host;
    // Determine the server
    switch (url.protocol) {
      case 'https:':
        ssl = true;
        // SSL & non-SSL both need host, no break here.
      case 'http:':
        host = url.hostname;
        break;

      case 'file:':
        local = true;
        break;

      case undefined:
      case '':
        host = "localhost";
        break;

      default:
        throw "Protocol not supported.";
    }

    // Load files off the local filesystem (file://)
    if (local) {
      if (settings.method !== "GET") {
        throw "XMLHttpRequest: Only GET method is supported";
      }

      if (settings.async) {
        fs.readFile(url.pathname, 'utf8', function(error, data) {
          if (error) {
            self.handleError(error);
          } else {
            self.status = 200;
            self.responseText = data;
            setState(self.DONE);
          }
        });
      } else {
        try {
          this.responseText = fs.readFileSync(url.pathname, 'utf8');
          this.status = 200;
          setState(self.DONE);
        } catch(e) {
          this.handleError(e);
        }
      }

      return;
    }

    // Default to port 80. If accessing localhost on another port be sure
    // to use http://localhost:port/path
    var port = url.port || (ssl ? 443 : 80);
    // Add query string if one is used
    var uri = url.pathname + (url.search ? url.search : '');

    // Set the Host header or the server may reject the request
    headers["Host"] = host;
    if (!((ssl && port === 443) || port === 80)) {
      headers["Host"] += ':' + url.port;
    }

    // Set Basic Auth if necessary
    if (settings.user) {
      if (typeof settings.password == "undefined") {
        settings.password = "";
      }
      var authBuf = new Buffer(settings.user + ":" + settings.password);
      headers["Authorization"] = "Basic " + authBuf.toString("base64");
    }

    // Set content length header
    if (settings.method === "GET" || settings.method === "HEAD") {
      data = null;
    } else if (data) {
      headers["Content-Length"] = Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data);

      if (!headers["Content-Type"]) {
        headers["Content-Type"] = "text/plain;charset=UTF-8";
      }
    } else if (settings.method === "POST") {
      // For a post with no data set Content-Length: 0.
      // This is required by buggy servers that don't meet the specs.
      headers["Content-Length"] = 0;
    }

    var options = {
      host: host,
      port: port,
      path: uri,
      method: settings.method,
      headers: headers,
      agent: false
    };

    // Reset error flag
    errorFlag = false;

    // Handle async requests
    if (settings.async) {
      // Use the proper protocol
      var doRequest = ssl ? https.request : http.request;

      // Request is being sent, set send flag
      sendFlag = true;

      // As per spec, this is called here for historical reasons.
      self.dispatchEvent("readystatechange");

      // Handler for the response
      function responseHandler(resp) {
        // Set response var to the response we got back
        // This is so it remains accessable outside this scope
        response = resp;
        // Check for redirect
        // @TODO Prevent looped redirects
        if (response.statusCode === 302 || response.statusCode === 303 || response.statusCode === 307) {
          // Change URL to the redirect location
          settings.url = response.headers.location;
          var url = Url.parse(settings.url);
          // Set host var in case it's used later
          host = url.hostname;
          // Options for the new request
          var newOptions = {
            hostname: url.hostname,
            port: url.port,
            path: url.path,
            method: response.statusCode === 303 ? 'GET' : settings.method,
            headers: headers
          };

          // Issue the new request
          request = doRequest(newOptions, responseHandler).on('error', errorHandler);
          request.end();
          // @TODO Check if an XHR event needs to be fired here
          return;
        }

        response.setEncoding("utf8");

        setState(self.HEADERS_RECEIVED);
        self.status = response.statusCode;

        response.on('data', function(chunk) {
          // Make sure there's some data
          if (chunk) {
            self.responseText += chunk;
          }
          // Don't emit state changes if the connection has been aborted.
          if (sendFlag) {
            setState(self.LOADING);
          }
        });

        response.on('end', function() {
          if (sendFlag) {
            // Discard the 'end' event if the connection has been aborted
            setState(self.DONE);
            sendFlag = false;
          }
        });

        response.on('error', function(error) {
          self.handleError(error);
        });
      }

      // Error handler for the request
      function errorHandler(error) {
        self.handleError(error);
      }

      // Create the request
      request = doRequest(options, responseHandler).on('error', errorHandler);

      // Node 0.4 and later won't accept empty data. Make sure it's needed.
      if (data) {
        request.write(data);
      }

      request.end();

      self.dispatchEvent("loadstart");
    } else { // Synchronous
      // Create a temporary file for communication with the other Node process
      var contentFile = ".node-xmlhttprequest-content-" + process.pid;
      var syncFile = ".node-xmlhttprequest-sync-" + process.pid;
      fs.writeFileSync(syncFile, "", "utf8");
      // The async request the other Node process executes
      var execString = "var http = require('http'), https = require('https'), fs = require('fs');"
        + "var doRequest = http" + (ssl ? "s" : "") + ".request;"
        + "var options = " + JSON.stringify(options) + ";"
        + "var responseText = '';"
        + "var req = doRequest(options, function(response) {"
        + "response.setEncoding('utf8');"
        + "response.on('data', function(chunk) {"
        + "  responseText += chunk;"
        + "});"
        + "response.on('end', function() {"
        + "fs.writeFileSync('" + contentFile + "', 'NODE-XMLHTTPREQUEST-STATUS:' + response.statusCode + ',' + responseText, 'utf8');"
        + "fs.unlinkSync('" + syncFile + "');"
        + "});"
        + "response.on('error', function(error) {"
        + "fs.writeFileSync('" + contentFile + "', 'NODE-XMLHTTPREQUEST-ERROR:' + JSON.stringify(error), 'utf8');"
        + "fs.unlinkSync('" + syncFile + "');"
        + "});"
        + "}).on('error', function(error) {"
        + "fs.writeFileSync('" + contentFile + "', 'NODE-XMLHTTPREQUEST-ERROR:' + JSON.stringify(error), 'utf8');"
        + "fs.unlinkSync('" + syncFile + "');"
        + "});"
        + (data ? "req.write('" + data.replace(/'/g, "\\'") + "');":"")
        + "req.end();";
      // Start the other Node Process, executing this string
      var syncProc = spawn(process.argv[0], ["-e", execString]);
      var statusText;
      while(fs.existsSync(syncFile)) {
        // Wait while the sync file is empty
      }
      self.responseText = fs.readFileSync(contentFile, 'utf8');
      // Kill the child process once the file has data
      syncProc.stdin.end();
      // Remove the temporary file
      fs.unlinkSync(contentFile);
      if (self.responseText.match(/^NODE-XMLHTTPREQUEST-ERROR:/)) {
        // If the file returned an error, handle it
        var errorObj = self.responseText.replace(/^NODE-XMLHTTPREQUEST-ERROR:/, "");
        self.handleError(errorObj);
      } else {
        // If the file returned okay, parse its data and move to the DONE state
        self.status = self.responseText.replace(/^NODE-XMLHTTPREQUEST-STATUS:([0-9]*),.*/, "$1");
        self.responseText = self.responseText.replace(/^NODE-XMLHTTPREQUEST-STATUS:[0-9]*,(.*)/, "$1");
        setState(self.DONE);
      }
    }
  };

  /**
   * Called when an error is encountered to deal with it.
   */
  this.handleError = function(error) {
    this.status = 503;
    this.statusText = error;
    this.responseText = error.stack;
    errorFlag = true;
    setState(this.DONE);
  };

  /**
   * Aborts a request.
   */
  this.abort = function() {
    if (request) {
      request.abort();
      request = null;
    }

    headers = defaultHeaders;
    this.responseText = "";
    this.responseXML = "";

    errorFlag = true;

    if (this.readyState !== this.UNSENT
        && (this.readyState !== this.OPENED || sendFlag)
        && this.readyState !== this.DONE) {
      sendFlag = false;
      setState(this.DONE);
    }
    this.readyState = this.UNSENT;
  };

  /**
   * Adds an event listener. Preferred method of binding to events.
   */
  this.addEventListener = function(event, callback) {
    if (!(event in listeners)) {
      listeners[event] = [];
    }
    // Currently allows duplicate callbacks. Should it?
    listeners[event].push(callback);
  };

  /**
   * Remove an event callback that has already been bound.
   * Only works on the matching funciton, cannot be a copy.
   */
  this.removeEventListener = function(event, callback) {
    if (event in listeners) {
      // Filter will return a new array with the callback removed
      listeners[event] = listeners[event].filter(function(ev) {
        return ev !== callback;
      });
    }
  };

  /**
   * Dispatch any events, including both "on" methods and events attached using addEventListener.
   */
  this.dispatchEvent = function(event) {
    if (typeof self["on" + event] === "function") {
      self["on" + event]();
    }
    if (event in listeners) {
      for (var i = 0, len = listeners[event].length; i < len; i++) {
        listeners[event][i].call(self);
      }
    }
  };

  /**
   * Changes readyState and calls onreadystatechange.
   *
   * @param int state New state
   */
  var setState = function(state) {
    if (self.readyState !== state) {
      self.readyState = state;

      if (settings.async || self.readyState < self.OPENED || self.readyState === self.DONE) {
        self.dispatchEvent("readystatechange");
      }

      if (self.readyState === self.DONE && !errorFlag) {
        self.dispatchEvent("load");
        // @TODO figure out InspectorInstrumentation::didLoadXHR(cookie)
        self.dispatchEvent("loadend");
      }
    }
  };
};

}).call(this,require('_process'),require("buffer").Buffer)

},{"_process":27,"buffer":6,"child_process":5,"fs":5,"http":11,"https":16,"url":15}],69:[function(require,module,exports){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}],70:[function(require,module,exports){
/**
 * Accepts an array of strings that represent a reference to a value on an
 * object. Supports passing an optional setter, to set the value.
 *
 * @param  {Object} object
 * @param  {Array}  path
 * @param  {*}      [setter]
 * @return {*}
 */
module.exports = function (object, path, setter) {
  var isSetter = arguments.length > 2;

  for (var i = 0; i < path.length; i++) {
    var prop = path[i];

    if (isSetter) {
      if (i === path.length - 1) {
        object[prop] = setter;
      } else if (!(prop in object)) {
        object[prop] = {};
      }
    }

    object = object[prop];
  }

  // Return the updated object reference.
  return object;
};

},{}],71:[function(require,module,exports){
/* global App */
var _        = App.Library._;
var async    = App.Library.async;
var template = require('./client-generator/template');

/**
 * Map authentication types to automatic preference.
 *
 * @type {Array}
 */
var ORDER_PREFERENCE = ['OAuth 2.0', 'OAuth 1.0', 'Basic Authentication'];

/**
 * Required authentication keys used to check the options object.
 *
 * @type {Object}
 */
var DEFAULT_REQUIRED_FIELDS = {
  'OAuth 1.0': {
    consumerKey:    true,
    consumerSecret: true
  },
  'OAuth 2.0': {
    clientId:     true,
    clientSecret: true
  },
  'Basic Authentication': {
    username: true,
    password: true
  }
};

/**
 * Possible tokens to be filled out by the user.
 *
 * @type {Object}
 */
var DEFAULT_POSSIBLE_FIELDS = {
  'OAuth 1.0':            ['consumerKey', 'consumerSecret'],
  'OAuth 2.0':            ['clientId', 'clientSecret', 'scopes'],
  'Basic Authentication': ['username', 'password']
};

/**
 * Default authentication prompt titles.
 *
 * @type {Object}
 */
var DEFAULT_PROMPT_TITLES = {
  'OAuth 1.0':            'Please Enter Your OAuth 1.0 Keys',
  'OAuth 2.0':            'Please Enter Your OAuth 2.0 Keys',
  'Basic Authentication': 'Please Enter Your Username and Password'
};

/**
 * Map of object keys to their readable names.
 *
 * @type {Object}
 */
var DEFAULT_FIELD_NAMES = {
  consumerKey:    'Consumer Key',
  consumerSecret: 'Consumer Secret',
  clientId:       'Client ID',
  clientSecret:   'Client Secret',
  scopes:         'Permissions',
  username:       'Username',
  password:       'Password'
};

/**
 * These fields must be hidden in the UI.
 *
 * @type {Object}
 */
var SECRET_FIELDS = {
  clientSecret: true,
  consumerSecret: true,
  password: true
};

/**
 * Returns an object of available keys and whether they are required.
 *
 * @param  {Object} scheme
 * @return {Object}
 */
var requiredTokens = function (scheme) {
  var keys = _.extend({}, DEFAULT_REQUIRED_FIELDS[scheme.type]);

  // Special case is required for OAuth2 implicit auth flow.
  if (scheme.type === 'OAuth 2.0') {
    keys.clientSecret = !_.contains(
      scheme.settings.authorizationGrants, 'token'
    );
  }

  return keys;
};

/**
 * Sanitize scopes to be an array.
 *
 * @param  {*}     scopes
 * @return {Array}
 */
var sanitizeScope = function (scopes) {
  if (_.isString(scopes)) {
    return scopes.split(' ');
  }

  if (!Array.isArray(scopes)) {
    return [];
  }

  return scopes;
};

/**
 * Check the tokens object against the required tokens.
 *
 * @param  {Object}  scheme
 * @param  {Object}  tokens
 * @return {Boolean}
 */
var hasRequiredTokens = function (scheme, tokens) {
  // Iterate over the required tokens and check that the token is defined.
  return _.every(requiredTokens(scheme), function (value, key) {
    return value ? tokens[key] : true;
  });
};

/**
 * Prompt the user for authentication tokens based on a scheme. We can pass in
 * the current options object to help decide what data to display to the user.
 *
 * @param {Object}   scheme
 * @param {Object}   options
 * @param {Function} done
 */
var promptTokens = function (scheme, options, done) {
  var cancelled   = true;
  var needsTokens = requiredTokens(scheme);

  // Generate an array of the tokens to use with our prompt and filter
  // explicitly not required tokens.
  var possibleTokens = _.filter(
    DEFAULT_POSSIBLE_FIELDS[scheme.type],
    function (token) {
      return needsTokens[token] !== false;
    }
  );

  // Multiple ways of setting the scope option.
  options.scopes = sanitizeScope(options.scope || options.scopes);
  delete options.scope;

  // Generate the form to prompt the user with.
  var promptForm = _.map(possibleTokens, function (key) {
    if (key === 'scopes') {
      var scopes = sanitizeScope(scheme.settings.scopes);

      // Ignore the scopes selection when nothing is available for selection.
      if (!scopes.length) {
        return '';
      }

      // Map scopes to checkbox selections.
      var scopeOptions = _.map(scopes, function (scope) {
        // Check if the scope is already in the selected scopes. If there is
        // only one possible scope, just select it by default anyway.
        var hasScope = _.contains(options.scopes, scope) || scopes.length === 1;

        return [
          '<div class="checkbox">',
          '<label>',
          '<input type="checkbox" id="scopes" value="' + scope + '" ' +
            (hasScope ? 'checked' : '') + '>',
          scope,
          '</label>',
          '</div>'
        ].join('');
      }).join('\n');

      return [
        '<div class="form-group">',
        '<label class="form-label">' + DEFAULT_FIELD_NAMES[key] + '</label>',
        '<div class="form-content">' + scopeOptions + '</div>',
        '</div>'
      ].join('\n');
    }

    // By default we show the user an input field to input their keys.
    return [
      '<div class="form-group">',
      '<label for="' + key + '" class="form-label">',
      DEFAULT_FIELD_NAMES[key],
      '</label>',
      '<div class="form-content">',
      '<input id="' + key + '" value="' + (options[key] || '') + '"' +
        (SECRET_FIELDS[key] ? ' type="password"' : '') + '>',
      '</div>',
      '</div>'
    ].join('');
  }).join('\n');

  return App.middleware.trigger('ui:modal', {
    title: DEFAULT_PROMPT_TITLES[scheme.type],
    content: [
      '<p>',
      'This API requires authentication. Please enter your application keys.',
      '</p>',
      '<p><em>We do not store your keys.</em></p>',
      '<form>',
      promptForm,
      '<div class="form-footer">',
      '<button type="submit" class="btn btn-primary">Submit</button>',
      '</div>',
      '</form>'
    ].join('\n'),
    show: function (modal) {
      modal.el.querySelector('form')
        .addEventListener('submit', function (e) {
          e.preventDefault();

          _.each(this.querySelectorAll('input'), function (el) {
            var name = el.getAttribute('id');

            if (name === 'scopes') {
              var indexOf = _.indexOf(options.scopes, el.value);

              if (el.checked) {
                if (indexOf < 0) {
                  options.scopes.push(el.value);
                }
              } else {
                if (indexOf > -1) {
                  options.scopes.splice(indexOf, 1);
                }
              }
            } else {
              options[name] = el.value.trim();
            }
          });

          cancelled = false;
          modal.close();
        });
    }
  }, function (err) {
    return done(err || (cancelled ? new Error('Modal closed') : null), options);
  });
};

/**
 * Authenticate using an authentication scheme and passed in options.
 *
 * @param  {Object}   scheme
 * @param  {Object}   options
 * @param  {Function} done
 */
var authenticate = function (scheme, options, done) {
  var opts = _.defaults({
    type: scheme.type
  }, options, scheme.settings);

  // Interpolate all uri parameters.
  _.each([
    'accessTokenUri',
    'authorizationUri',
    'requestTokenUri',
    'authorizationUri',
    'tokenCredentialsUri'
  ], function (param) {
    opts[param] = template(opts[param], opts.baseUriParameters);
  });

  // Trigger the authentication flow.
  App.middleware.trigger('authenticate', opts, function (err, tokens) {
    if (err) {
      return done(err);
    }

    if (!tokens) {
      return done(new Error('Authentication failed'));
    }

    return done(null, scheme, options, tokens);
  }, true);
};

/**
 * Request authentication credentials from a third-party source.
 *
 * @param {Object}   scheme
 * @param {Object}   options
 * @param {Function} done
 */
var requestTokens = function (scheme, options, done) {
  var cb = function (err, tokens) {
    return done(err, _.extend({}, tokens, options));
  };

  return App.middleware.trigger('ramlClient:token', scheme, cb, true);
};

/**
 * Return the preferred scheme option from an object of every scheme.
 *
 * @param  {Object} schemes
 * @return {Object}
 */
var preferredScheme = function (schemes) {
  // Fix `undefined` schemes issues.
  if (!schemes || !Object.keys(schemes).length) {
    return;
  }

  var method = _.intersection(ORDER_PREFERENCE, _.pluck(schemes, 'type'))[0];

  // Return an essentially random but consistent scheme.
  if (!method) {
    return schemes[_.keys(schemes)[0]];
  }

  // Find the scheme that matched our preferred method.
  return _.find(schemes, function (scheme) {
    return scheme.type === method;
  });
};

/**
 * Retrieve authentication tokens and method any way possible. It will attempt
 * to resolve automatically. If that is not possible, it will defer to
 * prompting the user.
 *
 * @param {Object}   schemes
 * @param {Object}   options
 * @param {Function} done
 */
var retrieveTokens = function (schemes, options, done) {
  var tokens;

  // Attempt to get the first resolving set of access tokens.
  async.detectSeries(_.map(schemes, function (secured, method) {
    return schemes[method];
  }), function (scheme, cb) {
    return requestTokens(scheme, options, function (err, data) {
      if (err || !data || !hasRequiredTokens(scheme, data)) {
        return cb(false);
      }

      return cb(tokens = data);
    });
  }, function (scheme) {
    if (!scheme) {
      scheme = preferredScheme(schemes);

      if (!scheme) {
        return done(new Error('No schemes available'));
      }

      return promptTokens(scheme, options, function (err, tokens) {
        return done(err, scheme, tokens);
      });
    }

    return done(null, scheme, tokens);
  });
};

/**
 * Attempt to magically resolve to the first working authentication method. If
 * we fail, we need to fall back to manual authentication options with the
 * optimal authentication scheme available.
 *
 * @param {Object}   schemes
 * @param {Object}   options
 * @param {Function} done
 */
var resolveScheme = function (schemes, options, done) {
  return retrieveTokens(schemes, options, function (err, scheme, tokens) {
    if (err) { return done(err); }

    return authenticate(scheme, tokens, done);
  });
};

/**
 * Export a function that will contain all the logic for automagically
 * selecting an appropriate authentication method and prompting the user
 * for the following steps.
 *
 * @param {Object}   schemes
 * @param {String}   method
 * @param {Object}   options
 * @param {Function} done
 */
exports = module.exports = function (schemes, method, options, done) {
  var auth = _.extend({}, options);

  // If no authentication method has been passed in, attempt to pick our own.
  if (!method) {
    return resolveScheme(schemes, auth, done);
  }

  // Ensure we are attempting to authenticate with a valid method.
  if (!Object.prototype.hasOwnProperty.call(schemes, method)) {
    return done(new Error(
      'The only available authentication methods are: ' +
      _.keys(schemes).map(JSON.stringify).join(', ')
    ));
  }

  var scheme = schemes[method];

  // If we don't have all the required tokens available, prompt the user to
  // input tokens and continue authenticating.
  if (!hasRequiredTokens(scheme, auth)) {
    return requestTokens(scheme, auth, function (err, data) {
      if (err) { return done(err); }

      // Don't prompt for the tokens if we managed to retrieve them anyway.
      if (hasRequiredTokens(scheme, _.defaults(auth, data))) {
        return authenticate(scheme, auth, done);
      }

      return promptTokens(scheme, auth, function (err, tokens) {
        if (err) { return done(err); }

        return authenticate(scheme, tokens, done);
      });
    });
  }

  // Finally we have everything we need and can initiate authentication.
  return authenticate(scheme, auth, done);
};

/**
 * Expose secret field names.
 */
exports.SECRET_FIELDS = SECRET_FIELDS;

},{"./client-generator/template":74}],72:[function(require,module,exports){
/* global App */
var _           = App.Library._;
var qs          = App.Library.qs;
var template    = require('./template');
var sanitizeAST = require('./sanitize-ast');

var CONFIG_PROPERTY = '!config';
var CLIENT_PROPERTY = '!client';

var JSON_REGEXP = /^application\/([\w!#\$%&\*`\-\.\^~]*\+)?json$/i;

var HTTP_METHODS         = ['get', 'head', 'put', 'post', 'patch', 'delete'];
var RETURN_PROPERTY      = '!return';
var DESCRIPTION_PROPERTY = '!description';
var CONFIG_OPTIONS       = [
  'body',
  'proxy',
  'uriParameters',
  'baseUri',
  'baseUriParameters',
  'headers',
  'query',
  'beforeSend'
];
var OVERRIDABLE_CONFIG_OPTIONS = _.object(
  ['body', 'proxy', 'baseUri', 'beforeSend'], true
);

/**
 * Static description of the media type extension function.
 *
 * @type {Object}
 */
var EXTENSION_DESCRIPTION = {
  '!type': 'fn(extension)',
  '!args': [{
    '!type': 'string',
    '!doc':  'Set the file extension with relevant `Accept` header.'
  }],
  '!doc': [
    'Set the path extension and corresponding accept header.'
  ].join(' ')
};

/**
 * Static description of the client object.
 *
 * @type {Object}
 */
var CLIENT_DESCRIPTION = {
  '!type': 'fn(url, data?)',
  '!args': [{
    '!type': 'string',
    '!doc':  'Provide a url relative to the base uri.'
  }, {
    '!type': 'object',
    '!doc':  'Provide a data object to replace template tags in the `url`.'
  }],
  '!doc': [
    'Make an API request to a custom URL.'
  ].join(' ')
};

/**
 * Map the supported auth types to the known triggers.
 *
 * @type {Object}
 */
var authMap = {
  'OAuth 1.0':            'oauth1',
  'OAuth 2.0':            'oauth2',
  'Basic Authentication': 'basicAuth'
};

/**
 * Transform a data object into a form data instance.
 *
 * @param  {Object}   data
 * @return {FormData}
 */
var toFormData = function (data) {
  var form = new FormData();

  // Iterate over every piece of data and append to the form data object.
  _.each(data, function (value, key) {
    form.append(key, value);
  });

  return form;
};

/**
 * Map mime types to their parsers.
 *
 * @type {Object}
 */
var parse = [
  [JSON_REGEXP, JSON.parse],
  ['application/x-www-form-urlencoded', qs.parse]
];

/**
 * Map mime types to their serializers.
 *
 * @type {Object}
 */
var serialize = [
  [JSON_REGEXP, JSON.stringify],
  ['application/x-www-form-urlencoded', qs.stringify],
  ['multipart/form-data', toFormData]
];

/**
 * Iterate over an array of match and result values, and return the
 * first matching value.
 *
 * @param  {Array}    array
 * @param  {String}   test
 * @return {Function}
 */
var getMatch = function (array, test) {
  var match = _.find(array, function (value) {
    var check = value[0];

    if (_.isRegExp(check)) {
      return check.test(test);
    }

    return check === test;
  });

  return match && match[1];
};

/**
 * Sort mimes by preference.
 *
 * @param  {String} mime
 * @return {Number}
 */
var mimePreference = function (mime) {
  return getMatch([
    [JSON_REGEXP, 3],
    ['application/x-www-form-urlencoded', 2],
    ['multipart/form-data', 1]
  ], mime) || 0;
};

/**
 * Turn a string into inline code.
 *
 * @param  {String} str
 * @return {String}
 */
var codifyMarkdown = function (str) {
  return '`' + str + '`';
};

/**
 * Convert a raml body object to a markdown documentation string.
 *
 * @param  {Object} body
 * @return {String}
 */
var ramlBodyToMarkdown = function (body) {
  var mimes         = _.keys(body).sort(mimePreference);
  var documentation = [];

  // If multiple mime types are supported, add a default mime type usage note.
  if (mimes.length > 1) {
    documentation.push(
      'The body for this resource supports multiple content types. By ' +
      'default, ' + codifyMarkdown(mimes[0]) + ' will be used. However, you ' +
      'can easily specify another `Content-Type` to be used.'
    );
  }

  // Iterate over each mime type and append documentation.
  _.each(mimes, function (mime) {
    var contentType = body[mime];

    // Avoid building documentation if it's not an object.
    if (!_.isObject(contentType)) {
      return;
    }

    // If there are multiple available mime types, we need to prefix each
    // definition with some text about the current mime type.
    if (mimes.length > 1) {
      documentation.push(
        'When the content type is ' + codifyMarkdown(mime) + ':'
      );
    }

    // Append the available form parameters to the markdown content.
    if (contentType.formParameters) {
      // Iterate over each form parameter and generate basic documentation.
      _.each(contentType.formParameters, function (param, key) {
        documentation.push(
          '* **' + key + (param.required ? '' : '?') + ':** ' +
          '*' + param.type + '* ' + param.description
        );
      });
    }

    // Push the example onto the description for reference.
    if (contentType.example || contentType.examples) {
      (function () {
        var example = contentType.example || userfriendlifyExamples(contentType.examples);
        if (typeof example !== 'string') {
          example = JSON.stringify(example, null, 2);
        }

        documentation.push(
          '**Example(s):**',
          '```\n' + example + '\n```'
        );
      })();
    }

    // Push the schema onto the description for reference.
    if (contentType.schema) {
      documentation.push(
        '**Schema:**',
        '```\n' + contentType.schema + '\n```'
      );
    }
  });

  return documentation.join('\n\n');
};

var userfriendlifyExamples = function (examples) {
  var newExamples = {};

  examples.forEach(function (example, index) {
    newExamples[example.name || ('Example #' + index + 1)] = example.value.content || example.value;
  });

  return newExamples;
};

/**
 * Check if a method is a query method (not a body as the argument).
 *
 * @param  {String}  method
 * @return {Boolean}
 */
var isQueryMethod = function (method) {
  return method === 'get' || method === 'head';
};

/**
 * Map of methods to their tooltip description objects.
 *
 * @type {Object}
 */
var METHOD_DESCRIPTION = _.object(_.map(HTTP_METHODS, function (method) {
  var body = isQueryMethod(method) ? 'query?' : 'body?';

  return [method, {
    '!type': 'fn(' + body + ', options?, async?)'
  }];
}));

/**
 * Convert a raml object into a documentation object.
 *
 * @param  {Object} object
 * @return {Object}
 */
var ramlToDocumentationFormat = function (object) {
  var documentation = {};

  // Iterate over each key and wipe out wipe a clean documentation object.
  _.each(object, function (object, key) {
    documentation[key] = {
      '!doc':      object.description,
      '!type':     object.type,
      '!required': object.required
    };
  });

  return documentation;
};

/**
 * Transform a RAML method object into a tooltip documentation object.
 *
 * @param  {Array}  nodes
 * @param  {Object} method
 * @return {Object}
 */
var toMethodDescription = function (nodes, method) {
  var isQuery       = isQueryMethod(method.method);
  var configOptions = { '!type': 'object' };
  var bodyOptions   = { '!type': 'object' };

  var callbackOptions = {
    '!doc':  'Pass a function to make the request execute asynchonously.',
    '!type': 'fn(error, response)'
  };

  // Add documentation on the proxy.
  configOptions.proxy = {
    '!type': 'string|boolean',
    '!doc':  'Disable or set a custom proxy url for the current request.'
  };

  // Document the `beforeSend` ability.
  configOptions.beforeSend = {
    '!type': 'fn(xhr)',
    '!doc':  'Modify the `XMLHttpRequest` before it gets sent.'
  };

  // Add documentation on header parameters.
  configOptions.headers = _.extend({
    '!type': 'object'
  }, ramlToDocumentationFormat(method.headers));

  // If the method is a query method (GET/HEAD), set the body as a config option
  // and vise versa.
  if (isQuery) {
    _.extend(bodyOptions, ramlToDocumentationFormat(method.queryParameters));

    configOptions.body = {
      '!type': 'object',
      '!doc':  ramlBodyToMarkdown(method.body)
    };
  } else {
    bodyOptions = {
      '!type': 'object|string',
      '!doc':  ramlBodyToMarkdown(method.body),
    };

    configOptions.query = _.extend({
      '!type': 'object'
    }, ramlToDocumentationFormat(method.queryParameters));
  }

  // If the current node has baseUriParameters, show it in the documentation.
  if (nodes.client.baseUriParameters) {
    configOptions.baseUriParameters = _.extend({
      '!type': 'object'
    }, ramlToDocumentationFormat(nodes.client.baseUriParameters));
  }

  return _.extend({
    '!doc':  method.description,
    '!args': [bodyOptions, configOptions, callbackOptions]
  }, METHOD_DESCRIPTION[method.method]);
};

/**
 * List of all plain HTTP methods in the format from the AST.
 *
 * @type {Object}
 */
var allHttpMethods = _.chain(HTTP_METHODS).map(function (method) {
    return [method, {
      method: method
    }];
  }).object().value();

/**
 * Parse an XHR request for response headers and return as an object. Pass an
 * additional flag to filter any potential duplicate headers (E.g. different
 * cases).
 *
 * @param  {Object} xhr
 * @return {Object}
 */
var getAllReponseHeaders = function (xhr) {
  var responseHeaders = {};

  _.each(xhr.getAllResponseHeaders().split('\n'), function (header) {
    header = header.split(':');

    // Make sure we have both parts of the header.
    if (header.length > 1) {
      var name  = header.shift();
      var value = header.join(':').trim();

      responseHeaders[name.toLowerCase()] = value;
    }
  });

  return responseHeaders;
};

/**
 * Return the xhr response mime type.
 *
 * @param  {String} contentType
 * @return {String}
 */
var getMime = function (contentType) {
  return contentType == null ? null : String(contentType).split(';')[0];
};

/**
 * Check if an object is a host object and avoid serializing.
 *
 * @param  {Object}  obj
 * @return {Boolean}
 */
var isHost = function (obj) {
  var str = Object.prototype.toString.call(obj);

  switch (str) {
    case '[object File]':
    case '[object Blob]':
    case '[object String]':
    case '[object Number]':
    case '[object Boolean]':
    case '[object FormData]':
      return true;
    default:
      return false;
  }
};

/**
 * Sanitize a specific configuration option.
 *
 * @type {Object}
 */
var sanitizeOption = {
  query: function (query) {
    if (_.isString(query)) {
      return qs.parse(query);
    }

    return query;
  }
};

/**
 * Gets a header from the header object.
 *
 * @param  {Object}  headers
 * @param  {String}  header
 * @return {Boolean}
 */
var findHeader = function (headers, header) {
  header = header.toLowerCase();

  return _.find(headers, function (value, name) {
    return name.toLowerCase() === header;
  });
};

/**
 * Sanitize the XHR request into the desired format.
 *
 * @param  {XMLHttpRequest} xhr
 * @return {Object}
 */
var sanitizeXHR = function (xhr) {
  if (!xhr) { return xhr; }

  var mime    = getMime(xhr.getResponseHeader('Content-Type'));
  var body    = xhr.responseText.trim();
  var headers = getAllReponseHeaders(xhr);

  // Automatically parse all response bodies. Only parse when we have response
  // body content. Errors that occur parsing will be propagated to the client.
  body = body ? (getMatch(parse, mime) || _.identity)(body) : undefined;

  return {
    body:    body,
    status:  xhr.status,
    headers: headers
  };
};

/**
 * Returns a function that can be used to make ajax requests.
 *
 * @param  {String}   url
 * @return {Function}
 */
var httpRequest = function (nodes, method) {
  return function (body, config, done) {
    // Allow config to be omitted from arguments.
    if (_.isFunction(arguments[1])) {
      done   = arguments[1];
      config = null;
    }

    config = config || {};

    // Map configuration options and merge with the passed in object.
    config = _.object(CONFIG_OPTIONS, _.map(CONFIG_OPTIONS, function (option) {
      if (_.has(OVERRIDABLE_CONFIG_OPTIONS, option)) {
        return _.has(config, option) ? config[option] : nodes.config[option];
      }

      var nodeOption   = nodes.config[option];
      var configOption = config && config[option];
      var sanitize     = sanitizeOption[option] || _.identity;

      return _.extend({}, sanitize(nodeOption), sanitize(configOption));
    }));

    var async   = !!done;
    var request = 'ajax';
    var mime    = getMime(findHeader(config.headers, 'Content-Type'));
    var baseUri = template(config.baseUri, config.baseUriParameters);
    var fullUri = baseUri.replace(/\/+$/, '') + '/' + nodes.join('/');

    // If the request is async, set the relevant function callbacks.
    if (async) {
      App._executeContext.timeout(Infinity);

      if (!_.isFunction(done)) {
        done = App._executeContext.async();
      }
    } else {
      // Synchronous error and response handling.
      done = function (err, res) {
        if (err) {
          throw err;
        }

        return res;
      };
    }

    // GET and HEAD requests accept the query string as the first argument.
    if (isQueryMethod(method.method)) {
      _.extend(config.query, sanitizeOption.query(body));
      body = null;
    }

    // Set the config object body to the passed in body.
    if (body != null) {
      config.body = body;
    }

    // Append the query string if one is available.
    if (_.keys(config.query).length) {
      fullUri += '?' + qs.stringify(config.query);
    }

    // If we have no accept header set already, default to accepting
    // everything. This is required because Firefox sets the base accept
    // header to essentially be `html/xml`.
    if (!findHeader(config.headers, 'accept')) {
      config.headers.accept = '*/*';
    }

    // If we were passed in data, attempt to sanitize it to the correct type.
    if (!isHost(config.body)) {
      // Set the correct `Content-Type` header, if none exists. Kind of random
      // if more than one exists - I would suggest setting it yourself.
      if (mime == null) {
        // If we have a method body object, sort the method types by most
        // desirable and fallback to a random content type.
        if (typeof method.body === 'object') {
          mime = _.keys(method.body).sort(mimePreference).pop();
        }

        // Set the config to the updated mime type header. If none exists, use
        // `application/json` by default.
        config.headers['Content-Type'] = mime = mime || 'application/json';
      }

      // Automatically attempt to serialize the body.
      var serializer = getMatch(serialize, mime);

      if (!serializer) {
        return done(
          new TypeError('Can not serialize content type of "' + mime + '"')
        );
      }

      try {
        config.body = serializer(config.body);
      } catch (e) {
        return done(new TypeError('Could not serialize body: ' + e.message));
      }
    }

    var options = {
      url:        fullUri,
      data:       config.body,
      async:      async,
      proxy:      config.proxy,
      method:     method.method,
      headers:    config.headers,
      beforeSend: config.beforeSend
    };

    // Iterate through `securedBy` methods and accept the first one we are
    // already authenticated for.
    _.some(method.securedBy || nodes.client.securedBy, function (secured, key) {
      var scheme = nodes.client.securitySchemes[key];

      // Scheme is not documented in the RAML security schemes.
      if (!scheme) {
        return;
      }

      var authenticated = nodes.client.authentication[scheme.type];
      var authType      = authMap[scheme.type];

      if (authenticated) {
        options[authType] = authenticated;

        return (request = 'ajax:' + authType);
      }
    });

    // Awkward sync and async code mixing.
    var response, error;

    // Trigger the ajax middleware so plugins can hook onto the requests. If
    // the function is async we need to register a callback for the middleware.
    App.middleware.trigger(request, options, function (err, xhr) {
      error = err;

      if (!error) {
        try {
          response = sanitizeXHR(xhr);
        } catch (e) {
          error = new TypeError('Could not parse response: ' + e.message);
        }
      }

      return async && done(error, response);
    });

    // If the request was synchronous, return the sanitized XHR response data.
    if (!async) {
      return done(error, response);
    }
  };
};

/**
 * Attaches XHR request methods to the context object for each available method.
 *
 * @param  {Array}  nodes
 * @param  {Object} context
 * @param  {Object} methods
 * @return {Object}
 */
var attachMethods = function (nodes, context, methods) {
  // Attach the available methods to the current context.
  _.each(methods, function (method, verb) {
    context[verb] = httpRequest(nodes, method);
    context[verb][DESCRIPTION_PROPERTY] = toMethodDescription(nodes, method);
  });

  return context;
};

/**
 * Attach a special media extension handler.
 *
 * @param  {Array}  nodes
 * @param  {Object} context
 * @param  {Object} resource
 * @return {Object}
 */
var attachMediaTypeExtension = function (nodes, context, resource) {
  /**
   * Push the extension onto the current route and set relevant headers.
   *
   * @param  {String} extension
   * @return {Object}
   */
  context.extension = function (extension) {
    extension = extension == null ? '' : String(extension);

    // Prepend a period to the extension before adding to the route.
    if (extension && extension.charAt(0) !== '.') {
      extension = '.' + extension;
    }

    var newContext = {};
    var routeNodes = _.extend([], nodes);

    // Append the extension to the current route.
    routeNodes[routeNodes.length - 1] += extension;

    attachMethods(routeNodes, newContext, resource.methods);
    attachResources(routeNodes, newContext, resource.resources);

    return newContext;
  };

  // Attach a description and return property.
  context.extension[RETURN_PROPERTY]      = context.extension('');
  context.extension[DESCRIPTION_PROPERTY] = EXTENSION_DESCRIPTION;

  // If the media type extension is not required, allow direct invocation of
  // the request method.
  if (resource.uriParameters.mediaTypeExtension.required === false) {
    attachMethods(nodes, context, resource.methods);
  }

  // Iterate over the enum options and automatically attach to the context.
  _.each(resource.uriParameters.mediaTypeExtension.enum, function (extension) {
    if (extension.charAt(0) === '.') {
      extension = extension.substr(1);
    }

    context[extension] = context.extension(extension);
  });

  return context;
};

/**
 * Generate a context or attach methods and resources to an existing context.
 *
 * @param  {Array}   nodes
 * @param  {Object}  resource
 * @param  {Boolean} hasMediaExtension
 * @param  {Object}  context
 * @return {Object}
 */
var newContext = function (nodes, resource, hasMediaExtension, context) {
  context = context || {};

  if (hasMediaExtension) {
    attachMediaTypeExtension(nodes, context, resource);
  } else {
    attachMethods(nodes, context, resource.methods);
    attachResources(nodes, context, resource.resources);
  }

  return context;
};

/**
 * Recurses through a resource object in the RAML AST, generating a dynamic
 * DSL that only allows methods that were defined in the RAML spec.
 *
 * @param  {Array}  nodes
 * @param  {Object} context
 * @param  {Object} resources
 * @return {Object}
 */

/* jshint -W003 */
var attachResources = function (nodes, context, resources) {
  _.each(resources, function (resource, route) {
    var routeNodes        = _.extend([], nodes);
    var routeName         = route;
    var hasMediaExtension = route.substr(-20) === '{mediaTypeExtension}';

    // Ignore media type extensions in route generation.
    if (hasMediaExtension) {
      route = routeName = route.slice(0, -20);
    }

    // Check the route against our valid uri parameters.
    var templateTags = route.match(template.REGEXP);

    // Push the current route into the route array.
    routeNodes.push(route);

    // If we have template tags available, attach a dynamic route.
    if (templateTags) {
      var routeSuffix = templateTags.join('');

      // The route must end with the chained template tags and have no
      // text between tags.
      if (route.substr(-routeSuffix.length) !== routeSuffix) {
        return false;
      }

      // If the route is only a template tag with no static text, use the
      // template tag text as the method name.
      if (templateTags.length === 1 && route === templateTags[0]) {
        routeName = templateTags[0].slice(1, -1);
      } else {
        routeName = route.substr(0, route.indexOf('{'));
      }

      // Avoid adding empty route name cases. This can occur when we have
      // multiple tag names and no front text. For example, `{this}{that}`.
      // This could also occur if for some reason we are passing in a route that
      // isn't dynamic.
      if (!routeName) {
        return false;
      }

      // Get the ordered tag names for completion.
      var tags = _.map(templateTags, function (param) {
        return resource.uriParameters[param.slice(1, -1)];
      });

      // The route is dynamic, so we set the route name to be a function
      // which accepts the template arguments and updates the path fragment.
      // We'll extend any route already at the same namespace so we can do
      // things like use both `/{route}` and `/route`, if needed.
      context[routeName] = _.extend(function () {
        var args = arguments;

        // Map the tags to the arguments or default arguments.
        var parts = _.map(tags, function (tag, index) {
          // Inject enum parameters if there is only one available enum.
          // TODO: When/if we add validation back, have these routes
          // be generated instead of typed out.
          if (args[index] == null && tag.enum && tag.enum.length === 1) {
            return tag.enum[0];
          }

          // Use any passed in argument - even it's falsy.
          if (index in args) {
            return args[index];
          }

          var param = templateTags[index].slice(1, -1);

          // Fallback to injecting the fallback configuration uri parameter.
          return routeNodes.config && routeNodes.config.uriParameters[param];
        });

        // Change the last path fragment to the proper template text.
        routeNodes[routeNodes.length - 1] = template(route, parts);

        return newContext(routeNodes, resource, hasMediaExtension);
      }, context[routeName]);

      // Generate the description object for helping tooltip display.
      context[routeName][DESCRIPTION_PROPERTY] = {
        '!type': 'fn(' + _.map(tags, function (param) {
          return param.displayName + (param.required ? '' : '?');
        }).join(', ') + ')',
        '!args': _.map(tags, function (param) {
          return {
            '!type': param.type,
            '!doc':  param.description
          };
        }),
        '!doc': 'Dynamically inject variables into the request path.'
      };

      // Generate the return property for helping autocompletion.
      context[routeName][RETURN_PROPERTY] = newContext(
        routeNodes, resource, hasMediaExtension
      );

      return context[routeName];
    }

    // Handle root `/` resources.
    if (!routeName) {
      context = newContext(routeNodes, resource, hasMediaExtension, context);
    } else {
      context[routeName] = newContext(
        routeNodes, resource, hasMediaExtension, context[routeName]
      );
    }
  });

  return context;
};
/* jshint +W003 */

/**
 * Generate the client object from a sanitized AST object.
 *
 * @param  {Object} ast Passed through `sanitizeAST`
 * @return {Object}
 */
var generateClient = function (ast, config) {
  // Generate the base uri parameters and defaults.
  var baseUriParameters = _.extend(
    {}, _.pick(ast, 'version'), config.baseUriParameters
  );

  // Generate the root node array. Set properties directly on this array to be
  // copied to the next execution part. We have a global configuration object
  // which can be altered externally at any point, as well as when we finally
  // make a request. For this reason, it's important that we use objects which
  // are passed by reference.
  var nodes = _.extend([], {
    config: _.extend({
      baseUri: ast.baseUri
    }, config, {
      baseUriParameters: baseUriParameters
    }),
    client: {
      securedBy:         ast.securedBy,
      authentication:    {},
      securitySchemes:   ast.securitySchemes,
      baseUriParameters: ast.baseUriParameters
    }
  });

  // Throw an error if the baseUri string is missing.
  if (!_.isString(nodes.config.baseUri)) {
    throw new Error('A "baseUri" string is required');
  }

  /**
   * The root client implementation is simply a function. This allows us to
   * enter a custom path that may not be supported by the DSL and run any
   * method regardless of whether it was defined in the spec.
   *
   * @param  {String} path
   * @param  {Object} context
   * @return {Object}
   */
  var client = function (path, context) {
    var route = template(
      path || '', context || {}
    ).replace(/^\/+/, '').split('/');

    return attachMethods(_.extend([], nodes, route), {}, allHttpMethods);
  };

  client[CONFIG_PROPERTY]      = nodes.config;
  client[CLIENT_PROPERTY]      = nodes.client;
  client[DESCRIPTION_PROPERTY] = CLIENT_DESCRIPTION;
  client[RETURN_PROPERTY]      = attachMethods(nodes, {}, allHttpMethods);

  attachResources(nodes, client, ast.resources);

  return client;
};

/**
 * Exports the client generator, which accepts the AST of a RAML document.
 *
 * @return {Object} Dynamic object for constructing API requests from the AST.
 */
module.exports = function (ast, config) {
  return generateClient(sanitizeAST(ast), config);
};

},{"./sanitize-ast":73,"./template":74}],73:[function(require,module,exports){
/* global App */
var _ = App.Library._;

/**
 * Sanitize the secured by into an object.
 *
 * @param  {Array}  secured
 * @return {Object}
 */
var sanitizeSecuredBy = function (secured) {
  if (!Array.isArray(secured)) {
    return null;
  }

  var securedBy = {};

  // Since `securedBy` can either be an array of strings or array of objects
  // with only a single key, we merge it down to an object.
  _.each(secured, function (value) {
    if (value == null) {
      return; // Ignore `null` array values, shouldn't be useful to me.
    }

    if (_.isString(value)) {
      return securedBy[value] = true;
    }

    return _.extend(securedBy, value);
  });

  return securedBy;
};

/**
 * Sanitize the AST from the RAML parser into something easier to work with.
 *
 * @param  {Object} ast
 * @return {Object}
 */
module.exports = function (ast) {
  // Create the base sanitized ast with only the properties we want.
  var sanitizedAst = _.pick(ast, [
    'title',
    'version',
    'baseUri',
    'baseUriParameters'
  ]);

  // Merge an array of objects into a single object using `_.extend` and
  // `apply` (since `_.extend` accepts unlimited number of arguments).
  if (ast.securitySchemes) {
    sanitizedAst.securitySchemes = _.extend.apply(_, ast.securitySchemes);
  }

  // Sanitize secured by which is a bit more complicated than extending.
  if (ast.securedBy) {
    sanitizedAst.securedBy = sanitizeSecuredBy(ast.securedBy);
  }

  // Recurse through the resources and move URIs to be the key names.
  sanitizedAst.resources = (function flattenResources (resources) {
    var map = {};

    // Resources are provided as an array, we'll move them to be an object.
    _.each(resources, function (resource) {
      var sanitizedResource = {};

      // Methods are implemented as arrays of objects too, but not recursively.
      // TODO: If the endpoint is the final route and has no methods, implement
      // backtracking and remove access to it from the AST.
      if (resource.methods) {
        sanitizedResource.methods = _.object(
          _.pluck(resource.methods, 'method'),
          _.map(resource.methods, function (method) {
            // Create the sanitized method by including the properties we want.
            var sanitizedMethod = _.pick(method, [
              'method',
              'body',
              'headers',
              'description',
              'queryParameters'
            ]);

            // Sanitize the `securedBy` method.
            if (method.securedBy) {
              sanitizedMethod.securedBy = sanitizeSecuredBy(method.securedBy);
            }

            return sanitizedMethod;
          })
        );
      }

      if (resource.resources) {
        sanitizedResource.resources = flattenResources(resource.resources);
      }

      (function attachResource (map, segments) {
        var segment = segments.shift();
        var part    = map[segment] = map[segment] || {};

        // Currently on the last url segment, embed the full resource.
        if (!segments.length) {
          part = map[segment] = sanitizedResource;
        }

        // Pull any possible tags out of the relative uri part.
        var tags = _.map(segment.match(/\{([^\}]+)\}/g), function (tag) {
          return tag.slice(1, -1);
        });

        // Add only the used tags to the current resource segment.
        if (tags.length) {
          part.uriParameters = _.pick(resource.uriParameters, tags);
        }

        // If we have more segment parts left, recursively embed resources.
        if (segments.length) {
          part.resources = part.resources || {};

          return attachResource(part.resources, segments);
        }
      })(map, resource.relativeUri.substr(1).split('/'));
    });

    return map;
  })(ast.resources);

  return sanitizedAst;
};

},{}],74:[function(require,module,exports){
/* global App */
var _ = App.Library._;

/**
 * Match raml uri parameters in a uri.
 *
 * @type {RegExp}
 */
var URI_PARAM_REGEXP = /{[^}]+}/g;

/**
 * Simple "template" function for working with the uri param variables.
 *
 * @param  {String}         template
 * @param  {(Object|Array)} context
 * @return {String}
 */
exports = module.exports = function (string, context) {
  context = context || {};

  // No uri string has been specified.
  if (string == null) {
    return null;
  }

  // If the context is an array, we need to transform the replacements into
  // index based positions for the uri template parser.
  if (_.isArray(context)) {
    var index = 0;

    return string.replace(URI_PARAM_REGEXP, function () {
      return encodeURIComponent(context[index++] || '');
    });
  }

  return string.replace(URI_PARAM_REGEXP, function (match) {
    return encodeURIComponent(context[match.slice(1, -1)] || '');
  });
};

/**
 * Export the replacement regexp.
 */
exports.REGEXP = URI_PARAM_REGEXP;

},{}],75:[function(require,module,exports){
/* global App */
var _               = App._;
var ramlParser      = require('raml-parser');
var authenticate    = require('./authenticate');
var clientGenerator = require('./client-generator');
var fromPath        = require('../../lib/from-path');

/**
 * Implementation helpers.
 */
require('./inject-api-keys');
require('./insert-api-client');

/**
 * Provided a special documentation property for functionsw with another plugin.
 *
 * @type {String}
 */
var DESCRIPTION_PROPERTY = '!description';

/**
 * Custom file reader for RAML specs.
 *
 * @param  {String}  url
 * @return {Q.defer}
 */
var createReader = function (config) {
  return new ramlParser.FileReader(function (url) {
    var deferred = this.q.defer();

    App.middleware.trigger('ajax', {
      url: url,
      proxy: config.proxy,
      headers: {
        'Accept': 'application/raml+yaml, */*'
      }
    }, function (err, xhr) {
      if (err) {
        return deferred.reject(err);
      }

      if (Math.floor(xhr.status / 100) !== 2) {
        return deferred.reject(
          new Error('Received status code ' + xhr.status + ' loading ' + url)
        );
      }

      return deferred.resolve(xhr.responseText);
    });

    return deferred.promise;
  });
};

/**
 * The Api object is used in the execution context.
 *
 * @type {Object}
 */
var API = {};

/**
 * Responsible for loading RAML documents and return API clients.
 *
 * @param {String}   name
 * @param {String}   uri
 * @param {Object}   [config]
 * @param {Function} done
 */
API.createClient = function (name, uri, config, done) {
  if (!_.isString(name)) {
    throw new Error('Provide a name for the generated client');
  }

  if (!_.isString(uri)) {
    throw new Error('Provide a URL for the ' + name + ' RAML document');
  }

  // Allow the config object to be skipped.
  if (typeof config === 'function') {
    done   = arguments[2];
    config = {};
  }

  App._executeContext.timeout(Infinity);
  done   = done   || App._executeContext.async();
  config = config || {};

  /**
   * Generate and attach the RAML client from the AST.
   *
   * @param  {Object} ast
   */
  var createClient = function (ast) {
    try {
      fromPath(
        App._executeWindow, name.split('.'), clientGenerator(ast, config)
      );
    } catch (e) {
      return done(e);
    }

    return done(
      null,
      'Create a new code cell and type "' + name + '." to explore this API.'
    );
  };

  /**
   * Manually initialise the first ajax request to support JSON responses.
   */
  return App.middleware.trigger('ajax', {
    url:   uri,
    proxy: config.proxy,
    headers: {
      'Accept': 'application/raml+yaml, application/json, */*'
    }
  }, function (err, xhr) {
    if (err) {
      return done(err);
    }

    if (Math.floor(xhr.status / 100) !== 2) {
      return done(new Error('HTTP ' + xhr.status));
    }

    // Support JSON responses. Originally this checked the response content
    // types, etc. but it's just as easy to attempt parsing as JSON and if it
    // fails pass it onto the raml parser.
    try {
      return createClient(JSON.parse(xhr.responseText));
    } catch (e) {}

    // Pass our url to the RAML parser for processing and transform the promise
    // back into a callback format.
    return ramlParser.load(xhr.responseText, uri, {
      reader: createReader(config)
    }).then(createClient, done);
  });

};

/**
 * Description of the create client function.
 */
API.createClient[DESCRIPTION_PROPERTY] = {
  '!type': 'fn(alias, url, options?, cb?)',
  '!args': [{
    '!type': 'string'
  }, {
    '!type': 'string'
  }, {
    '!type': 'object',
    '!doc': [
      'Initialize the client with default config options. Valid options:',
      '* **proxy**: Set to a custom proxy or `false` to disable entirely',
      '* **body**: Set a fallback request body',
      '* **uriParameters**: Set fallback uri parameters to inject',
      '* **baseUri:** Override the base uri',
      '* **baseUriParameters**: Inject base uri parameters to override',
      '* **headers**: Set default headers to send with every request',
      '* **query**: Set a default query string to send with every request'
    ].join('\n')
  }, {
    '!type': 'fn(error, client)',
    '!doc': [
      'Pass in a custom callback to run when the client has loaded.'
    ].join('\n')
  }],
  '!doc': [
    'Generate an API client from a RAML document and alias it on the window.'
  ].join(' ')
};

/**
 * Set a configuration value on a client.
 *
 * @param {Function} client
 * @param {String}   key
 * @param {*}        value
 */
API.set = function (client, key, value) {
  // If we don't have enough arguments for a key and value, assume we have
  // a fresh configuration object.
  if (arguments.length < 3) {
    return _.extend(client['!config'], key);
  }

  return client['!config'][key] = value;
};

/**
 * Set the description of the API client configuration setter.
 */
API.set[DESCRIPTION_PROPERTY] = {
  '!type': 'fn(client, key, value)',
  '!args': [{
    '!type': 'fn()',
    '!doc': 'A function generated by `API.createClient`.'
  }, {
    '!type': 'string'
  }],
  '!doc': 'Set a configuration option of a RAML API client.'
};

/**
 * Retrieve a value from the client config object.
 *
 * @param  {Function} client
 * @param  {String}   key
 * @return {*}
 */
API.get = function (client, key) {
  if (arguments.length < 2) {
    return client['!config'];
  }

  return client['!config'][key];
};

/**
 * Set the description of the API client configuration getter.
 */
API.get[DESCRIPTION_PROPERTY] = {
  '!type': 'fn(client, key)',
  '!args': [{
    '!type': 'fn()',
    '!doc': 'A function generated by `API.createClient`.'
  }, {
    '!type': 'string'
  }],
  '!doc': 'Get a configuration option from a RAML API client.'
};

/**
 * Unset a key from the client configuration.
 *
 * @param  {Function} client
 * @param  {String}   key
 * @return {Boolean}
 */
API.unset = function (client, key) {
  if (arguments.length < 2) {
    _.each(client['!config'], function (value, key, obj) {
      delete obj[key];
    });

    return true;
  }

  return delete client['!config'][key];
};

/**
 * Set the description of the API client configuration unsetter.
 */
API.unset[DESCRIPTION_PROPERTY] = {
  '!type': 'fn(client, key)',
  '!args': [{
    '!type': 'fn()',
    '!doc': 'A function generated by `API.createClient`.'
  }, {
    '!type': 'string'
  }],
  '!doc': 'Unset a configuration option from a RAML API client.'
};

/**
 * Authenticate a RAML API client passing an optional method and accompanying
 * options object.
 *
 * @param {Function} client
 * @param {String}   method
 * @param {Object}   options
 * @param {Function} done
 */
API.authenticate = function (client, method, options, done) {
  App._executeContext.timeout(10 * 60 * 1000);
  done = done || App._executeContext.async();

  var clientOption    = client['!client'];
  var securitySchemes = clientOption.securitySchemes;

  // Extend passed in options with global options (for `baseUriParameters`).
  options = _.extend({}, options, client['!config']);

  /**
   * The callback is used to handle the persistence of data to the client.
   *
   * @param  {Error}    err
   * @param  {Object}   scheme
   * @param  {Object}   options
   * @param  {Object}   tokens
   * @return {Function}
   */
  var cb = function (err, scheme, options, tokens) {
    if (err) {
      return done(err);
    }

    // Alias onto the client object for future use.
    clientOption.authentication[scheme.type] = _.extend({}, options, tokens);

    // Set private fields to asterisks of an arbitrary length.
    _.each(tokens, function (value, key) {
      if (authenticate.SECRET_FIELDS[key]) {
        tokens[key] = new Array(Math.ceil(value.length / 5) * 5).join('*');
      }
    });

    return done(null, tokens);
  };

  return authenticate(securitySchemes, method, options, cb);
};

/**
 * Set the description of the API client authenticator.
 */
API.authenticate[DESCRIPTION_PROPERTY] = {
  '!type': [
    'fn(client, method?, options?, cb?)'
  ].join(''),
  '!args': [{
    '!type': 'fn()',
    '!doc': 'A function generated by `API.createClient`.'
  }, {
    '!type': 'string',
    '!doc': 'Select an authentication method defined in the RAML file.'
  }, {
    '!type': 'object',
    '!doc': 'Override the default selected authentication method options.'
  }, {
    '!type': 'fn(error, response)'
  }],
  '!doc': [
    'Authentication parameters are optional. For popular APIs, we provide',
    'keys. If we need your keys we will prompt you via a modal. Never enter',
    'keys directly into a notebook unless you explicitly intend to share',
    'them. If you would like to know more about authenticating',
    'with this API, see \'securityScheme.settings\' in the RAML file.'
  ].join(' ')
};

/**
 * Alter the context to include the RAML client generator.
 *
 * @param {Object}   data
 * @param {Function} next
 */
exports['sandbox:context'] = function (context, next) {
  // This is extremely janky, but is required for Safari 7.0 which seems to
  // be ignoring direct property assignments under certain conditions.
  Object.defineProperty(context, 'API', { value: API });
  return next();
};

},{"../../lib/from-path":70,"./authenticate":71,"./client-generator":72,"./inject-api-keys":76,"./insert-api-client":77,"raml-parser":42}],76:[function(require,module,exports){
/* global App */
var apiKeys = {"github":{"clientId":"stephanesan","clientSecret":"..."}}.ramlClient;

/**
 * Check against our OAuth tokens and inject the tokens we have available.
 *
 * @param {Object}   data
 * @param {Function} next
 */
App.middleware.register('ramlClient:token', function (scheme, next, done) {
  var authUri = scheme.settings.authorizationUri;

  if (scheme.type === 'OAuth 1.0' && apiKeys.oauth1[authUri]) {
    return done(null, apiKeys.oauth1[authUri]);
  }

  if (scheme.type === 'OAuth 2.0' && apiKeys.oauth2[authUri]) {
    return done(null, apiKeys.oauth2[authUri]);
  }

  return next();
});

},{}],77:[function(require,module,exports){
/* global App */
var _          = App.Library._;
var qs         = App.Library.qs;
var domify     = App.Library.domify;
var Backbone   = App.Library.Backbone;
var changeCase = App.Library.changeCase;

var BASE_URI = 'https://anypoint.mulesoft.com/apiplatform/repository/v2' +
  '/public/apis';
var ITEMS_PER_PAGE = 10;

/**
 * Create an api client cell that can load the selected api document.
 *
 * @param  {Cell}     cell
 * @param  {String}   invoke
 * @return {Function}
 */
var createApiClientCell = function (cell, invoke) {
  return function (err, api, version) {
    if (err) { return; }

    // Convert the API name into a variable for use.
    var variable = changeCase.camelCase(api.name);

    // Create the view with api creation details.
    var view = cell.notebook[invoke + 'CodeView'](cell.el, [
      '// Read about the ' + api.name + ' at ' + version.portalUrl,
      'API.createClient(\'' + variable + '\', \'' + version.ramlUrl + '\');'
    ].join('\n')).execute();

    cell.focus();

    // Trigger a raml client insertion message.
    App.messages.trigger('ramlClient:insert');

    return view;
  };
};

/**
 * Show RAML definitions to users in a modal, and upon selection pass the
 * selected definition back to the callback.
 *
 * @param {Function} done
 */
var selectAPIDefinition = function (done) {
  // Trigger modal display messages.
  App.messages.trigger('ramlClient:modal');

  /**
   * The current search specification object, passed to the middleware layer.
   *
   * @type {Object}
   */
  var searchSpec = {
    offset: 0,
    limit:  ITEMS_PER_PAGE,
    query:  ''
  };

  return App.middleware.trigger('ui:modal', {
    title: 'Insert an API Client',
    content: function (done) {
      return done(null, '<div class="modal-instructions">' +
        'Insert an API client from a RAML specification. An API client is ' +
        'a JavaScript representation of an API that you can use to explore ' +
        'available endpoints and their parameters. ' +
        '<a href="http://raml.org/" target="_blank">' +
        'Learn more about RAML</a>.' +
        '</div>' +
        '<div class="form-group">' +
        '<input class="item-search" placeholder="Search">' +
        '</div>' +
        '<div class="items-loading" ' +
        'style="text-align: center; font-size: 3em;">' +
        '<i class="icon-arrows-cw animate-spin"></i>' +
        '</div>' +
        '<div class="items-container clearfix">' +
        '<div class="items-container-total"></div>' +
        '<ul class="items-list"></ul>' +
        '<button class="btn-secondary items-prev-btn" style="float: left">' +
        'Previous</button>' +
        '<button class="btn-secondary items-next-btn" style="float: right">' +
        'Next</button>' +
        '</div>' +
        '<p class="items-unavailable">No matching APIs found.</p>'
      );
    },
    show: function (modal) {
      var itemsEl            = modal.el.querySelector('.items-container');
      var itemsListEl        = itemsEl.querySelector('.items-list');
      var itemsLoadingEl     = modal.el.querySelector('.items-loading');
      var itemsNextBtnEl     = itemsEl.querySelector('.items-next-btn');
      var itemsPrevBtnEl     = itemsEl.querySelector('.items-prev-btn');
      var itemsUnavailableEl = modal.el.querySelector('.items-unavailable');
      var totalItemsEl       = modal.el.querySelector('.items-container-total');
      var searchId;

      /**
       * Load all the API definitions and return the items as an array.
       *
       * @param {Function} done
       */
      var loadAPIDefinitions = function (search, done) {
        var currentSearchId = Math.random();

        // Track current search index.
        searchId = currentSearchId;

        // Reset element states and show a loading indicator.
        itemsEl.classList.add('hide');
        itemsUnavailableEl.classList.add('hide');
        itemsLoadingEl.classList.remove('hide');

        // Set both buttons to disabled for now.
        itemsNextBtnEl.setAttribute('disabled', 'disabled');
        itemsPrevBtnEl.setAttribute('disabled', 'disabled');

        return App.middleware.trigger(
          'ramlClient:search',
          search,
          function (err, data) {
            // Skip updates when the ID has changed.
            if (currentSearchId !== searchId) {
              return;
            }

            return done(err, data);
          }
        );
      };

      /**
       * Render the search results.
       *
       * @param {Error}  err
       * @param {Object} result
       * @param {Number} result.total
       * @param {Array}  result.items
       */
      var updateResults = function (err, result) {
        // Always remove the loading indicator.
        itemsLoadingEl.classList.add('hide');

        // Empty the list before we populate it again.
        itemsListEl.innerHTML = '';
        totalItemsEl.innerHTML = '';

        if (err) {
          return done(err);
        }

        if (result.items.length === 0) {
          return itemsUnavailableEl.classList.remove('hide');
        }

        totalItemsEl.appendChild(document.createTextNode(
          'Showing ' + result.items.length + ' of ' + result.total + ' results'
        ));

        itemsEl.classList.remove('hide');

        // If the offset is past the first page, allow going back.
        if (searchSpec.offset > 0) {
          itemsPrevBtnEl.removeAttribute('disabled');
        }

        // If the offset can still move before hitting the last result, allow.
        if (searchSpec.offset < result.total - searchSpec.limit) {
          itemsNextBtnEl.removeAttribute('disabled');
        }

        // Iterate over each version and append to the item list.
        _.each(result.items, function (item) {
          var name = _.escape(item.name);
          var masterOrg = _.escape(item.versions[0].masterOrganizationName);

          var el = domify([
            '<li>',
            '<div class="item-info clearfix">',
            '<div class="item-action">',
            '<button class="btn btn-primary btn-small item-add">Add</button>',
            '</div>',
            '<a href="#" class="item-link">All versions</a>',
            '<div class="item-name">' +
            name + ' <small>' + masterOrg + '</small>' +
            '</div>',
            '</div>',
            '<div class="item-versions">',
            _.map(item.versions, function (version, index) {
              var name        = _.escape(version.name);
              var description = _.escape(version.description).trim();
              var portalUrl   = _.escape(version.portalUrl);

              return [
                '<div class="item-version clearfix">',
                '<div class="item-action">',
                '<button class="btn btn-primary btn-small item-add" ' +
                'data-index="' + index + '">',
                'Select',
                '</button>',
                '</div>',
                '<a href="' + portalUrl + '" class="item-link ' +
                'item-read-more" target="_blank">Read more</a>',
                '<div class="item-name">',
                description ?
                  '<span class="hint--top" data-hint="' + description + '">' :
                  '',
                name,
                description ? '</span>' : '',
                '</div>',
                '</div>'
              ].join('\n');
            }).join('\n'),
            '</div>',
            '</li>'
          ].join('\n'));

          itemsListEl.appendChild(el);

          // When the element is clicked, render the code cell.
          Backbone.$(el)
            .on('click', function (e) {
              // Do nothing if the read more link is clicked.
              if (e.target.classList.contains('item-read-more')) {
                return;
              }

              // Prevent following of links.
              e.preventDefault();

              var method = 'add';

              // Remove the attribute if it exists.
              if (el.classList.contains('item-visible')) {
                method = 'remove';
              }

              el.classList[method]('item-visible');
            })
            .on('click', '.item-add', function (e, el) {
              modal.close();
              e.stopPropagation();

              // Resolve to the clicked API version, or "latest".
              var version = item.versions[el.getAttribute('data-index') || 0];

              return done(null, item, version);
            });
        });
      };

      Backbone.$(modal.el)
        .on('click', '.items-next-btn', function () {
          return loadAPIDefinitions(_.extend(searchSpec, {
            offset: searchSpec.offset + ITEMS_PER_PAGE
          }), updateResults);
        })
        .on('click', '.items-prev-btn', function () {
          return loadAPIDefinitions(_.extend(searchSpec, {
            offset: searchSpec.offset - ITEMS_PER_PAGE
          }), updateResults);
        })
        .on('keyup', '.item-search', _.throttle(function (e, el) {
          // Avoid updating when the value hasn't changed.
          if (searchSpec.query === el.value) {
            return;
          }

          return loadAPIDefinitions(_.extend(searchSpec, {
            offset: 0,
            query:  el.value
          }), updateResults);
        }, 700));

      return loadAPIDefinitions(searchSpec, updateResults);
    }
  });
};

/**
 * Inserts a new code cell above with a RAML API client and executes it.
 */
App.View.EditorCell.prototype.newRAMLAbove = function () {
  return selectAPIDefinition(createApiClientCell(this, 'prepend'));
};

/**
 * Inserts a new code cell below with a RAML API client and executes it.
 */
App.View.EditorCell.prototype.newRAMLBelow = function () {
  return selectAPIDefinition(createApiClientCell(this, 'append'));
};

/**
 * Insert a RAML document by using the cell border buttons.
 */
App.View.CellButtons.controls.push({
  label:   'Insert API Client',
  command: 'newRAML'
});

/**
 * Insert a RAML document by using the cell menu buttons.
 */
App.View.CodeCell.prototype.cellControls.push({
  label:   'Insert API Client',
  command: 'newRAMLBelow'
});

/**
 * Register the basic raml client search middleware.
 */
App.middleware.register('ramlClient:search', function (search, next, done) {
  var url = BASE_URI + '?' + qs.stringify({
    sort:        'name',
    ascending:   true,
    requireRaml: true,
    limit:       search.limit,
    offset:      search.offset,
    query:       search.query
  });

  return App.middleware.trigger('ajax', {
    url: url
  }, function (err, xhr) {
    var result;
    var data = {};

    if (err) {
      return done(err);
    }

    try {
      result = JSON.parse(xhr.responseText);
    } catch (e) {
      return done(e);
    }

    data.items = result.apis;
    data.total = result.total;

    return done(null, data);
  });
});

},{}]},{},[75])(75)
});
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2J1ZmZlci1zaGltcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLXV0aWwtaXMvbGliL3V0aWwuanMiLCJub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2xpYi9iNjQuanMiLCJub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWlsdGluLXN0YXR1cy1jb2Rlcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvZm9yZWFjaC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9zdHJlYW0taHR0cC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9zdHJlYW0taHR0cC9saWIvY2FwYWJpbGl0eS5qcyIsIm5vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9zdHJlYW0taHR0cC9saWIvcmVxdWVzdC5qcyIsIm5vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9zdHJlYW0taHR0cC9saWIvcmVzcG9uc2UuanMiLCJub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdXJsL3VybC5qcyIsIm5vZGVfbW9kdWxlcy9odHRwcy1icm93c2VyaWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaW5kZXhvZi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pbmZsZWN0aW9uL2xpYi9pbmZsZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvaXMtYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzb24tbGludC9qc29ubGludC5qcyIsIm5vZGVfbW9kdWxlcy9vYmplY3Qta2V5cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9vYmplY3Qta2V5cy9pc0FyZ3VtZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzLW5leHRpY2stYXJncy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcHVueWNvZGUvcHVueWNvZGUuanMiLCJub2RlX21vZHVsZXMvcS9xLmpzIiwibm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9kZWNvZGUuanMiLCJub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2VuY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmFtbC1wYXJzZXIvbGliL2NvbXBvc2VyLmpzIiwibm9kZV9tb2R1bGVzL3JhbWwtcGFyc2VyL2xpYi9jb25zdHJ1Y3QuanMiLCJub2RlX21vZHVsZXMvcmFtbC1wYXJzZXIvbGliL2Vycm9ycy5qcyIsIm5vZGVfbW9kdWxlcy9yYW1sLXBhcnNlci9saWIvZXZlbnRzLmpzIiwibm9kZV9tb2R1bGVzL3JhbWwtcGFyc2VyL2xpYi9qb2luZXIuanMiLCJub2RlX21vZHVsZXMvcmFtbC1wYXJzZXIvbGliL2xvYWRlci5qcyIsIm5vZGVfbW9kdWxlcy9yYW1sLXBhcnNlci9saWIvbm9kZXMuanMiLCJub2RlX21vZHVsZXMvcmFtbC1wYXJzZXIvbGliL3BhcnNlci5qcyIsIm5vZGVfbW9kdWxlcy9yYW1sLXBhcnNlci9saWIvcHJvdG9jb2xzLmpzIiwibm9kZV9tb2R1bGVzL3JhbWwtcGFyc2VyL2xpYi9yYW1sLmpzIiwibm9kZV9tb2R1bGVzL3JhbWwtcGFyc2VyL2xpYi9yZWFkZXIuanMiLCJub2RlX21vZHVsZXMvcmFtbC1wYXJzZXIvbGliL3Jlc29sdmVyLmpzIiwibm9kZV9tb2R1bGVzL3JhbWwtcGFyc2VyL2xpYi9yZXNvdXJjZVR5cGVzLmpzIiwibm9kZV9tb2R1bGVzL3JhbWwtcGFyc2VyL2xpYi9zY2FubmVyLmpzIiwibm9kZV9tb2R1bGVzL3JhbWwtcGFyc2VyL2xpYi9zY2hlbWFzLmpzIiwibm9kZV9tb2R1bGVzL3JhbWwtcGFyc2VyL2xpYi9zZWN1cml0eVNjaGVtZXMuanMiLCJub2RlX21vZHVsZXMvcmFtbC1wYXJzZXIvbGliL3Rva2Vucy5qcyIsIm5vZGVfbW9kdWxlcy9yYW1sLXBhcnNlci9saWIvdHJhaXRzLmpzIiwibm9kZV9tb2R1bGVzL3JhbWwtcGFyc2VyL2xpYi90cmFuc2Zvcm1hdGlvbnMuanMiLCJub2RlX21vZHVsZXMvcmFtbC1wYXJzZXIvbGliL3V0aWwuanMiLCJub2RlX21vZHVsZXMvcmFtbC1wYXJzZXIvbGliL3ZhbGlkYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3N0cmluZ19kZWNvZGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3VyaXRlbXBsYXRlL2Jpbi91cml0ZW1wbGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy91dGlsLWRlcHJlY2F0ZS9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3htbGh0dHByZXF1ZXN0L2xpYi9YTUxIdHRwUmVxdWVzdC5qcyIsIm5vZGVfbW9kdWxlcy94dGVuZC9pbW11dGFibGUuanMiLCJzcmMvc2NyaXB0cy9saWIvZnJvbS1wYXRoLmpzIiwic3JjL3NjcmlwdHMvcGx1Z2lucy9yYW1sLWNsaWVudC1nZW5lcmF0b3IvYXV0aGVudGljYXRlLmpzIiwic3JjL3NjcmlwdHMvcGx1Z2lucy9yYW1sLWNsaWVudC1nZW5lcmF0b3IvY2xpZW50LWdlbmVyYXRvci9pbmRleC5qcyIsInNyYy9zY3JpcHRzL3BsdWdpbnMvcmFtbC1jbGllbnQtZ2VuZXJhdG9yL2NsaWVudC1nZW5lcmF0b3Ivc2FuaXRpemUtYXN0LmpzIiwic3JjL3NjcmlwdHMvcGx1Z2lucy9yYW1sLWNsaWVudC1nZW5lcmF0b3IvY2xpZW50LWdlbmVyYXRvci90ZW1wbGF0ZS5qcyIsInNyYy9zY3JpcHRzL3BsdWdpbnMvcmFtbC1jbGllbnQtZ2VuZXJhdG9yL2luZGV4LmpzIiwic3JjL3NjcmlwdHMvcGx1Z2lucy9yYW1sLWNsaWVudC1nZW5lcmF0b3IvaW5qZWN0LWFwaS1rZXlzLmpzIiwic3JjL3NjcmlwdHMvcGx1Z2lucy9yYW1sLWNsaWVudC1nZW5lcmF0b3IvaW5zZXJ0LWFwaS1jbGllbnQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzVnREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN0UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDN0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzluQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6ZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNyaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2o1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNuakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ptQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9NQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbi9DQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1M0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbkxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDN2dCQTtBQUNBOzs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaEJBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzdOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNyM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3ZsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4NkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsbnVsbCwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJyk7XG52YXIgQnVmZmVyID0gYnVmZmVyLkJ1ZmZlcjtcbnZhciBTbG93QnVmZmVyID0gYnVmZmVyLlNsb3dCdWZmZXI7XG52YXIgTUFYX0xFTiA9IGJ1ZmZlci5rTWF4TGVuZ3RoIHx8IDIxNDc0ODM2NDc7XG5leHBvcnRzLmFsbG9jID0gZnVuY3Rpb24gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBCdWZmZXIuYWxsb2MgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKTtcbiAgfVxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3Qgbm90IGJlIG51bWJlcicpO1xuICB9XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzaXplIG11c3QgYmUgYSBudW1iZXInKTtcbiAgfVxuICBpZiAoc2l6ZSA+IE1BWF9MRU4pIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc2l6ZSBpcyB0b28gbGFyZ2UnKTtcbiAgfVxuICB2YXIgZW5jID0gZW5jb2Rpbmc7XG4gIHZhciBfZmlsbCA9IGZpbGw7XG4gIGlmIChfZmlsbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jID0gdW5kZWZpbmVkO1xuICAgIF9maWxsID0gMDtcbiAgfVxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihzaXplKTtcbiAgaWYgKHR5cGVvZiBfZmlsbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgZmlsbEJ1ZiA9IG5ldyBCdWZmZXIoX2ZpbGwsIGVuYyk7XG4gICAgdmFyIGZsZW4gPSBmaWxsQnVmLmxlbmd0aDtcbiAgICB2YXIgaSA9IC0xO1xuICAgIHdoaWxlICgrK2kgPCBzaXplKSB7XG4gICAgICBidWZbaV0gPSBmaWxsQnVmW2kgJSBmbGVuXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYnVmLmZpbGwoX2ZpbGwpO1xuICB9XG4gIHJldHVybiBidWY7XG59XG5leHBvcnRzLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gYWxsb2NVbnNhZmUoc2l6ZSkge1xuICBpZiAodHlwZW9mIEJ1ZmZlci5hbGxvY1Vuc2FmZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2NVbnNhZmUoc2l6ZSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NpemUgbXVzdCBiZSBhIG51bWJlcicpO1xuICB9XG4gIGlmIChzaXplID4gTUFYX0xFTikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzaXplIGlzIHRvbyBsYXJnZScpO1xuICB9XG4gIHJldHVybiBuZXcgQnVmZmVyKHNpemUpO1xufVxuZXhwb3J0cy5mcm9tID0gZnVuY3Rpb24gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgQnVmZmVyLmZyb20gPT09ICdmdW5jdGlvbicgJiYgKCFnbG9iYWwuVWludDhBcnJheSB8fCBVaW50OEFycmF5LmZyb20gIT09IEJ1ZmZlci5mcm9tKSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpO1xuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICB2YXIgb2Zmc2V0ID0gZW5jb2RpbmdPck9mZnNldDtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIG5ldyBCdWZmZXIodmFsdWUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIHZhciBsZW4gPSBsZW5ndGg7XG4gICAgaWYgKHR5cGVvZiBsZW4gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBsZW4gPSB2YWx1ZS5ieXRlTGVuZ3RoIC0gb2Zmc2V0O1xuICAgIH1cbiAgICBpZiAob2Zmc2V0ID49IHZhbHVlLmJ5dGVMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpO1xuICAgIH1cbiAgICBpZiAobGVuID4gdmFsdWUuYnl0ZUxlbmd0aCAtIG9mZnNldCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQnVmZmVyKHZhbHVlLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbGVuKSk7XG4gIH1cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEJ1ZmZlcih2YWx1ZS5sZW5ndGgpO1xuICAgIHZhbHVlLmNvcHkob3V0LCAwLCAwLCB2YWx1ZS5sZW5ndGgpO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgaWYgKHZhbHVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8ICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiB2YWx1ZSkge1xuICAgICAgcmV0dXJuIG5ldyBCdWZmZXIodmFsdWUpO1xuICAgIH1cbiAgICBpZiAodmFsdWUudHlwZSA9PT0gJ0J1ZmZlcicgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZS5kYXRhKSkge1xuICAgICAgcmV0dXJuIG5ldyBCdWZmZXIodmFsdWUuZGF0YSk7XG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCAnICsgJ0FycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJyk7XG59XG5leHBvcnRzLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIGFsbG9jVW5zYWZlU2xvdyhzaXplKSB7XG4gIGlmICh0eXBlb2YgQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KHNpemUpO1xuICB9XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzaXplIG11c3QgYmUgYSBudW1iZXInKTtcbiAgfVxuICBpZiAoc2l6ZSA+PSBNQVhfTEVOKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NpemUgaXMgdG9vIGxhcmdlJyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBTbG93QnVmZmVyKHNpemUpO1xufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKTtcbiAgfVxuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IEJ1ZmZlci5pc0J1ZmZlcjtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuIiwidmFyIGxvb2t1cCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcblxuOyhmdW5jdGlvbiAoZXhwb3J0cykge1xuXHQndXNlIHN0cmljdCc7XG5cbiAgdmFyIEFyciA9ICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgPyBVaW50OEFycmF5XG4gICAgOiBBcnJheVxuXG5cdHZhciBQTFVTICAgPSAnKycuY2hhckNvZGVBdCgwKVxuXHR2YXIgU0xBU0ggID0gJy8nLmNoYXJDb2RlQXQoMClcblx0dmFyIE5VTUJFUiA9ICcwJy5jaGFyQ29kZUF0KDApXG5cdHZhciBMT1dFUiAgPSAnYScuY2hhckNvZGVBdCgwKVxuXHR2YXIgVVBQRVIgID0gJ0EnLmNoYXJDb2RlQXQoMClcblx0dmFyIFBMVVNfVVJMX1NBRkUgPSAnLScuY2hhckNvZGVBdCgwKVxuXHR2YXIgU0xBU0hfVVJMX1NBRkUgPSAnXycuY2hhckNvZGVBdCgwKVxuXG5cdGZ1bmN0aW9uIGRlY29kZSAoZWx0KSB7XG5cdFx0dmFyIGNvZGUgPSBlbHQuY2hhckNvZGVBdCgwKVxuXHRcdGlmIChjb2RlID09PSBQTFVTIHx8XG5cdFx0ICAgIGNvZGUgPT09IFBMVVNfVVJMX1NBRkUpXG5cdFx0XHRyZXR1cm4gNjIgLy8gJysnXG5cdFx0aWYgKGNvZGUgPT09IFNMQVNIIHx8XG5cdFx0ICAgIGNvZGUgPT09IFNMQVNIX1VSTF9TQUZFKVxuXHRcdFx0cmV0dXJuIDYzIC8vICcvJ1xuXHRcdGlmIChjb2RlIDwgTlVNQkVSKVxuXHRcdFx0cmV0dXJuIC0xIC8vbm8gbWF0Y2hcblx0XHRpZiAoY29kZSA8IE5VTUJFUiArIDEwKVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBOVU1CRVIgKyAyNiArIDI2XG5cdFx0aWYgKGNvZGUgPCBVUFBFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBVUFBFUlxuXHRcdGlmIChjb2RlIDwgTE9XRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gTE9XRVIgKyAyNlxuXHR9XG5cblx0ZnVuY3Rpb24gYjY0VG9CeXRlQXJyYXkgKGI2NCkge1xuXHRcdHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG5cblx0XHRpZiAoYjY0Lmxlbmd0aCAlIDQgPiAwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuXHRcdH1cblxuXHRcdC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuXHRcdC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuXHRcdC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuXHRcdC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2Vcblx0XHR2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXHRcdHBsYWNlSG9sZGVycyA9ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAyKSA/IDIgOiAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMSkgPyAxIDogMFxuXG5cdFx0Ly8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5cdFx0YXJyID0gbmV3IEFycihiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cblx0XHQvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG5cdFx0bCA9IHBsYWNlSG9sZGVycyA+IDAgPyBiNjQubGVuZ3RoIC0gNCA6IGI2NC5sZW5ndGhcblxuXHRcdHZhciBMID0gMFxuXG5cdFx0ZnVuY3Rpb24gcHVzaCAodikge1xuXHRcdFx0YXJyW0wrK10gPSB2XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxOCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCAxMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA8PCA2KSB8IGRlY29kZShiNjQuY2hhckF0KGkgKyAzKSlcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMDAwKSA+PiAxNilcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMCkgPj4gOClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPj4gNClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxMCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCA0KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpID4+IDIpXG5cdFx0XHRwdXNoKCh0bXAgPj4gOCkgJiAweEZGKVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdHJldHVybiBhcnJcblx0fVxuXG5cdGZ1bmN0aW9uIHVpbnQ4VG9CYXNlNjQgKHVpbnQ4KSB7XG5cdFx0dmFyIGksXG5cdFx0XHRleHRyYUJ5dGVzID0gdWludDgubGVuZ3RoICUgMywgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcblx0XHRcdG91dHB1dCA9IFwiXCIsXG5cdFx0XHR0ZW1wLCBsZW5ndGhcblxuXHRcdGZ1bmN0aW9uIGVuY29kZSAobnVtKSB7XG5cdFx0XHRyZXR1cm4gbG9va3VwLmNoYXJBdChudW0pXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcblx0XHRcdHJldHVybiBlbmNvZGUobnVtID4+IDE4ICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDEyICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDYgJiAweDNGKSArIGVuY29kZShudW0gJiAweDNGKVxuXHRcdH1cblxuXHRcdC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcblx0XHRmb3IgKGkgPSAwLCBsZW5ndGggPSB1aW50OC5sZW5ndGggLSBleHRyYUJ5dGVzOyBpIDwgbGVuZ3RoOyBpICs9IDMpIHtcblx0XHRcdHRlbXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG5cdFx0XHRvdXRwdXQgKz0gdHJpcGxldFRvQmFzZTY0KHRlbXApXG5cdFx0fVxuXG5cdFx0Ly8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuXHRcdHN3aXRjaCAoZXh0cmFCeXRlcykge1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHR0ZW1wID0gdWludDhbdWludDgubGVuZ3RoIC0gMV1cblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDIpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz09J1xuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHR0ZW1wID0gKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDJdIDw8IDgpICsgKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMTApXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPj4gNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDIpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9J1xuXHRcdFx0XHRicmVha1xuXHRcdH1cblxuXHRcdHJldHVybiBvdXRwdXRcblx0fVxuXG5cdGV4cG9ydHMudG9CeXRlQXJyYXkgPSBiNjRUb0J5dGVBcnJheVxuXHRleHBvcnRzLmZyb21CeXRlQXJyYXkgPSB1aW50OFRvQmFzZTY0XG59KHR5cGVvZiBleHBvcnRzID09PSAndW5kZWZpbmVkJyA/ICh0aGlzLmJhc2U2NGpzID0ge30pIDogZXhwb3J0cykpXG4iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbnZhciByb290UGFyZW50ID0ge31cblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAgLSBTYWZhcmkgNS03IGxhY2tzIHN1cHBvcnQgZm9yIGNoYW5naW5nIHRoZSBgT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvcmAgcHJvcGVydHlcbiAqICAgICBvbiBvYmplY3RzLlxuICpcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgOiB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgZnVuY3Rpb24gQmFyICgpIHt9XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLmZvbyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH1cbiAgICBhcnIuY29uc3RydWN0b3IgPSBCYXJcbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MiAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxuICAgICAgICBhcnIuY29uc3RydWN0b3IgPT09IEJhciAmJiAvLyBjb25zdHJ1Y3RvciBjYW4gYmUgc2V0XG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbi8qKlxuICogQ2xhc3M6IEJ1ZmZlclxuICogPT09PT09PT09PT09PVxuICpcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgYXJlIGF1Z21lbnRlZFxuICogd2l0aCBmdW5jdGlvbiBwcm9wZXJ0aWVzIGZvciBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgQVBJIGZ1bmN0aW9ucy4gV2UgdXNlXG4gKiBgVWludDhBcnJheWAgc28gdGhhdCBzcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdCByZXR1cm5zXG4gKiBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBCeSBhdWdtZW50aW5nIHRoZSBpbnN0YW5jZXMsIHdlIGNhbiBhdm9pZCBtb2RpZnlpbmcgdGhlIGBVaW50OEFycmF5YFxuICogcHJvdG90eXBlLlxuICovXG5mdW5jdGlvbiBCdWZmZXIgKGFyZykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIC8vIEF2b2lkIGdvaW5nIHRocm91Z2ggYW4gQXJndW1lbnRzQWRhcHRvclRyYW1wb2xpbmUgaW4gdGhlIGNvbW1vbiBjYXNlLlxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBhcmd1bWVudHNbMV0pXG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnKVxuICB9XG5cbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXMubGVuZ3RoID0gMFxuICAgIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGZyb21OdW1iZXIodGhpcywgYXJnKVxuICB9XG5cbiAgLy8gU2xpZ2h0bHkgbGVzcyBjb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhpcywgYXJnLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6ICd1dGY4JylcbiAgfVxuXG4gIC8vIFVudXN1YWwuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoaXMsIGFyZylcbn1cblxuZnVuY3Rpb24gZnJvbU51bWJlciAodGhhdCwgbGVuZ3RoKSB7XG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGggPCAwID8gMCA6IGNoZWNrZWQobGVuZ3RoKSB8IDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGF0W2ldID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykgZW5jb2RpbmcgPSAndXRmOCdcblxuICAvLyBBc3N1bXB0aW9uOiBieXRlTGVuZ3RoKCkgcmV0dXJuIHZhbHVlIGlzIGFsd2F5cyA8IGtNYXhMZW5ndGguXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuXG4gIHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqZWN0KSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqZWN0KSkgcmV0dXJuIGZyb21CdWZmZXIodGhhdCwgb2JqZWN0KVxuXG4gIGlmIChpc0FycmF5KG9iamVjdCkpIHJldHVybiBmcm9tQXJyYXkodGhhdCwgb2JqZWN0KVxuXG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ211c3Qgc3RhcnQgd2l0aCBudW1iZXIsIGJ1ZmZlciwgYXJyYXkgb3Igc3RyaW5nJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKG9iamVjdC5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgcmV0dXJuIGZyb21UeXBlZEFycmF5KHRoYXQsIG9iamVjdClcbiAgICB9XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIG9iamVjdClcbiAgICB9XG4gIH1cblxuICBpZiAob2JqZWN0Lmxlbmd0aCkgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqZWN0KVxuXG4gIHJldHVybiBmcm9tSnNvbk9iamVjdCh0aGF0LCBvYmplY3QpXG59XG5cbmZ1bmN0aW9uIGZyb21CdWZmZXIgKHRoYXQsIGJ1ZmZlcikge1xuICB2YXIgbGVuZ3RoID0gY2hlY2tlZChidWZmZXIubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcbiAgYnVmZmVyLmNvcHkodGhhdCwgMCwgMCwgbGVuZ3RoKVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXkgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vLyBEdXBsaWNhdGUgb2YgZnJvbUFycmF5KCkgdG8ga2VlcCBmcm9tQXJyYXkoKSBtb25vbW9ycGhpYy5cbmZ1bmN0aW9uIGZyb21UeXBlZEFycmF5ICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuICAvLyBUcnVuY2F0aW5nIHRoZSBlbGVtZW50cyBpcyBwcm9iYWJseSBub3Qgd2hhdCBwZW9wbGUgZXhwZWN0IGZyb20gdHlwZWRcbiAgLy8gYXJyYXlzIHdpdGggQllURVNfUEVSX0VMRU1FTlQgPiAxIGJ1dCBpdCdzIGNvbXBhdGlibGUgd2l0aCB0aGUgYmVoYXZpb3JcbiAgLy8gb2YgdGhlIG9sZCBCdWZmZXIgY29uc3RydWN0b3IuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5KSB7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIGFycmF5LmJ5dGVMZW5ndGhcbiAgICB0aGF0ID0gQnVmZmVyLl9hdWdtZW50KG5ldyBVaW50OEFycmF5KGFycmF5KSlcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21UeXBlZEFycmF5KHRoYXQsIG5ldyBVaW50OEFycmF5KGFycmF5KSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLy8gRGVzZXJpYWxpemUgeyB0eXBlOiAnQnVmZmVyJywgZGF0YTogWzEsMiwzLC4uLl0gfSBpbnRvIGEgQnVmZmVyIG9iamVjdC5cbi8vIFJldHVybnMgYSB6ZXJvLWxlbmd0aCBidWZmZXIgZm9yIGlucHV0cyB0aGF0IGRvbid0IGNvbmZvcm0gdG8gdGhlIHNwZWMuXG5mdW5jdGlvbiBmcm9tSnNvbk9iamVjdCAodGhhdCwgb2JqZWN0KSB7XG4gIHZhciBhcnJheVxuICB2YXIgbGVuZ3RoID0gMFxuXG4gIGlmIChvYmplY3QudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmplY3QuZGF0YSkpIHtcbiAgICBhcnJheSA9IG9iamVjdC5kYXRhXG4gICAgbGVuZ3RoID0gY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB9XG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG59IGVsc2Uge1xuICAvLyBwcmUtc2V0IGZvciB2YWx1ZXMgdGhhdCBtYXkgZXhpc3QgaW4gdGhlIGZ1dHVyZVxuICBCdWZmZXIucHJvdG90eXBlLmxlbmd0aCA9IHVuZGVmaW5lZFxuICBCdWZmZXIucHJvdG90eXBlLnBhcmVudCA9IHVuZGVmaW5lZFxufVxuXG5mdW5jdGlvbiBhbGxvY2F0ZSAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBCdWZmZXIuX2F1Z21lbnQobmV3IFVpbnQ4QXJyYXkobGVuZ3RoKSlcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGhcbiAgICB0aGF0Ll9pc0J1ZmZlciA9IHRydWVcbiAgfVxuXG4gIHZhciBmcm9tUG9vbCA9IGxlbmd0aCAhPT0gMCAmJiBsZW5ndGggPD0gQnVmZmVyLnBvb2xTaXplID4+PiAxXG4gIGlmIChmcm9tUG9vbCkgdGhhdC5wYXJlbnQgPSByb290UGFyZW50XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChzdWJqZWN0LCBlbmNvZGluZykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU2xvd0J1ZmZlcikpIHJldHVybiBuZXcgU2xvd0J1ZmZlcihzdWJqZWN0LCBlbmNvZGluZylcblxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihzdWJqZWN0LCBlbmNvZGluZylcbiAgZGVsZXRlIGJ1Zi5wYXJlbnRcbiAgcmV0dXJuIGJ1ZlxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgdmFyIGkgPSAwXG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSBicmVha1xuXG4gICAgKytpXG4gIH1cblxuICBpZiAoaSAhPT0gbGVuKSB7XG4gICAgeCA9IGFbaV1cbiAgICB5ID0gYltpXVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICdyYXcnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdsaXN0IGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycy4nKVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV1cbiAgICBpdGVtLmNvcHkoYnVmLCBwb3MpXG4gICAgcG9zICs9IGl0ZW0ubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykgc3RyaW5nID0gJycgKyBzdHJpbmdcblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIC8vIERlcHJlY2F0ZWRcbiAgICAgIGNhc2UgJ3Jhdyc6XG4gICAgICBjYXNlICdyYXdzJzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICBzdGFydCA9IHN0YXJ0IHwgMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPT09IEluZmluaXR5ID8gdGhpcy5sZW5ndGggOiBlbmQgfCAwXG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcbiAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKGVuZCA8PSBzdGFydCkgcmV0dXJuICcnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gYmluYXJ5U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiAwXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICBieXRlT2Zmc2V0ID4+PSAwXG5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gdGhpcy5sZW5ndGgpIHJldHVybiAtMVxuXG4gIC8vIE5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gTWF0aC5tYXgodGhpcy5sZW5ndGggKyBieXRlT2Zmc2V0LCAwKVxuXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSByZXR1cm4gLTEgLy8gc3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcgYWx3YXlzIGZhaWxzXG4gICAgcmV0dXJuIFN0cmluZy5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKHRoaXMsIHZhbCwgYnl0ZU9mZnNldClcbiAgfVxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldClcbiAgfVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbCh0aGlzLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YodGhpcywgWyB2YWwgXSwgYnl0ZU9mZnNldClcbiAgfVxuXG4gIGZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yICh2YXIgaSA9IDA7IGJ5dGVPZmZzZXQgKyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYXJyW2J5dGVPZmZzZXQgKyBpXSA9PT0gdmFsW2ZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4XSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbC5sZW5ndGgpIHJldHVybiBieXRlT2Zmc2V0ICsgZm91bmRJbmRleFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuLy8gYGdldGAgaXMgZGVwcmVjYXRlZFxuQnVmZmVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLmdldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMucmVhZFVJbnQ4KG9mZnNldClcbn1cblxuLy8gYHNldGAgaXMgZGVwcmVjYXRlZFxuQnVmZmVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQgKHYsIG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLnNldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMud3JpdGVVSW50OCh2LCBvZmZzZXQpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmluYXJ5V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuICB9IGVsc2Uge1xuICAgIHZhciBzd2FwID0gZW5jb2RpbmdcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIG9mZnNldCA9IGxlbmd0aCB8IDBcbiAgICBsZW5ndGggPSBzd2FwXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignYXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGJpbmFyeVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gYmluYXJ5U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IEJ1ZmZlci5fYXVnbWVudCh0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpKVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47IGkrKykge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgaWYgKG5ld0J1Zi5sZW5ndGgpIG5ld0J1Zi5wYXJlbnQgPSB0aGlzLnBhcmVudCB8fCB0aGlzXG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdidWZmZXIgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3ZhbHVlIGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpLCAwKVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpLCAwKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gdmFsdWUgPCAwID8gMSA6IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSB2YWx1ZSA8IDAgPyAxIDogMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCd2YWx1ZSBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0Ll9zZXQodGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLCB0YXJnZXRTdGFydClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gZmlsbCh2YWx1ZSwgc3RhcnQ9MCwgZW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXZhbHVlKSB2YWx1ZSA9IDBcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kKSBlbmQgPSB0aGlzLmxlbmd0aFxuXG4gIGlmIChlbmQgPCBzdGFydCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2VuZCA8IHN0YXJ0JylcblxuICAvLyBGaWxsIDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVyblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVyblxuXG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDAgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdlbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB0aGlzW2ldID0gdmFsdWVcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gdXRmOFRvQnl0ZXModmFsdWUudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdGhpc1tpXSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGBBcnJheUJ1ZmZlcmAgd2l0aCB0aGUgKmNvcGllZCogbWVtb3J5IG9mIHRoZSBidWZmZXIgaW5zdGFuY2UuXG4gKiBBZGRlZCBpbiBOb2RlIDAuMTIuIE9ubHkgYXZhaWxhYmxlIGluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBBcnJheUJ1ZmZlci5cbiAqL1xuQnVmZmVyLnByb3RvdHlwZS50b0FycmF5QnVmZmVyID0gZnVuY3Rpb24gdG9BcnJheUJ1ZmZlciAoKSB7XG4gIGlmICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAgIHJldHVybiAobmV3IEJ1ZmZlcih0aGlzKSkuYnVmZmVyXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aClcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBidWYubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgYnVmW2ldID0gdGhpc1tpXVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1Zi5idWZmZXJcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQnVmZmVyLnRvQXJyYXlCdWZmZXIgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKVxuICB9XG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIEJQID0gQnVmZmVyLnByb3RvdHlwZVxuXG4vKipcbiAqIEF1Z21lbnQgYSBVaW50OEFycmF5ICppbnN0YW5jZSogKG5vdCB0aGUgVWludDhBcnJheSBjbGFzcyEpIHdpdGggQnVmZmVyIG1ldGhvZHNcbiAqL1xuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gX2F1Z21lbnQgKGFycikge1xuICBhcnIuY29uc3RydWN0b3IgPSBCdWZmZXJcbiAgYXJyLl9pc0J1ZmZlciA9IHRydWVcblxuICAvLyBzYXZlIHJlZmVyZW5jZSB0byBvcmlnaW5hbCBVaW50OEFycmF5IHNldCBtZXRob2QgYmVmb3JlIG92ZXJ3cml0aW5nXG4gIGFyci5fc2V0ID0gYXJyLnNldFxuXG4gIC8vIGRlcHJlY2F0ZWRcbiAgYXJyLmdldCA9IEJQLmdldFxuICBhcnIuc2V0ID0gQlAuc2V0XG5cbiAgYXJyLndyaXRlID0gQlAud3JpdGVcbiAgYXJyLnRvU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvTG9jYWxlU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvSlNPTiA9IEJQLnRvSlNPTlxuICBhcnIuZXF1YWxzID0gQlAuZXF1YWxzXG4gIGFyci5jb21wYXJlID0gQlAuY29tcGFyZVxuICBhcnIuaW5kZXhPZiA9IEJQLmluZGV4T2ZcbiAgYXJyLmNvcHkgPSBCUC5jb3B5XG4gIGFyci5zbGljZSA9IEJQLnNsaWNlXG4gIGFyci5yZWFkVUludExFID0gQlAucmVhZFVJbnRMRVxuICBhcnIucmVhZFVJbnRCRSA9IEJQLnJlYWRVSW50QkVcbiAgYXJyLnJlYWRVSW50OCA9IEJQLnJlYWRVSW50OFxuICBhcnIucmVhZFVJbnQxNkxFID0gQlAucmVhZFVJbnQxNkxFXG4gIGFyci5yZWFkVUludDE2QkUgPSBCUC5yZWFkVUludDE2QkVcbiAgYXJyLnJlYWRVSW50MzJMRSA9IEJQLnJlYWRVSW50MzJMRVxuICBhcnIucmVhZFVJbnQzMkJFID0gQlAucmVhZFVJbnQzMkJFXG4gIGFyci5yZWFkSW50TEUgPSBCUC5yZWFkSW50TEVcbiAgYXJyLnJlYWRJbnRCRSA9IEJQLnJlYWRJbnRCRVxuICBhcnIucmVhZEludDggPSBCUC5yZWFkSW50OFxuICBhcnIucmVhZEludDE2TEUgPSBCUC5yZWFkSW50MTZMRVxuICBhcnIucmVhZEludDE2QkUgPSBCUC5yZWFkSW50MTZCRVxuICBhcnIucmVhZEludDMyTEUgPSBCUC5yZWFkSW50MzJMRVxuICBhcnIucmVhZEludDMyQkUgPSBCUC5yZWFkSW50MzJCRVxuICBhcnIucmVhZEZsb2F0TEUgPSBCUC5yZWFkRmxvYXRMRVxuICBhcnIucmVhZEZsb2F0QkUgPSBCUC5yZWFkRmxvYXRCRVxuICBhcnIucmVhZERvdWJsZUxFID0gQlAucmVhZERvdWJsZUxFXG4gIGFyci5yZWFkRG91YmxlQkUgPSBCUC5yZWFkRG91YmxlQkVcbiAgYXJyLndyaXRlVUludDggPSBCUC53cml0ZVVJbnQ4XG4gIGFyci53cml0ZVVJbnRMRSA9IEJQLndyaXRlVUludExFXG4gIGFyci53cml0ZVVJbnRCRSA9IEJQLndyaXRlVUludEJFXG4gIGFyci53cml0ZVVJbnQxNkxFID0gQlAud3JpdGVVSW50MTZMRVxuICBhcnIud3JpdGVVSW50MTZCRSA9IEJQLndyaXRlVUludDE2QkVcbiAgYXJyLndyaXRlVUludDMyTEUgPSBCUC53cml0ZVVJbnQzMkxFXG4gIGFyci53cml0ZVVJbnQzMkJFID0gQlAud3JpdGVVSW50MzJCRVxuICBhcnIud3JpdGVJbnRMRSA9IEJQLndyaXRlSW50TEVcbiAgYXJyLndyaXRlSW50QkUgPSBCUC53cml0ZUludEJFXG4gIGFyci53cml0ZUludDggPSBCUC53cml0ZUludDhcbiAgYXJyLndyaXRlSW50MTZMRSA9IEJQLndyaXRlSW50MTZMRVxuICBhcnIud3JpdGVJbnQxNkJFID0gQlAud3JpdGVJbnQxNkJFXG4gIGFyci53cml0ZUludDMyTEUgPSBCUC53cml0ZUludDMyTEVcbiAgYXJyLndyaXRlSW50MzJCRSA9IEJQLndyaXRlSW50MzJCRVxuICBhcnIud3JpdGVGbG9hdExFID0gQlAud3JpdGVGbG9hdExFXG4gIGFyci53cml0ZUZsb2F0QkUgPSBCUC53cml0ZUZsb2F0QkVcbiAgYXJyLndyaXRlRG91YmxlTEUgPSBCUC53cml0ZURvdWJsZUxFXG4gIGFyci53cml0ZURvdWJsZUJFID0gQlAud3JpdGVEb3VibGVCRVxuICBhcnIuZmlsbCA9IEJQLmZpbGxcbiAgYXJyLmluc3BlY3QgPSBCUC5pbnNwZWN0XG4gIGFyci50b0FycmF5QnVmZmVyID0gQlAudG9BcnJheUJ1ZmZlclxuXG4gIHJldHVybiBhcnJcbn1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBcIjEwMFwiOiBcIkNvbnRpbnVlXCIsXG4gIFwiMTAxXCI6IFwiU3dpdGNoaW5nIFByb3RvY29sc1wiLFxuICBcIjEwMlwiOiBcIlByb2Nlc3NpbmdcIixcbiAgXCIyMDBcIjogXCJPS1wiLFxuICBcIjIwMVwiOiBcIkNyZWF0ZWRcIixcbiAgXCIyMDJcIjogXCJBY2NlcHRlZFwiLFxuICBcIjIwM1wiOiBcIk5vbi1BdXRob3JpdGF0aXZlIEluZm9ybWF0aW9uXCIsXG4gIFwiMjA0XCI6IFwiTm8gQ29udGVudFwiLFxuICBcIjIwNVwiOiBcIlJlc2V0IENvbnRlbnRcIixcbiAgXCIyMDZcIjogXCJQYXJ0aWFsIENvbnRlbnRcIixcbiAgXCIyMDdcIjogXCJNdWx0aS1TdGF0dXNcIixcbiAgXCIzMDBcIjogXCJNdWx0aXBsZSBDaG9pY2VzXCIsXG4gIFwiMzAxXCI6IFwiTW92ZWQgUGVybWFuZW50bHlcIixcbiAgXCIzMDJcIjogXCJNb3ZlZCBUZW1wb3JhcmlseVwiLFxuICBcIjMwM1wiOiBcIlNlZSBPdGhlclwiLFxuICBcIjMwNFwiOiBcIk5vdCBNb2RpZmllZFwiLFxuICBcIjMwNVwiOiBcIlVzZSBQcm94eVwiLFxuICBcIjMwN1wiOiBcIlRlbXBvcmFyeSBSZWRpcmVjdFwiLFxuICBcIjMwOFwiOiBcIlBlcm1hbmVudCBSZWRpcmVjdFwiLFxuICBcIjQwMFwiOiBcIkJhZCBSZXF1ZXN0XCIsXG4gIFwiNDAxXCI6IFwiVW5hdXRob3JpemVkXCIsXG4gIFwiNDAyXCI6IFwiUGF5bWVudCBSZXF1aXJlZFwiLFxuICBcIjQwM1wiOiBcIkZvcmJpZGRlblwiLFxuICBcIjQwNFwiOiBcIk5vdCBGb3VuZFwiLFxuICBcIjQwNVwiOiBcIk1ldGhvZCBOb3QgQWxsb3dlZFwiLFxuICBcIjQwNlwiOiBcIk5vdCBBY2NlcHRhYmxlXCIsXG4gIFwiNDA3XCI6IFwiUHJveHkgQXV0aGVudGljYXRpb24gUmVxdWlyZWRcIixcbiAgXCI0MDhcIjogXCJSZXF1ZXN0IFRpbWUtb3V0XCIsXG4gIFwiNDA5XCI6IFwiQ29uZmxpY3RcIixcbiAgXCI0MTBcIjogXCJHb25lXCIsXG4gIFwiNDExXCI6IFwiTGVuZ3RoIFJlcXVpcmVkXCIsXG4gIFwiNDEyXCI6IFwiUHJlY29uZGl0aW9uIEZhaWxlZFwiLFxuICBcIjQxM1wiOiBcIlJlcXVlc3QgRW50aXR5IFRvbyBMYXJnZVwiLFxuICBcIjQxNFwiOiBcIlJlcXVlc3QtVVJJIFRvbyBMYXJnZVwiLFxuICBcIjQxNVwiOiBcIlVuc3VwcG9ydGVkIE1lZGlhIFR5cGVcIixcbiAgXCI0MTZcIjogXCJSZXF1ZXN0ZWQgUmFuZ2UgTm90IFNhdGlzZmlhYmxlXCIsXG4gIFwiNDE3XCI6IFwiRXhwZWN0YXRpb24gRmFpbGVkXCIsXG4gIFwiNDE4XCI6IFwiSSdtIGEgdGVhcG90XCIsXG4gIFwiNDIyXCI6IFwiVW5wcm9jZXNzYWJsZSBFbnRpdHlcIixcbiAgXCI0MjNcIjogXCJMb2NrZWRcIixcbiAgXCI0MjRcIjogXCJGYWlsZWQgRGVwZW5kZW5jeVwiLFxuICBcIjQyNVwiOiBcIlVub3JkZXJlZCBDb2xsZWN0aW9uXCIsXG4gIFwiNDI2XCI6IFwiVXBncmFkZSBSZXF1aXJlZFwiLFxuICBcIjQyOFwiOiBcIlByZWNvbmRpdGlvbiBSZXF1aXJlZFwiLFxuICBcIjQyOVwiOiBcIlRvbyBNYW55IFJlcXVlc3RzXCIsXG4gIFwiNDMxXCI6IFwiUmVxdWVzdCBIZWFkZXIgRmllbGRzIFRvbyBMYXJnZVwiLFxuICBcIjUwMFwiOiBcIkludGVybmFsIFNlcnZlciBFcnJvclwiLFxuICBcIjUwMVwiOiBcIk5vdCBJbXBsZW1lbnRlZFwiLFxuICBcIjUwMlwiOiBcIkJhZCBHYXRld2F5XCIsXG4gIFwiNTAzXCI6IFwiU2VydmljZSBVbmF2YWlsYWJsZVwiLFxuICBcIjUwNFwiOiBcIkdhdGV3YXkgVGltZS1vdXRcIixcbiAgXCI1MDVcIjogXCJIVFRQIFZlcnNpb24gTm90IFN1cHBvcnRlZFwiLFxuICBcIjUwNlwiOiBcIlZhcmlhbnQgQWxzbyBOZWdvdGlhdGVzXCIsXG4gIFwiNTA3XCI6IFwiSW5zdWZmaWNpZW50IFN0b3JhZ2VcIixcbiAgXCI1MDlcIjogXCJCYW5kd2lkdGggTGltaXQgRXhjZWVkZWRcIixcbiAgXCI1MTBcIjogXCJOb3QgRXh0ZW5kZWRcIixcbiAgXCI1MTFcIjogXCJOZXR3b3JrIEF1dGhlbnRpY2F0aW9uIFJlcXVpcmVkXCJcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuJyk7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcbiAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG5cbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2VcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG5cbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICB2YXIgbTtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9XG5cbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMub24odHlwZSwgZyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICBwb3NpdGlvbiA9IC0xO1xuXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIga2V5LCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2Uge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIGVsc2VcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IDA7XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24oZW1pdHRlci5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSAxO1xuICBlbHNlXG4gICAgcmV0ID0gZW1pdHRlci5fZXZlbnRzW3R5cGVdLmxlbmd0aDtcbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbiIsIlxudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZvckVhY2ggKG9iaiwgZm4sIGN0eCkge1xuICAgIGlmICh0b1N0cmluZy5jYWxsKGZuKSAhPT0gJ1tvYmplY3QgRnVuY3Rpb25dJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpdGVyYXRvciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICB9XG4gICAgdmFyIGwgPSBvYmoubGVuZ3RoO1xuICAgIGlmIChsID09PSArbCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgZm4uY2FsbChjdHgsIG9ialtpXSwgaSwgb2JqKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGsgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwob2JqLCBrKSkge1xuICAgICAgICAgICAgICAgIGZuLmNhbGwoY3R4LCBvYmpba10sIGssIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4iLCJ2YXIgQ2xpZW50UmVxdWVzdCA9IHJlcXVpcmUoJy4vbGliL3JlcXVlc3QnKVxudmFyIGV4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kJylcbnZhciBzdGF0dXNDb2RlcyA9IHJlcXVpcmUoJ2J1aWx0aW4tc3RhdHVzLWNvZGVzJylcbnZhciB1cmwgPSByZXF1aXJlKCd1cmwnKVxuXG52YXIgaHR0cCA9IGV4cG9ydHNcblxuaHR0cC5yZXF1ZXN0ID0gZnVuY3Rpb24gKG9wdHMsIGNiKSB7XG5cdGlmICh0eXBlb2Ygb3B0cyA9PT0gJ3N0cmluZycpXG5cdFx0b3B0cyA9IHVybC5wYXJzZShvcHRzKVxuXHRlbHNlXG5cdFx0b3B0cyA9IGV4dGVuZChvcHRzKVxuXG5cdHZhciBwcm90b2NvbCA9IG9wdHMucHJvdG9jb2wgfHwgJydcblx0dmFyIGhvc3QgPSBvcHRzLmhvc3RuYW1lIHx8IG9wdHMuaG9zdFxuXHR2YXIgcG9ydCA9IG9wdHMucG9ydFxuXHR2YXIgcGF0aCA9IG9wdHMucGF0aCB8fCAnLydcblxuXHQvLyBOZWNlc3NhcnkgZm9yIElQdjYgYWRkcmVzc2VzXG5cdGlmIChob3N0ICYmIGhvc3QuaW5kZXhPZignOicpICE9PSAtMSlcblx0XHRob3N0ID0gJ1snICsgaG9zdCArICddJ1xuXG5cdC8vIFRoaXMgbWF5IGJlIGEgcmVsYXRpdmUgdXJsLiBUaGUgYnJvd3NlciBzaG91bGQgYWx3YXlzIGJlIGFibGUgdG8gaW50ZXJwcmV0IGl0IGNvcnJlY3RseS5cblx0b3B0cy51cmwgPSAoaG9zdCA/IChwcm90b2NvbCArICcvLycgKyBob3N0KSA6ICcnKSArIChwb3J0ID8gJzonICsgcG9ydCA6ICcnKSArIHBhdGhcblx0b3B0cy5tZXRob2QgPSAob3B0cy5tZXRob2QgfHwgJ0dFVCcpLnRvVXBwZXJDYXNlKClcblx0b3B0cy5oZWFkZXJzID0gb3B0cy5oZWFkZXJzIHx8IHt9XG5cblx0Ly8gQWxzbyB2YWxpZCBvcHRzLmF1dGgsIG9wdHMubW9kZVxuXG5cdHZhciByZXEgPSBuZXcgQ2xpZW50UmVxdWVzdChvcHRzKVxuXHRpZiAoY2IpXG5cdFx0cmVxLm9uKCdyZXNwb25zZScsIGNiKVxuXHRyZXR1cm4gcmVxXG59XG5cbmh0dHAuZ2V0ID0gZnVuY3Rpb24gZ2V0IChvcHRzLCBjYikge1xuXHR2YXIgcmVxID0gaHR0cC5yZXF1ZXN0KG9wdHMsIGNiKVxuXHRyZXEuZW5kKClcblx0cmV0dXJuIHJlcVxufVxuXG5odHRwLkFnZW50ID0gZnVuY3Rpb24gKCkge31cbmh0dHAuQWdlbnQuZGVmYXVsdE1heFNvY2tldHMgPSA0XG5cbmh0dHAuU1RBVFVTX0NPREVTID0gc3RhdHVzQ29kZXNcblxuaHR0cC5NRVRIT0RTID0gW1xuXHQnQ0hFQ0tPVVQnLFxuXHQnQ09OTkVDVCcsXG5cdCdDT1BZJyxcblx0J0RFTEVURScsXG5cdCdHRVQnLFxuXHQnSEVBRCcsXG5cdCdMT0NLJyxcblx0J00tU0VBUkNIJyxcblx0J01FUkdFJyxcblx0J01LQUNUSVZJVFknLFxuXHQnTUtDT0wnLFxuXHQnTU9WRScsXG5cdCdOT1RJRlknLFxuXHQnT1BUSU9OUycsXG5cdCdQQVRDSCcsXG5cdCdQT1NUJyxcblx0J1BST1BGSU5EJyxcblx0J1BST1BQQVRDSCcsXG5cdCdQVVJHRScsXG5cdCdQVVQnLFxuXHQnUkVQT1JUJyxcblx0J1NFQVJDSCcsXG5cdCdTVUJTQ1JJQkUnLFxuXHQnVFJBQ0UnLFxuXHQnVU5MT0NLJyxcblx0J1VOU1VCU0NSSUJFJ1xuXSIsImV4cG9ydHMuZmV0Y2ggPSBpc0Z1bmN0aW9uKGdsb2JhbC5mZXRjaCkgJiYgaXNGdW5jdGlvbihnbG9iYWwuUmVhZGFibGVCeXRlU3RyZWFtKVxuXG5leHBvcnRzLmJsb2JDb25zdHJ1Y3RvciA9IGZhbHNlXG50cnkge1xuXHRuZXcgQmxvYihbbmV3IEFycmF5QnVmZmVyKDEpXSlcblx0ZXhwb3J0cy5ibG9iQ29uc3RydWN0b3IgPSB0cnVlXG59IGNhdGNoIChlKSB7fVxuXG52YXIgeGhyID0gbmV3IGdsb2JhbC5YTUxIdHRwUmVxdWVzdCgpXG4vLyBJZiBsb2NhdGlvbi5ob3N0IGlzIGVtcHR5LCBlLmcuIGlmIHRoaXMgcGFnZS93b3JrZXIgd2FzIGxvYWRlZFxuLy8gZnJvbSBhIEJsb2IsIHRoZW4gdXNlIGV4YW1wbGUuY29tIHRvIGF2b2lkIGFuIGVycm9yXG54aHIub3BlbignR0VUJywgZ2xvYmFsLmxvY2F0aW9uLmhvc3QgPyAnLycgOiAnaHR0cHM6Ly9leGFtcGxlLmNvbScpXG5cbmZ1bmN0aW9uIGNoZWNrVHlwZVN1cHBvcnQgKHR5cGUpIHtcblx0dHJ5IHtcblx0XHR4aHIucmVzcG9uc2VUeXBlID0gdHlwZVxuXHRcdHJldHVybiB4aHIucmVzcG9uc2VUeXBlID09PSB0eXBlXG5cdH0gY2F0Y2ggKGUpIHt9XG5cdHJldHVybiBmYWxzZVxufVxuXG4vLyBGb3Igc29tZSBzdHJhbmdlIHJlYXNvbiwgU2FmYXJpIDcuMCByZXBvcnRzIHR5cGVvZiBnbG9iYWwuQXJyYXlCdWZmZXIgPT09ICdvYmplY3QnLlxuLy8gU2FmYXJpIDcuMSBhcHBlYXJzIHRvIGhhdmUgZml4ZWQgdGhpcyBidWcuXG52YXIgaGF2ZUFycmF5QnVmZmVyID0gdHlwZW9mIGdsb2JhbC5BcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCdcbnZhciBoYXZlU2xpY2UgPSBoYXZlQXJyYXlCdWZmZXIgJiYgaXNGdW5jdGlvbihnbG9iYWwuQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlKVxuXG5leHBvcnRzLmFycmF5YnVmZmVyID0gaGF2ZUFycmF5QnVmZmVyICYmIGNoZWNrVHlwZVN1cHBvcnQoJ2FycmF5YnVmZmVyJylcbi8vIFRoZXNlIG5leHQgdHdvIHRlc3RzIHVuYXZvaWRhYmx5IHNob3cgd2FybmluZ3MgaW4gQ2hyb21lLiBTaW5jZSBmZXRjaCB3aWxsIGFsd2F5c1xuLy8gYmUgdXNlZCBpZiBpdCdzIGF2YWlsYWJsZSwganVzdCByZXR1cm4gZmFsc2UgZm9yIHRoZXNlIHRvIGF2b2lkIHRoZSB3YXJuaW5ncy5cbmV4cG9ydHMubXNzdHJlYW0gPSAhZXhwb3J0cy5mZXRjaCAmJiBoYXZlU2xpY2UgJiYgY2hlY2tUeXBlU3VwcG9ydCgnbXMtc3RyZWFtJylcbmV4cG9ydHMubW96Y2h1bmtlZGFycmF5YnVmZmVyID0gIWV4cG9ydHMuZmV0Y2ggJiYgaGF2ZUFycmF5QnVmZmVyICYmXG5cdGNoZWNrVHlwZVN1cHBvcnQoJ21vei1jaHVua2VkLWFycmF5YnVmZmVyJylcbmV4cG9ydHMub3ZlcnJpZGVNaW1lVHlwZSA9IGlzRnVuY3Rpb24oeGhyLm92ZXJyaWRlTWltZVR5cGUpXG5leHBvcnRzLnZiQXJyYXkgPSBpc0Z1bmN0aW9uKGdsb2JhbC5WQkFycmF5KVxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nXG59XG5cbnhociA9IG51bGwgLy8gSGVscCBnY1xuIiwiLy8gdmFyIEJhc2U2NCA9IHJlcXVpcmUoJ0Jhc2U2NCcpXG52YXIgY2FwYWJpbGl0eSA9IHJlcXVpcmUoJy4vY2FwYWJpbGl0eScpXG52YXIgZm9yZWFjaCA9IHJlcXVpcmUoJ2ZvcmVhY2gnKVxudmFyIGluZGV4T2YgPSByZXF1aXJlKCdpbmRleG9mJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBrZXlzID0gcmVxdWlyZSgnb2JqZWN0LWtleXMnKVxudmFyIHJlc3BvbnNlID0gcmVxdWlyZSgnLi9yZXNwb25zZScpXG52YXIgc3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJylcblxudmFyIEluY29taW5nTWVzc2FnZSA9IHJlc3BvbnNlLkluY29taW5nTWVzc2FnZVxudmFyIHJTdGF0ZXMgPSByZXNwb25zZS5yZWFkeVN0YXRlc1xuXG5mdW5jdGlvbiBkZWNpZGVNb2RlIChwcmVmZXJCaW5hcnkpIHtcblx0aWYgKGNhcGFiaWxpdHkuZmV0Y2gpIHtcblx0XHRyZXR1cm4gJ2ZldGNoJ1xuXHR9IGVsc2UgaWYgKGNhcGFiaWxpdHkubW96Y2h1bmtlZGFycmF5YnVmZmVyKSB7XG5cdFx0cmV0dXJuICdtb3otY2h1bmtlZC1hcnJheWJ1ZmZlcidcblx0fSBlbHNlIGlmIChjYXBhYmlsaXR5Lm1zc3RyZWFtKSB7XG5cdFx0cmV0dXJuICdtcy1zdHJlYW0nXG5cdH0gZWxzZSBpZiAoY2FwYWJpbGl0eS5hcnJheWJ1ZmZlciAmJiBwcmVmZXJCaW5hcnkpIHtcblx0XHRyZXR1cm4gJ2FycmF5YnVmZmVyJ1xuXHR9IGVsc2UgaWYgKGNhcGFiaWxpdHkudmJBcnJheSAmJiBwcmVmZXJCaW5hcnkpIHtcblx0XHRyZXR1cm4gJ3RleHQ6dmJhcnJheSdcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gJ3RleHQnXG5cdH1cbn1cblxudmFyIENsaWVudFJlcXVlc3QgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRzKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXHRzdHJlYW0uV3JpdGFibGUuY2FsbChzZWxmKVxuXG5cdHNlbGYuX29wdHMgPSBvcHRzXG5cdHNlbGYuX2JvZHkgPSBbXVxuXHRzZWxmLl9oZWFkZXJzID0ge31cblx0aWYgKG9wdHMuYXV0aClcblx0XHRzZWxmLnNldEhlYWRlcignQXV0aG9yaXphdGlvbicsICdCYXNpYyAnICsgbmV3IEJ1ZmZlcihvcHRzLmF1dGgpLnRvU3RyaW5nKCdiYXNlNjQnKSlcblx0Zm9yZWFjaChrZXlzKG9wdHMuaGVhZGVycyksIGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0c2VsZi5zZXRIZWFkZXIobmFtZSwgb3B0cy5oZWFkZXJzW25hbWVdKVxuXHR9KVxuXG5cdHZhciBwcmVmZXJCaW5hcnlcblx0aWYgKG9wdHMubW9kZSA9PT0gJ3ByZWZlci1zdHJlYW1pbmcnKSB7XG5cdFx0Ly8gSWYgc3RyZWFtaW5nIGlzIGEgaGlnaCBwcmlvcml0eSBidXQgYmluYXJ5IGNvbXBhdGliaWxpdHkgYW5kXG5cdFx0Ly8gdGhlIGFjY3VyYWN5IG9mIHRoZSAnY29udGVudC10eXBlJyBoZWFkZXIgYXJlbid0XG5cdFx0cHJlZmVyQmluYXJ5ID0gZmFsc2Vcblx0fSBlbHNlIGlmIChvcHRzLm1vZGUgPT09ICdhbGxvdy13cm9uZy1jb250ZW50LXR5cGUnKSB7XG5cdFx0Ly8gSWYgc3RyZWFtaW5nIGlzIG1vcmUgaW1wb3J0YW50IHRoYW4gcHJlc2VydmluZyB0aGUgJ2NvbnRlbnQtdHlwZScgaGVhZGVyXG5cdFx0cHJlZmVyQmluYXJ5ID0gIWNhcGFiaWxpdHkub3ZlcnJpZGVNaW1lVHlwZVxuXHR9IGVsc2UgaWYgKCFvcHRzLm1vZGUgfHwgb3B0cy5tb2RlID09PSAnZGVmYXVsdCcgfHwgb3B0cy5tb2RlID09PSAncHJlZmVyLWZhc3QnKSB7XG5cdFx0Ly8gVXNlIGJpbmFyeSBpZiB0ZXh0IHN0cmVhbWluZyBtYXkgY29ycnVwdCBkYXRhIG9yIHRoZSBjb250ZW50LXR5cGUgaGVhZGVyLCBvciBmb3Igc3BlZWRcblx0XHRwcmVmZXJCaW5hcnkgPSB0cnVlXG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZhbHVlIGZvciBvcHRzLm1vZGUnKVxuXHR9XG5cdHNlbGYuX21vZGUgPSBkZWNpZGVNb2RlKHByZWZlckJpbmFyeSlcblxuXHRzZWxmLm9uKCdmaW5pc2gnLCBmdW5jdGlvbiAoKSB7XG5cdFx0c2VsZi5fb25GaW5pc2goKVxuXHR9KVxufVxuXG5pbmhlcml0cyhDbGllbnRSZXF1ZXN0LCBzdHJlYW0uV3JpdGFibGUpXG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLnNldEhlYWRlciA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuXHR2YXIgc2VsZiA9IHRoaXNcblx0dmFyIGxvd2VyTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKVxuXHQvLyBUaGlzIGNoZWNrIGlzIG5vdCBuZWNlc3NhcnksIGJ1dCBpdCBwcmV2ZW50cyB3YXJuaW5ncyBmcm9tIGJyb3dzZXJzIGFib3V0IHNldHRpbmcgdW5zYWZlXG5cdC8vIGhlYWRlcnMuIFRvIGJlIGhvbmVzdCBJJ20gbm90IGVudGlyZWx5IHN1cmUgaGlkaW5nIHRoZXNlIHdhcm5pbmdzIGlzIGEgZ29vZCB0aGluZywgYnV0XG5cdC8vIGh0dHAtYnJvd3NlcmlmeSBkaWQgaXQsIHNvIEkgd2lsbCB0b28uXG5cdGlmIChpbmRleE9mKHVuc2FmZUhlYWRlcnMsIGxvd2VyTmFtZSkgIT09IC0xKVxuXHRcdHJldHVyblxuXG5cdHNlbGYuX2hlYWRlcnNbbG93ZXJOYW1lXSA9IHtcblx0XHRuYW1lOiBuYW1lLFxuXHRcdHZhbHVlOiB2YWx1ZVxuXHR9XG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLmdldEhlYWRlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXHRyZXR1cm4gc2VsZi5faGVhZGVyc1tuYW1lLnRvTG93ZXJDYXNlKCldLnZhbHVlXG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLnJlbW92ZUhlYWRlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXHRkZWxldGUgc2VsZi5faGVhZGVyc1tuYW1lLnRvTG93ZXJDYXNlKCldXG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLl9vbkZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cblx0aWYgKHNlbGYuX2Rlc3Ryb3llZClcblx0XHRyZXR1cm5cblx0dmFyIG9wdHMgPSBzZWxmLl9vcHRzXG5cblx0dmFyIGhlYWRlcnNPYmogPSBzZWxmLl9oZWFkZXJzXG5cdHZhciBib2R5XG5cdGlmIChvcHRzLm1ldGhvZCA9PT0gJ1BPU1QnIHx8IG9wdHMubWV0aG9kID09PSAnUFVUJykge1xuXHRcdGlmIChjYXBhYmlsaXR5LmJsb2JDb25zdHJ1Y3Rvcikge1xuXHRcdFx0Ym9keSA9IG5ldyBnbG9iYWwuQmxvYihzZWxmLl9ib2R5Lm1hcChmdW5jdGlvbiAoYnVmZmVyKSB7XG5cdFx0XHRcdHJldHVybiBidWZmZXIudG9BcnJheUJ1ZmZlcigpXG5cdFx0XHR9KSwge1xuXHRcdFx0XHR0eXBlOiAoaGVhZGVyc09ialsnY29udGVudC10eXBlJ10gfHwge30pLnZhbHVlIHx8ICcnXG5cdFx0XHR9KVxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBnZXQgdXRmOCBzdHJpbmdcblx0XHRcdGJvZHkgPSBCdWZmZXIuY29uY2F0KHNlbGYuX2JvZHkpLnRvU3RyaW5nKClcblx0XHR9XG5cdH1cblxuXHRpZiAoc2VsZi5fbW9kZSA9PT0gJ2ZldGNoJykge1xuXHRcdHZhciBoZWFkZXJzID0ga2V5cyhoZWFkZXJzT2JqKS5tYXAoZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRcdHJldHVybiBbaGVhZGVyc09ialtuYW1lXS5uYW1lLCBoZWFkZXJzT2JqW25hbWVdLnZhbHVlXVxuXHRcdH0pXG5cblx0XHRnbG9iYWwuZmV0Y2goc2VsZi5fb3B0cy51cmwsIHtcblx0XHRcdG1ldGhvZDogc2VsZi5fb3B0cy5tZXRob2QsXG5cdFx0XHRoZWFkZXJzOiBoZWFkZXJzLFxuXHRcdFx0Ym9keTogYm9keSxcblx0XHRcdG1vZGU6ICdjb3JzJyxcblx0XHRcdGNyZWRlbnRpYWxzOiBvcHRzLndpdGhDcmVkZW50aWFscyA/ICdpbmNsdWRlJyA6ICdzYW1lLW9yaWdpbidcblx0XHR9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXHRcdFx0c2VsZi5fZmV0Y2hSZXNwb25zZSA9IHJlc3BvbnNlXG5cdFx0XHRzZWxmLl9jb25uZWN0KClcblx0XHR9KS50aGVuKHVuZGVmaW5lZCwgZnVuY3Rpb24gKHJlYXNvbikge1xuXHRcdFx0c2VsZi5lbWl0KCdlcnJvcicsIHJlYXNvbilcblx0XHR9KVxuXHR9IGVsc2Uge1xuXHRcdHZhciB4aHIgPSBzZWxmLl94aHIgPSBuZXcgZ2xvYmFsLlhNTEh0dHBSZXF1ZXN0KClcblx0XHR0cnkge1xuXHRcdFx0eGhyLm9wZW4oc2VsZi5fb3B0cy5tZXRob2QsIHNlbGYuX29wdHMudXJsLCB0cnVlKVxuXHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0cHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpXG5cdFx0XHR9KVxuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXG5cdFx0Ly8gQ2FuJ3Qgc2V0IHJlc3BvbnNlVHlwZSBvbiByZWFsbHkgb2xkIGJyb3dzZXJzXG5cdFx0aWYgKCdyZXNwb25zZVR5cGUnIGluIHhocilcblx0XHRcdHhoci5yZXNwb25zZVR5cGUgPSBzZWxmLl9tb2RlLnNwbGl0KCc6JylbMF1cblxuXHRcdGlmICgnd2l0aENyZWRlbnRpYWxzJyBpbiB4aHIpXG5cdFx0XHR4aHIud2l0aENyZWRlbnRpYWxzID0gISFvcHRzLndpdGhDcmVkZW50aWFsc1xuXG5cdFx0aWYgKHNlbGYuX21vZGUgPT09ICd0ZXh0JyAmJiAnb3ZlcnJpZGVNaW1lVHlwZScgaW4geGhyKVxuXHRcdFx0eGhyLm92ZXJyaWRlTWltZVR5cGUoJ3RleHQvcGxhaW47IGNoYXJzZXQ9eC11c2VyLWRlZmluZWQnKVxuXG5cdFx0Zm9yZWFjaChrZXlzKGhlYWRlcnNPYmopLCBmdW5jdGlvbiAobmFtZSkge1xuXHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyc09ialtuYW1lXS5uYW1lLCBoZWFkZXJzT2JqW25hbWVdLnZhbHVlKVxuXHRcdH0pXG5cblx0XHRzZWxmLl9yZXNwb25zZSA9IG51bGxcblx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0c3dpdGNoICh4aHIucmVhZHlTdGF0ZSkge1xuXHRcdFx0XHRjYXNlIHJTdGF0ZXMuTE9BRElORzpcblx0XHRcdFx0Y2FzZSByU3RhdGVzLkRPTkU6XG5cdFx0XHRcdFx0c2VsZi5fb25YSFJQcm9ncmVzcygpXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gTmVjZXNzYXJ5IGZvciBzdHJlYW1pbmcgaW4gRmlyZWZveCwgc2luY2UgeGhyLnJlc3BvbnNlIGlzIE9OTFkgZGVmaW5lZFxuXHRcdC8vIGluIG9ucHJvZ3Jlc3MsIG5vdCBpbiBvbnJlYWR5c3RhdGVjaGFuZ2Ugd2l0aCB4aHIucmVhZHlTdGF0ZSA9IDNcblx0XHRpZiAoc2VsZi5fbW9kZSA9PT0gJ21vei1jaHVua2VkLWFycmF5YnVmZmVyJykge1xuXHRcdFx0eGhyLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHNlbGYuX29uWEhSUHJvZ3Jlc3MoKVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHhoci5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKHNlbGYuX2Rlc3Ryb3llZClcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHRzZWxmLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdYSFIgZXJyb3InKSlcblx0XHR9XG5cblx0XHR0cnkge1xuXHRcdFx0eGhyLnNlbmQoYm9keSlcblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKVxuXHRcdFx0fSlcblx0XHRcdHJldHVyblxuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIENoZWNrcyBpZiB4aHIuc3RhdHVzIGlzIHJlYWRhYmxlLiBFdmVuIHRob3VnaCB0aGUgc3BlYyBzYXlzIGl0IHNob3VsZFxuICogYmUgYXZhaWxhYmxlIGluIHJlYWR5U3RhdGUgMywgYWNjZXNzaW5nIGl0IHRocm93cyBhbiBleGNlcHRpb24gaW4gSUU4XG4gKi9cbmZ1bmN0aW9uIHN0YXR1c1ZhbGlkICh4aHIpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gKHhoci5zdGF0dXMgIT09IG51bGwpXG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2Vcblx0fVxufVxuXG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5fb25YSFJQcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cblx0aWYgKCFzdGF0dXNWYWxpZChzZWxmLl94aHIpIHx8IHNlbGYuX2Rlc3Ryb3llZClcblx0XHRyZXR1cm5cblxuXHRpZiAoIXNlbGYuX3Jlc3BvbnNlKVxuXHRcdHNlbGYuX2Nvbm5lY3QoKVxuXG5cdHNlbGYuX3Jlc3BvbnNlLl9vblhIUlByb2dyZXNzKClcbn1cblxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuX2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXG5cdGlmIChzZWxmLl9kZXN0cm95ZWQpXG5cdFx0cmV0dXJuXG5cblx0c2VsZi5fcmVzcG9uc2UgPSBuZXcgSW5jb21pbmdNZXNzYWdlKHNlbGYuX3hociwgc2VsZi5fZmV0Y2hSZXNwb25zZSwgc2VsZi5fbW9kZSlcblx0c2VsZi5lbWl0KCdyZXNwb25zZScsIHNlbGYuX3Jlc3BvbnNlKVxufVxuXG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuXHR2YXIgc2VsZiA9IHRoaXNcblxuXHRzZWxmLl9ib2R5LnB1c2goY2h1bmspXG5cdGNiKClcbn1cblxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuYWJvcnQgPSBDbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgc2VsZiA9IHRoaXNcblx0c2VsZi5fZGVzdHJveWVkID0gdHJ1ZVxuXHRpZiAoc2VsZi5fcmVzcG9uc2UpXG5cdFx0c2VsZi5fcmVzcG9uc2UuX2Rlc3Ryb3llZCA9IHRydWVcblx0aWYgKHNlbGYuX3hocilcblx0XHRzZWxmLl94aHIuYWJvcnQoKVxuXHQvLyBDdXJyZW50bHksIHRoZXJlIGlzbid0IGEgd2F5IHRvIHRydWx5IGFib3J0IGEgZmV0Y2guXG5cdC8vIElmIHlvdSBsaWtlIGJpa2VzaGVkZGluZywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93aGF0d2cvZmV0Y2gvaXNzdWVzLzI3XG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChkYXRhLCBlbmNvZGluZywgY2IpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cdGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdGNiID0gZGF0YVxuXHRcdGRhdGEgPSB1bmRlZmluZWRcblx0fVxuXG5cdHN0cmVhbS5Xcml0YWJsZS5wcm90b3R5cGUuZW5kLmNhbGwoc2VsZiwgZGF0YSwgZW5jb2RpbmcsIGNiKVxufVxuXG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5mbHVzaEhlYWRlcnMgPSBmdW5jdGlvbiAoKSB7fVxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuc2V0VGltZW91dCA9IGZ1bmN0aW9uICgpIHt9XG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5zZXROb0RlbGF5ID0gZnVuY3Rpb24gKCkge31cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLnNldFNvY2tldEtlZXBBbGl2ZSA9IGZ1bmN0aW9uICgpIHt9XG5cbi8vIFRha2VuIGZyb20gaHR0cDovL3d3dy53My5vcmcvVFIvWE1MSHR0cFJlcXVlc3QvI3RoZS1zZXRyZXF1ZXN0aGVhZGVyJTI4JTI5LW1ldGhvZFxudmFyIHVuc2FmZUhlYWRlcnMgPSBbXG5cdCdhY2NlcHQtY2hhcnNldCcsXG5cdCdhY2NlcHQtZW5jb2RpbmcnLFxuXHQnYWNjZXNzLWNvbnRyb2wtcmVxdWVzdC1oZWFkZXJzJyxcblx0J2FjY2Vzcy1jb250cm9sLXJlcXVlc3QtbWV0aG9kJyxcblx0J2Nvbm5lY3Rpb24nLFxuXHQnY29udGVudC1sZW5ndGgnLFxuXHQnY29va2llJyxcblx0J2Nvb2tpZTInLFxuXHQnZGF0ZScsXG5cdCdkbnQnLFxuXHQnZXhwZWN0Jyxcblx0J2hvc3QnLFxuXHQna2VlcC1hbGl2ZScsXG5cdCdvcmlnaW4nLFxuXHQncmVmZXJlcicsXG5cdCd0ZScsXG5cdCd0cmFpbGVyJyxcblx0J3RyYW5zZmVyLWVuY29kaW5nJyxcblx0J3VwZ3JhZGUnLFxuXHQndXNlci1hZ2VudCcsXG5cdCd2aWEnXG5dXG4iLCJ2YXIgY2FwYWJpbGl0eSA9IHJlcXVpcmUoJy4vY2FwYWJpbGl0eScpXG52YXIgZm9yZWFjaCA9IHJlcXVpcmUoJ2ZvcmVhY2gnKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpXG5cbnZhciByU3RhdGVzID0gZXhwb3J0cy5yZWFkeVN0YXRlcyA9IHtcblx0VU5TRU5UOiAwLFxuXHRPUEVORUQ6IDEsXG5cdEhFQURFUlNfUkVDRUlWRUQ6IDIsXG5cdExPQURJTkc6IDMsXG5cdERPTkU6IDRcbn1cblxudmFyIEluY29taW5nTWVzc2FnZSA9IGV4cG9ydHMuSW5jb21pbmdNZXNzYWdlID0gZnVuY3Rpb24gKHhociwgcmVzcG9uc2UsIG1vZGUpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cdHN0cmVhbS5SZWFkYWJsZS5jYWxsKHNlbGYpXG5cblx0c2VsZi5fbW9kZSA9IG1vZGVcblx0c2VsZi5oZWFkZXJzID0ge31cblx0c2VsZi5yYXdIZWFkZXJzID0gW11cblx0c2VsZi50cmFpbGVycyA9IHt9XG5cdHNlbGYucmF3VHJhaWxlcnMgPSBbXVxuXG5cdC8vIEZha2UgdGhlICdjbG9zZScgZXZlbnQsIGJ1dCBvbmx5IG9uY2UgJ2VuZCcgZmlyZXNcblx0c2VsZi5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuXHRcdC8vIFRoZSBuZXh0VGljayBpcyBuZWNlc3NhcnkgdG8gcHJldmVudCB0aGUgJ3JlcXVlc3QnIG1vZHVsZSBmcm9tIGNhdXNpbmcgYW4gaW5maW5pdGUgbG9vcFxuXHRcdHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuXHRcdFx0c2VsZi5lbWl0KCdjbG9zZScpXG5cdFx0fSlcblx0fSlcblxuXHRpZiAobW9kZSA9PT0gJ2ZldGNoJykge1xuXHRcdHNlbGYuX2ZldGNoUmVzcG9uc2UgPSByZXNwb25zZVxuXG5cdFx0c2VsZi5zdGF0dXNDb2RlID0gcmVzcG9uc2Uuc3RhdHVzXG5cdFx0c2VsZi5zdGF0dXNNZXNzYWdlID0gcmVzcG9uc2Uuc3RhdHVzVGV4dFxuXHRcdC8vIGJhY2t3YXJkcyBjb21wYXRpYmxlIHZlcnNpb24gb2YgZm9yICg8aXRlbT4gb2YgPGl0ZXJhYmxlPik6XG5cdFx0Ly8gZm9yICh2YXIgPGl0ZW0+LF9pLF9pdCA9IDxpdGVyYWJsZT5bU3ltYm9sLml0ZXJhdG9yXSgpOyA8aXRlbT4gPSAoX2kgPSBfaXQubmV4dCgpKS52YWx1ZSwhX2kuZG9uZTspXG5cdFx0Zm9yICh2YXIgaGVhZGVyLCBfaSwgX2l0ID0gcmVzcG9uc2UuaGVhZGVyc1tTeW1ib2wuaXRlcmF0b3JdKCk7IGhlYWRlciA9IChfaSA9IF9pdC5uZXh0KCkpLnZhbHVlLCAhX2kuZG9uZTspIHtcblx0XHRcdHNlbGYuaGVhZGVyc1toZWFkZXJbMF0udG9Mb3dlckNhc2UoKV0gPSBoZWFkZXJbMV1cblx0XHRcdHNlbGYucmF3SGVhZGVycy5wdXNoKGhlYWRlclswXSwgaGVhZGVyWzFdKVxuXHRcdH1cblxuXHRcdC8vIFRPRE86IHRoaXMgZG9lc24ndCByZXNwZWN0IGJhY2twcmVzc3VyZS4gT25jZSBXcml0YWJsZVN0cmVhbSBpcyBhdmFpbGFibGUsIHRoaXMgY2FuIGJlIGZpeGVkXG5cdFx0dmFyIHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKClcblx0XHRmdW5jdGlvbiByZWFkICgpIHtcblx0XHRcdHJlYWRlci5yZWFkKCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG5cdFx0XHRcdGlmIChzZWxmLl9kZXN0cm95ZWQpXG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdGlmIChyZXN1bHQuZG9uZSkge1xuXHRcdFx0XHRcdHNlbGYucHVzaChudWxsKVxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHR9XG5cdFx0XHRcdHNlbGYucHVzaChuZXcgQnVmZmVyKHJlc3VsdC52YWx1ZSkpXG5cdFx0XHRcdHJlYWQoKVxuXHRcdFx0fSlcblx0XHR9XG5cdFx0cmVhZCgpXG5cblx0fSBlbHNlIHtcblx0XHRzZWxmLl94aHIgPSB4aHJcblx0XHRzZWxmLl9wb3MgPSAwXG5cblx0XHRzZWxmLnN0YXR1c0NvZGUgPSB4aHIuc3RhdHVzXG5cdFx0c2VsZi5zdGF0dXNNZXNzYWdlID0geGhyLnN0YXR1c1RleHRcblx0XHR2YXIgaGVhZGVycyA9IHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKS5zcGxpdCgvXFxyP1xcbi8pXG5cdFx0Zm9yZWFjaChoZWFkZXJzLCBmdW5jdGlvbiAoaGVhZGVyKSB7XG5cdFx0XHR2YXIgbWF0Y2hlcyA9IGhlYWRlci5tYXRjaCgvXihbXjpdKyk6XFxzKiguKikvKVxuXHRcdFx0aWYgKG1hdGNoZXMpIHtcblx0XHRcdFx0dmFyIGtleSA9IG1hdGNoZXNbMV0udG9Mb3dlckNhc2UoKVxuXHRcdFx0XHRpZiAoc2VsZi5oZWFkZXJzW2tleV0gIT09IHVuZGVmaW5lZClcblx0XHRcdFx0XHRzZWxmLmhlYWRlcnNba2V5XSArPSAnLCAnICsgbWF0Y2hlc1syXVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0c2VsZi5oZWFkZXJzW2tleV0gPSBtYXRjaGVzWzJdXG5cdFx0XHRcdHNlbGYucmF3SGVhZGVycy5wdXNoKG1hdGNoZXNbMV0sIG1hdGNoZXNbMl0pXG5cdFx0XHR9XG5cdFx0fSlcblxuXHRcdHNlbGYuX2NoYXJzZXQgPSAneC11c2VyLWRlZmluZWQnXG5cdFx0aWYgKCFjYXBhYmlsaXR5Lm92ZXJyaWRlTWltZVR5cGUpIHtcblx0XHRcdHZhciBtaW1lVHlwZSA9IHNlbGYucmF3SGVhZGVyc1snbWltZS10eXBlJ11cblx0XHRcdGlmIChtaW1lVHlwZSkge1xuXHRcdFx0XHR2YXIgY2hhcnNldE1hdGNoID0gbWltZVR5cGUubWF0Y2goLztcXHMqY2hhcnNldD0oW147XSkoO3wkKS8pXG5cdFx0XHRcdGlmIChjaGFyc2V0TWF0Y2gpIHtcblx0XHRcdFx0XHRzZWxmLl9jaGFyc2V0ID0gY2hhcnNldE1hdGNoWzFdLnRvTG93ZXJDYXNlKClcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCFzZWxmLl9jaGFyc2V0KVxuXHRcdFx0XHRzZWxmLl9jaGFyc2V0ID0gJ3V0Zi04JyAvLyBiZXN0IGd1ZXNzXG5cdFx0fVxuXHR9XG59XG5cbmluaGVyaXRzKEluY29taW5nTWVzc2FnZSwgc3RyZWFtLlJlYWRhYmxlKVxuXG5JbmNvbWluZ01lc3NhZ2UucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKCkge31cblxuSW5jb21pbmdNZXNzYWdlLnByb3RvdHlwZS5fb25YSFJQcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cblx0dmFyIHhociA9IHNlbGYuX3hoclxuXG5cdHZhciByZXNwb25zZSA9IG51bGxcblx0c3dpdGNoIChzZWxmLl9tb2RlKSB7XG5cdFx0Y2FzZSAndGV4dDp2YmFycmF5JzogLy8gRm9yIElFOVxuXHRcdFx0aWYgKHhoci5yZWFkeVN0YXRlICE9PSByU3RhdGVzLkRPTkUpXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHR0cnkge1xuXHRcdFx0XHQvLyBUaGlzIGZhaWxzIGluIElFOFxuXHRcdFx0XHRyZXNwb25zZSA9IG5ldyBnbG9iYWwuVkJBcnJheSh4aHIucmVzcG9uc2VCb2R5KS50b0FycmF5KClcblx0XHRcdH0gY2F0Y2ggKGUpIHt9XG5cdFx0XHRpZiAocmVzcG9uc2UgIT09IG51bGwpIHtcblx0XHRcdFx0c2VsZi5wdXNoKG5ldyBCdWZmZXIocmVzcG9uc2UpKVxuXHRcdFx0XHRicmVha1xuXHRcdFx0fVxuXHRcdFx0Ly8gRmFsbHMgdGhyb3VnaCBpbiBJRThcdFxuXHRcdGNhc2UgJ3RleHQnOlxuXHRcdFx0dHJ5IHsgLy8gVGhpcyB3aWxsIGZhaWwgd2hlbiByZWFkeVN0YXRlID0gMyBpbiBJRTkuIFN3aXRjaCBtb2RlIGFuZCB3YWl0IGZvciByZWFkeVN0YXRlID0gNFxuXHRcdFx0XHRyZXNwb25zZSA9IHhoci5yZXNwb25zZVRleHRcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0c2VsZi5fbW9kZSA9ICd0ZXh0OnZiYXJyYXknXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHR9XG5cdFx0XHRpZiAocmVzcG9uc2UubGVuZ3RoID4gc2VsZi5fcG9zKSB7XG5cdFx0XHRcdHZhciBuZXdEYXRhID0gcmVzcG9uc2Uuc3Vic3RyKHNlbGYuX3Bvcylcblx0XHRcdFx0aWYgKHNlbGYuX2NoYXJzZXQgPT09ICd4LXVzZXItZGVmaW5lZCcpIHtcblx0XHRcdFx0XHR2YXIgYnVmZmVyID0gbmV3IEJ1ZmZlcihuZXdEYXRhLmxlbmd0aClcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG5ld0RhdGEubGVuZ3RoOyBpKyspXG5cdFx0XHRcdFx0XHRidWZmZXJbaV0gPSBuZXdEYXRhLmNoYXJDb2RlQXQoaSkgJiAweGZmXG5cblx0XHRcdFx0XHRzZWxmLnB1c2goYnVmZmVyKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNlbGYucHVzaChuZXdEYXRhLCBzZWxmLl9jaGFyc2V0KVxuXHRcdFx0XHR9XG5cdFx0XHRcdHNlbGYuX3BvcyA9IHJlc3BvbnNlLmxlbmd0aFxuXHRcdFx0fVxuXHRcdFx0YnJlYWtcblx0XHRjYXNlICdhcnJheWJ1ZmZlcic6XG5cdFx0XHRpZiAoeGhyLnJlYWR5U3RhdGUgIT09IHJTdGF0ZXMuRE9ORSlcblx0XHRcdFx0YnJlYWtcblx0XHRcdHJlc3BvbnNlID0geGhyLnJlc3BvbnNlXG5cdFx0XHRzZWxmLnB1c2gobmV3IEJ1ZmZlcihuZXcgVWludDhBcnJheShyZXNwb25zZSkpKVxuXHRcdFx0YnJlYWtcblx0XHRjYXNlICdtb3otY2h1bmtlZC1hcnJheWJ1ZmZlcic6IC8vIHRha2Ugd2hvbGVcblx0XHRcdHJlc3BvbnNlID0geGhyLnJlc3BvbnNlXG5cdFx0XHRpZiAoeGhyLnJlYWR5U3RhdGUgIT09IHJTdGF0ZXMuTE9BRElORyB8fCAhcmVzcG9uc2UpXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRzZWxmLnB1c2gobmV3IEJ1ZmZlcihuZXcgVWludDhBcnJheShyZXNwb25zZSkpKVxuXHRcdFx0YnJlYWtcblx0XHRjYXNlICdtcy1zdHJlYW0nOlxuXHRcdFx0cmVzcG9uc2UgPSB4aHIucmVzcG9uc2Vcblx0XHRcdGlmICh4aHIucmVhZHlTdGF0ZSAhPT0gclN0YXRlcy5MT0FESU5HKVxuXHRcdFx0XHRicmVha1xuXHRcdFx0dmFyIHJlYWRlciA9IG5ldyBnbG9iYWwuTVNTdHJlYW1SZWFkZXIoKVxuXHRcdFx0cmVhZGVyLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGlmIChyZWFkZXIucmVzdWx0LmJ5dGVMZW5ndGggPiBzZWxmLl9wb3MpIHtcblx0XHRcdFx0XHRzZWxmLnB1c2gobmV3IEJ1ZmZlcihuZXcgVWludDhBcnJheShyZWFkZXIucmVzdWx0LnNsaWNlKHNlbGYuX3BvcykpKSlcblx0XHRcdFx0XHRzZWxmLl9wb3MgPSByZWFkZXIucmVzdWx0LmJ5dGVMZW5ndGhcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0c2VsZi5wdXNoKG51bGwpXG5cdFx0XHR9XG5cdFx0XHQvLyByZWFkZXIub25lcnJvciA9ID8/PyAvLyBUT0RPOiB0aGlzXG5cdFx0XHRyZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIocmVzcG9uc2UpXG5cdFx0XHRicmVha1xuXHR9XG5cblx0Ly8gVGhlIG1zLXN0cmVhbSBjYXNlIGhhbmRsZXMgZW5kIHNlcGFyYXRlbHkgaW4gcmVhZGVyLm9ubG9hZCgpXG5cdGlmIChzZWxmLl94aHIucmVhZHlTdGF0ZSA9PT0gclN0YXRlcy5ET05FICYmIHNlbGYuX21vZGUgIT09ICdtcy1zdHJlYW0nKSB7XG5cdFx0c2VsZi5wdXNoKG51bGwpXG5cdH1cbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgcHVueWNvZGUgPSByZXF1aXJlKCdwdW55Y29kZScpO1xuXG5leHBvcnRzLnBhcnNlID0gdXJsUGFyc2U7XG5leHBvcnRzLnJlc29sdmUgPSB1cmxSZXNvbHZlO1xuZXhwb3J0cy5yZXNvbHZlT2JqZWN0ID0gdXJsUmVzb2x2ZU9iamVjdDtcbmV4cG9ydHMuZm9ybWF0ID0gdXJsRm9ybWF0O1xuXG5leHBvcnRzLlVybCA9IFVybDtcblxuZnVuY3Rpb24gVXJsKCkge1xuICB0aGlzLnByb3RvY29sID0gbnVsbDtcbiAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgdGhpcy5hdXRoID0gbnVsbDtcbiAgdGhpcy5ob3N0ID0gbnVsbDtcbiAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgdGhpcy5ob3N0bmFtZSA9IG51bGw7XG4gIHRoaXMuaGFzaCA9IG51bGw7XG4gIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgdGhpcy5xdWVyeSA9IG51bGw7XG4gIHRoaXMucGF0aG5hbWUgPSBudWxsO1xuICB0aGlzLnBhdGggPSBudWxsO1xuICB0aGlzLmhyZWYgPSBudWxsO1xufVxuXG4vLyBSZWZlcmVuY2U6IFJGQyAzOTg2LCBSRkMgMTgwOCwgUkZDIDIzOTZcblxuLy8gZGVmaW5lIHRoZXNlIGhlcmUgc28gYXQgbGVhc3QgdGhleSBvbmx5IGhhdmUgdG8gYmVcbi8vIGNvbXBpbGVkIG9uY2Ugb24gdGhlIGZpcnN0IG1vZHVsZSBsb2FkLlxudmFyIHByb3RvY29sUGF0dGVybiA9IC9eKFthLXowLTkuKy1dKzopL2ksXG4gICAgcG9ydFBhdHRlcm4gPSAvOlswLTldKiQvLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgcmVzZXJ2ZWQgZm9yIGRlbGltaXRpbmcgVVJMcy5cbiAgICAvLyBXZSBhY3R1YWxseSBqdXN0IGF1dG8tZXNjYXBlIHRoZXNlLlxuICAgIGRlbGltcyA9IFsnPCcsICc+JywgJ1wiJywgJ2AnLCAnICcsICdcXHInLCAnXFxuJywgJ1xcdCddLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgbm90IGFsbG93ZWQgZm9yIHZhcmlvdXMgcmVhc29ucy5cbiAgICB1bndpc2UgPSBbJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICdgJ10uY29uY2F0KGRlbGltcyksXG5cbiAgICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXG4gICAgYXV0b0VzY2FwZSA9IFsnXFwnJ10uY29uY2F0KHVud2lzZSksXG4gICAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgICAvLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4gICAgLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4gICAgLy8gdGhlbS5cbiAgICBub25Ib3N0Q2hhcnMgPSBbJyUnLCAnLycsICc/JywgJzsnLCAnIyddLmNvbmNhdChhdXRvRXNjYXBlKSxcbiAgICBob3N0RW5kaW5nQ2hhcnMgPSBbJy8nLCAnPycsICcjJ10sXG4gICAgaG9zdG5hbWVNYXhMZW4gPSAyNTUsXG4gICAgaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eW2EtejAtOUEtWl8tXXswLDYzfSQvLFxuICAgIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oW2EtejAtOUEtWl8tXXswLDYzfSkoLiopJC8sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93IFwidW5zYWZlXCIgYW5kIFwidW53aXNlXCIgY2hhcnMuXG4gICAgdW5zYWZlUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBuZXZlciBoYXZlIGEgaG9zdG5hbWUuXG4gICAgaG9zdGxlc3NQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBjb250YWluIGEgLy8gYml0LlxuICAgIHNsYXNoZWRQcm90b2NvbCA9IHtcbiAgICAgICdodHRwJzogdHJ1ZSxcbiAgICAgICdodHRwcyc6IHRydWUsXG4gICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICdnb3BoZXInOiB0cnVlLFxuICAgICAgJ2ZpbGUnOiB0cnVlLFxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICdodHRwczonOiB0cnVlLFxuICAgICAgJ2Z0cDonOiB0cnVlLFxuICAgICAgJ2dvcGhlcjonOiB0cnVlLFxuICAgICAgJ2ZpbGU6JzogdHJ1ZVxuICAgIH0sXG4gICAgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgaXNPYmplY3QodXJsKSAmJiB1cmwgaW5zdGFuY2VvZiBVcmwpIHJldHVybiB1cmw7XG5cbiAgdmFyIHUgPSBuZXcgVXJsO1xuICB1LnBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpO1xuICByZXR1cm4gdTtcbn1cblxuVXJsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKCFpc1N0cmluZyh1cmwpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhcmFtZXRlciAndXJsJyBtdXN0IGJlIGEgc3RyaW5nLCBub3QgXCIgKyB0eXBlb2YgdXJsKTtcbiAgfVxuXG4gIHZhciByZXN0ID0gdXJsO1xuXG4gIC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXG4gIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiICBodHRwOi8vZm9vLmNvbSAgXFxuXCJcbiAgcmVzdCA9IHJlc3QudHJpbSgpO1xuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnByb3RvY29sID0gbG93ZXJQcm90bztcbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XG4gICAgdmFyIHNsYXNoZXMgPSByZXN0LnN1YnN0cigwLCAyKSA9PT0gJy8vJztcbiAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIGhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xuICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dICYmXG4gICAgICAoc2xhc2hlcyB8fCAocHJvdG8gJiYgIXNsYXNoZWRQcm90b2NvbFtwcm90b10pKSkge1xuXG4gICAgLy8gdGhlcmUncyBhIGhvc3RuYW1lLlxuICAgIC8vIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiAvLCA/LCA7LCBvciAjIGVuZHMgdGhlIGhvc3QuXG4gICAgLy9cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBAIGluIHRoZSBob3N0bmFtZSwgdGhlbiBub24taG9zdCBjaGFycyAqYXJlKiBhbGxvd2VkXG4gICAgLy8gdG8gdGhlIGxlZnQgb2YgdGhlIGxhc3QgQCBzaWduLCB1bmxlc3Mgc29tZSBob3N0LWVuZGluZyBjaGFyYWN0ZXJcbiAgICAvLyBjb21lcyAqYmVmb3JlKiB0aGUgQC1zaWduLlxuICAgIC8vIFVSTHMgYXJlIG9ibm94aW91cy5cbiAgICAvL1xuICAgIC8vIGV4OlxuICAgIC8vIGh0dHA6Ly9hQGJAYy8gPT4gdXNlcjphQGIgaG9zdDpjXG4gICAgLy8gaHR0cDovL2FAYj9AYyA9PiB1c2VyOmEgaG9zdDpjIHBhdGg6Lz9AY1xuXG4gICAgLy8gdjAuMTIgVE9ETyhpc2FhY3MpOiBUaGlzIGlzIG5vdCBxdWl0ZSBob3cgQ2hyb21lIGRvZXMgdGhpbmdzLlxuICAgIC8vIFJldmlldyBvdXIgdGVzdCBjYXNlIGFnYWluc3QgYnJvd3NlcnMgbW9yZSBjb21wcmVoZW5zaXZlbHkuXG5cbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgaG9zdEVuZGluZ0NoYXJzXG4gICAgdmFyIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvc3RFbmRpbmdDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihob3N0RW5kaW5nQ2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cblxuICAgIC8vIGF0IHRoaXMgcG9pbnQsIGVpdGhlciB3ZSBoYXZlIGFuIGV4cGxpY2l0IHBvaW50IHdoZXJlIHRoZVxuICAgIC8vIGF1dGggcG9ydGlvbiBjYW5ub3QgZ28gcGFzdCwgb3IgdGhlIGxhc3QgQCBjaGFyIGlzIHRoZSBkZWNpZGVyLlxuICAgIHZhciBhdXRoLCBhdFNpZ247XG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XG4gICAgICAvLyBhdFNpZ24gY2FuIGJlIGFueXdoZXJlLlxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhdFNpZ24gbXVzdCBiZSBpbiBhdXRoIHBvcnRpb24uXG4gICAgICAvLyBodHRwOi8vYUBiL2NAZCA9PiBob3N0OmIgYXV0aDphIHBhdGg6L2NAZFxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcsIGhvc3RFbmQpO1xuICAgIH1cblxuICAgIC8vIE5vdyB3ZSBoYXZlIGEgcG9ydGlvbiB3aGljaCBpcyBkZWZpbml0ZWx5IHRoZSBhdXRoLlxuICAgIC8vIFB1bGwgdGhhdCBvZmYuXG4gICAgaWYgKGF0U2lnbiAhPT0gLTEpIHtcbiAgICAgIGF1dGggPSByZXN0LnNsaWNlKDAsIGF0U2lnbik7XG4gICAgICByZXN0ID0gcmVzdC5zbGljZShhdFNpZ24gKyAxKTtcbiAgICAgIHRoaXMuYXV0aCA9IGRlY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICB9XG5cbiAgICAvLyB0aGUgaG9zdCBpcyB0aGUgcmVtYWluaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBub24taG9zdCBjaGFyXG4gICAgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9uSG9zdENoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKG5vbkhvc3RDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuICAgIC8vIGlmIHdlIHN0aWxsIGhhdmUgbm90IGhpdCBpdCwgdGhlbiB0aGUgZW50aXJlIHRoaW5nIGlzIGEgaG9zdC5cbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpXG4gICAgICBob3N0RW5kID0gcmVzdC5sZW5ndGg7XG5cbiAgICB0aGlzLmhvc3QgPSByZXN0LnNsaWNlKDAsIGhvc3RFbmQpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKGhvc3RFbmQpO1xuXG4gICAgLy8gcHVsbCBvdXQgcG9ydC5cbiAgICB0aGlzLnBhcnNlSG9zdCgpO1xuXG4gICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxuICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuXG4gICAgLy8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbiAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cbiAgICB2YXIgaXB2Nkhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZVswXSA9PT0gJ1snICYmXG4gICAgICAgIHRoaXMuaG9zdG5hbWVbdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAxXSA9PT0gJ10nO1xuXG4gICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaG9zdHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IGhvc3RwYXJ0c1tpXTtcbiAgICAgICAgaWYgKCFwYXJ0KSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgdmFyIG5ld3BhcnQgPSAnJztcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGopID4gMTI3KSB7XG4gICAgICAgICAgICAgIC8vIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBieSByZXBsYWNpbmcgbm9uLUFTQ0lJIGJ5IG5vdGhpbmdcbiAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdlIHRlc3QgYWdhaW4gd2l0aCBBU0NJSSBjaGFyIG9ubHlcbiAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgdmFyIG5vdEhvc3QgPSBob3N0cGFydHMuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgICB2YWxpZFBhcnRzLnB1c2goYml0WzFdKTtcbiAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdCA9ICcvJyArIG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB2YWxpZFBhcnRzLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhvc3RuYW1lcyBhcmUgYWx3YXlzIGxvd2VyIGNhc2UuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICAvLyBJRE5BIFN1cHBvcnQ6IFJldHVybnMgYSBwdW55IGNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIFwiZG9tYWluXCIuXG4gICAgICAvLyBJdCBvbmx5IGNvbnZlcnRzIHRoZSBwYXJ0IG9mIHRoZSBkb21haW4gbmFtZSB0aGF0XG4gICAgICAvLyBoYXMgbm9uIEFTQ0lJIGNoYXJhY3RlcnMuIEkuZS4gaXQgZG9zZW50IG1hdHRlciBpZlxuICAgICAgLy8geW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0IGFscmVhZHkgaXMgaW4gQVNDSUkuXG4gICAgICB2YXIgZG9tYWluQXJyYXkgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KCcuJyk7XG4gICAgICB2YXIgbmV3T3V0ID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRvbWFpbkFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBzID0gZG9tYWluQXJyYXlbaV07XG4gICAgICAgIG5ld091dC5wdXNoKHMubWF0Y2goL1teQS1aYS16MC05Xy1dLykgP1xuICAgICAgICAgICAgJ3huLS0nICsgcHVueWNvZGUuZW5jb2RlKHMpIDogcyk7XG4gICAgICB9XG4gICAgICB0aGlzLmhvc3RuYW1lID0gbmV3T3V0LmpvaW4oJy4nKTtcbiAgICB9XG5cbiAgICB2YXIgcCA9IHRoaXMucG9ydCA/ICc6JyArIHRoaXMucG9ydCA6ICcnO1xuICAgIHZhciBoID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcbiAgICB0aGlzLmhvc3QgPSBoICsgcDtcbiAgICB0aGlzLmhyZWYgKz0gdGhpcy5ob3N0O1xuXG4gICAgLy8gc3RyaXAgWyBhbmQgXSBmcm9tIHRoZSBob3N0bmFtZVxuICAgIC8vIHRoZSBob3N0IGZpZWxkIHN0aWxsIHJldGFpbnMgdGhlbSwgdGhvdWdoXG4gICAgaWYgKGlwdjZIb3N0bmFtZSkge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUuc3Vic3RyKDEsIHRoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBpZiAocmVzdFswXSAhPT0gJy8nKSB7XG4gICAgICAgIHJlc3QgPSAnLycgKyByZXN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG5vdyByZXN0IGlzIHNldCB0byB0aGUgcG9zdC1ob3N0IHN0dWZmLlxuICAvLyBjaG9wIG9mZiBhbnkgZGVsaW0gY2hhcnMuXG4gIGlmICghdW5zYWZlUHJvdG9jb2xbbG93ZXJQcm90b10pIHtcblxuICAgIC8vIEZpcnN0LCBtYWtlIDEwMCUgc3VyZSB0aGF0IGFueSBcImF1dG9Fc2NhcGVcIiBjaGFycyBnZXRcbiAgICAvLyBlc2NhcGVkLCBldmVuIGlmIGVuY29kZVVSSUNvbXBvbmVudCBkb2Vzbid0IHRoaW5rIHRoZXlcbiAgICAvLyBuZWVkIHRvIGJlLlxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXV0b0VzY2FwZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhZSA9IGF1dG9Fc2NhcGVbaV07XG4gICAgICB2YXIgZXNjID0gZW5jb2RlVVJJQ29tcG9uZW50KGFlKTtcbiAgICAgIGlmIChlc2MgPT09IGFlKSB7XG4gICAgICAgIGVzYyA9IGVzY2FwZShhZSk7XG4gICAgICB9XG4gICAgICByZXN0ID0gcmVzdC5zcGxpdChhZSkuam9pbihlc2MpO1xuICAgIH1cbiAgfVxuXG5cbiAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbiAgdmFyIGhhc2ggPSByZXN0LmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxuICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xuICB9XG4gIHZhciBxbSA9IHJlc3QuaW5kZXhPZignPycpO1xuICBpZiAocW0gIT09IC0xKSB7XG4gICAgdGhpcy5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgdGhpcy5xdWVyeSA9IHJlc3Quc3Vic3RyKHFtICsgMSk7XG4gICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnF1ZXJ5KTtcbiAgICB9XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAvLyBubyBxdWVyeSBzdHJpbmcsIGJ1dCBwYXJzZVF1ZXJ5U3RyaW5nIHN0aWxsIHJlcXVlc3RlZFxuICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgdGhpcy5xdWVyeSA9IHt9O1xuICB9XG4gIGlmIChyZXN0KSB0aGlzLnBhdGhuYW1lID0gcmVzdDtcbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtsb3dlclByb3RvXSAmJlxuICAgICAgdGhpcy5ob3N0bmFtZSAmJiAhdGhpcy5wYXRobmFtZSkge1xuICAgIHRoaXMucGF0aG5hbWUgPSAnLyc7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gIGlmICh0aGlzLnBhdGhuYW1lIHx8IHRoaXMuc2VhcmNoKSB7XG4gICAgdmFyIHAgPSB0aGlzLnBhdGhuYW1lIHx8ICcnO1xuICAgIHZhciBzID0gdGhpcy5zZWFyY2ggfHwgJyc7XG4gICAgdGhpcy5wYXRoID0gcCArIHM7XG4gIH1cblxuICAvLyBmaW5hbGx5LCByZWNvbnN0cnVjdCB0aGUgaHJlZiBiYXNlZCBvbiB3aGF0IGhhcyBiZWVuIHZhbGlkYXRlZC5cbiAgdGhpcy5ocmVmID0gdGhpcy5mb3JtYXQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBmb3JtYXQgYSBwYXJzZWQgb2JqZWN0IGludG8gYSB1cmwgc3RyaW5nXG5mdW5jdGlvbiB1cmxGb3JtYXQob2JqKSB7XG4gIC8vIGVuc3VyZSBpdCdzIGFuIG9iamVjdCwgYW5kIG5vdCBhIHN0cmluZyB1cmwuXG4gIC8vIElmIGl0J3MgYW4gb2JqLCB0aGlzIGlzIGEgbm8tb3AuXG4gIC8vIHRoaXMgd2F5LCB5b3UgY2FuIGNhbGwgdXJsX2Zvcm1hdCgpIG9uIHN0cmluZ3NcbiAgLy8gdG8gY2xlYW4gdXAgcG90ZW50aWFsbHkgd29ua3kgdXJscy5cbiAgaWYgKGlzU3RyaW5nKG9iaikpIG9iaiA9IHVybFBhcnNlKG9iaik7XG4gIGlmICghKG9iaiBpbnN0YW5jZW9mIFVybCkpIHJldHVybiBVcmwucHJvdG90eXBlLmZvcm1hdC5jYWxsKG9iaik7XG4gIHJldHVybiBvYmouZm9ybWF0KCk7XG59XG5cblVybC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhdXRoID0gdGhpcy5hdXRoIHx8ICcnO1xuICBpZiAoYXV0aCkge1xuICAgIGF1dGggPSBlbmNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgYXV0aCA9IGF1dGgucmVwbGFjZSgvJTNBL2ksICc6Jyk7XG4gICAgYXV0aCArPSAnQCc7XG4gIH1cblxuICB2YXIgcHJvdG9jb2wgPSB0aGlzLnByb3RvY29sIHx8ICcnLFxuICAgICAgcGF0aG5hbWUgPSB0aGlzLnBhdGhuYW1lIHx8ICcnLFxuICAgICAgaGFzaCA9IHRoaXMuaGFzaCB8fCAnJyxcbiAgICAgIGhvc3QgPSBmYWxzZSxcbiAgICAgIHF1ZXJ5ID0gJyc7XG5cbiAgaWYgKHRoaXMuaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgdGhpcy5ob3N0O1xuICB9IGVsc2UgaWYgKHRoaXMuaG9zdG5hbWUpIHtcbiAgICBob3N0ID0gYXV0aCArICh0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSA9PT0gLTEgP1xuICAgICAgICB0aGlzLmhvc3RuYW1lIDpcbiAgICAgICAgJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyk7XG4gICAgaWYgKHRoaXMucG9ydCkge1xuICAgICAgaG9zdCArPSAnOicgKyB0aGlzLnBvcnQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMucXVlcnkgJiZcbiAgICAgIGlzT2JqZWN0KHRoaXMucXVlcnkpICYmXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLnF1ZXJ5KS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeSh0aGlzLnF1ZXJ5KTtcbiAgfVxuXG4gIHZhciBzZWFyY2ggPSB0aGlzLnNlYXJjaCB8fCAocXVlcnkgJiYgKCc/JyArIHF1ZXJ5KSkgfHwgJyc7XG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLnN1YnN0cigtMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xuXG4gIC8vIG9ubHkgdGhlIHNsYXNoZWRQcm90b2NvbHMgZ2V0IHRoZSAvLy4gIE5vdCBtYWlsdG86LCB4bXBwOiwgZXRjLlxuICAvLyB1bmxlc3MgdGhleSBoYWQgdGhlbSB0byBiZWdpbiB3aXRoLlxuICBpZiAodGhpcy5zbGFzaGVzIHx8XG4gICAgICAoIXByb3RvY29sIHx8IHNsYXNoZWRQcm90b2NvbFtwcm90b2NvbF0pICYmIGhvc3QgIT09IGZhbHNlKSB7XG4gICAgaG9zdCA9ICcvLycgKyAoaG9zdCB8fCAnJyk7XG4gICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSBwYXRobmFtZSA9ICcvJyArIHBhdGhuYW1lO1xuICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgaG9zdCA9ICcnO1xuICB9XG5cbiAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09ICcjJykgaGFzaCA9ICcjJyArIGhhc2g7XG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoLmNoYXJBdCgwKSAhPT0gJz8nKSBzZWFyY2ggPSAnPycgKyBzZWFyY2g7XG5cbiAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChtYXRjaCk7XG4gIH0pO1xuICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKTtcblxuICByZXR1cm4gcHJvdG9jb2wgKyBob3N0ICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZShzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlKHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgcmV0dXJuIHRoaXMucmVzb2x2ZU9iamVjdCh1cmxQYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpKS5mb3JtYXQoKTtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmVPYmplY3Qoc291cmNlLCByZWxhdGl2ZSkge1xuICBpZiAoIXNvdXJjZSkgcmV0dXJuIHJlbGF0aXZlO1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZU9iamVjdChyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZU9iamVjdCA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIGlmIChpc1N0cmluZyhyZWxhdGl2ZSkpIHtcbiAgICB2YXIgcmVsID0gbmV3IFVybCgpO1xuICAgIHJlbC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpO1xuICAgIHJlbGF0aXZlID0gcmVsO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IG5ldyBVcmwoKTtcbiAgT2JqZWN0LmtleXModGhpcykuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgcmVzdWx0W2tdID0gdGhpc1trXTtcbiAgfSwgdGhpcyk7XG5cbiAgLy8gaGFzaCBpcyBhbHdheXMgb3ZlcnJpZGRlbiwgbm8gbWF0dGVyIHdoYXQuXG4gIC8vIGV2ZW4gaHJlZj1cIlwiIHdpbGwgcmVtb3ZlIGl0LlxuICByZXN1bHQuaGFzaCA9IHJlbGF0aXZlLmhhc2g7XG5cbiAgLy8gaWYgdGhlIHJlbGF0aXZlIHVybCBpcyBlbXB0eSwgdGhlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBkbyBoZXJlLlxuICBpZiAocmVsYXRpdmUuaHJlZiA9PT0gJycpIHtcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaHJlZnMgbGlrZSAvL2Zvby9iYXIgYWx3YXlzIGN1dCB0byB0aGUgcHJvdG9jb2wuXG4gIGlmIChyZWxhdGl2ZS5zbGFzaGVzICYmICFyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgIC8vIHRha2UgZXZlcnl0aGluZyBleGNlcHQgdGhlIHByb3RvY29sIGZyb20gcmVsYXRpdmVcbiAgICBPYmplY3Qua2V5cyhyZWxhdGl2ZSkuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICBpZiAoayAhPT0gJ3Byb3RvY29sJylcbiAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107XG4gICAgfSk7XG5cbiAgICAvL3VybFBhcnNlIGFwcGVuZHMgdHJhaWxpbmcgLyB0byB1cmxzIGxpa2UgaHR0cDovL3d3dy5leGFtcGxlLmNvbVxuICAgIGlmIChzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXSAmJlxuICAgICAgICByZXN1bHQuaG9zdG5hbWUgJiYgIXJlc3VsdC5wYXRobmFtZSkge1xuICAgICAgcmVzdWx0LnBhdGggPSByZXN1bHQucGF0aG5hbWUgPSAnLyc7XG4gICAgfVxuXG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmIChyZWxhdGl2ZS5wcm90b2NvbCAmJiByZWxhdGl2ZS5wcm90b2NvbCAhPT0gcmVzdWx0LnByb3RvY29sKSB7XG4gICAgLy8gaWYgaXQncyBhIGtub3duIHVybCBwcm90b2NvbCwgdGhlbiBjaGFuZ2luZ1xuICAgIC8vIHRoZSBwcm90b2NvbCBkb2VzIHdlaXJkIHRoaW5nc1xuICAgIC8vIGZpcnN0LCBpZiBpdCdzIG5vdCBmaWxlOiwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBob3N0LFxuICAgIC8vIGFuZCBpZiB0aGVyZSB3YXMgYSBwYXRoXG4gICAgLy8gdG8gYmVnaW4gd2l0aCwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBwYXRoLlxuICAgIC8vIGlmIGl0IGlzIGZpbGU6LCB0aGVuIHRoZSBob3N0IGlzIGRyb3BwZWQsXG4gICAgLy8gYmVjYXVzZSB0aGF0J3Mga25vd24gdG8gYmUgaG9zdGxlc3MuXG4gICAgLy8gYW55dGhpbmcgZWxzZSBpcyBhc3N1bWVkIHRvIGJlIGFic29sdXRlLlxuICAgIGlmICghc2xhc2hlZFByb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgT2JqZWN0LmtleXMocmVsYXRpdmUpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgICByZXN1bHRba10gPSByZWxhdGl2ZVtrXTtcbiAgICAgIH0pO1xuICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJlc3VsdC5wcm90b2NvbCA9IHJlbGF0aXZlLnByb3RvY29sO1xuICAgIGlmICghcmVsYXRpdmUuaG9zdCAmJiAhaG9zdGxlc3NQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciByZWxQYXRoID0gKHJlbGF0aXZlLnBhdGhuYW1lIHx8ICcnKS5zcGxpdCgnLycpO1xuICAgICAgd2hpbGUgKHJlbFBhdGgubGVuZ3RoICYmICEocmVsYXRpdmUuaG9zdCA9IHJlbFBhdGguc2hpZnQoKSkpO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0KSByZWxhdGl2ZS5ob3N0ID0gJyc7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3RuYW1lKSByZWxhdGl2ZS5ob3N0bmFtZSA9ICcnO1xuICAgICAgaWYgKHJlbFBhdGhbMF0gIT09ICcnKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgaWYgKHJlbFBhdGgubGVuZ3RoIDwgMikgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbFBhdGguam9pbignLycpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTtcbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICByZXN1bHQuaG9zdCA9IHJlbGF0aXZlLmhvc3QgfHwgJyc7XG4gICAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoO1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3Q7XG4gICAgcmVzdWx0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuICAgIC8vIHRvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5wYXRobmFtZSB8fCByZXN1bHQuc2VhcmNoKSB7XG4gICAgICB2YXIgcCA9IHJlc3VsdC5wYXRobmFtZSB8fCAnJztcbiAgICAgIHZhciBzID0gcmVzdWx0LnNlYXJjaCB8fCAnJztcbiAgICAgIHJlc3VsdC5wYXRoID0gcCArIHM7XG4gICAgfVxuICAgIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIGlzU291cmNlQWJzID0gKHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpLFxuICAgICAgaXNSZWxBYnMgPSAoXG4gICAgICAgICAgcmVsYXRpdmUuaG9zdCB8fFxuICAgICAgICAgIHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgICApLFxuICAgICAgbXVzdEVuZEFicyA9IChpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fFxuICAgICAgICAgICAgICAgICAgICAocmVzdWx0Lmhvc3QgJiYgcmVsYXRpdmUucGF0aG5hbWUpKSxcbiAgICAgIHJlbW92ZUFsbERvdHMgPSBtdXN0RW5kQWJzLFxuICAgICAgc3JjUGF0aCA9IHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHJlbFBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcHN5Y2hvdGljID0gcmVzdWx0LnByb3RvY29sICYmICFzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXTtcblxuICAvLyBpZiB0aGUgdXJsIGlzIGEgbm9uLXNsYXNoZWQgdXJsLCB0aGVuIHJlbGF0aXZlXG4gIC8vIGxpbmtzIGxpa2UgLi4vLi4gc2hvdWxkIGJlIGFibGVcbiAgLy8gdG8gY3Jhd2wgdXAgdG8gdGhlIGhvc3RuYW1lLCBhcyB3ZWxsLiAgVGhpcyBpcyBzdHJhbmdlLlxuICAvLyByZXN1bHQucHJvdG9jb2wgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgbm93LlxuICAvLyBMYXRlciBvbiwgcHV0IHRoZSBmaXJzdCBwYXRoIHBhcnQgaW50byB0aGUgaG9zdCBmaWVsZC5cbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9ICcnO1xuICAgIHJlc3VsdC5wb3J0ID0gbnVsbDtcbiAgICBpZiAocmVzdWx0Lmhvc3QpIHtcbiAgICAgIGlmIChzcmNQYXRoWzBdID09PSAnJykgc3JjUGF0aFswXSA9IHJlc3VsdC5ob3N0O1xuICAgICAgZWxzZSBzcmNQYXRoLnVuc2hpZnQocmVzdWx0Lmhvc3QpO1xuICAgIH1cbiAgICByZXN1bHQuaG9zdCA9ICcnO1xuICAgIGlmIChyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgPSBudWxsO1xuICAgICAgcmVsYXRpdmUucG9ydCA9IG51bGw7XG4gICAgICBpZiAocmVsYXRpdmUuaG9zdCkge1xuICAgICAgICBpZiAocmVsUGF0aFswXSA9PT0gJycpIHJlbFBhdGhbMF0gPSByZWxhdGl2ZS5ob3N0O1xuICAgICAgICBlbHNlIHJlbFBhdGgudW5zaGlmdChyZWxhdGl2ZS5ob3N0KTtcbiAgICAgIH1cbiAgICAgIHJlbGF0aXZlLmhvc3QgPSBudWxsO1xuICAgIH1cbiAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyAmJiAocmVsUGF0aFswXSA9PT0gJycgfHwgc3JjUGF0aFswXSA9PT0gJycpO1xuICB9XG5cbiAgaWYgKGlzUmVsQWJzKSB7XG4gICAgLy8gaXQncyBhYnNvbHV0ZS5cbiAgICByZXN1bHQuaG9zdCA9IChyZWxhdGl2ZS5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0IDogcmVzdWx0Lmhvc3Q7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gKHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3RuYW1lID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lIDogcmVzdWx0Lmhvc3RuYW1lO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgc3JjUGF0aCA9IHJlbFBhdGg7XG4gICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBpdCdzIHJlbGF0aXZlXG4gICAgLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuXG4gICAgaWYgKCFzcmNQYXRoKSBzcmNQYXRoID0gW107XG4gICAgc3JjUGF0aC5wb3AoKTtcbiAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aCk7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgfSBlbHNlIGlmICghaXNOdWxsT3JVbmRlZmluZWQocmVsYXRpdmUuc2VhcmNoKSkge1xuICAgIC8vIGp1c3QgcHVsbCBvdXQgdGhlIHNlYXJjaC5cbiAgICAvLyBsaWtlIGhyZWY9Jz9mb28nLlxuICAgIC8vIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFuc1xuICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gc3JjUGF0aC5zaGlmdCgpO1xuICAgICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgICAgLy90aGlzIGVzcGVjaWFseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmICghaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIWlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIC8vIG5vIHBhdGggYXQgYWxsLiAgZWFzeS5cbiAgICAvLyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQgdGhlIG90aGVyIHN0dWZmIGFib3ZlLlxuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQuc2VhcmNoKSB7XG4gICAgICByZXN1bHQucGF0aCA9ICcvJyArIHJlc3VsdC5zZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGlmIGEgdXJsIEVORHMgaW4gLiBvciAuLiwgdGhlbiBpdCBtdXN0IGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAvLyBob3dldmVyLCBpZiBpdCBlbmRzIGluIGFueXRoaW5nIGVsc2Ugbm9uLXNsYXNoeSxcbiAgLy8gdGhlbiBpdCBtdXN0IE5PVCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgdmFyIGxhc3QgPSBzcmNQYXRoLnNsaWNlKC0xKVswXTtcbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSAoXG4gICAgICAocmVzdWx0Lmhvc3QgfHwgcmVsYXRpdmUuaG9zdCkgJiYgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSB8fFxuICAgICAgbGFzdCA9PT0gJycpO1xuXG4gIC8vIHN0cmlwIHNpbmdsZSBkb3RzLCByZXNvbHZlIGRvdWJsZSBkb3RzIHRvIHBhcmVudCBkaXJcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHNyY1BhdGgubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgIGxhc3QgPSBzcmNQYXRoW2ldO1xuICAgIGlmIChsYXN0ID09ICcuJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKCFtdXN0RW5kQWJzICYmICFyZW1vdmVBbGxEb3RzKSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBzcmNQYXRoLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgc3JjUGF0aFswXSAhPT0gJycgJiZcbiAgICAgICghc3JjUGF0aFswXSB8fCBzcmNQYXRoWzBdLmNoYXJBdCgwKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiAoc3JjUGF0aC5qb2luKCcvJykuc3Vic3RyKC0xKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgucHVzaCgnJyk7XG4gIH1cblxuICB2YXIgaXNBYnNvbHV0ZSA9IHNyY1BhdGhbMF0gPT09ICcnIHx8XG4gICAgICAoc3JjUGF0aFswXSAmJiBzcmNQYXRoWzBdLmNoYXJBdCgwKSA9PT0gJy8nKTtcblxuICAvLyBwdXQgdGhlIGhvc3QgYmFja1xuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBpc0Fic29sdXRlID8gJycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjUGF0aC5sZW5ndGggPyBzcmNQYXRoLnNoaWZ0KCkgOiAnJztcbiAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgLy90aGlzIGVzcGVjaWFseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgfVxuICB9XG5cbiAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgfHwgKHJlc3VsdC5ob3N0ICYmIHNyY1BhdGgubGVuZ3RoKTtcblxuICBpZiAobXVzdEVuZEFicyAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gc3JjUGF0aC5qb2luKCcvJyk7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgcmVxdWVzdC5odHRwXG4gIGlmICghaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIWlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gIH1cbiAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoIHx8IHJlc3VsdC5hdXRoO1xuICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVXJsLnByb3RvdHlwZS5wYXJzZUhvc3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGhvc3QgPSB0aGlzLmhvc3Q7XG4gIHZhciBwb3J0ID0gcG9ydFBhdHRlcm4uZXhlYyhob3N0KTtcbiAgaWYgKHBvcnQpIHtcbiAgICBwb3J0ID0gcG9ydFswXTtcbiAgICBpZiAocG9ydCAhPT0gJzonKSB7XG4gICAgICB0aGlzLnBvcnQgPSBwb3J0LnN1YnN0cigxKTtcbiAgICB9XG4gICAgaG9zdCA9IGhvc3Quc3Vic3RyKDAsIGhvc3QubGVuZ3RoIC0gcG9ydC5sZW5ndGgpO1xuICB9XG4gIGlmIChob3N0KSB0aGlzLmhvc3RuYW1lID0gaG9zdDtcbn07XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gXCJzdHJpbmdcIjtcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gIGFyZyA9PSBudWxsO1xufVxuIiwidmFyIGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG5cbnZhciBodHRwcyA9IG1vZHVsZS5leHBvcnRzO1xuXG5mb3IgKHZhciBrZXkgaW4gaHR0cCkge1xuICAgIGlmIChodHRwLmhhc093blByb3BlcnR5KGtleSkpIGh0dHBzW2tleV0gPSBodHRwW2tleV07XG59O1xuXG5odHRwcy5yZXF1ZXN0ID0gZnVuY3Rpb24gKHBhcmFtcywgY2IpIHtcbiAgICBpZiAoIXBhcmFtcykgcGFyYW1zID0ge307XG4gICAgcGFyYW1zLnNjaGVtZSA9ICdodHRwcyc7XG4gICAgcGFyYW1zLnByb3RvY29sID0gJ2h0dHBzOic7XG4gICAgcmV0dXJuIGh0dHAucmVxdWVzdC5jYWxsKHRoaXMsIHBhcmFtcywgY2IpO1xufVxuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCJcbnZhciBpbmRleE9mID0gW10uaW5kZXhPZjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcnIsIG9iail7XG4gIGlmIChpbmRleE9mKSByZXR1cm4gYXJyLmluZGV4T2Yob2JqKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoYXJyW2ldID09PSBvYmopIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn07IiwiLyohXG4gKiBpbmZsZWN0aW9uXG4gKiBDb3B5cmlnaHQoYykgMjAxMSBCZW4gTGluIDxiZW5AZHJlYW1lcnNsYWIuY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKlxuICogQGZpbGVvdmVydmlld1xuICogQSBwb3J0IG9mIGluZmxlY3Rpb24tanMgdG8gbm9kZS5qcyBtb2R1bGUuXG4gKi9cblxuKCBmdW5jdGlvbiAoIHJvb3QsIGZhY3RvcnkgKXtcbiAgaWYoIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApe1xuICAgIGRlZmluZShbXSwgZmFjdG9yeSApO1xuICB9ZWxzZSBpZiggdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICl7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gIH1lbHNle1xuICAgIHJvb3QuaW5mbGVjdGlvbiA9IGZhY3RvcnkoKTtcbiAgfVxufSggdGhpcywgZnVuY3Rpb24gKCl7XG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiBUaGlzIGlzIGEgbGlzdCBvZiBub3VucyB0aGF0IHVzZSB0aGUgc2FtZSBmb3JtIGZvciBib3RoIHNpbmd1bGFyIGFuZCBwbHVyYWwuXG4gICAqICAgICAgICAgICAgICBUaGlzIGxpc3Qgc2hvdWxkIHJlbWFpbiBlbnRpcmVseSBpbiBsb3dlciBjYXNlIHRvIGNvcnJlY3RseSBtYXRjaCBTdHJpbmdzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdmFyIHVuY291bnRhYmxlX3dvcmRzID0gW1xuICAgICdlcXVpcG1lbnQnLCAnaW5mb3JtYXRpb24nLCAncmljZScsICdtb25leScsICdzcGVjaWVzJyxcbiAgICAnc2VyaWVzJywgJ2Zpc2gnLCAnc2hlZXAnLCAnbW9vc2UnLCAnZGVlcicsICduZXdzJ1xuICBdO1xuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb24gVGhlc2UgcnVsZXMgdHJhbnNsYXRlIGZyb20gdGhlIHNpbmd1bGFyIGZvcm0gb2YgYSBub3VuIHRvIGl0cyBwbHVyYWwgZm9ybS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHZhciBwbHVyYWxfcnVsZXMgPSBbXG5cbiAgICAvLyBkbyBub3QgcmVwbGFjZSBpZiBpdHMgYWxyZWFkeSBhIHBsdXJhbCB3b3JkXG4gICAgWyBuZXcgUmVnRXhwKCAnKG0pZW4kJywgICAgICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhwZSlvcGxlJCcsICAgJ2dpJyApXSxcbiAgICBbIG5ldyBSZWdFeHAoICcoY2hpbGQpcmVuJCcsICdnaScgKV0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKFt0aV0pYSQnLCAgICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJygoYSluYWx5fChiKWF8KGQpaWFnbm98KHApYXJlbnRoZXwocClyb2dub3wocyl5bm9wfCh0KWhlKXNlcyQnLCdnaScgKV0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKGhpdmUpcyQnLCAgICAgICAgICAgJ2dpJyApXSxcbiAgICBbIG5ldyBSZWdFeHAoICcodGl2ZSlzJCcsICAgICAgICAgICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhjdXJ2ZSlzJCcsICAgICAgICAgICdnaScgKV0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKFtscl0pdmVzJCcsICAgICAgICAgJ2dpJyApXSxcbiAgICBbIG5ldyBSZWdFeHAoICcoW15mb10pdmVzJCcsICAgICAgICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhbXmFlaW91eV18cXUpaWVzJCcsICdnaScgKV0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKHMpZXJpZXMkJywgICAgICAgICAgJ2dpJyApXSxcbiAgICBbIG5ldyBSZWdFeHAoICcobSlvdmllcyQnLCAgICAgICAgICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJyh4fGNofHNzfHNoKWVzJCcsICAgICdnaScgKV0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKFttfGxdKWljZSQnLCAgICAgICAgJ2dpJyApXSxcbiAgICBbIG5ldyBSZWdFeHAoICcoYnVzKWVzJCcsICAgICAgICAgICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhvKWVzJCcsICAgICAgICAgICAgICdnaScgKV0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKHNob2UpcyQnLCAgICAgICAgICAgJ2dpJyApXSxcbiAgICBbIG5ldyBSZWdFeHAoICcoY3Jpc3xheHx0ZXN0KWVzJCcsICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhvY3RvcHx2aXIpaSQnLCAgICAgICdnaScgKV0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKGFsaWFzfHN0YXR1cyllcyQnLCAgJ2dpJyApXSxcbiAgICBbIG5ldyBSZWdFeHAoICdeKG94KWVuJywgICAgICAgICAgICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJyh2ZXJ0fGluZClpY2VzJCcsICAgICdnaScgKV0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKG1hdHIpaWNlcyQnLCAgICAgICAgJ2dpJyApXSxcbiAgICBbIG5ldyBSZWdFeHAoICcocXVpeil6ZXMkJywgICAgICAgICAnZ2knICldLFxuXG4gICAgLy8gb3JpZ2luYWwgcnVsZVxuICAgIFsgbmV3IFJlZ0V4cCggJyhtKWFuJCcsICdnaScgKSwgICAgICAgICAgICAgICAgICckMWVuJyBdLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhwZSlyc29uJCcsICdnaScgKSwgICAgICAgICAgICAgICckMW9wbGUnIF0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKGNoaWxkKSQnLCAnZ2knICksICAgICAgICAgICAgICAgJyQxcmVuJyBdLFxuICAgIFsgbmV3IFJlZ0V4cCggJ14ob3gpJCcsICdnaScgKSwgICAgICAgICAgICAgICAgICckMWVuJyBdLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhheHx0ZXN0KWlzJCcsICdnaScgKSwgICAgICAgICAgICckMWVzJyBdLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhvY3RvcHx2aXIpdXMkJywgJ2dpJyApLCAgICAgICAgICckMWknIF0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKGFsaWFzfHN0YXR1cykkJywgJ2dpJyApLCAgICAgICAgJyQxZXMnIF0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKGJ1KXMkJywgJ2dpJyApLCAgICAgICAgICAgICAgICAgJyQxc2VzJyBdLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhidWZmYWx8dG9tYXR8cG90YXQpbyQnLCAnZ2knICksICckMW9lcycgXSxcbiAgICBbIG5ldyBSZWdFeHAoICcoW3RpXSl1bSQnLCAnZ2knICksICAgICAgICAgICAgICAnJDFhJyBdLFxuICAgIFsgbmV3IFJlZ0V4cCggJ3NpcyQnLCAnZ2knICksICAgICAgICAgICAgICAgICAgICdzZXMnIF0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKD86KFteZl0pZmV8KFtscl0pZikkJywgJ2dpJyApLCAgJyQxJDJ2ZXMnIF0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKGhpdmUpJCcsICdnaScgKSwgICAgICAgICAgICAgICAgJyQxcycgXSxcbiAgICBbIG5ldyBSZWdFeHAoICcoW15hZWlvdXldfHF1KXkkJywgJ2dpJyApLCAgICAgICAnJDFpZXMnIF0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKHh8Y2h8c3N8c2gpJCcsICdnaScgKSwgICAgICAgICAgJyQxZXMnIF0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKG1hdHJ8dmVydHxpbmQpaXh8ZXgkJywgJ2dpJyApLCAgJyQxaWNlcycgXSxcbiAgICBbIG5ldyBSZWdFeHAoICcoW218bF0pb3VzZSQnLCAnZ2knICksICAgICAgICAgICAnJDFpY2UnIF0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKHF1aXopJCcsICdnaScgKSwgICAgICAgICAgICAgICAgJyQxemVzJyBdLFxuXG4gICAgWyBuZXcgUmVnRXhwKCAncyQnLCAnZ2knICksICdzJyBdLFxuICAgIFsgbmV3IFJlZ0V4cCggJyQnLCAnZ2knICksICAncycgXVxuICBdO1xuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb24gVGhlc2UgcnVsZXMgdHJhbnNsYXRlIGZyb20gdGhlIHBsdXJhbCBmb3JtIG9mIGEgbm91biB0byBpdHMgc2luZ3VsYXIgZm9ybS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHZhciBzaW5ndWxhcl9ydWxlcyA9IFtcblxuICAgIC8vIGRvIG5vdCByZXBsYWNlIGlmIGl0cyBhbHJlYWR5IGEgc2luZ3VsYXIgd29yZFxuICAgIFsgbmV3IFJlZ0V4cCggJyhtKWFuJCcsICAgICAgICAgICAgICAgICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhwZSlyc29uJCcsICAgICAgICAgICAgICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhjaGlsZCkkJywgICAgICAgICAgICAgICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJ14ob3gpJCcsICAgICAgICAgICAgICAgICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhheHx0ZXN0KWlzJCcsICAgICAgICAgICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhvY3RvcHx2aXIpdXMkJywgICAgICAgICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhhbGlhc3xzdGF0dXMpJCcsICAgICAgICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhidSlzJCcsICAgICAgICAgICAgICAgICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhidWZmYWx8dG9tYXR8cG90YXQpbyQnLCAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhbdGldKXVtJCcsICAgICAgICAgICAgICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJ3NpcyQnLCAgICAgICAgICAgICAgICAgICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJyg/OihbXmZdKWZlfChbbHJdKWYpJCcsICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhoaXZlKSQnLCAgICAgICAgICAgICAgICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhbXmFlaW91eV18cXUpeSQnLCAgICAgICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJyh4fGNofHNzfHNoKSQnLCAgICAgICAgICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhtYXRyfHZlcnR8aW5kKWl4fGV4JCcsICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhbbXxsXSlvdXNlJCcsICAgICAgICAgICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhxdWl6KSQnLCAgICAgICAgICAgICAgICAnZ2knICldLFxuXG4gICAgLy8gb3JpZ2luYWwgcnVsZVxuICAgIFsgbmV3IFJlZ0V4cCggJyhtKWVuJCcsICdnaScgKSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyQxYW4nIF0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKHBlKW9wbGUkJywgJ2dpJyApLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJDFyc29uJyBdLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhjaGlsZClyZW4kJywgJ2dpJyApLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyQxJyBdLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhbdGldKWEkJywgJ2dpJyApLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyQxdW0nIF0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKChhKW5hbHl8KGIpYXwoZClpYWdub3wocClhcmVudGhlfChwKXJvZ25vfChzKXlub3B8KHQpaGUpc2VzJCcsJ2dpJyApLCAnJDEkMnNpcycgXSxcbiAgICBbIG5ldyBSZWdFeHAoICcoaGl2ZSlzJCcsICdnaScgKSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICckMScgXSxcbiAgICBbIG5ldyBSZWdFeHAoICcodGl2ZSlzJCcsICdnaScgKSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICckMScgXSxcbiAgICBbIG5ldyBSZWdFeHAoICcoY3VydmUpcyQnLCAnZ2knICksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICckMScgXSxcbiAgICBbIG5ldyBSZWdFeHAoICcoW2xyXSl2ZXMkJywgJ2dpJyApLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICckMWYnIF0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKFteZm9dKXZlcyQnLCAnZ2knICksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJDFmZScgXSxcbiAgICBbIG5ldyBSZWdFeHAoICcobSlvdmllcyQnLCAnZ2knICksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICckMW92aWUnIF0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKFteYWVpb3V5XXxxdSlpZXMkJywgJ2dpJyApLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJDF5JyBdLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhzKWVyaWVzJCcsICdnaScgKSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyQxZXJpZXMnIF0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKHh8Y2h8c3N8c2gpZXMkJywgJ2dpJyApLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJDEnIF0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKFttfGxdKWljZSQnLCAnZ2knICksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJDFvdXNlJyBdLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhidXMpZXMkJywgJ2dpJyApLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyQxJyBdLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhvKWVzJCcsICdnaScgKSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyQxJyBdLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhzaG9lKXMkJywgJ2dpJyApLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyQxJyBdLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhjcmlzfGF4fHRlc3QpZXMkJywgJ2dpJyApLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyQxaXMnIF0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKG9jdG9wfHZpcilpJCcsICdnaScgKSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJDF1cycgXSxcbiAgICBbIG5ldyBSZWdFeHAoICcoYWxpYXN8c3RhdHVzKWVzJCcsICdnaScgKSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICckMScgXSxcbiAgICBbIG5ldyBSZWdFeHAoICdeKG94KWVuJywgJ2dpJyApLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICckMScgXSxcbiAgICBbIG5ldyBSZWdFeHAoICcodmVydHxpbmQpaWNlcyQnLCAnZ2knICksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICckMWV4JyBdLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhtYXRyKWljZXMkJywgJ2dpJyApLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyQxaXgnIF0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKHF1aXopemVzJCcsICdnaScgKSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJDEnIF0sXG4gICAgWyBuZXcgUmVnRXhwKCAnc3MkJywgJ2dpJyApLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc3MnIF0sXG4gICAgWyBuZXcgUmVnRXhwKCAncyQnLCAnZ2knICksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJyBdXG4gIF07XG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiBUaGlzIGlzIGEgbGlzdCBvZiB3b3JkcyB0aGF0IHNob3VsZCBub3QgYmUgY2FwaXRhbGl6ZWQgZm9yIHRpdGxlIGNhc2UuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB2YXIgbm9uX3RpdGxlY2FzZWRfd29yZHMgPSBbXG4gICAgJ2FuZCcsICdvcicsICdub3InLCAnYScsICdhbicsICd0aGUnLCAnc28nLCAnYnV0JywgJ3RvJywgJ29mJywgJ2F0JywnYnknLFxuICAgICdmcm9tJywgJ2ludG8nLCAnb24nLCAnb250bycsICdvZmYnLCAnb3V0JywgJ2luJywgJ292ZXInLCAnd2l0aCcsICdmb3InXG4gIF07XG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiBUaGVzZSBhcmUgcmVndWxhciBleHByZXNzaW9ucyB1c2VkIGZvciBjb252ZXJ0aW5nIGJldHdlZW4gU3RyaW5nIGZvcm1hdHMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB2YXIgaWRfc3VmZml4ICAgICAgICAgPSBuZXcgUmVnRXhwKCAnKF9pZHN8X2lkKSQnLCAnZycgKTtcbiAgdmFyIHVuZGVyYmFyICAgICAgICAgID0gbmV3IFJlZ0V4cCggJ18nLCAnZycgKTtcbiAgdmFyIHNwYWNlX29yX3VuZGVyYmFyID0gbmV3IFJlZ0V4cCggJ1tcXCBfXScsICdnJyApO1xuICB2YXIgdXBwZXJjYXNlICAgICAgICAgPSBuZXcgUmVnRXhwKCAnKFtBLVpdKScsICdnJyApO1xuICB2YXIgdW5kZXJiYXJfcHJlZml4ICAgPSBuZXcgUmVnRXhwKCAnXl8nICk7XG5cbiAgdmFyIGluZmxlY3RvciA9IHtcblxuICAvKipcbiAgICogQSBoZWxwZXIgbWV0aG9kIHRoYXQgYXBwbGllcyBydWxlcyBiYXNlZCByZXBsYWNlbWVudCB0byBhIFN0cmluZy5cbiAgICogQHByaXZhdGVcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgU3RyaW5nIHRvIG1vZGlmeSBhbmQgcmV0dXJuIGJhc2VkIG9uIHRoZSBwYXNzZWQgcnVsZXMuXG4gICAqIEBwYXJhbSB7QXJyYXk6IFtSZWdFeHAsIFN0cmluZ119IHJ1bGVzIFJlZ2V4cCB0byBtYXRjaCBwYWlyZWQgd2l0aCBTdHJpbmcgdG8gdXNlIGZvciByZXBsYWNlbWVudFxuICAgKiBAcGFyYW0ge0FycmF5OiBbU3RyaW5nXX0gc2tpcCBTdHJpbmdzIHRvIHNraXAgaWYgdGhleSBtYXRjaFxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3ZlcnJpZGUgU3RyaW5nIHRvIHJldHVybiBhcyB0aG91Z2ggdGhpcyBtZXRob2Qgc3VjY2VlZGVkICh1c2VkIHRvIGNvbmZvcm0gdG8gQVBJcylcbiAgICogQHJldHVybnMge1N0cmluZ30gUmV0dXJuIHBhc3NlZCBTdHJpbmcgbW9kaWZpZWQgYnkgcGFzc2VkIHJ1bGVzLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdGhpcy5fYXBwbHlfcnVsZXMoICdjb3dzJywgc2luZ3VsYXJfcnVsZXMgKTsgLy8gPT09ICdjb3cnXG4gICAqL1xuICAgIF9hcHBseV9ydWxlcyA6IGZ1bmN0aW9uICggc3RyLCBydWxlcywgc2tpcCwgb3ZlcnJpZGUgKXtcbiAgICAgIGlmKCBvdmVycmlkZSApe1xuICAgICAgICBzdHIgPSBvdmVycmlkZTtcbiAgICAgIH1lbHNle1xuICAgICAgICB2YXIgaWdub3JlID0gKCBpbmZsZWN0b3IuaW5kZXhPZiggc2tpcCwgc3RyLnRvTG93ZXJDYXNlKCkpID4gLTEgKTtcblxuICAgICAgICBpZiggIWlnbm9yZSApe1xuICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICB2YXIgaiA9IHJ1bGVzLmxlbmd0aDtcblxuICAgICAgICAgIGZvciggOyBpIDwgajsgaSsrICl7XG4gICAgICAgICAgICBpZiggc3RyLm1hdGNoKCBydWxlc1sgaSBdWyAwIF0pKXtcbiAgICAgICAgICAgICAgaWYoIHJ1bGVzWyBpIF1bIDEgXSAhPT0gdW5kZWZpbmVkICl7XG4gICAgICAgICAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoIHJ1bGVzWyBpIF1bIDAgXSwgcnVsZXNbIGkgXVsgMSBdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9LFxuXG5cblxuICAvKipcbiAgICogVGhpcyBsZXRzIHVzIGRldGVjdCBpZiBhbiBBcnJheSBjb250YWlucyBhIGdpdmVuIGVsZW1lbnQuXG4gICAqIEBwdWJsaWNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFyciBUaGUgc3ViamVjdCBhcnJheS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gT2JqZWN0IHRvIGxvY2F0ZSBpbiB0aGUgQXJyYXkuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmcm9tX2luZGV4IFN0YXJ0cyBjaGVja2luZyBmcm9tIHRoaXMgcG9zaXRpb24gaW4gdGhlIEFycmF5LihvcHRpb25hbClcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyZV9mdW5jIEZ1bmN0aW9uIHVzZWQgdG8gY29tcGFyZSBBcnJheSBpdGVtIHZzIHBhc3NlZCBpdGVtLihvcHRpb25hbClcbiAgICogQHJldHVybnMge051bWJlcn0gUmV0dXJuIGluZGV4IHBvc2l0aW9uIGluIHRoZSBBcnJheSBvZiB0aGUgcGFzc2VkIGl0ZW0uXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgaW5mbGVjdGlvbiA9IHJlcXVpcmUoICdpbmZsZWN0aW9uJyApO1xuICAgKlxuICAgKiAgICAgaW5mbGVjdGlvbi5pbmRleE9mKFsgJ2hpJywndGhlcmUnIF0sICdndXlzJyApOyAvLyA9PT0gLTFcbiAgICogICAgIGluZmxlY3Rpb24uaW5kZXhPZihbICdoaScsJ3RoZXJlJyBdLCAnaGknICk7IC8vID09PSAwXG4gICAqL1xuICAgIGluZGV4T2YgOiBmdW5jdGlvbiAoIGFyciwgaXRlbSwgZnJvbV9pbmRleCwgY29tcGFyZV9mdW5jICl7XG4gICAgICBpZiggIWZyb21faW5kZXggKXtcbiAgICAgICAgZnJvbV9pbmRleCA9IC0xO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgIHZhciBpICAgICA9IGZyb21faW5kZXg7XG4gICAgICB2YXIgaiAgICAgPSBhcnIubGVuZ3RoO1xuXG4gICAgICBmb3IoIDsgaSA8IGo7IGkrKyApe1xuICAgICAgICBpZiggYXJyWyBpIF0gID09PSBpdGVtIHx8IGNvbXBhcmVfZnVuYyAmJiBjb21wYXJlX2Z1bmMoIGFyclsgaSBdLCBpdGVtICkpe1xuICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfSxcblxuXG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gYWRkcyBwbHVyYWxpemF0aW9uIHN1cHBvcnQgdG8gZXZlcnkgU3RyaW5nIG9iamVjdC5cbiAgICogQHB1YmxpY1xuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3ViamVjdCBzdHJpbmcuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwbHVyYWwgT3ZlcnJpZGVzIG5vcm1hbCBvdXRwdXQgd2l0aCBzYWlkIFN0cmluZy4ob3B0aW9uYWwpXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IFNpbmd1bGFyIEVuZ2xpc2ggbGFuZ3VhZ2Ugbm91bnMgYXJlIHJldHVybmVkIGluIHBsdXJhbCBmb3JtLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGluZmxlY3Rpb24gPSByZXF1aXJlKCAnaW5mbGVjdGlvbicgKTtcbiAgICpcbiAgICogICAgIGluZmxlY3Rpb24ucGx1cmFsaXplKCAncGVyc29uJyApOyAvLyA9PT0gJ3Blb3BsZSdcbiAgICogICAgIGluZmxlY3Rpb24ucGx1cmFsaXplKCAnb2N0b3B1cycgKTsgLy8gPT09ICdvY3RvcGknXG4gICAqICAgICBpbmZsZWN0aW9uLnBsdXJhbGl6ZSggJ0hhdCcgKTsgLy8gPT09ICdIYXRzJ1xuICAgKiAgICAgaW5mbGVjdGlvbi5wbHVyYWxpemUoICdwZXJzb24nLCAnZ3V5cycgKTsgLy8gPT09ICdndXlzJ1xuICAgKi9cbiAgICBwbHVyYWxpemUgOiBmdW5jdGlvbiAoIHN0ciwgcGx1cmFsICl7XG4gICAgICByZXR1cm4gaW5mbGVjdG9yLl9hcHBseV9ydWxlcyggc3RyLCBwbHVyYWxfcnVsZXMsIHVuY291bnRhYmxlX3dvcmRzLCBwbHVyYWwgKTtcbiAgICB9LFxuXG5cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBhZGRzIHNpbmd1bGFyaXphdGlvbiBzdXBwb3J0IHRvIGV2ZXJ5IFN0cmluZyBvYmplY3QuXG4gICAqIEBwdWJsaWNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN1YmplY3Qgc3RyaW5nLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc2luZ3VsYXIgT3ZlcnJpZGVzIG5vcm1hbCBvdXRwdXQgd2l0aCBzYWlkIFN0cmluZy4ob3B0aW9uYWwpXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IFBsdXJhbCBFbmdsaXNoIGxhbmd1YWdlIG5vdW5zIGFyZSByZXR1cm5lZCBpbiBzaW5ndWxhciBmb3JtLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGluZmxlY3Rpb24gPSByZXF1aXJlKCAnaW5mbGVjdGlvbicgKTtcbiAgICpcbiAgICogICAgIGluZmxlY3Rpb24uc2luZ3VsYXJpemUoICdwZW9wbGUnICk7IC8vID09PSAncGVyc29uJ1xuICAgKiAgICAgaW5mbGVjdGlvbi5zaW5ndWxhcml6ZSggJ29jdG9waScgKTsgLy8gPT09ICdvY3RvcHVzJ1xuICAgKiAgICAgaW5mbGVjdGlvbi5zaW5ndWxhcml6ZSggJ0hhdHMnICk7IC8vID09PSAnSGF0J1xuICAgKiAgICAgaW5mbGVjdGlvbi5zaW5ndWxhcml6ZSggJ2d1eXMnLCAncGVyc29uJyApOyAvLyA9PT0gJ3BlcnNvbidcbiAgICovXG4gICAgc2luZ3VsYXJpemUgOiBmdW5jdGlvbiAoIHN0ciwgc2luZ3VsYXIgKXtcbiAgICAgIHJldHVybiBpbmZsZWN0b3IuX2FwcGx5X3J1bGVzKCBzdHIsIHNpbmd1bGFyX3J1bGVzLCB1bmNvdW50YWJsZV93b3Jkcywgc2luZ3VsYXIgKTtcbiAgICB9LFxuXG5cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBhZGRzIGNhbWVsaXphdGlvbiBzdXBwb3J0IHRvIGV2ZXJ5IFN0cmluZyBvYmplY3QuXG4gICAqIEBwdWJsaWNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN1YmplY3Qgc3RyaW5nLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGxvd19maXJzdF9sZXR0ZXIgRGVmYXVsdCBpcyB0byBjYXBpdGFsaXplIHRoZSBmaXJzdCBsZXR0ZXIgb2YgdGhlIHJlc3VsdHMuKG9wdGlvbmFsKVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBhc3NpbmcgdHJ1ZSB3aWxsIGxvd2VyY2FzZSBpdC5cbiAgICogQHJldHVybnMge1N0cmluZ30gTG93ZXIgY2FzZSB1bmRlcnNjb3JlZCB3b3JkcyB3aWxsIGJlIHJldHVybmVkIGluIGNhbWVsIGNhc2UuXG4gICAqICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbGx5ICcvJyBpcyB0cmFuc2xhdGVkIHRvICc6OidcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBpbmZsZWN0aW9uID0gcmVxdWlyZSggJ2luZmxlY3Rpb24nICk7XG4gICAqXG4gICAqICAgICBpbmZsZWN0aW9uLmNhbWVsaXplKCAnbWVzc2FnZV9wcm9wZXJ0aWVzJyApOyAvLyA9PT0gJ01lc3NhZ2VQcm9wZXJ0aWVzJ1xuICAgKiAgICAgaW5mbGVjdGlvbi5jYW1lbGl6ZSggJ21lc3NhZ2VfcHJvcGVydGllcycsIHRydWUgKTsgLy8gPT09ICdtZXNzYWdlUHJvcGVydGllcydcbiAgICovXG4gICAgY2FtZWxpemUgOiBmdW5jdGlvbiAoIHN0ciwgbG93X2ZpcnN0X2xldHRlciApe1xuICAgICAgdmFyIHN0cl9wYXRoID0gc3RyLnNwbGl0KCAnLycgKTtcbiAgICAgIHZhciBpICAgICAgICA9IDA7XG4gICAgICB2YXIgaiAgICAgICAgPSBzdHJfcGF0aC5sZW5ndGg7XG4gICAgICB2YXIgc3RyX2FyciwgaW5pdF94LCBrLCBsLCBmaXJzdDtcblxuICAgICAgZm9yKCA7IGkgPCBqOyBpKysgKXtcbiAgICAgICAgc3RyX2FyciA9IHN0cl9wYXRoWyBpIF0uc3BsaXQoICdfJyApO1xuICAgICAgICBrICAgICAgID0gMDtcbiAgICAgICAgbCAgICAgICA9IHN0cl9hcnIubGVuZ3RoO1xuXG4gICAgICAgIGZvciggOyBrIDwgbDsgaysrICl7XG4gICAgICAgICAgaWYoIGsgIT09IDAgKXtcbiAgICAgICAgICAgIHN0cl9hcnJbIGsgXSA9IHN0cl9hcnJbIGsgXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZpcnN0ID0gc3RyX2FyclsgayBdLmNoYXJBdCggMCApO1xuICAgICAgICAgIGZpcnN0ID0gbG93X2ZpcnN0X2xldHRlciAmJiBpID09PSAwICYmIGsgPT09IDBcbiAgICAgICAgICAgID8gZmlyc3QudG9Mb3dlckNhc2UoKSA6IGZpcnN0LnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgc3RyX2FyclsgayBdID0gZmlyc3QgKyBzdHJfYXJyWyBrIF0uc3Vic3RyaW5nKCAxICk7XG4gICAgICAgIH1cblxuICAgICAgICBzdHJfcGF0aFsgaSBdID0gc3RyX2Fyci5qb2luKCAnJyApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RyX3BhdGguam9pbiggJzo6JyApO1xuICAgIH0sXG5cblxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGFkZHMgdW5kZXJzY29yZSBzdXBwb3J0IHRvIGV2ZXJ5IFN0cmluZyBvYmplY3QuXG4gICAqIEBwdWJsaWNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN1YmplY3Qgc3RyaW5nLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFsbF91cHBlcl9jYXNlIERlZmF1bHQgaXMgdG8gbG93ZXJjYXNlIGFuZCBhZGQgdW5kZXJzY29yZSBwcmVmaXguKG9wdGlvbmFsKVxuICAgKiAgICAgICAgICAgICAgICAgIFBhc3NpbmcgdHJ1ZSB3aWxsIHJldHVybiBhcyBlbnRlcmVkLlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBDYW1lbCBjYXNlZCB3b3JkcyBhcmUgcmV0dXJuZWQgYXMgbG93ZXIgY2FzZWQgYW5kIHVuZGVyc2NvcmVkLlxuICAgKiAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxseSAnOjonIGlzIHRyYW5zbGF0ZWQgdG8gJy8nLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGluZmxlY3Rpb24gPSByZXF1aXJlKCAnaW5mbGVjdGlvbicgKTtcbiAgICpcbiAgICogICAgIGluZmxlY3Rpb24udW5kZXJzY29yZSggJ01lc3NhZ2VQcm9wZXJ0aWVzJyApOyAvLyA9PT0gJ21lc3NhZ2VfcHJvcGVydGllcydcbiAgICogICAgIGluZmxlY3Rpb24udW5kZXJzY29yZSggJ21lc3NhZ2VQcm9wZXJ0aWVzJyApOyAvLyA9PT0gJ21lc3NhZ2VfcHJvcGVydGllcydcbiAgICogICAgIGluZmxlY3Rpb24udW5kZXJzY29yZSggJ01QJywgdHJ1ZSApOyAvLyA9PT0gJ01QJ1xuICAgKi9cbiAgICB1bmRlcnNjb3JlIDogZnVuY3Rpb24gKCBzdHIsIGFsbF91cHBlcl9jYXNlICl7XG4gICAgICBpZiggYWxsX3VwcGVyX2Nhc2UgJiYgc3RyID09PSBzdHIudG9VcHBlckNhc2UoKSkgcmV0dXJuIHN0cjtcblxuICAgICAgdmFyIHN0cl9wYXRoID0gc3RyLnNwbGl0KCAnOjonICk7XG4gICAgICB2YXIgaSAgICAgICAgPSAwO1xuICAgICAgdmFyIGogICAgICAgID0gc3RyX3BhdGgubGVuZ3RoO1xuXG4gICAgICBmb3IoIDsgaSA8IGo7IGkrKyApe1xuICAgICAgICBzdHJfcGF0aFsgaSBdID0gc3RyX3BhdGhbIGkgXS5yZXBsYWNlKCB1cHBlcmNhc2UsICdfJDEnICk7XG4gICAgICAgIHN0cl9wYXRoWyBpIF0gPSBzdHJfcGF0aFsgaSBdLnJlcGxhY2UoIHVuZGVyYmFyX3ByZWZpeCwgJycgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0cl9wYXRoLmpvaW4oICcvJyApLnRvTG93ZXJDYXNlKCk7XG4gICAgfSxcblxuXG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gYWRkcyBodW1hbml6ZSBzdXBwb3J0IHRvIGV2ZXJ5IFN0cmluZyBvYmplY3QuXG4gICAqIEBwdWJsaWNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN1YmplY3Qgc3RyaW5nLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGxvd19maXJzdF9sZXR0ZXIgRGVmYXVsdCBpcyB0byBjYXBpdGFsaXplIHRoZSBmaXJzdCBsZXR0ZXIgb2YgdGhlIHJlc3VsdHMuKG9wdGlvbmFsKVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBhc3NpbmcgdHJ1ZSB3aWxsIGxvd2VyY2FzZSBpdC5cbiAgICogQHJldHVybnMge1N0cmluZ30gTG93ZXIgY2FzZSB1bmRlcnNjb3JlZCB3b3JkcyB3aWxsIGJlIHJldHVybmVkIGluIGh1bWFuaXplZCBmb3JtLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGluZmxlY3Rpb24gPSByZXF1aXJlKCAnaW5mbGVjdGlvbicgKTtcbiAgICpcbiAgICogICAgIGluZmxlY3Rpb24uaHVtYW5pemUoICdtZXNzYWdlX3Byb3BlcnRpZXMnICk7IC8vID09PSAnTWVzc2FnZSBwcm9wZXJ0aWVzJ1xuICAgKiAgICAgaW5mbGVjdGlvbi5odW1hbml6ZSggJ21lc3NhZ2VfcHJvcGVydGllcycsIHRydWUgKTsgLy8gPT09ICdtZXNzYWdlIHByb3BlcnRpZXMnXG4gICAqL1xuICAgIGh1bWFuaXplIDogZnVuY3Rpb24gKCBzdHIsIGxvd19maXJzdF9sZXR0ZXIgKXtcbiAgICAgIHN0ciA9IHN0ci50b0xvd2VyQ2FzZSgpO1xuICAgICAgc3RyID0gc3RyLnJlcGxhY2UoIGlkX3N1ZmZpeCwgJycgKTtcbiAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKCB1bmRlcmJhciwgJyAnICk7XG5cbiAgICAgIGlmKCAhbG93X2ZpcnN0X2xldHRlciApe1xuICAgICAgICBzdHIgPSBpbmZsZWN0b3IuY2FwaXRhbGl6ZSggc3RyICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfSxcblxuXG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gYWRkcyBjYXBpdGFsaXphdGlvbiBzdXBwb3J0IHRvIGV2ZXJ5IFN0cmluZyBvYmplY3QuXG4gICAqIEBwdWJsaWNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN1YmplY3Qgc3RyaW5nLlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBBbGwgY2hhcmFjdGVycyB3aWxsIGJlIGxvd2VyIGNhc2UgYW5kIHRoZSBmaXJzdCB3aWxsIGJlIHVwcGVyLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGluZmxlY3Rpb24gPSByZXF1aXJlKCAnaW5mbGVjdGlvbicgKTtcbiAgICpcbiAgICogICAgIGluZmxlY3Rpb24uY2FwaXRhbGl6ZSggJ21lc3NhZ2VfcHJvcGVydGllcycgKTsgLy8gPT09ICdNZXNzYWdlX3Byb3BlcnRpZXMnXG4gICAqICAgICBpbmZsZWN0aW9uLmNhcGl0YWxpemUoICdtZXNzYWdlIHByb3BlcnRpZXMnLCB0cnVlICk7IC8vID09PSAnTWVzc2FnZSBwcm9wZXJ0aWVzJ1xuICAgKi9cbiAgICBjYXBpdGFsaXplIDogZnVuY3Rpb24gKCBzdHIgKXtcbiAgICAgIHN0ciA9IHN0ci50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICByZXR1cm4gc3RyLnN1YnN0cmluZyggMCwgMSApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc3Vic3RyaW5nKCAxICk7XG4gICAgfSxcblxuXG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gYWRkcyBkYXNoZXJpemF0aW9uIHN1cHBvcnQgdG8gZXZlcnkgU3RyaW5nIG9iamVjdC5cbiAgICogQHB1YmxpY1xuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3ViamVjdCBzdHJpbmcuXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IFJlcGxhY2VzIGFsbCBzcGFjZXMgb3IgdW5kZXJiYXJzIHdpdGggZGFzaGVzLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGluZmxlY3Rpb24gPSByZXF1aXJlKCAnaW5mbGVjdGlvbicgKTtcbiAgICpcbiAgICogICAgIGluZmxlY3Rpb24uZGFzaGVyaXplKCAnbWVzc2FnZV9wcm9wZXJ0aWVzJyApOyAvLyA9PT0gJ21lc3NhZ2UtcHJvcGVydGllcydcbiAgICogICAgIGluZmxlY3Rpb24uZGFzaGVyaXplKCAnTWVzc2FnZSBQcm9wZXJ0aWVzJyApOyAvLyA9PT0gJ01lc3NhZ2UtUHJvcGVydGllcydcbiAgICovXG4gICAgZGFzaGVyaXplIDogZnVuY3Rpb24gKCBzdHIgKXtcbiAgICAgIHJldHVybiBzdHIucmVwbGFjZSggc3BhY2Vfb3JfdW5kZXJiYXIsICctJyApO1xuICAgIH0sXG5cblxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGFkZHMgdGl0bGVpemUgc3VwcG9ydCB0byBldmVyeSBTdHJpbmcgb2JqZWN0LlxuICAgKiBAcHVibGljXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdWJqZWN0IHN0cmluZy5cbiAgICogQHJldHVybnMge1N0cmluZ30gQ2FwaXRhbGl6ZXMgd29yZHMgYXMgeW91IHdvdWxkIGZvciBhIGJvb2sgdGl0bGUuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgaW5mbGVjdGlvbiA9IHJlcXVpcmUoICdpbmZsZWN0aW9uJyApO1xuICAgKlxuICAgKiAgICAgaW5mbGVjdGlvbi50aXRsZWl6ZSggJ21lc3NhZ2VfcHJvcGVydGllcycgKTsgLy8gPT09ICdNZXNzYWdlIFByb3BlcnRpZXMnXG4gICAqICAgICBpbmZsZWN0aW9uLnRpdGxlaXplKCAnbWVzc2FnZSBwcm9wZXJ0aWVzIHRvIGtlZXAnICk7IC8vID09PSAnTWVzc2FnZSBQcm9wZXJ0aWVzIHRvIEtlZXAnXG4gICAqL1xuICAgIHRpdGxlaXplIDogZnVuY3Rpb24gKCBzdHIgKXtcbiAgICAgIHN0ciAgICAgICAgID0gc3RyLnRvTG93ZXJDYXNlKCkucmVwbGFjZSggdW5kZXJiYXIsICcgJyApO1xuICAgICAgdmFyIHN0cl9hcnIgPSBzdHIuc3BsaXQoICcgJyApO1xuICAgICAgdmFyIGkgICAgICAgPSAwO1xuICAgICAgdmFyIGogICAgICAgPSBzdHJfYXJyLmxlbmd0aDtcbiAgICAgIHZhciBkLCBrLCBsO1xuXG4gICAgICBmb3IoIDsgaSA8IGo7IGkrKyApe1xuICAgICAgICBkID0gc3RyX2FyclsgaSBdLnNwbGl0KCAnLScgKTtcbiAgICAgICAgayA9IDA7XG4gICAgICAgIGwgPSBkLmxlbmd0aDtcblxuICAgICAgICBmb3IoIDsgayA8IGw7IGsrKyl7XG4gICAgICAgICAgaWYoIGluZmxlY3Rvci5pbmRleE9mKCBub25fdGl0bGVjYXNlZF93b3JkcywgZFsgayBdLnRvTG93ZXJDYXNlKCkpIDwgMCApe1xuICAgICAgICAgICAgZFsgayBdID0gaW5mbGVjdG9yLmNhcGl0YWxpemUoIGRbIGsgXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3RyX2FyclsgaSBdID0gZC5qb2luKCAnLScgKTtcbiAgICAgIH1cblxuICAgICAgc3RyID0gc3RyX2Fyci5qb2luKCAnICcgKTtcbiAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoIDAsIDEgKS50b1VwcGVyQ2FzZSgpICsgc3RyLnN1YnN0cmluZyggMSApO1xuXG4gICAgICByZXR1cm4gc3RyO1xuICAgIH0sXG5cblxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGFkZHMgZGVtb2R1bGl6ZSBzdXBwb3J0IHRvIGV2ZXJ5IFN0cmluZyBvYmplY3QuXG4gICAqIEBwdWJsaWNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN1YmplY3Qgc3RyaW5nLlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBSZW1vdmVzIG1vZHVsZSBuYW1lcyBsZWF2aW5nIG9ubHkgY2xhc3MgbmFtZXMuKFJ1Ynkgc3R5bGUpXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgaW5mbGVjdGlvbiA9IHJlcXVpcmUoICdpbmZsZWN0aW9uJyApO1xuICAgKlxuICAgKiAgICAgaW5mbGVjdGlvbi5kZW1vZHVsaXplKCAnTWVzc2FnZTo6QnVzOjpQcm9wZXJ0aWVzJyApOyAvLyA9PT0gJ1Byb3BlcnRpZXMnXG4gICAqL1xuICAgIGRlbW9kdWxpemUgOiBmdW5jdGlvbiAoIHN0ciApe1xuICAgICAgdmFyIHN0cl9hcnIgPSBzdHIuc3BsaXQoICc6OicgKTtcblxuICAgICAgcmV0dXJuIHN0cl9hcnJbIHN0cl9hcnIubGVuZ3RoIC0gMSBdO1xuICAgIH0sXG5cblxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGFkZHMgdGFibGVpemUgc3VwcG9ydCB0byBldmVyeSBTdHJpbmcgb2JqZWN0LlxuICAgKiBAcHVibGljXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdWJqZWN0IHN0cmluZy5cbiAgICogQHJldHVybnMge1N0cmluZ30gUmV0dXJuIGNhbWVsIGNhc2VkIHdvcmRzIGludG8gdGhlaXIgdW5kZXJzY29yZWQgcGx1cmFsIGZvcm0uXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgaW5mbGVjdGlvbiA9IHJlcXVpcmUoICdpbmZsZWN0aW9uJyApO1xuICAgKlxuICAgKiAgICAgaW5mbGVjdGlvbi50YWJsZWl6ZSggJ01lc3NhZ2VCdXNQcm9wZXJ0eScgKTsgLy8gPT09ICdtZXNzYWdlX2J1c19wcm9wZXJ0aWVzJ1xuICAgKi9cbiAgICB0YWJsZWl6ZSA6IGZ1bmN0aW9uICggc3RyICl7XG4gICAgICBzdHIgPSBpbmZsZWN0b3IudW5kZXJzY29yZSggc3RyICk7XG4gICAgICBzdHIgPSBpbmZsZWN0b3IucGx1cmFsaXplKCBzdHIgKTtcblxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9LFxuXG5cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBhZGRzIGNsYXNzaWZpY2F0aW9uIHN1cHBvcnQgdG8gZXZlcnkgU3RyaW5nIG9iamVjdC5cbiAgICogQHB1YmxpY1xuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3ViamVjdCBzdHJpbmcuXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IFVuZGVyc2NvcmVkIHBsdXJhbCBub3VucyBiZWNvbWUgdGhlIGNhbWVsIGNhc2VkIHNpbmd1bGFyIGZvcm0uXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgaW5mbGVjdGlvbiA9IHJlcXVpcmUoICdpbmZsZWN0aW9uJyApO1xuICAgKlxuICAgKiAgICAgaW5mbGVjdGlvbi5jbGFzc2lmeSggJ21lc3NhZ2VfYnVzX3Byb3BlcnRpZXMnICk7IC8vID09PSAnTWVzc2FnZUJ1c1Byb3BlcnR5J1xuICAgKi9cbiAgICBjbGFzc2lmeSA6IGZ1bmN0aW9uICggc3RyICl7XG4gICAgICBzdHIgPSBpbmZsZWN0b3IuY2FtZWxpemUoIHN0ciApO1xuICAgICAgc3RyID0gaW5mbGVjdG9yLnNpbmd1bGFyaXplKCBzdHIgKTtcblxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9LFxuXG5cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBhZGRzIGZvcmVpZ24ga2V5IHN1cHBvcnQgdG8gZXZlcnkgU3RyaW5nIG9iamVjdC5cbiAgICogQHB1YmxpY1xuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3ViamVjdCBzdHJpbmcuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZHJvcF9pZF91YmFyIERlZmF1bHQgaXMgdG8gc2VwZXJhdGUgaWQgd2l0aCBhbiB1bmRlcmJhciBhdCB0aGUgZW5kIG9mIHRoZSBjbGFzcyBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeW91IGNhbiBwYXNzIHRydWUgdG8gc2tpcCBpdC4ob3B0aW9uYWwpXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IFVuZGVyc2NvcmVkIHBsdXJhbCBub3VucyBiZWNvbWUgdGhlIGNhbWVsIGNhc2VkIHNpbmd1bGFyIGZvcm0uXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgaW5mbGVjdGlvbiA9IHJlcXVpcmUoICdpbmZsZWN0aW9uJyApO1xuICAgKlxuICAgKiAgICAgaW5mbGVjdGlvbi5mb3JlaWduX2tleSggJ01lc3NhZ2VCdXNQcm9wZXJ0eScgKTsgLy8gPT09ICdtZXNzYWdlX2J1c19wcm9wZXJ0eV9pZCdcbiAgICogICAgIGluZmxlY3Rpb24uZm9yZWlnbl9rZXkoICdNZXNzYWdlQnVzUHJvcGVydHknLCB0cnVlICk7IC8vID09PSAnbWVzc2FnZV9idXNfcHJvcGVydHlpZCdcbiAgICovXG4gICAgZm9yZWlnbl9rZXkgOiBmdW5jdGlvbiAoIHN0ciwgZHJvcF9pZF91YmFyICl7XG4gICAgICBzdHIgPSBpbmZsZWN0b3IuZGVtb2R1bGl6ZSggc3RyICk7XG4gICAgICBzdHIgPSBpbmZsZWN0b3IudW5kZXJzY29yZSggc3RyICkgKyAoKCBkcm9wX2lkX3ViYXIgKSA/ICggJycgKSA6ICggJ18nICkpICsgJ2lkJztcblxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9LFxuXG5cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBhZGRzIG9yZGluYWxpemUgc3VwcG9ydCB0byBldmVyeSBTdHJpbmcgb2JqZWN0LlxuICAgKiBAcHVibGljXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdWJqZWN0IHN0cmluZy5cbiAgICogQHJldHVybnMge1N0cmluZ30gUmV0dXJuIGFsbCBmb3VuZCBudW1iZXJzIHRoZWlyIHNlcXVlbmNlIGxpa2UgJzIybmQnLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGluZmxlY3Rpb24gPSByZXF1aXJlKCAnaW5mbGVjdGlvbicgKTtcbiAgICpcbiAgICogICAgIGluZmxlY3Rpb24ub3JkaW5hbGl6ZSggJ3RoZSAxIHBpdGNoJyApOyAvLyA9PT0gJ3RoZSAxc3QgcGl0Y2gnXG4gICAqL1xuICAgIG9yZGluYWxpemUgOiBmdW5jdGlvbiAoIHN0ciApe1xuICAgICAgdmFyIHN0cl9hcnIgPSBzdHIuc3BsaXQoICcgJyApO1xuICAgICAgdmFyIGkgICAgICAgPSAwO1xuICAgICAgdmFyIGogICAgICAgPSBzdHJfYXJyLmxlbmd0aDtcblxuICAgICAgZm9yKCA7IGkgPCBqOyBpKysgKXtcbiAgICAgICAgdmFyIGsgPSBwYXJzZUludCggc3RyX2FyclsgaSBdLCAxMCApO1xuXG4gICAgICAgIGlmKCAhaXNOYU4oIGsgKSl7XG4gICAgICAgICAgdmFyIGx0ZCA9IHN0cl9hcnJbIGkgXS5zdWJzdHJpbmcoIHN0cl9hcnJbIGkgXS5sZW5ndGggLSAyICk7XG4gICAgICAgICAgdmFyIGxkICA9IHN0cl9hcnJbIGkgXS5zdWJzdHJpbmcoIHN0cl9hcnJbIGkgXS5sZW5ndGggLSAxICk7XG4gICAgICAgICAgdmFyIHN1ZiA9ICd0aCc7XG5cbiAgICAgICAgICBpZiggbHRkICE9ICcxMScgJiYgbHRkICE9ICcxMicgJiYgbHRkICE9ICcxMycgKXtcbiAgICAgICAgICAgIGlmKCBsZCA9PT0gJzEnICl7XG4gICAgICAgICAgICAgIHN1ZiA9ICdzdCc7XG4gICAgICAgICAgICB9ZWxzZSBpZiggbGQgPT09ICcyJyApe1xuICAgICAgICAgICAgICBzdWYgPSAnbmQnO1xuICAgICAgICAgICAgfWVsc2UgaWYoIGxkID09PSAnMycgKXtcbiAgICAgICAgICAgICAgc3VmID0gJ3JkJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzdHJfYXJyWyBpIF0gKz0gc3VmO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHJfYXJyLmpvaW4oICcgJyApO1xuICAgIH0sXG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gcGVyZm9ybXMgbXVsdGlwbGUgaW5mbGVjdGlvbiBtZXRob2RzIG9uIGEgc3RyaW5nXG4gICAqIEBwdWJsaWNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN1YmplY3Qgc3RyaW5nLlxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnIgQW4gYXJyYXkgb2YgaW5mbGVjdGlvbiBtZXRob2RzLlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGluZmxlY3Rpb24gPSByZXF1aXJlKCAnaW5mbGVjdGlvbicgKTtcbiAgICpcbiAgICogICAgIGluZmxlY3Rpb24udHJhbnNmb3JtKCAnYWxsIGpvYicsIFsgJ3BsdXJhbGl6ZScsICdjYXBpdGFsaXplJywgJ2Rhc2hlcml6ZScgXSk7IC8vID09PSAnQWxsLWpvYnMnXG4gICAqL1xuICAgIHRyYW5zZm9ybSA6IGZ1bmN0aW9uICggc3RyLCBhcnIgKXtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBqID0gYXJyLmxlbmd0aDtcblxuICAgICAgZm9yKCA7aSA8IGo7IGkrKyApe1xuICAgICAgICB2YXIgbWV0aG9kID0gYXJyWyBpIF07XG5cbiAgICAgICAgaWYoIHRoaXMuaGFzT3duUHJvcGVydHkoIG1ldGhvZCApKXtcbiAgICAgICAgICBzdHIgPSB0aGlzWyBtZXRob2QgXSggc3RyICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG4gIGluZmxlY3Rvci52ZXJzaW9uID0gJzEuMy44JztcblxuICByZXR1cm4gaW5mbGVjdG9yO1xufSkpO1xuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCIvKipcbiAqIERldGVybWluZSBpZiBhbiBvYmplY3QgaXMgQnVmZmVyXG4gKlxuICogQXV0aG9yOiAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBMaWNlbnNlOiAgTUlUXG4gKlxuICogYG5wbSBpbnN0YWxsIGlzLWJ1ZmZlcmBcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuICEhKG9iaiAhPSBudWxsICYmXG4gICAgKG9iai5faXNCdWZmZXIgfHwgLy8gRm9yIFNhZmFyaSA1LTcgKG1pc3NpbmcgT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvcilcbiAgICAgIChvYmouY29uc3RydWN0b3IgJiZcbiAgICAgIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopKVxuICAgICkpXG59XG4iLCIoZnVuY3Rpb24oIGdsb2IsIHVuZGVmaW5lZCApIHtcblxudmFyIHJudW1iZXIgPSAvWzAtOV0vLFxuXHRybmV3bGluZSA9IC8oXFxyXFxufFxccnxcXG4pLyxcblx0cmV2aWRlbmNlID0gL1xcclxcbnxcXHJ8XFxuLyxcblx0cndoaXRlc3BhY2UgPSAvKFxcc3xcXHQpLyxcblx0cnZhbGlkc29saWR1cyA9IC9cXFxcKFwifFxcXFx8XFwvfGJ8ZnxufHJ8dHx1WzAtOV17NH0pLyxcblx0ckUgPSAvXihcXC18XFwrKT9bMC05XS87XG5cblxuLy8gTGVlZWVlZWVycnJycm9vb3l5IEplbm5ra2tpaWlubm5zc1xuZnVuY3Rpb24gSlNPTkxpbnQoIGpzb24sIG9wdGlvbnMgKSB7XG5cdHZhciBzZWxmID0gdGhpcztcblxuXHRpZiAoICEgKCBzZWxmIGluc3RhbmNlb2YgSlNPTkxpbnQgKSApIHtcblx0XHRyZXR1cm4gbmV3IEpTT05MaW50KCBqc29uLCBvcHRpb25zICk7XG5cdH1cblxuXHQvLyBBcmd1bWVudCBoYW5kbGluZ1xuXHRzZWxmLmpzb24gPSBqc29uIHx8ICcnO1xuXHRzZWxmLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRzZWxmLmxvd2VyID0gc2VsZi5qc29uLnRvTG93ZXJDYXNlKCk7XG5cblx0Ly8gQWxsb3cgY29tbWVudHMgYnkgZGVmYXVsdFxuXHRpZiAoICEgc2VsZi5vcHRpb25zLmhhc093blByb3BlcnR5KCAnY29tbWVudHMnICkgKSB7XG5cdFx0c2VsZi5vcHRpb25zLmNvbW1lbnRzID0gdHJ1ZTtcblx0fVxuXG5cdC8vIEludGVybmFsc1xuXHRzZWxmLmMgPSAnJztcblx0c2VsZi5pID0gLTE7XG5cdHNlbGYubGVuZ3RoID0gc2VsZi5qc29uLmxlbmd0aDtcblx0c2VsZi5saW5lID0gMTtcblx0c2VsZi5jaGFyYWN0ZXIgPSAwO1xuXHRzZWxmLl9ldmlkZW5jZSA9IHNlbGYuanNvbi5zcGxpdCggcmV2aWRlbmNlICk7XG5cdHNlbGYuZW5kYmxvY2sgPSAnJztcblx0c2VsZi5jb21tYWJyZWFrID0gZmFsc2U7XG5cblx0dHJ5IHtcblx0XHRzZWxmLnJlbmRlcigpO1xuXHR9IGNhdGNoICggZSApIHtcblx0XHRpZiAoIHR5cGVvZiBlICE9ICdzdHJpbmcnICkge1xuXHRcdFx0dGhyb3cgZTtcblx0XHR9XG5cdFx0c2VsZi5lcnJvciA9IGU7XG5cdFx0c2VsZi5zZXRFdmlkZW5jZSgpO1xuXHR9XG59XG5cblxuLy8gTWV0YSAoUGxlYXNlIGNoYW5nZSBjb250YWN0IGluZm8gZm9yIHJlcHVibGlzaGluZyB3aXRoIGNoYW5nZXMpXG5KU09OTGludC5jb250YWN0ID0gXCJDb3JleSBIYXJ0IChjb3JleUBjb2Rlbm90aGluZy5jb20pXCI7XG5KU09OTGludC52ZXJzaW9uID0gJ1tWRVJTSU9OXSc7XG5KU09OTGludC5kYXRlID0gJ1tEQVRFXSc7XG5cblxuLy8gTWV0aG9kc1xuSlNPTkxpbnQucHJvdG90eXBlID0ge1xuXG5cdC8vIFJlbmRlcmluZyBTdGFydFxuXHRyZW5kZXI6IGZ1bmN0aW9uKCl7XG5cdFx0dmFyIHNlbGYgPSB0aGlzLCBwZWVrID0gJycsIGNvbnRlbnQgPSBmYWxzZTtcblxuXHRcdGZvciAoIDsgKytzZWxmLmkgPCBzZWxmLmxlbmd0aDsgKSB7XG5cdFx0XHRzZWxmLmMgPSBzZWxmLmpzb25bIHNlbGYuaSBdO1xuXHRcdFx0c2VsZi5jaGFyYWN0ZXIrKztcblxuXHRcdFx0aWYgKCBzZWxmLm9wdGlvbnMuY29tbWVudHMgJiYgc2VsZi5jID09ICcvJyApIHtcblx0XHRcdFx0cGVlayA9IHNlbGYuanNvblsgc2VsZi5pICsgMSBdO1xuXHRcdFx0XHRpZiAoIHBlZWsgPT0gJyonICkge1xuXHRcdFx0XHRcdHNlbGYubXVsdGljb21tZW50KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoIHBlZWsgPT0gJy8nICkge1xuXHRcdFx0XHRcdHNlbGYuY29tbWVudCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IFwiVW5rbm93biBjaGFyYWN0ZXIgJy8nLCBtYXliZSBhIGNvbW1lbnQ/XCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBybmV3bGluZS5leGVjKCBzZWxmLmMgKSApIHtcblx0XHRcdFx0c2VsZi5saW5lKys7XG5cdFx0XHRcdHNlbGYuY2hhcmFjdGVyID0gMDtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCByd2hpdGVzcGFjZS5leGVjKCBzZWxmLmMgKSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggY29udGVudCApIHtcblx0XHRcdFx0dGhyb3cgXCJVbmtub3duIGNoYXJhY3RlciAnXCIgKyBzZWxmLmMgKyBcIicsIGV4cGVjdGluZyBlbmQgb2YgZmlsZS5cIjtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBzZWxmLmMgPT0gJ1snICkge1xuXHRcdFx0XHRjb250ZW50ID0gdHJ1ZTtcblx0XHRcdFx0c2VsZi5hcnJheSgpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIHNlbGYuYyA9PSAneycgKSB7XG5cdFx0XHRcdGNvbnRlbnQgPSB0cnVlO1xuXHRcdFx0XHRzZWxmLm9iamVjdCgpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHRocm93IFwiVW5rbm93biBjaGFyYWN0ZXIgJ1wiICsgc2VsZi5jICsgXCInLCBleHBlY3Rpbmcgb3BlbmluZyBibG9jayAneycgb3IgJ1snLCBvciBtYXliZSBhIGNvbW1lbnRcIjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDaGVjayBmb3IgcHVyZSB3aGl0ZXNwYWNlXG5cdFx0aWYgKCAhIGNvbnRlbnQgKSB7XG5cdFx0XHR0aHJvdyBcIkludmFsaWQgSlNPTiwgbm8gY29udGVudC5cIjtcblx0XHR9XG5cdH0sXG5cblx0Ly8gTXVsdGkgbGluZSBjb21tZW50XG5cdG11bHRpY29tbWVudDogZnVuY3Rpb24oKXtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0XHRmb3IgKCA7ICsrc2VsZi5pIDwgc2VsZi5sZW5ndGg7ICkge1xuXHRcdFx0c2VsZi5jID0gc2VsZi5qc29uWyBzZWxmLmkgXTtcblx0XHRcdHNlbGYuY2hhcmFjdGVyKys7XG5cblx0XHRcdGlmICggc2VsZi5jID09IFwiKlwiICYmIHNlbGYuanNvblsgc2VsZi5pICsgMSBdID09IFwiL1wiICkge1xuXHRcdFx0XHRzZWxmLmkrKztcblx0XHRcdFx0c2VsZi5jaGFyYWN0ZXIrKztcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggcm5ld2xpbmUuZXhlYyggc2VsZi5jICkgKSB7XG5cdFx0XHRcdHNlbGYubGluZSsrO1xuXHRcdFx0XHRzZWxmLmNoYXJhY3RlciA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIFNpbmdsZSBsaW5lIGNvbW1lbnRcblx0Y29tbWVudDogZnVuY3Rpb24oKXtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0XHRmb3IgKCA7ICsrc2VsZi5pIDwgc2VsZi5sZW5ndGg7ICkge1xuXHRcdFx0c2VsZi5jID0gc2VsZi5qc29uWyBzZWxmLmkgXTtcblx0XHRcdHNlbGYuY2hhcmFjdGVyKys7XG5cblx0XHRcdGlmICggcm5ld2xpbmUuZXhlYyggc2VsZi5jICkgKSB7XG5cdFx0XHRcdHNlbGYubGluZSsrO1xuXHRcdFx0XHRzZWxmLmNoYXJhY3RlciA9IDA7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBBcnJheSBCbG9ja1xuXHRhcnJheTogZnVuY3Rpb24oKXtcblx0XHQvLyBLZWVwIHJlZmVyZW5jZSBvZiBjdXJyZW50IGVuZGJsb2NrXG5cdFx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdFx0X2VuZGJsb2NrID0gc2VsZi5lbmRibG9jayxcblx0XHRcdF9jb21tYWJyZWFrID0gc2VsZi5jb21tYWJyZWFrLFxuXHRcdFx0ZW5kZWQgPSBmYWxzZTtcblxuXHRcdHNlbGYuZW5kYmxvY2sgPSAnXSc7XG5cdFx0c2VsZi5jb21tYWJyZWFrID0gZmFsc2U7XG5cdFx0d2hpbGUgKCAoIGVuZGVkID0gc2VsZi52YWx1ZSgpICkgIT09IHRydWUgJiYgc2VsZi5pIDwgc2VsZi5sZW5ndGggKSB7XG5cdFx0XHQvLyBEbyBub3RoaW5nLCBqdXN0IHdhaXQgZm9yIGFycmF5IHZhbHVlcyB0byBmaW5pc2hcblx0XHR9XG5cblx0XHRpZiAoICEgZW5kZWQgKSB7XG5cdFx0XHR0aHJvdyBcIkVPRiBFcnJvci4gRXhwZWN0aW5nIGNsb3NpbmcgJ10nXCI7XG5cdFx0fVxuXG5cdFx0Ly8gUmVzZXQgcHJldmlvdXMgZW5kYmxvY2tcblx0XHRzZWxmLmVuZGJsb2NrID0gX2VuZGJsb2NrO1xuXHRcdHNlbGYuY29tbWFicmVhayA9IF9jb21tYWJyZWFrO1xuXHR9LFxuXG5cdC8vIE9iamVjdCBCbG9ja1xuXHRvYmplY3Q6IGZ1bmN0aW9uKCl7XG5cdFx0Ly8gS2VlcCByZWZlcmVuY2Ugb2YgY3VycmVudCBlbmRibG9ja1xuXHRcdHZhciBzZWxmID0gdGhpcyxcblx0XHRcdF9lbmRibG9jayA9IHNlbGYuZW5kYmxvY2ssXG5cdFx0XHRfY29tbWFicmVhayA9IHNlbGYuY29tbWFicmVhayxcblx0XHRcdGZvdW5kID0gZmFsc2UsIHBlZWsgPSAnJywgZW1wdHkgPSB0cnVlO1xuXG5cdFx0c2VsZi5lbmRibG9jayA9ICd9Jztcblx0XHRzZWxmLmNvbW1hYnJlYWsgPSBmYWxzZTtcblx0XHRmb3IgKCA7ICsrc2VsZi5pIDwgc2VsZi5sZW5ndGg7ICkge1xuXHRcdFx0c2VsZi5jID0gc2VsZi5qc29uWyBzZWxmLmkgXTtcblx0XHRcdHNlbGYuY2hhcmFjdGVyKys7XG5cblx0XHRcdGlmICggc2VsZi5vcHRpb25zLmNvbW1lbnRzICYmIHNlbGYuYyA9PSAnLycgKSB7XG5cdFx0XHRcdHBlZWsgPSBzZWxmLmpzb25bIHNlbGYuaSArIDEgXTtcblx0XHRcdFx0aWYgKCBwZWVrID09ICcqJyApIHtcblx0XHRcdFx0XHRzZWxmLm11bHRpY29tbWVudCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKCBwZWVrID09ICcvJyApIHtcblx0XHRcdFx0XHRzZWxmLmNvbW1lbnQoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR0aHJvdyBcIlVua25vd24gY2hhcmFjdGVyICcvJywgbWF5YmUgYSBjb21tZW50P1wiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggcm5ld2xpbmUuZXhlYyggc2VsZi5jICkgKSB7XG5cdFx0XHRcdHNlbGYubGluZSsrO1xuXHRcdFx0XHRzZWxmLmNoYXJhY3RlciA9IDA7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggcndoaXRlc3BhY2UuZXhlYyggc2VsZi5jICkgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIHNlbGYuYyA9PSAnXCInICkge1xuXHRcdFx0XHRlbXB0eSA9IGZhbHNlO1xuXHRcdFx0XHRpZiAoIHNlbGYua2V5KCkgPT09IHRydWUgKSB7XG5cdFx0XHRcdFx0Ly8gUmVzZXQgb2xkIGVuZGJsb2NrXG5cdFx0XHRcdFx0c2VsZi5lbmRibG9jayA9IF9lbmRibG9jaztcblx0XHRcdFx0XHRzZWxmLmNvbW1hYnJlYWsgPSBfY29tbWFicmVhaztcblx0XHRcdFx0XHRmb3VuZCA9IHRydWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBlbXB0eSAmJiBzZWxmLmMgPT0gJ30nICkge1xuXHRcdFx0XHRzZWxmLmVuZGJsb2NrID0gX2VuZGJsb2NrO1xuXHRcdFx0XHRzZWxmLmNvbW1hYnJlYWsgPSBfY29tbWFicmVhaztcblx0XHRcdFx0Zm91bmQgPSB0cnVlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBcIlVua25vd24gQ2hhcmFjdGVyICdcIiArIHNlbGYuYyArIFwiJywgZXhwZWN0aW5nIGEgc3RyaW5nIGZvciBrZXkgc3RhdGVtZW50LlwiO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggISBmb3VuZCApIHtcblx0XHRcdHRocm93IFwiRU9GIEVycm9yLCBleHBlY3RpbmcgY2xvc2luZyAnfScuXCI7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIEtleSBTdGF0ZW1lbnRcblx0a2V5OiBmdW5jdGlvbigpe1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRzZWxmLnN0cmluZygpO1xuXG5cdFx0Zm9yICggdmFyIHBlZWsgPSAnJzsgKytzZWxmLmkgPCBzZWxmLmxlbmd0aDsgKSB7XG5cdFx0XHRzZWxmLmMgPSBzZWxmLmpzb25bIHNlbGYuaSBdO1xuXHRcdFx0c2VsZi5jaGFyYWN0ZXIrKztcblxuXHRcdFx0aWYgKCBzZWxmLm9wdGlvbnMuY29tbWVudHMgJiYgc2VsZi5jID09ICcvJyApIHtcblx0XHRcdFx0cGVlayA9IHNlbGYuanNvblsgc2VsZi5pICsgMSBdO1xuXHRcdFx0XHRpZiAoIHBlZWsgPT0gJyonICkge1xuXHRcdFx0XHRcdHNlbGYubXVsdGljb21tZW50KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoIHBlZWsgPT0gJy8nICkge1xuXHRcdFx0XHRcdHNlbGYuY29tbWVudCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IFwiVW5rbm93biBjaGFyYWN0ZXIgJy8nLCBtYXliZSBhIGNvbW1lbnQ/XCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBybmV3bGluZS5leGVjKCBzZWxmLmMgKSApIHtcblx0XHRcdFx0c2VsZi5saW5lKys7XG5cdFx0XHRcdHNlbGYuY2hhcmFjdGVyID0gMDtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCByd2hpdGVzcGFjZS5leGVjKCBzZWxmLmMgKSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggc2VsZi5jID09IFwiOlwiICkge1xuXHRcdFx0XHRyZXR1cm4gc2VsZi52YWx1ZSgpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHRocm93IFwiVW5rbm93biBDaGFyYWN0ZXIgJ1wiICsgc2VsZi5jICsgXCInLCBleHBlY3RpbmcgYSBzZW1pY29sb24uXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIFZhbHVlIHN0YXRlbWVudFxuXHR2YWx1ZTogZnVuY3Rpb24oKXtcblx0XHR2YXIgc2VsZiA9IHRoaXMsIHBlZWsgPSAnJztcblxuXHRcdGZvciAoIDsgKytzZWxmLmkgPCBzZWxmLmxlbmd0aDsgKSB7XG5cdFx0XHRzZWxmLmMgPSBzZWxmLmpzb25bIHNlbGYuaSBdO1xuXHRcdFx0c2VsZi5jaGFyYWN0ZXIrKztcblxuXHRcdFx0aWYgKCBzZWxmLm9wdGlvbnMuY29tbWVudHMgJiYgc2VsZi5jID09ICcvJyApIHtcblx0XHRcdFx0cGVlayA9IHNlbGYuanNvblsgc2VsZi5pICsgMSBdO1xuXHRcdFx0XHRpZiAoIHBlZWsgPT0gJyonICkge1xuXHRcdFx0XHRcdHNlbGYubXVsdGljb21tZW50KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoIHBlZWsgPT0gJy8nICkge1xuXHRcdFx0XHRcdHNlbGYuY29tbWVudCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IFwiVW5rbm93biBjaGFyYWN0ZXIgJy8nLCBtYXliZSBhIGNvbW1lbnQ/XCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBybmV3bGluZS5leGVjKCBzZWxmLmMgKSApIHtcblx0XHRcdFx0c2VsZi5saW5lKys7XG5cdFx0XHRcdHNlbGYuY2hhcmFjdGVyID0gMDtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCByd2hpdGVzcGFjZS5leGVjKCBzZWxmLmMgKSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggc2VsZi5jID09ICd7JyApIHtcblx0XHRcdFx0c2VsZi5vYmplY3QoKTtcblx0XHRcdFx0cmV0dXJuIHNlbGYuZW5kdmFsKCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggc2VsZi5jID09ICdbJyApIHtcblx0XHRcdFx0c2VsZi5hcnJheSgpO1xuXHRcdFx0XHRyZXR1cm4gc2VsZi5lbmR2YWwoKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBzZWxmLmMgPT0gJ1wiJyApIHtcblx0XHRcdFx0c2VsZi5zdHJpbmcoKTtcblx0XHRcdFx0cmV0dXJuIHNlbGYuZW5kdmFsKCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggc2VsZi5qc29uLmluZGV4T2YoICd0cnVlJywgc2VsZi5pICkgPT09IHNlbGYuaSApIHtcblx0XHRcdFx0c2VsZi5pICs9IDM7XG5cdFx0XHRcdHNlbGYuY2hhcmFjdGVyICs9IDM7XG5cdFx0XHRcdHJldHVybiBzZWxmLmVuZHZhbCgpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIHNlbGYuanNvbi5pbmRleE9mKCAnZmFsc2UnLCBzZWxmLmkgKSA9PT0gc2VsZi5pICkge1xuXHRcdFx0XHRzZWxmLmkgKz0gNDtcblx0XHRcdFx0c2VsZi5jaGFyYWN0ZXIgKz0gNDtcblx0XHRcdFx0cmV0dXJuIHNlbGYuZW5kdmFsKCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggc2VsZi5qc29uLmluZGV4T2YoICdudWxsJywgc2VsZi5pICkgPT09IHNlbGYuaSApIHtcblx0XHRcdFx0c2VsZi5pICs9IDM7XG5cdFx0XHRcdHNlbGYuY2hhcmFjdGVyICs9IDM7XG5cdFx0XHRcdHJldHVybiBzZWxmLmVuZHZhbCgpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIHNlbGYuYyA9PSAnLScgfHwgcm51bWJlci5leGVjKCBzZWxmLmMgKSApIHtcblx0XHRcdFx0cmV0dXJuIHNlbGYubnVtZXJpYygpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIHNlbGYuYyA9PSAnXScgJiYgc2VsZi5lbmRibG9jayA9PSAnXScgKSB7XG5cdFx0XHRcdGlmICggc2VsZi5jb21tYWJyZWFrICkge1xuXHRcdFx0XHRcdHRocm93IFwiVW5leHBlY3RlZCBFbmQgT2YgQXJyYXkgRXJyb3IuIEV4cGVjdGluZyBhIHZhbHVlIHN0YXRlbWVudC5cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBcIlVua25vd24gQ2hhcmFjdGVyICdcIiArIHNlbGYuYyArIFwiJywgZXhwZWN0aW5nIGEgdmFsdWUuXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIFN0cmluZyBzdGF0ZW1lbnRcblx0c3RyaW5nOiBmdW5jdGlvbigpe1xuXHRcdHZhciBzZWxmID0gdGhpcywgZm91bmQgPSBmYWxzZSwgbTtcblxuXHRcdGZvciAoIDsgKytzZWxmLmkgPCBzZWxmLmxlbmd0aDsgKSB7XG5cdFx0XHRzZWxmLmMgPSBzZWxmLmpzb25bIHNlbGYuaSBdO1xuXHRcdFx0c2VsZi5jaGFyYWN0ZXIrKztcblxuXHRcdFx0aWYgKCBzZWxmLmMgPT0gXCJcXFxcXCIgKSB7XG5cdFx0XHRcdGlmICggKCBtID0gcnZhbGlkc29saWR1cy5leGVjKCBzZWxmLmpzb24uc3Vic3RyKCBzZWxmLmkgKSApICkgJiYgbS5pbmRleCA9PT0gMCApIHtcblx0XHRcdFx0XHRzZWxmLmkgKz0gbVsgMSBdLmxlbmd0aDtcblx0XHRcdFx0XHRzZWxmLmNoYXJhY3RlciArPSBtWyAxIF0ubGVuZ3RoO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IFwiSW52YWxpZCBSZXZlcnNlIFNvbGlkdXMgJ1xcXFwnIGRlY2xhcmF0aW9uLlwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggcm5ld2xpbmUuZXhlYyggc2VsZi5jICkgKSB7XG5cdFx0XHRcdHNlbGYubGluZSsrO1xuXHRcdFx0XHRzZWxmLmNoYXJhY3RlciA9IDA7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggc2VsZi5jID09ICdcIicgKSB7XG5cdFx0XHRcdGZvdW5kID0gdHJ1ZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIGNsb3NlIHN0cmluZyBpcyBmb3VuZFxuXHRcdGlmICggISBmb3VuZCApIHtcblx0XHRcdHRocm93IFwiRU9GOiBObyBjbG9zZSBzdHJpbmcgJ1xcXCInIGZvdW5kLlwiO1xuXHRcdH1cblx0fSxcblxuXHQvLyBOdW1lcmljIFZhbHVlXG5cdG51bWVyaWM6IGZ1bmN0aW9uKCl7XG5cdFx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdFx0bmVnYXRpdmUgPSB0cnVlLFxuXHRcdFx0ZGVjaW1hbCA9IG51bGwsXG5cdFx0XHRlID0gbnVsbCxcblx0XHRcdHBlZWsgPSAnJztcblxuXHRcdC8vIFdlIG5lZWQgdG8ganVtcCBiYWNrIGEgY2hhcmFjdGVyIHRvIGNhdGNoIHRoZSB3aG9sZSBudW1iZXJcblx0XHRzZWxmLmktLTtcblx0XHRzZWxmLmNoYXJhY3Rlci0tO1xuXHRcdGZvciAoIDsgKytzZWxmLmkgPCBzZWxmLmxlbmd0aDsgKSB7XG5cdFx0XHRzZWxmLmMgPSBzZWxmLmpzb25bIHNlbGYuaSBdO1xuXHRcdFx0c2VsZi5jaGFyYWN0ZXIrKztcblxuXHRcdFx0Ly8gSGFuZGxlIGluaXRpYWwgbmVnYXRpdmUgc2lnblxuXHRcdFx0aWYgKCBuZWdhdGl2ZSApIHtcblx0XHRcdFx0bmVnYXRpdmUgPSBmYWxzZTtcblx0XHRcdFx0aWYgKCBzZWxmLmMgPT0gJy0nICkge1xuXHRcdFx0XHRcdGlmICggISBybnVtYmVyLmV4ZWMoIHNlbGYuanNvblsgc2VsZi5pICsgMSBdICkgKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBcIlVua25vd24gQ2hhcmFjdGVyICdcIiArIHNlbGYuYyArIFwiJyBmb2xsb3dpbmcgYSBuZWdhdGl2ZSwgZXhwZWN0aW5nIGEgbnVtZXJpYyB2YWx1ZS5cIjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gT25seSBhIHNpbmdsZSBkZWNpbWFsIGlzIGFsbG93ZWQgaW4gYSBudW1lcmljIHZhbHVlXG5cdFx0XHRpZiAoIGRlY2ltYWwgJiYgc2VsZi5jID09ICcuJyApIHtcblx0XHRcdFx0ZGVjaW1hbCA9IGZhbHNlO1xuXHRcdFx0XHRlID0gdHJ1ZTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHQvLyBPbmx5IGEgc2luZ2xlIGUgbm90YXRpb24gaXMgYWxsb3dlZCBpbiBhIG51bWVyaWMgdmFsdWVcblx0XHRcdGVsc2UgaWYgKCBlICYmIHNlbGYuYy50b0xvd2VyQ2FzZSgpID09ICdlJyApIHtcblx0XHRcdFx0ZSA9IGZhbHNlO1xuXHRcdFx0XHRuZWdhdGl2ZSA9IHRydWU7XG5cdFx0XHRcdGlmICggckUuZXhlYyggc2VsZi5qc29uLnN1YnN0ciggc2VsZi5pICsgMSwgMiApICkgKSB7XG5cdFx0XHRcdFx0c2VsZi5jaGFyYWN0ZXIrKztcblx0XHRcdFx0XHRzZWxmLmkrKztcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRzZWxmLmNoYXJhY3RlcisrO1xuXHRcdFx0XHRcdHRocm93IFwiVW5rbm93biBDaGFyYWN0ZXIgJ1wiICsgc2VsZi5qc29uWyBzZWxmLmkgKyAxIF0gKyBcIicgZm9sbG93aW5nIGUgbm90YXRpb24sIGV4cGVjdGluZyBhIG51bWVyaWMgdmFsdWUuXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIE5vcm1hbCBEaWdpdFxuXHRcdFx0ZWxzZSBpZiAoIHJudW1iZXIuZXhlYyggc2VsZi5jICkgKSB7XG5cdFx0XHRcdGlmICggZGVjaW1hbCA9PT0gbnVsbCApIHtcblx0XHRcdFx0XHRkZWNpbWFsID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gQXNzdW1lIGVuZCBvZiBudW1iZXIsIGFuZCBhbGxvdyBlbmR2YWwgdG8gaGFuZGxlIGl0XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Ly8gSnVtcCBiYWNrIGEgY2hhcmFjdGVyIHRvIGluY2x1ZGUgdGhlIGN1cnJlbnQgb25lXG5cdFx0XHRcdHNlbGYuaS0tO1xuXHRcdFx0XHRzZWxmLmNoYXJhY3Rlci0tO1xuXHRcdFx0XHRyZXR1cm4gc2VsZi5lbmR2YWwoKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gRW5kaW5nIGEgdmFsdWUgc3RhdGVtZW50XG5cdGVuZHZhbDogZnVuY3Rpb24oKXtcblx0XHR2YXIgc2VsZiA9IHRoaXMsIHBlZWsgPSAnJztcblx0XHRzZWxmLmNvbW1hYnJlYWsgPSBmYWxzZTtcblxuXHRcdGZvciAoIDsgKytzZWxmLmkgPCBzZWxmLmxlbmd0aDsgKSB7XG5cdFx0XHRzZWxmLmMgPSBzZWxmLmpzb25bIHNlbGYuaSBdO1xuXHRcdFx0c2VsZi5jaGFyYWN0ZXIrKztcblxuXHRcdFx0aWYgKCBzZWxmLm9wdGlvbnMuY29tbWVudHMgJiYgc2VsZi5jID09ICcvJyApIHtcblx0XHRcdFx0cGVlayA9IHNlbGYuanNvblsgc2VsZi5pICsgMSBdO1xuXHRcdFx0XHRpZiAoIHBlZWsgPT0gJyonICkge1xuXHRcdFx0XHRcdHNlbGYubXVsdGljb21tZW50KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoIHBlZWsgPT0gJy8nICkge1xuXHRcdFx0XHRcdHNlbGYuY29tbWVudCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IFwiVW5rbm93biBjaGFyYWN0ZXIgJy8nLCBtYXliZSBhIGNvbW1lbnQ/XCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBybmV3bGluZS5leGVjKCBzZWxmLmMgKSApIHtcblx0XHRcdFx0c2VsZi5saW5lKys7XG5cdFx0XHRcdHNlbGYuY2hhcmFjdGVyID0gMDtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCByd2hpdGVzcGFjZS5leGVjKCBzZWxmLmMgKSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggc2VsZi5jID09ICcsJyApIHtcblx0XHRcdFx0c2VsZi5jb21tYWJyZWFrID0gdHJ1ZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggc2VsZi5jID09IHNlbGYuZW5kYmxvY2sgKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHRocm93IFwiVW5rbm93biBDaGFyYWN0ZXIgJ1wiICsgc2VsZi5jICsgXCInLCBleHBlY3RpbmcgYSBjb21tYSBvciBhIGNsb3NpbmcgJ1wiICsgc2VsZi5lbmRibG9jayArIFwiJ1wiO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBFeHBvc2UgbGluZSBvZiB0aGUgZXJyb3Jcblx0c2V0RXZpZGVuY2U6IGZ1bmN0aW9uKCl7XG5cdFx0dmFyIHNlbGYgPSB0aGlzLCBzdGFydCA9IHNlbGYubGluZSAtIDUsIGVuZCA9IHN0YXJ0ICsgOCwgZXZpZGVuY2UgPSAnJztcblxuXHRcdC8vIE1pbiBzdGFydFxuXHRcdGlmICggc3RhcnQgPCAwICkge1xuXHRcdFx0c3RhcnQgPSAwO1xuXHRcdFx0ZW5kID0gODtcblx0XHR9XG5cblx0XHQvLyBNYXggZW5kXG5cdFx0aWYgKCBlbmQgPj0gc2VsZi5fZXZpZGVuY2UubGVuZ3RoICkge1xuXHRcdFx0ZW5kID0gc2VsZi5fZXZpZGVuY2UubGVuZ3RoO1xuXHRcdH1cblxuXHRcdC8vIEV2aWRlbmNlIGRpc3BsYXlcblx0XHRmb3IgKCA7IHN0YXJ0IDwgZW5kOyBzdGFydCsrICkge1xuXHRcdFx0ZXZpZGVuY2UgKz0gKCBzdGFydCA9PT0gKCBzZWxmLmxpbmUgLSAxICkgPyBcIi0+IFwiIDogXCIgICBcIiApICtcblx0XHRcdFx0KCBzdGFydCArIDEgKSArICd8ICcgK1xuXHRcdFx0XHRzZWxmLl9ldmlkZW5jZVsgc3RhcnQgXSArIFwiXFxuXCI7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBldmlkZW5jZSBkaXNwbGF5XG5cdFx0c2VsZi5ldmlkZW5jZSA9IGV2aWRlbmNlO1xuXHR9XG59O1xuXG5cbi8vIENoZWNrIGZvciBub2RlanMgbW9kdWxlIHN5c3RlbVxuaWYgKCB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICkge1xuXHRtb2R1bGUuZXhwb3J0cyA9IEpTT05MaW50O1xufVxuLy8gSW4gYSBicm93c2VyXG5lbHNlIHtcblx0Z2xvYi5KU09OTGludCA9IEpTT05MaW50O1xufVxuXG59KSggdGhpcyApO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBtb2RpZmllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbVxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIGlzQXJncyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKTtcbnZhciBpc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIGhhc0RvbnRFbnVtQnVnID0gIWlzRW51bWVyYWJsZS5jYWxsKHsgdG9TdHJpbmc6IG51bGwgfSwgJ3RvU3RyaW5nJyk7XG52YXIgaGFzUHJvdG9FbnVtQnVnID0gaXNFbnVtZXJhYmxlLmNhbGwoZnVuY3Rpb24gKCkge30sICdwcm90b3R5cGUnKTtcbnZhciBkb250RW51bXMgPSBbXG5cdCd0b1N0cmluZycsXG5cdCd0b0xvY2FsZVN0cmluZycsXG5cdCd2YWx1ZU9mJyxcblx0J2hhc093blByb3BlcnR5Jyxcblx0J2lzUHJvdG90eXBlT2YnLFxuXHQncHJvcGVydHlJc0VudW1lcmFibGUnLFxuXHQnY29uc3RydWN0b3InXG5dO1xudmFyIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlID0gZnVuY3Rpb24gKG8pIHtcblx0dmFyIGN0b3IgPSBvLmNvbnN0cnVjdG9yO1xuXHRyZXR1cm4gY3RvciAmJiBjdG9yLnByb3RvdHlwZSA9PT0gbztcbn07XG52YXIgZXhjbHVkZWRLZXlzID0ge1xuXHQkY29uc29sZTogdHJ1ZSxcblx0JGV4dGVybmFsOiB0cnVlLFxuXHQkZnJhbWU6IHRydWUsXG5cdCRmcmFtZUVsZW1lbnQ6IHRydWUsXG5cdCRmcmFtZXM6IHRydWUsXG5cdCRpbm5lckhlaWdodDogdHJ1ZSxcblx0JGlubmVyV2lkdGg6IHRydWUsXG5cdCRvdXRlckhlaWdodDogdHJ1ZSxcblx0JG91dGVyV2lkdGg6IHRydWUsXG5cdCRwYWdlWE9mZnNldDogdHJ1ZSxcblx0JHBhZ2VZT2Zmc2V0OiB0cnVlLFxuXHQkcGFyZW50OiB0cnVlLFxuXHQkc2Nyb2xsTGVmdDogdHJ1ZSxcblx0JHNjcm9sbFRvcDogdHJ1ZSxcblx0JHNjcm9sbFg6IHRydWUsXG5cdCRzY3JvbGxZOiB0cnVlLFxuXHQkc2VsZjogdHJ1ZSxcblx0JHdlYmtpdEluZGV4ZWREQjogdHJ1ZSxcblx0JHdlYmtpdFN0b3JhZ2VJbmZvOiB0cnVlLFxuXHQkd2luZG93OiB0cnVlXG59O1xudmFyIGhhc0F1dG9tYXRpb25FcXVhbGl0eUJ1ZyA9IChmdW5jdGlvbiAoKSB7XG5cdC8qIGdsb2JhbCB3aW5kb3cgKi9cblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRmb3IgKHZhciBrIGluIHdpbmRvdykge1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAoIWV4Y2x1ZGVkS2V5c1snJCcgKyBrXSAmJiBoYXMuY2FsbCh3aW5kb3csIGspICYmIHdpbmRvd1trXSAhPT0gbnVsbCAmJiB0eXBlb2Ygd2luZG93W2tdID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlKHdpbmRvd1trXSk7XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZmFsc2U7XG59KCkpO1xudmFyIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlSWZOb3RCdWdneSA9IGZ1bmN0aW9uIChvKSB7XG5cdC8qIGdsb2JhbCB3aW5kb3cgKi9cblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNBdXRvbWF0aW9uRXF1YWxpdHlCdWcpIHtcblx0XHRyZXR1cm4gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUobyk7XG5cdH1cblx0dHJ5IHtcblx0XHRyZXR1cm4gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUobyk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG5cbnZhciBrZXlzU2hpbSA9IGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG5cdHZhciBpc09iamVjdCA9IG9iamVjdCAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0Jztcblx0dmFyIGlzRnVuY3Rpb24gPSB0b1N0ci5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cdHZhciBpc0FyZ3VtZW50cyA9IGlzQXJncyhvYmplY3QpO1xuXHR2YXIgaXNTdHJpbmcgPSBpc09iamVjdCAmJiB0b1N0ci5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xuXHR2YXIgdGhlS2V5cyA9IFtdO1xuXG5cdGlmICghaXNPYmplY3QgJiYgIWlzRnVuY3Rpb24gJiYgIWlzQXJndW1lbnRzKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmtleXMgY2FsbGVkIG9uIGEgbm9uLW9iamVjdCcpO1xuXHR9XG5cblx0dmFyIHNraXBQcm90byA9IGhhc1Byb3RvRW51bUJ1ZyAmJiBpc0Z1bmN0aW9uO1xuXHRpZiAoaXNTdHJpbmcgJiYgb2JqZWN0Lmxlbmd0aCA+IDAgJiYgIWhhcy5jYWxsKG9iamVjdCwgMCkpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5sZW5ndGg7ICsraSkge1xuXHRcdFx0dGhlS2V5cy5wdXNoKFN0cmluZyhpKSk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKGlzQXJndW1lbnRzICYmIG9iamVjdC5sZW5ndGggPiAwKSB7XG5cdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBvYmplY3QubGVuZ3RoOyArK2opIHtcblx0XHRcdHRoZUtleXMucHVzaChTdHJpbmcoaikpO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRmb3IgKHZhciBuYW1lIGluIG9iamVjdCkge1xuXHRcdFx0aWYgKCEoc2tpcFByb3RvICYmIG5hbWUgPT09ICdwcm90b3R5cGUnKSAmJiBoYXMuY2FsbChvYmplY3QsIG5hbWUpKSB7XG5cdFx0XHRcdHRoZUtleXMucHVzaChTdHJpbmcobmFtZSkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmIChoYXNEb250RW51bUJ1Zykge1xuXHRcdHZhciBza2lwQ29uc3RydWN0b3IgPSBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZUlmTm90QnVnZ3kob2JqZWN0KTtcblxuXHRcdGZvciAodmFyIGsgPSAwOyBrIDwgZG9udEVudW1zLmxlbmd0aDsgKytrKSB7XG5cdFx0XHRpZiAoIShza2lwQ29uc3RydWN0b3IgJiYgZG9udEVudW1zW2tdID09PSAnY29uc3RydWN0b3InKSAmJiBoYXMuY2FsbChvYmplY3QsIGRvbnRFbnVtc1trXSkpIHtcblx0XHRcdFx0dGhlS2V5cy5wdXNoKGRvbnRFbnVtc1trXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiB0aGVLZXlzO1xufTtcblxua2V5c1NoaW0uc2hpbSA9IGZ1bmN0aW9uIHNoaW1PYmplY3RLZXlzKCkge1xuXHRpZiAoT2JqZWN0LmtleXMpIHtcblx0XHR2YXIga2V5c1dvcmtzV2l0aEFyZ3VtZW50cyA9IChmdW5jdGlvbiAoKSB7XG5cdFx0XHQvLyBTYWZhcmkgNS4wIGJ1Z1xuXHRcdFx0cmV0dXJuIChPYmplY3Qua2V5cyhhcmd1bWVudHMpIHx8ICcnKS5sZW5ndGggPT09IDI7XG5cdFx0fSgxLCAyKSk7XG5cdFx0aWYgKCFrZXlzV29ya3NXaXRoQXJndW1lbnRzKSB7XG5cdFx0XHR2YXIgb3JpZ2luYWxLZXlzID0gT2JqZWN0LmtleXM7XG5cdFx0XHRPYmplY3Qua2V5cyA9IGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG5cdFx0XHRcdGlmIChpc0FyZ3Mob2JqZWN0KSkge1xuXHRcdFx0XHRcdHJldHVybiBvcmlnaW5hbEtleXMoc2xpY2UuY2FsbChvYmplY3QpKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gb3JpZ2luYWxLZXlzKG9iamVjdCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdE9iamVjdC5rZXlzID0ga2V5c1NoaW07XG5cdH1cblx0cmV0dXJuIE9iamVjdC5rZXlzIHx8IGtleXNTaGltO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzU2hpbTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuXHR2YXIgc3RyID0gdG9TdHIuY2FsbCh2YWx1ZSk7XG5cdHZhciBpc0FyZ3MgPSBzdHIgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXHRpZiAoIWlzQXJncykge1xuXHRcdGlzQXJncyA9IHN0ciAhPT0gJ1tvYmplY3QgQXJyYXldJyAmJlxuXHRcdFx0dmFsdWUgIT09IG51bGwgJiZcblx0XHRcdHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcblx0XHRcdHR5cGVvZiB2YWx1ZS5sZW5ndGggPT09ICdudW1iZXInICYmXG5cdFx0XHR2YWx1ZS5sZW5ndGggPj0gMCAmJlxuXHRcdFx0dG9TdHIuY2FsbCh2YWx1ZS5jYWxsZWUpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXHR9XG5cdHJldHVybiBpc0FyZ3M7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAoIXByb2Nlc3MudmVyc2lvbiB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MC4nKSA9PT0gMCB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS4nKSA9PT0gMCAmJiBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuOC4nKSAhPT0gMCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IG5leHRUaWNrO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBwcm9jZXNzLm5leHRUaWNrO1xufVxuXG5mdW5jdGlvbiBuZXh0VGljayhmbiwgYXJnMSwgYXJnMiwgYXJnMykge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJjYWxsYmFja1wiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG4gIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgYXJncywgaTtcbiAgc3dpdGNoIChsZW4pIHtcbiAgY2FzZSAwOlxuICBjYXNlIDE6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZm4pO1xuICBjYXNlIDI6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrT25lKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxKTtcbiAgICB9KTtcbiAgY2FzZSAzOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1R3bygpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMik7XG4gICAgfSk7XG4gIGNhc2UgNDpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUaHJlZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgfSk7XG4gIGRlZmF1bHQ6XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICBhcmdzW2krK10gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGljaygpIHtcbiAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0pO1xuICB9XG59XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICB9IGNhdGNoIChlKSB7XG4gICAgY2FjaGVkU2V0VGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBpcyBub3QgZGVmaW5lZCcpO1xuICAgIH1cbiAgfVxuICB0cnkge1xuICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGlzIG5vdCBkZWZpbmVkJyk7XG4gICAgfVxuICB9XG59ICgpKVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gY2FjaGVkU2V0VGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgY2FjaGVkQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIi8qISBodHRwczovL210aHMuYmUvcHVueWNvZGUgdjEuNC4xIGJ5IEBtYXRoaWFzICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGVzICovXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiZcblx0XHQhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0IW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdGlmIChcblx0XHRmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC5zZWxmID09PSBmcmVlR2xvYmFsXG5cdCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBgcHVueWNvZGVgIG9iamVjdC5cblx0ICogQG5hbWUgcHVueWNvZGVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL1xuXHR2YXIgcHVueWNvZGUsXG5cblx0LyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuXHRtYXhJbnQgPSAyMTQ3NDgzNjQ3LCAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXG5cblx0LyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuXHRiYXNlID0gMzYsXG5cdHRNaW4gPSAxLFxuXHR0TWF4ID0gMjYsXG5cdHNrZXcgPSAzOCxcblx0ZGFtcCA9IDcwMCxcblx0aW5pdGlhbEJpYXMgPSA3Mixcblx0aW5pdGlhbE4gPSAxMjgsIC8vIDB4ODBcblx0ZGVsaW1pdGVyID0gJy0nLCAvLyAnXFx4MkQnXG5cblx0LyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cblx0cmVnZXhQdW55Y29kZSA9IC9eeG4tLS8sXG5cdHJlZ2V4Tm9uQVNDSUkgPSAvW15cXHgyMC1cXHg3RV0vLCAvLyB1bnByaW50YWJsZSBBU0NJSSBjaGFycyArIG5vbi1BU0NJSSBjaGFyc1xuXHRyZWdleFNlcGFyYXRvcnMgPSAvW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nLCAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXG5cblx0LyoqIEVycm9yIG1lc3NhZ2VzICovXG5cdGVycm9ycyA9IHtcblx0XHQnb3ZlcmZsb3cnOiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxuXHRcdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdFx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcblx0fSxcblxuXHQvKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5cdGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbixcblx0Zmxvb3IgPSBNYXRoLmZsb29yLFxuXHRzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLFxuXG5cdC8qKiBUZW1wb3JhcnkgdmFyaWFibGUgKi9cblx0a2V5O1xuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG5cdCAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cblx0ICovXG5cdGZ1bmN0aW9uIGVycm9yKHR5cGUpIHtcblx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcblx0ICogaXRlbS5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdFx0cmVzdWx0W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcblx0ICogYWRkcmVzc2VzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcblx0ICogY2hhcmFjdGVyLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuXHQgKiBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdFx0dmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJyk7XG5cdFx0dmFyIHJlc3VsdCA9ICcnO1xuXHRcdGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG5cdFx0XHQvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXG5cdFx0XHQvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LlxuXHRcdFx0cmVzdWx0ID0gcGFydHNbMF0gKyAnQCc7XG5cdFx0XHRzdHJpbmcgPSBwYXJ0c1sxXTtcblx0XHR9XG5cdFx0Ly8gQXZvaWQgYHNwbGl0KHJlZ2V4KWAgZm9yIElFOCBjb21wYXRpYmlsaXR5LiBTZWUgIzE3LlxuXHRcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XG5cdFx0dmFyIGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuXHRcdHZhciBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcblx0XHRyZXR1cm4gcmVzdWx0ICsgZW5jb2RlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG5cdCAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcblx0ICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcblx0ICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG5cdCAqIG1hdGNoaW5nIFVURi0xNi5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG5cdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBkZWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS5cblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGNvdW50ZXIgPSAwLFxuXHRcdCAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuXHRcdCAgICB2YWx1ZSxcblx0XHQgICAgZXh0cmE7XG5cdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5kZWNvZGVgXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGVuY29kZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2RlUG9pbnRzIFRoZSBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0cmV0dXJuIG1hcChhcnJheSwgZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH0pLmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cblx0ICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcblx0ICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNpY1RvRGlnaXQoY29kZVBvaW50KSB7XG5cdFx0aWYgKGNvZGVQb2ludCAtIDQ4IDwgMTApIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSAyMjtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDY1IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA2NTtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDk3IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA5Nztcblx0XHR9XG5cdFx0cmV0dXJuIGJhc2U7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAc2VlIGBiYXNpY1RvRGlnaXQoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIGJhc2ljIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgKHdoZW4gdXNlZCBmb3Jcblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2Vcblx0ICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG5cdCAqIHVzZWQ7IGVsc2UsIHRoZSBsb3dlcmNhc2UgZm9ybSBpcyB1c2VkLiBUaGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkXG5cdCAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG5cdCAqL1xuXHRmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcblx0XHQvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuXHRcdC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuXHRcdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG5cdH1cblxuXHQvKipcblx0ICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cblx0ICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xuXHRcdHZhciBrID0gMDtcblx0XHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRcdGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcblx0XHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuXHQgKiBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcblx0XHQvLyBEb24ndCB1c2UgVUNTLTJcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuXHRcdCAgICBvdXQsXG5cdFx0ICAgIGkgPSAwLFxuXHRcdCAgICBuID0gaW5pdGlhbE4sXG5cdFx0ICAgIGJpYXMgPSBpbml0aWFsQmlhcyxcblx0XHQgICAgYmFzaWMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIGluZGV4LFxuXHRcdCAgICBvbGRpLFxuXHRcdCAgICB3LFxuXHRcdCAgICBrLFxuXHRcdCAgICBkaWdpdCxcblx0XHQgICAgdCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGJhc2VNaW51c1Q7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0XHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHRcdC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuXG5cdFx0YmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRcdGlmIChiYXNpYyA8IDApIHtcblx0XHRcdGJhc2ljID0gMDtcblx0XHR9XG5cblx0XHRmb3IgKGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAweDgwKSB7XG5cdFx0XHRcdGVycm9yKCdub3QtYmFzaWMnKTtcblx0XHRcdH1cblx0XHRcdG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0XHQvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLlxuXG5cdFx0Zm9yIChpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHtcblxuXHRcdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuXHRcdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG5cdFx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdFx0Zm9yIChvbGRpID0gaSwgdyA9IDEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXG5cdFx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cblx0XHRcdH1cblxuXHRcdFx0b3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0XHRiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuXHRcdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcblx0XHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0XHRpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdFx0aSAlPSBvdXQ7XG5cblx0XHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXRcblx0XHRcdG91dHB1dC5zcGxpY2UoaSsrLCAwLCBuKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKG91dHB1dCk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcblx0ICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG5cdFx0dmFyIG4sXG5cdFx0ICAgIGRlbHRhLFxuXHRcdCAgICBoYW5kbGVkQ1BDb3VudCxcblx0XHQgICAgYmFzaWNMZW5ndGgsXG5cdFx0ICAgIGJpYXMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIG0sXG5cdFx0ICAgIHEsXG5cdFx0ICAgIGssXG5cdFx0ICAgIHQsXG5cdFx0ICAgIGN1cnJlbnRWYWx1ZSxcblx0XHQgICAgb3V0cHV0ID0gW10sXG5cdFx0ICAgIC8qKiBgaW5wdXRMZW5ndGhgIHdpbGwgaG9sZCB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIGluIGBpbnB1dGAuICovXG5cdFx0ICAgIGlucHV0TGVuZ3RoLFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgaGFuZGxlZENQQ291bnRQbHVzT25lLFxuXHRcdCAgICBiYXNlTWludXNULFxuXHRcdCAgICBxTWludXNUO1xuXG5cdFx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZVxuXHRcdGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XG5cblx0XHQvLyBDYWNoZSB0aGUgbGVuZ3RoXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0XHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxuXHRcdG4gPSBpbml0aWFsTjtcblx0XHRkZWx0YSA9IDA7XG5cdFx0YmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xuXHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblxuXHRcdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHRcdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHRcdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIC0gaWYgaXQgaXMgbm90IGVtcHR5IC0gd2l0aCBhIGRlbGltaXRlclxuXHRcdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdFx0d2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHRcdGZvciAobSA9IG1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdFx0Ly8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3dcblx0XHRcdGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRcdGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdFx0biA9IG07XG5cblx0XHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyXG5cdFx0XHRcdFx0Zm9yIChxID0gZGVsdGEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXHRcdFx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cdFx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHRcdFx0c3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0KytkZWx0YTtcblx0XHRcdCsrbjtcblxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3Ncblx0ICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuXHQgKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cblx0ICogY29udmVydGVkIHRvIFVuaWNvZGUuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIGNvbnZlcnQgdG8gVW5pY29kZS5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG5cdCAqIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvVW5pY29kZShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsXG5cdCAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxuXHQgKiBBU0NJSS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXG5cdCAqIFVuaWNvZGUgc3RyaW5nLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yXG5cdCAqIGVtYWlsIGFkZHJlc3MuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cblx0cHVueWNvZGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqL1xuXHRcdCd2ZXJzaW9uJzogJzEuNC4xJyxcblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuXHRcdCAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG5cdFx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICovXG5cdFx0J3VjczInOiB7XG5cdFx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHRcdCdlbmNvZGUnOiB1Y3MyZW5jb2RlXG5cdFx0fSxcblx0XHQnZGVjb2RlJzogZGVjb2RlLFxuXHRcdCdlbmNvZGUnOiBlbmNvZGUsXG5cdFx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHRcdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcblx0fTtcblxuXHQvKiogRXhwb3NlIGBwdW55Y29kZWAgKi9cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoJ3B1bnljb2RlJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gcHVueWNvZGU7XG5cdFx0fSk7XG5cdH0gZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuXHRcdGlmIChtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cykge1xuXHRcdFx0Ly8gaW4gTm9kZS5qcywgaW8uanMsIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gcHVueWNvZGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHRmb3IgKGtleSBpbiBwdW55Y29kZSkge1xuXHRcdFx0XHRwdW55Y29kZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gcHVueWNvZGVba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LnB1bnljb2RlID0gcHVueWNvZGU7XG5cdH1cblxufSh0aGlzKSk7XG4iLCIvLyB2aW06dHM9NDpzdHM9NDpzdz00OlxuLyohXG4gKlxuICogQ29weXJpZ2h0IDIwMDktMjAxMiBLcmlzIEtvd2FsIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTUlUXG4gKiBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9naXRodWIuY29tL2tyaXNrb3dhbC9xL3Jhdy9tYXN0ZXIvTElDRU5TRVxuICpcbiAqIFdpdGggcGFydHMgYnkgVHlsZXIgQ2xvc2VcbiAqIENvcHlyaWdodCAyMDA3LTIwMDkgVHlsZXIgQ2xvc2UgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNSVQgWCBsaWNlbnNlIGZvdW5kXG4gKiBhdCBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLmh0bWxcbiAqIEZvcmtlZCBhdCByZWZfc2VuZC5qcyB2ZXJzaW9uOiAyMDA5LTA1LTExXG4gKlxuICogV2l0aCBwYXJ0cyBieSBNYXJrIE1pbGxlclxuICogQ29weXJpZ2h0IChDKSAyMDExIEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5cbihmdW5jdGlvbiAoZGVmaW5pdGlvbikge1xuICAgIC8vIFR1cm4gb2ZmIHN0cmljdCBtb2RlIGZvciB0aGlzIGZ1bmN0aW9uIHNvIHdlIGNhbiBhc3NpZ24gdG8gZ2xvYmFsLlFcbiAgICAvKiBqc2hpbnQgc3RyaWN0OiBmYWxzZSAqL1xuXG4gICAgLy8gVGhpcyBmaWxlIHdpbGwgZnVuY3Rpb24gcHJvcGVybHkgYXMgYSA8c2NyaXB0PiB0YWcsIG9yIGEgbW9kdWxlXG4gICAgLy8gdXNpbmcgQ29tbW9uSlMgYW5kIE5vZGVKUyBvciBSZXF1aXJlSlMgbW9kdWxlIGZvcm1hdHMuICBJblxuICAgIC8vIENvbW1vbi9Ob2RlL1JlcXVpcmVKUywgdGhlIG1vZHVsZSBleHBvcnRzIHRoZSBRIEFQSSBhbmQgd2hlblxuICAgIC8vIGV4ZWN1dGVkIGFzIGEgc2ltcGxlIDxzY3JpcHQ+LCBpdCBjcmVhdGVzIGEgUSBnbG9iYWwgaW5zdGVhZC5cblxuICAgIC8vIE1vbnRhZ2UgUmVxdWlyZVxuICAgIGlmICh0eXBlb2YgYm9vdHN0cmFwID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgYm9vdHN0cmFwKFwicHJvbWlzZVwiLCBkZWZpbml0aW9uKTtcblxuICAgIC8vIENvbW1vbkpTXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKTtcblxuICAgIC8vIFJlcXVpcmVKU1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKGRlZmluaXRpb24pO1xuXG4gICAgLy8gU0VTIChTZWN1cmUgRWNtYVNjcmlwdClcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZXMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKCFzZXMub2soKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VzLm1ha2VRID0gZGVmaW5pdGlvbjtcbiAgICAgICAgfVxuXG4gICAgLy8gPHNjcmlwdD5cbiAgICB9IGVsc2Uge1xuICAgICAgICBRID0gZGVmaW5pdGlvbigpO1xuICAgIH1cblxufSkoZnVuY3Rpb24gKCkge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBoYXNTdGFja3MgPSBmYWxzZTtcbnRyeSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCk7XG59IGNhdGNoIChlKSB7XG4gICAgaGFzU3RhY2tzID0gISFlLnN0YWNrO1xufVxuXG4vLyBBbGwgY29kZSBhZnRlciB0aGlzIHBvaW50IHdpbGwgYmUgZmlsdGVyZWQgZnJvbSBzdGFjayB0cmFjZXMgcmVwb3J0ZWRcbi8vIGJ5IFEuXG52YXIgcVN0YXJ0aW5nTGluZSA9IGNhcHR1cmVMaW5lKCk7XG52YXIgcUZpbGVOYW1lO1xuXG4vLyBzaGltc1xuXG4vLyB1c2VkIGZvciBmYWxsYmFjayBpbiBcImFsbFJlc29sdmVkXCJcbnZhciBub29wID0gZnVuY3Rpb24gKCkge307XG5cbi8vIFVzZSB0aGUgZmFzdGVzdCBwb3NzaWJsZSBtZWFucyB0byBleGVjdXRlIGEgdGFzayBpbiBhIGZ1dHVyZSB0dXJuXG4vLyBvZiB0aGUgZXZlbnQgbG9vcC5cbnZhciBuZXh0VGljayA9KGZ1bmN0aW9uICgpIHtcbiAgICAvLyBsaW5rZWQgbGlzdCBvZiB0YXNrcyAoc2luZ2xlLCB3aXRoIGhlYWQgbm9kZSlcbiAgICB2YXIgaGVhZCA9IHt0YXNrOiB2b2lkIDAsIG5leHQ6IG51bGx9O1xuICAgIHZhciB0YWlsID0gaGVhZDtcbiAgICB2YXIgZmx1c2hpbmcgPSBmYWxzZTtcbiAgICB2YXIgcmVxdWVzdFRpY2sgPSB2b2lkIDA7XG4gICAgdmFyIGlzTm9kZUpTID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAgICAgLyoganNoaW50IGxvb3BmdW5jOiB0cnVlICovXG5cbiAgICAgICAgd2hpbGUgKGhlYWQubmV4dCkge1xuICAgICAgICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICAgICAgICAgIHZhciB0YXNrID0gaGVhZC50YXNrO1xuICAgICAgICAgICAgaGVhZC50YXNrID0gdm9pZCAwO1xuICAgICAgICAgICAgdmFyIGRvbWFpbiA9IGhlYWQuZG9tYWluO1xuXG4gICAgICAgICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgaGVhZC5kb21haW4gPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgZG9tYWluLmVudGVyKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGFzaygpO1xuXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTm9kZUpTKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluIG5vZGUsIHVuY2F1Z2h0IGV4Y2VwdGlvbnMgYXJlIGNvbnNpZGVyZWQgZmF0YWwgZXJyb3JzLlxuICAgICAgICAgICAgICAgICAgICAvLyBSZS10aHJvdyB0aGVtIHN5bmNocm9ub3VzbHkgdG8gaW50ZXJydXB0IGZsdXNoaW5nIVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEVuc3VyZSBjb250aW51YXRpb24gaWYgdGhlIHVuY2F1Z2h0IGV4Y2VwdGlvbiBpcyBzdXBwcmVzc2VkXG4gICAgICAgICAgICAgICAgICAgIC8vIGxpc3RlbmluZyBcInVuY2F1Z2h0RXhjZXB0aW9uXCIgZXZlbnRzIChhcyBkb21haW5zIGRvZXMpLlxuICAgICAgICAgICAgICAgICAgICAvLyBDb250aW51ZSBpbiBuZXh0IGV2ZW50IHRvIGF2b2lkIHRpY2sgcmVjdXJzaW9uLlxuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb21haW4uZXhpdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZmx1c2gsIDApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb21haW4uZW50ZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbiBicm93c2VycywgdW5jYXVnaHQgZXhjZXB0aW9ucyBhcmUgbm90IGZhdGFsLlxuICAgICAgICAgICAgICAgICAgICAvLyBSZS10aHJvdyB0aGVtIGFzeW5jaHJvbm91c2x5IHRvIGF2b2lkIHNsb3ctZG93bnMuXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgICAgIGRvbWFpbi5leGl0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmbHVzaGluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIG5leHRUaWNrID0gZnVuY3Rpb24gKHRhc2spIHtcbiAgICAgICAgdGFpbCA9IHRhaWwubmV4dCA9IHtcbiAgICAgICAgICAgIHRhc2s6IHRhc2ssXG4gICAgICAgICAgICBkb21haW46IGlzTm9kZUpTICYmIHByb2Nlc3MuZG9tYWluLFxuICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICghZmx1c2hpbmcpIHtcbiAgICAgICAgICAgIGZsdXNoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlcXVlc3RUaWNrKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MubmV4dFRpY2spIHtcbiAgICAgICAgLy8gTm9kZS5qcyBiZWZvcmUgMC45LiBOb3RlIHRoYXQgc29tZSBmYWtlLU5vZGUgZW52aXJvbm1lbnRzLCBsaWtlIHRoZVxuICAgICAgICAvLyBNb2NoYSB0ZXN0IHJ1bm5lciwgaW50cm9kdWNlIGEgYHByb2Nlc3NgIGdsb2JhbCB3aXRob3V0IGEgYG5leHRUaWNrYC5cbiAgICAgICAgaXNOb2RlSlMgPSB0cnVlO1xuXG4gICAgICAgIHJlcXVlc3RUaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gICAgICAgIH07XG5cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAvLyBJbiBJRTEwLCBOb2RlLmpzIDAuOSssIG9yIGh0dHBzOi8vZ2l0aHViLmNvbS9Ob2JsZUpTL3NldEltbWVkaWF0ZVxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmVxdWVzdFRpY2sgPSBzZXRJbW1lZGlhdGUuYmluZCh3aW5kb3csIGZsdXNoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcXVlc3RUaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNldEltbWVkaWF0ZShmbHVzaCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAvLyBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgLy8gaHR0cDovL3d3dy5ub25ibG9ja2luZy5pby8yMDExLzA2L3dpbmRvd25leHR0aWNrLmh0bWxcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgLy8gQXQgbGVhc3QgU2FmYXJpIFZlcnNpb24gNi4wLjUgKDg1MzYuMzAuMSkgaW50ZXJtaXR0ZW50bHkgY2Fubm90IGNyZWF0ZVxuICAgICAgICAvLyB3b3JraW5nIG1lc3NhZ2UgcG9ydHMgdGhlIGZpcnN0IHRpbWUgYSBwYWdlIGxvYWRzLlxuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlcXVlc3RUaWNrID0gcmVxdWVzdFBvcnRUaWNrO1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmbHVzaDtcbiAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciByZXF1ZXN0UG9ydFRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBPcGVyYSByZXF1aXJlcyB1cyB0byBwcm92aWRlIGEgbWVzc2FnZSBwYXlsb2FkLCByZWdhcmRsZXNzIG9mXG4gICAgICAgICAgICAvLyB3aGV0aGVyIHdlIHVzZSBpdC5cbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG4gICAgICAgIH07XG4gICAgICAgIHJlcXVlc3RUaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2V0VGltZW91dChmbHVzaCwgMCk7XG4gICAgICAgICAgICByZXF1ZXN0UG9ydFRpY2soKTtcbiAgICAgICAgfTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG9sZCBicm93c2Vyc1xuICAgICAgICByZXF1ZXN0VGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZmx1c2gsIDApO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBuZXh0VGljaztcbn0pKCk7XG5cbi8vIEF0dGVtcHQgdG8gbWFrZSBnZW5lcmljcyBzYWZlIGluIHRoZSBmYWNlIG9mIGRvd25zdHJlYW1cbi8vIG1vZGlmaWNhdGlvbnMuXG4vLyBUaGVyZSBpcyBubyBzaXR1YXRpb24gd2hlcmUgdGhpcyBpcyBuZWNlc3NhcnkuXG4vLyBJZiB5b3UgbmVlZCBhIHNlY3VyaXR5IGd1YXJhbnRlZSwgdGhlc2UgcHJpbW9yZGlhbHMgbmVlZCB0byBiZVxuLy8gZGVlcGx5IGZyb3plbiBhbnl3YXksIGFuZCBpZiB5b3UgZG9u4oCZdCBuZWVkIGEgc2VjdXJpdHkgZ3VhcmFudGVlLFxuLy8gdGhpcyBpcyBqdXN0IHBsYWluIHBhcmFub2lkLlxuLy8gSG93ZXZlciwgdGhpcyBkb2VzIGhhdmUgdGhlIG5pY2Ugc2lkZS1lZmZlY3Qgb2YgcmVkdWNpbmcgdGhlIHNpemVcbi8vIG9mIHRoZSBjb2RlIGJ5IHJlZHVjaW5nIHguY2FsbCgpIHRvIG1lcmVseSB4KCksIGVsaW1pbmF0aW5nIG1hbnlcbi8vIGhhcmQtdG8tbWluaWZ5IGNoYXJhY3RlcnMuXG4vLyBTZWUgTWFyayBNaWxsZXLigJlzIGV4cGxhbmF0aW9uIG9mIHdoYXQgdGhpcyBkb2VzLlxuLy8gaHR0cDovL3dpa2kuZWNtYXNjcmlwdC5vcmcvZG9rdS5waHA/aWQ9Y29udmVudGlvbnM6c2FmZV9tZXRhX3Byb2dyYW1taW5nXG52YXIgY2FsbCA9IEZ1bmN0aW9uLmNhbGw7XG5mdW5jdGlvbiB1bmN1cnJ5VGhpcyhmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNhbGwuYXBwbHkoZiwgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuLy8gVGhpcyBpcyBlcXVpdmFsZW50LCBidXQgc2xvd2VyOlxuLy8gdW5jdXJyeVRoaXMgPSBGdW5jdGlvbl9iaW5kLmJpbmQoRnVuY3Rpb25fYmluZC5jYWxsKTtcbi8vIGh0dHA6Ly9qc3BlcmYuY29tL3VuY3Vycnl0aGlzXG5cbnZhciBhcnJheV9zbGljZSA9IHVuY3VycnlUaGlzKEFycmF5LnByb3RvdHlwZS5zbGljZSk7XG5cbnZhciBhcnJheV9yZWR1Y2UgPSB1bmN1cnJ5VGhpcyhcbiAgICBBcnJheS5wcm90b3R5cGUucmVkdWNlIHx8IGZ1bmN0aW9uIChjYWxsYmFjaywgYmFzaXMpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICAvLyBjb25jZXJuaW5nIHRoZSBpbml0aWFsIHZhbHVlLCBpZiBvbmUgaXMgbm90IHByb3ZpZGVkXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAvLyBzZWVrIHRvIHRoZSBmaXJzdCB2YWx1ZSBpbiB0aGUgYXJyYXksIGFjY291bnRpbmdcbiAgICAgICAgICAgIC8vIGZvciB0aGUgcG9zc2liaWxpdHkgdGhhdCBpcyBpcyBhIHNwYXJzZSBhcnJheVxuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCBpbiB0aGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2lzID0gdGhpc1tpbmRleCsrXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgrK2luZGV4ID49IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAoMSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVkdWNlXG4gICAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgLy8gYWNjb3VudCBmb3IgdGhlIHBvc3NpYmlsaXR5IHRoYXQgdGhlIGFycmF5IGlzIHNwYXJzZVxuICAgICAgICAgICAgaWYgKGluZGV4IGluIHRoaXMpIHtcbiAgICAgICAgICAgICAgICBiYXNpcyA9IGNhbGxiYWNrKGJhc2lzLCB0aGlzW2luZGV4XSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNpcztcbiAgICB9XG4pO1xuXG52YXIgYXJyYXlfaW5kZXhPZiA9IHVuY3VycnlUaGlzKFxuICAgIEFycmF5LnByb3RvdHlwZS5pbmRleE9mIHx8IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAvLyBub3QgYSB2ZXJ5IGdvb2Qgc2hpbSwgYnV0IGdvb2QgZW5vdWdoIGZvciBvdXIgb25lIHVzZSBvZiBpdFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzW2ldID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4pO1xuXG52YXIgYXJyYXlfbWFwID0gdW5jdXJyeVRoaXMoXG4gICAgQXJyYXkucHJvdG90eXBlLm1hcCB8fCBmdW5jdGlvbiAoY2FsbGJhY2ssIHRoaXNwKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGNvbGxlY3QgPSBbXTtcbiAgICAgICAgYXJyYXlfcmVkdWNlKHNlbGYsIGZ1bmN0aW9uICh1bmRlZmluZWQsIHZhbHVlLCBpbmRleCkge1xuICAgICAgICAgICAgY29sbGVjdC5wdXNoKGNhbGxiYWNrLmNhbGwodGhpc3AsIHZhbHVlLCBpbmRleCwgc2VsZikpO1xuICAgICAgICB9LCB2b2lkIDApO1xuICAgICAgICByZXR1cm4gY29sbGVjdDtcbiAgICB9XG4pO1xuXG52YXIgb2JqZWN0X2NyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gKHByb3RvdHlwZSkge1xuICAgIGZ1bmN0aW9uIFR5cGUoKSB7IH1cbiAgICBUeXBlLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgICByZXR1cm4gbmV3IFR5cGUoKTtcbn07XG5cbnZhciBvYmplY3RfaGFzT3duUHJvcGVydHkgPSB1bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcblxudmFyIG9iamVjdF9rZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgICBpZiAob2JqZWN0X2hhc093blByb3BlcnR5KG9iamVjdCwga2V5KSkge1xuICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtleXM7XG59O1xuXG52YXIgb2JqZWN0X3RvU3RyaW5nID0gdW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyk7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBPYmplY3QodmFsdWUpO1xufVxuXG4vLyBnZW5lcmF0b3IgcmVsYXRlZCBzaGltc1xuXG4vLyBGSVhNRTogUmVtb3ZlIHRoaXMgZnVuY3Rpb24gb25jZSBFUzYgZ2VuZXJhdG9ycyBhcmUgaW4gU3BpZGVyTW9ua2V5LlxuZnVuY3Rpb24gaXNTdG9wSXRlcmF0aW9uKGV4Y2VwdGlvbikge1xuICAgIHJldHVybiAoXG4gICAgICAgIG9iamVjdF90b1N0cmluZyhleGNlcHRpb24pID09PSBcIltvYmplY3QgU3RvcEl0ZXJhdGlvbl1cIiB8fFxuICAgICAgICBleGNlcHRpb24gaW5zdGFuY2VvZiBRUmV0dXJuVmFsdWVcbiAgICApO1xufVxuXG4vLyBGSVhNRTogUmVtb3ZlIHRoaXMgaGVscGVyIGFuZCBRLnJldHVybiBvbmNlIEVTNiBnZW5lcmF0b3JzIGFyZSBpblxuLy8gU3BpZGVyTW9ua2V5LlxudmFyIFFSZXR1cm5WYWx1ZTtcbmlmICh0eXBlb2YgUmV0dXJuVmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBRUmV0dXJuVmFsdWUgPSBSZXR1cm5WYWx1ZTtcbn0gZWxzZSB7XG4gICAgUVJldHVyblZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9O1xufVxuXG4vLyBVbnRpbCBWOCAzLjE5IC8gQ2hyb21pdW0gMjkgaXMgcmVsZWFzZWQsIFNwaWRlck1vbmtleSBpcyB0aGUgb25seVxuLy8gZW5naW5lIHRoYXQgaGFzIGEgZGVwbG95ZWQgYmFzZSBvZiBicm93c2VycyB0aGF0IHN1cHBvcnQgZ2VuZXJhdG9ycy5cbi8vIEhvd2V2ZXIsIFNNJ3MgZ2VuZXJhdG9ycyB1c2UgdGhlIFB5dGhvbi1pbnNwaXJlZCBzZW1hbnRpY3Mgb2Zcbi8vIG91dGRhdGVkIEVTNiBkcmFmdHMuICBXZSB3b3VsZCBsaWtlIHRvIHN1cHBvcnQgRVM2LCBidXQgd2UnZCBhbHNvXG4vLyBsaWtlIHRvIG1ha2UgaXQgcG9zc2libGUgdG8gdXNlIGdlbmVyYXRvcnMgaW4gZGVwbG95ZWQgYnJvd3NlcnMsIHNvXG4vLyB3ZSBhbHNvIHN1cHBvcnQgUHl0aG9uLXN0eWxlIGdlbmVyYXRvcnMuICBBdCBzb21lIHBvaW50IHdlIGNhbiByZW1vdmVcbi8vIHRoaXMgYmxvY2suXG52YXIgaGFzRVM2R2VuZXJhdG9ycztcbnRyeSB7XG4gICAgLyoganNoaW50IGV2aWw6IHRydWUsIG5vbmV3OiBmYWxzZSAqL1xuICAgIG5ldyBGdW5jdGlvbihcIihmdW5jdGlvbiogKCl7IHlpZWxkIDE7IH0pXCIpO1xuICAgIGhhc0VTNkdlbmVyYXRvcnMgPSB0cnVlO1xufSBjYXRjaCAoZSkge1xuICAgIGhhc0VTNkdlbmVyYXRvcnMgPSBmYWxzZTtcbn1cblxuLy8gbG9uZyBzdGFjayB0cmFjZXNcblxudmFyIFNUQUNLX0pVTVBfU0VQQVJBVE9SID0gXCJGcm9tIHByZXZpb3VzIGV2ZW50OlwiO1xuXG5mdW5jdGlvbiBtYWtlU3RhY2tUcmFjZUxvbmcoZXJyb3IsIHByb21pc2UpIHtcbiAgICAvLyBJZiBwb3NzaWJsZSwgdHJhbnNmb3JtIHRoZSBlcnJvciBzdGFjayB0cmFjZSBieSByZW1vdmluZyBOb2RlIGFuZCBRXG4gICAgLy8gY3J1ZnQsIHRoZW4gY29uY2F0ZW5hdGluZyB3aXRoIHRoZSBzdGFjayB0cmFjZSBvZiBgcHJvbWlzZWAuIFNlZSAjNTcuXG4gICAgaWYgKGhhc1N0YWNrcyAmJlxuICAgICAgICBwcm9taXNlLnN0YWNrICYmXG4gICAgICAgIHR5cGVvZiBlcnJvciA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICBlcnJvciAhPT0gbnVsbCAmJlxuICAgICAgICBlcnJvci5zdGFjayAmJlxuICAgICAgICBlcnJvci5zdGFjay5pbmRleE9mKFNUQUNLX0pVTVBfU0VQQVJBVE9SKSA9PT0gLTFcbiAgICApIHtcbiAgICAgICAgdmFyIHN0YWNrcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBwID0gcHJvbWlzZTsgISFwOyBwID0gcC5zb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChwLnN0YWNrKSB7XG4gICAgICAgICAgICAgICAgc3RhY2tzLnVuc2hpZnQocC5zdGFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2tzLnVuc2hpZnQoZXJyb3Iuc3RhY2spO1xuXG4gICAgICAgIHZhciBjb25jYXRlZFN0YWNrcyA9IHN0YWNrcy5qb2luKFwiXFxuXCIgKyBTVEFDS19KVU1QX1NFUEFSQVRPUiArIFwiXFxuXCIpO1xuICAgICAgICBlcnJvci5zdGFjayA9IGZpbHRlclN0YWNrU3RyaW5nKGNvbmNhdGVkU3RhY2tzKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZpbHRlclN0YWNrU3RyaW5nKHN0YWNrU3RyaW5nKSB7XG4gICAgdmFyIGxpbmVzID0gc3RhY2tTdHJpbmcuc3BsaXQoXCJcXG5cIik7XG4gICAgdmFyIGRlc2lyZWRMaW5lcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGxpbmUgPSBsaW5lc1tpXTtcblxuICAgICAgICBpZiAoIWlzSW50ZXJuYWxGcmFtZShsaW5lKSAmJiAhaXNOb2RlRnJhbWUobGluZSkgJiYgbGluZSkge1xuICAgICAgICAgICAgZGVzaXJlZExpbmVzLnB1c2gobGluZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlc2lyZWRMaW5lcy5qb2luKFwiXFxuXCIpO1xufVxuXG5mdW5jdGlvbiBpc05vZGVGcmFtZShzdGFja0xpbmUpIHtcbiAgICByZXR1cm4gc3RhY2tMaW5lLmluZGV4T2YoXCIobW9kdWxlLmpzOlwiKSAhPT0gLTEgfHxcbiAgICAgICAgICAgc3RhY2tMaW5lLmluZGV4T2YoXCIobm9kZS5qczpcIikgIT09IC0xO1xufVxuXG5mdW5jdGlvbiBnZXRGaWxlTmFtZUFuZExpbmVOdW1iZXIoc3RhY2tMaW5lKSB7XG4gICAgLy8gTmFtZWQgZnVuY3Rpb25zOiBcImF0IGZ1bmN0aW9uTmFtZSAoZmlsZW5hbWU6bGluZU51bWJlcjpjb2x1bW5OdW1iZXIpXCJcbiAgICAvLyBJbiBJRTEwIGZ1bmN0aW9uIG5hbWUgY2FuIGhhdmUgc3BhY2VzIChcIkFub255bW91cyBmdW5jdGlvblwiKSBPX29cbiAgICB2YXIgYXR0ZW1wdDEgPSAvYXQgLisgXFwoKC4rKTooXFxkKyk6KD86XFxkKylcXCkkLy5leGVjKHN0YWNrTGluZSk7XG4gICAgaWYgKGF0dGVtcHQxKSB7XG4gICAgICAgIHJldHVybiBbYXR0ZW1wdDFbMV0sIE51bWJlcihhdHRlbXB0MVsyXSldO1xuICAgIH1cblxuICAgIC8vIEFub255bW91cyBmdW5jdGlvbnM6IFwiYXQgZmlsZW5hbWU6bGluZU51bWJlcjpjb2x1bW5OdW1iZXJcIlxuICAgIHZhciBhdHRlbXB0MiA9IC9hdCAoW14gXSspOihcXGQrKTooPzpcXGQrKSQvLmV4ZWMoc3RhY2tMaW5lKTtcbiAgICBpZiAoYXR0ZW1wdDIpIHtcbiAgICAgICAgcmV0dXJuIFthdHRlbXB0MlsxXSwgTnVtYmVyKGF0dGVtcHQyWzJdKV07XG4gICAgfVxuXG4gICAgLy8gRmlyZWZveCBzdHlsZTogXCJmdW5jdGlvbkBmaWxlbmFtZTpsaW5lTnVtYmVyIG9yIEBmaWxlbmFtZTpsaW5lTnVtYmVyXCJcbiAgICB2YXIgYXR0ZW1wdDMgPSAvLipAKC4rKTooXFxkKykkLy5leGVjKHN0YWNrTGluZSk7XG4gICAgaWYgKGF0dGVtcHQzKSB7XG4gICAgICAgIHJldHVybiBbYXR0ZW1wdDNbMV0sIE51bWJlcihhdHRlbXB0M1syXSldO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNJbnRlcm5hbEZyYW1lKHN0YWNrTGluZSkge1xuICAgIHZhciBmaWxlTmFtZUFuZExpbmVOdW1iZXIgPSBnZXRGaWxlTmFtZUFuZExpbmVOdW1iZXIoc3RhY2tMaW5lKTtcblxuICAgIGlmICghZmlsZU5hbWVBbmRMaW5lTnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgZmlsZU5hbWUgPSBmaWxlTmFtZUFuZExpbmVOdW1iZXJbMF07XG4gICAgdmFyIGxpbmVOdW1iZXIgPSBmaWxlTmFtZUFuZExpbmVOdW1iZXJbMV07XG5cbiAgICByZXR1cm4gZmlsZU5hbWUgPT09IHFGaWxlTmFtZSAmJlxuICAgICAgICBsaW5lTnVtYmVyID49IHFTdGFydGluZ0xpbmUgJiZcbiAgICAgICAgbGluZU51bWJlciA8PSBxRW5kaW5nTGluZTtcbn1cblxuLy8gZGlzY292ZXIgb3duIGZpbGUgbmFtZSBhbmQgbGluZSBudW1iZXIgcmFuZ2UgZm9yIGZpbHRlcmluZyBzdGFja1xuLy8gdHJhY2VzXG5mdW5jdGlvbiBjYXB0dXJlTGluZSgpIHtcbiAgICBpZiAoIWhhc1N0YWNrcykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB2YXIgbGluZXMgPSBlLnN0YWNrLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICB2YXIgZmlyc3RMaW5lID0gbGluZXNbMF0uaW5kZXhPZihcIkBcIikgPiAwID8gbGluZXNbMV0gOiBsaW5lc1syXTtcbiAgICAgICAgdmFyIGZpbGVOYW1lQW5kTGluZU51bWJlciA9IGdldEZpbGVOYW1lQW5kTGluZU51bWJlcihmaXJzdExpbmUpO1xuICAgICAgICBpZiAoIWZpbGVOYW1lQW5kTGluZU51bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcUZpbGVOYW1lID0gZmlsZU5hbWVBbmRMaW5lTnVtYmVyWzBdO1xuICAgICAgICByZXR1cm4gZmlsZU5hbWVBbmRMaW5lTnVtYmVyWzFdO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZGVwcmVjYXRlKGNhbGxiYWNrLCBuYW1lLCBhbHRlcm5hdGl2ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUud2FybiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4obmFtZSArIFwiIGlzIGRlcHJlY2F0ZWQsIHVzZSBcIiArIGFsdGVybmF0aXZlICtcbiAgICAgICAgICAgICAgICAgICAgICAgICBcIiBpbnN0ZWFkLlwiLCBuZXcgRXJyb3IoXCJcIikuc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseShjYWxsYmFjaywgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuXG4vLyBlbmQgb2Ygc2hpbXNcbi8vIGJlZ2lubmluZyBvZiByZWFsIHdvcmtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgcHJvbWlzZSBmb3IgYW4gaW1tZWRpYXRlIHJlZmVyZW5jZSwgcGFzc2VzIHByb21pc2VzIHRocm91Z2gsIG9yXG4gKiBjb2VyY2VzIHByb21pc2VzIGZyb20gZGlmZmVyZW50IHN5c3RlbXMuXG4gKiBAcGFyYW0gdmFsdWUgaW1tZWRpYXRlIHJlZmVyZW5jZSBvciBwcm9taXNlXG4gKi9cbmZ1bmN0aW9uIFEodmFsdWUpIHtcbiAgICAvLyBJZiB0aGUgb2JqZWN0IGlzIGFscmVhZHkgYSBQcm9taXNlLCByZXR1cm4gaXQgZGlyZWN0bHkuICBUaGlzIGVuYWJsZXNcbiAgICAvLyB0aGUgcmVzb2x2ZSBmdW5jdGlvbiB0byBib3RoIGJlIHVzZWQgdG8gY3JlYXRlZCByZWZlcmVuY2VzIGZyb20gb2JqZWN0cyxcbiAgICAvLyBidXQgdG8gdG9sZXJhYmx5IGNvZXJjZSBub24tcHJvbWlzZXMgdG8gcHJvbWlzZXMuXG4gICAgaWYgKGlzUHJvbWlzZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8vIGFzc2ltaWxhdGUgdGhlbmFibGVzXG4gICAgaWYgKGlzUHJvbWlzZUFsaWtlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gY29lcmNlKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZnVsZmlsbCh2YWx1ZSk7XG4gICAgfVxufVxuUS5yZXNvbHZlID0gUTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIHRhc2sgaW4gYSBmdXR1cmUgdHVybiBvZiB0aGUgZXZlbnQgbG9vcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRhc2tcbiAqL1xuUS5uZXh0VGljayA9IG5leHRUaWNrO1xuXG4vKipcbiAqIENvbnRyb2xzIHdoZXRoZXIgb3Igbm90IGxvbmcgc3RhY2sgdHJhY2VzIHdpbGwgYmUgb25cbiAqL1xuUS5sb25nU3RhY2tTdXBwb3J0ID0gZmFsc2U7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIHtwcm9taXNlLCByZXNvbHZlLCByZWplY3R9IG9iamVjdC5cbiAqXG4gKiBgcmVzb2x2ZWAgaXMgYSBjYWxsYmFjayB0byBpbnZva2Ugd2l0aCBhIG1vcmUgcmVzb2x2ZWQgdmFsdWUgZm9yIHRoZVxuICogcHJvbWlzZS4gVG8gZnVsZmlsbCB0aGUgcHJvbWlzZSwgaW52b2tlIGByZXNvbHZlYCB3aXRoIGFueSB2YWx1ZSB0aGF0IGlzXG4gKiBub3QgYSB0aGVuYWJsZS4gVG8gcmVqZWN0IHRoZSBwcm9taXNlLCBpbnZva2UgYHJlc29sdmVgIHdpdGggYSByZWplY3RlZFxuICogdGhlbmFibGUsIG9yIGludm9rZSBgcmVqZWN0YCB3aXRoIHRoZSByZWFzb24gZGlyZWN0bHkuIFRvIHJlc29sdmUgdGhlXG4gKiBwcm9taXNlIHRvIGFub3RoZXIgdGhlbmFibGUsIHRodXMgcHV0dGluZyBpdCBpbiB0aGUgc2FtZSBzdGF0ZSwgaW52b2tlXG4gKiBgcmVzb2x2ZWAgd2l0aCB0aGF0IG90aGVyIHRoZW5hYmxlLlxuICovXG5RLmRlZmVyID0gZGVmZXI7XG5mdW5jdGlvbiBkZWZlcigpIHtcbiAgICAvLyBpZiBcIm1lc3NhZ2VzXCIgaXMgYW4gXCJBcnJheVwiLCB0aGF0IGluZGljYXRlcyB0aGF0IHRoZSBwcm9taXNlIGhhcyBub3QgeWV0XG4gICAgLy8gYmVlbiByZXNvbHZlZC4gIElmIGl0IGlzIFwidW5kZWZpbmVkXCIsIGl0IGhhcyBiZWVuIHJlc29sdmVkLiAgRWFjaFxuICAgIC8vIGVsZW1lbnQgb2YgdGhlIG1lc3NhZ2VzIGFycmF5IGlzIGl0c2VsZiBhbiBhcnJheSBvZiBjb21wbGV0ZSBhcmd1bWVudHMgdG9cbiAgICAvLyBmb3J3YXJkIHRvIHRoZSByZXNvbHZlZCBwcm9taXNlLiAgV2UgY29lcmNlIHRoZSByZXNvbHV0aW9uIHZhbHVlIHRvIGFcbiAgICAvLyBwcm9taXNlIHVzaW5nIHRoZSBgcmVzb2x2ZWAgZnVuY3Rpb24gYmVjYXVzZSBpdCBoYW5kbGVzIGJvdGggZnVsbHlcbiAgICAvLyBub24tdGhlbmFibGUgdmFsdWVzIGFuZCBvdGhlciB0aGVuYWJsZXMgZ3JhY2VmdWxseS5cbiAgICB2YXIgbWVzc2FnZXMgPSBbXSwgcHJvZ3Jlc3NMaXN0ZW5lcnMgPSBbXSwgcmVzb2x2ZWRQcm9taXNlO1xuXG4gICAgdmFyIGRlZmVycmVkID0gb2JqZWN0X2NyZWF0ZShkZWZlci5wcm90b3R5cGUpO1xuICAgIHZhciBwcm9taXNlID0gb2JqZWN0X2NyZWF0ZShQcm9taXNlLnByb3RvdHlwZSk7XG5cbiAgICBwcm9taXNlLnByb21pc2VEaXNwYXRjaCA9IGZ1bmN0aW9uIChyZXNvbHZlLCBvcCwgb3BlcmFuZHMpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMpO1xuICAgICAgICBpZiAobWVzc2FnZXMpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VzLnB1c2goYXJncyk7XG4gICAgICAgICAgICBpZiAob3AgPT09IFwid2hlblwiICYmIG9wZXJhbmRzWzFdKSB7IC8vIHByb2dyZXNzIG9wZXJhbmRcbiAgICAgICAgICAgICAgICBwcm9ncmVzc0xpc3RlbmVycy5wdXNoKG9wZXJhbmRzWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlZFByb21pc2UucHJvbWlzZURpc3BhdGNoLmFwcGx5KHJlc29sdmVkUHJvbWlzZSwgYXJncyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBYWFggZGVwcmVjYXRlZFxuICAgIHByb21pc2UudmFsdWVPZiA9IGRlcHJlY2F0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChtZXNzYWdlcykge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5lYXJlclZhbHVlID0gbmVhcmVyKHJlc29sdmVkUHJvbWlzZSk7XG4gICAgICAgIGlmIChpc1Byb21pc2UobmVhcmVyVmFsdWUpKSB7XG4gICAgICAgICAgICByZXNvbHZlZFByb21pc2UgPSBuZWFyZXJWYWx1ZTsgLy8gc2hvcnRlbiBjaGFpblxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZWFyZXJWYWx1ZTtcbiAgICB9LCBcInZhbHVlT2ZcIiwgXCJpbnNwZWN0XCIpO1xuXG4gICAgcHJvbWlzZS5pbnNwZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXJlc29sdmVkUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdGU6IFwicGVuZGluZ1wiIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmVkUHJvbWlzZS5pbnNwZWN0KCk7XG4gICAgfTtcblxuICAgIGlmIChRLmxvbmdTdGFja1N1cHBvcnQgJiYgaGFzU3RhY2tzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gTk9URTogZG9uJ3QgdHJ5IHRvIHVzZSBgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2VgIG9yIHRyYW5zZmVyIHRoZVxuICAgICAgICAgICAgLy8gYWNjZXNzb3IgYXJvdW5kOyB0aGF0IGNhdXNlcyBtZW1vcnkgbGVha3MgYXMgcGVyIEdILTExMS4gSnVzdFxuICAgICAgICAgICAgLy8gcmVpZnkgdGhlIHN0YWNrIHRyYWNlIGFzIGEgc3RyaW5nIEFTQVAuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gQXQgdGhlIHNhbWUgdGltZSwgY3V0IG9mZiB0aGUgZmlyc3QgbGluZTsgaXQncyBhbHdheXMganVzdFxuICAgICAgICAgICAgLy8gXCJbb2JqZWN0IFByb21pc2VdXFxuXCIsIGFzIHBlciB0aGUgYHRvU3RyaW5nYC5cbiAgICAgICAgICAgIHByb21pc2Uuc3RhY2sgPSBlLnN0YWNrLnN1YnN0cmluZyhlLnN0YWNrLmluZGV4T2YoXCJcXG5cIikgKyAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5PVEU6IHdlIGRvIHRoZSBjaGVja3MgZm9yIGByZXNvbHZlZFByb21pc2VgIGluIGVhY2ggbWV0aG9kLCBpbnN0ZWFkIG9mXG4gICAgLy8gY29uc29saWRhdGluZyB0aGVtIGludG8gYGJlY29tZWAsIHNpbmNlIG90aGVyd2lzZSB3ZSdkIGNyZWF0ZSBuZXdcbiAgICAvLyBwcm9taXNlcyB3aXRoIHRoZSBsaW5lcyBgYmVjb21lKHdoYXRldmVyKHZhbHVlKSlgLiBTZWUgZS5nLiBHSC0yNTIuXG5cbiAgICBmdW5jdGlvbiBiZWNvbWUobmV3UHJvbWlzZSkge1xuICAgICAgICByZXNvbHZlZFByb21pc2UgPSBuZXdQcm9taXNlO1xuICAgICAgICBwcm9taXNlLnNvdXJjZSA9IG5ld1Byb21pc2U7XG5cbiAgICAgICAgYXJyYXlfcmVkdWNlKG1lc3NhZ2VzLCBmdW5jdGlvbiAodW5kZWZpbmVkLCBtZXNzYWdlKSB7XG4gICAgICAgICAgICBuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbmV3UHJvbWlzZS5wcm9taXNlRGlzcGF0Y2guYXBwbHkobmV3UHJvbWlzZSwgbWVzc2FnZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgdm9pZCAwKTtcblxuICAgICAgICBtZXNzYWdlcyA9IHZvaWQgMDtcbiAgICAgICAgcHJvZ3Jlc3NMaXN0ZW5lcnMgPSB2b2lkIDA7XG4gICAgfVxuXG4gICAgZGVmZXJyZWQucHJvbWlzZSA9IHByb21pc2U7XG4gICAgZGVmZXJyZWQucmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAocmVzb2x2ZWRQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBiZWNvbWUoUSh2YWx1ZSkpO1xuICAgIH07XG5cbiAgICBkZWZlcnJlZC5mdWxmaWxsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmIChyZXNvbHZlZFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJlY29tZShmdWxmaWxsKHZhbHVlKSk7XG4gICAgfTtcbiAgICBkZWZlcnJlZC5yZWplY3QgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIGlmIChyZXNvbHZlZFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJlY29tZShyZWplY3QocmVhc29uKSk7XG4gICAgfTtcbiAgICBkZWZlcnJlZC5ub3RpZnkgPSBmdW5jdGlvbiAocHJvZ3Jlc3MpIHtcbiAgICAgICAgaWYgKHJlc29sdmVkUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYXJyYXlfcmVkdWNlKHByb2dyZXNzTGlzdGVuZXJzLCBmdW5jdGlvbiAodW5kZWZpbmVkLCBwcm9ncmVzc0xpc3RlbmVyKSB7XG4gICAgICAgICAgICBuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3NMaXN0ZW5lcihwcm9ncmVzcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgdm9pZCAwKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRlZmVycmVkO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBOb2RlLXN0eWxlIGNhbGxiYWNrIHRoYXQgd2lsbCByZXNvbHZlIG9yIHJlamVjdCB0aGUgZGVmZXJyZWRcbiAqIHByb21pc2UuXG4gKiBAcmV0dXJucyBhIG5vZGViYWNrXG4gKi9cbmRlZmVyLnByb3RvdHlwZS5tYWtlTm9kZVJlc29sdmVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gZnVuY3Rpb24gKGVycm9yLCB2YWx1ZSkge1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHNlbGYucmVqZWN0KGVycm9yKTtcbiAgICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgc2VsZi5yZXNvbHZlKGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5yZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG4vKipcbiAqIEBwYXJhbSByZXNvbHZlciB7RnVuY3Rpb259IGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIG5vdGhpbmcgYW5kIGFjY2VwdHNcbiAqIHRoZSByZXNvbHZlLCByZWplY3QsIGFuZCBub3RpZnkgZnVuY3Rpb25zIGZvciBhIGRlZmVycmVkLlxuICogQHJldHVybnMgYSBwcm9taXNlIHRoYXQgbWF5IGJlIHJlc29sdmVkIHdpdGggdGhlIGdpdmVuIHJlc29sdmUgYW5kIHJlamVjdFxuICogZnVuY3Rpb25zLCBvciByZWplY3RlZCBieSBhIHRocm93biBleGNlcHRpb24gaW4gcmVzb2x2ZXJcbiAqL1xuUS5wcm9taXNlID0gcHJvbWlzZTtcbmZ1bmN0aW9uIHByb21pc2UocmVzb2x2ZXIpIHtcbiAgICBpZiAodHlwZW9mIHJlc29sdmVyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInJlc29sdmVyIG11c3QgYmUgYSBmdW5jdGlvbi5cIik7XG4gICAgfVxuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgdHJ5IHtcbiAgICAgICAgcmVzb2x2ZXIoZGVmZXJyZWQucmVzb2x2ZSwgZGVmZXJyZWQucmVqZWN0LCBkZWZlcnJlZC5ub3RpZnkpO1xuICAgIH0gY2F0Y2ggKHJlYXNvbikge1xuICAgICAgICBkZWZlcnJlZC5yZWplY3QocmVhc29uKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59XG5cbi8vIFhYWCBleHBlcmltZW50YWwuICBUaGlzIG1ldGhvZCBpcyBhIHdheSB0byBkZW5vdGUgdGhhdCBhIGxvY2FsIHZhbHVlIGlzXG4vLyBzZXJpYWxpemFibGUgYW5kIHNob3VsZCBiZSBpbW1lZGlhdGVseSBkaXNwYXRjaGVkIHRvIGEgcmVtb3RlIHVwb24gcmVxdWVzdCxcbi8vIGluc3RlYWQgb2YgcGFzc2luZyBhIHJlZmVyZW5jZS5cblEucGFzc0J5Q29weSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAvL2ZyZWV6ZShvYmplY3QpO1xuICAgIC8vcGFzc0J5Q29waWVzLnNldChvYmplY3QsIHRydWUpO1xuICAgIHJldHVybiBvYmplY3Q7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5wYXNzQnlDb3B5ID0gZnVuY3Rpb24gKCkge1xuICAgIC8vZnJlZXplKG9iamVjdCk7XG4gICAgLy9wYXNzQnlDb3BpZXMuc2V0KG9iamVjdCwgdHJ1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIElmIHR3byBwcm9taXNlcyBldmVudHVhbGx5IGZ1bGZpbGwgdG8gdGhlIHNhbWUgdmFsdWUsIHByb21pc2VzIHRoYXQgdmFsdWUsXG4gKiBidXQgb3RoZXJ3aXNlIHJlamVjdHMuXG4gKiBAcGFyYW0geCB7QW55Kn1cbiAqIEBwYXJhbSB5IHtBbnkqfVxuICogQHJldHVybnMge0FueSp9IGEgcHJvbWlzZSBmb3IgeCBhbmQgeSBpZiB0aGV5IGFyZSB0aGUgc2FtZSwgYnV0IGEgcmVqZWN0aW9uXG4gKiBvdGhlcndpc2UuXG4gKlxuICovXG5RLmpvaW4gPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHJldHVybiBRKHgpLmpvaW4oeSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gKHRoYXQpIHtcbiAgICByZXR1cm4gUShbdGhpcywgdGhhdF0pLnNwcmVhZChmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICBpZiAoeCA9PT0geSkge1xuICAgICAgICAgICAgLy8gVE9ETzogXCI9PT1cIiBzaG91bGQgYmUgT2JqZWN0LmlzIG9yIGVxdWl2XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGpvaW46IG5vdCB0aGUgc2FtZTogXCIgKyB4ICsgXCIgXCIgKyB5KTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIGZpcnN0IG9mIGFuIGFycmF5IG9mIHByb21pc2VzIHRvIGJlY29tZSBmdWxmaWxsZWQuXG4gKiBAcGFyYW0gYW5zd2VycyB7QXJyYXlbQW55Kl19IHByb21pc2VzIHRvIHJhY2VcbiAqIEByZXR1cm5zIHtBbnkqfSB0aGUgZmlyc3QgcHJvbWlzZSB0byBiZSBmdWxmaWxsZWRcbiAqL1xuUS5yYWNlID0gcmFjZTtcbmZ1bmN0aW9uIHJhY2UoYW5zd2VyUHMpIHtcbiAgICByZXR1cm4gcHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgLy8gU3dpdGNoIHRvIHRoaXMgb25jZSB3ZSBjYW4gYXNzdW1lIGF0IGxlYXN0IEVTNVxuICAgICAgICAvLyBhbnN3ZXJQcy5mb3JFYWNoKGZ1bmN0aW9uKGFuc3dlclApIHtcbiAgICAgICAgLy8gICAgIFEoYW5zd2VyUCkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAvLyB9KTtcbiAgICAgICAgLy8gVXNlIHRoaXMgaW4gdGhlIG1lYW50aW1lXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhbnN3ZXJQcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgUShhbnN3ZXJQc1tpXSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cblByb21pc2UucHJvdG90eXBlLnJhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihRLnJhY2UpO1xufTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgUHJvbWlzZSB3aXRoIGEgcHJvbWlzZSBkZXNjcmlwdG9yIG9iamVjdCBhbmQgb3B0aW9uYWwgZmFsbGJhY2tcbiAqIGZ1bmN0aW9uLiAgVGhlIGRlc2NyaXB0b3IgY29udGFpbnMgbWV0aG9kcyBsaWtlIHdoZW4ocmVqZWN0ZWQpLCBnZXQobmFtZSksXG4gKiBzZXQobmFtZSwgdmFsdWUpLCBwb3N0KG5hbWUsIGFyZ3MpLCBhbmQgZGVsZXRlKG5hbWUpLCB3aGljaCBhbGxcbiAqIHJldHVybiBlaXRoZXIgYSB2YWx1ZSwgYSBwcm9taXNlIGZvciBhIHZhbHVlLCBvciBhIHJlamVjdGlvbi4gIFRoZSBmYWxsYmFja1xuICogYWNjZXB0cyB0aGUgb3BlcmF0aW9uIG5hbWUsIGEgcmVzb2x2ZXIsIGFuZCBhbnkgZnVydGhlciBhcmd1bWVudHMgdGhhdCB3b3VsZFxuICogaGF2ZSBiZWVuIGZvcndhcmRlZCB0byB0aGUgYXBwcm9wcmlhdGUgbWV0aG9kIGFib3ZlIGhhZCBhIG1ldGhvZCBiZWVuXG4gKiBwcm92aWRlZCB3aXRoIHRoZSBwcm9wZXIgbmFtZS4gIFRoZSBBUEkgbWFrZXMgbm8gZ3VhcmFudGVlcyBhYm91dCB0aGUgbmF0dXJlXG4gKiBvZiB0aGUgcmV0dXJuZWQgb2JqZWN0LCBhcGFydCBmcm9tIHRoYXQgaXQgaXMgdXNhYmxlIHdoZXJlZXZlciBwcm9taXNlcyBhcmVcbiAqIGJvdWdodCBhbmQgc29sZC5cbiAqL1xuUS5tYWtlUHJvbWlzZSA9IFByb21pc2U7XG5mdW5jdGlvbiBQcm9taXNlKGRlc2NyaXB0b3IsIGZhbGxiYWNrLCBpbnNwZWN0KSB7XG4gICAgaWYgKGZhbGxiYWNrID09PSB2b2lkIDApIHtcbiAgICAgICAgZmFsbGJhY2sgPSBmdW5jdGlvbiAob3ApIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiUHJvbWlzZSBkb2VzIG5vdCBzdXBwb3J0IG9wZXJhdGlvbjogXCIgKyBvcFxuICAgICAgICAgICAgKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChpbnNwZWN0ID09PSB2b2lkIDApIHtcbiAgICAgICAgaW5zcGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7c3RhdGU6IFwidW5rbm93blwifTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgcHJvbWlzZSA9IG9iamVjdF9jcmVhdGUoUHJvbWlzZS5wcm90b3R5cGUpO1xuXG4gICAgcHJvbWlzZS5wcm9taXNlRGlzcGF0Y2ggPSBmdW5jdGlvbiAocmVzb2x2ZSwgb3AsIGFyZ3MpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yW29wXSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRlc2NyaXB0b3Jbb3BdLmFwcGx5KHByb21pc2UsIGFyZ3MpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmYWxsYmFjay5jYWxsKHByb21pc2UsIG9wLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZWplY3QoZXhjZXB0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHByb21pc2UuaW5zcGVjdCA9IGluc3BlY3Q7XG5cbiAgICAvLyBYWFggZGVwcmVjYXRlZCBgdmFsdWVPZmAgYW5kIGBleGNlcHRpb25gIHN1cHBvcnRcbiAgICBpZiAoaW5zcGVjdCkge1xuICAgICAgICB2YXIgaW5zcGVjdGVkID0gaW5zcGVjdCgpO1xuICAgICAgICBpZiAoaW5zcGVjdGVkLnN0YXRlID09PSBcInJlamVjdGVkXCIpIHtcbiAgICAgICAgICAgIHByb21pc2UuZXhjZXB0aW9uID0gaW5zcGVjdGVkLnJlYXNvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb21pc2UudmFsdWVPZiA9IGRlcHJlY2F0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaW5zcGVjdGVkID0gaW5zcGVjdCgpO1xuICAgICAgICAgICAgaWYgKGluc3BlY3RlZC5zdGF0ZSA9PT0gXCJwZW5kaW5nXCIgfHxcbiAgICAgICAgICAgICAgICBpbnNwZWN0ZWQuc3RhdGUgPT09IFwicmVqZWN0ZWRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGluc3BlY3RlZC52YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cblByb21pc2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgUHJvbWlzZV1cIjtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiAoZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3NlZCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIHZhciBkb25lID0gZmFsc2U7ICAgLy8gZW5zdXJlIHRoZSB1bnRydXN0ZWQgcHJvbWlzZSBtYWtlcyBhdCBtb3N0IGFcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpbmdsZSBjYWxsIHRvIG9uZSBvZiB0aGUgY2FsbGJhY2tzXG5cbiAgICBmdW5jdGlvbiBfZnVsZmlsbGVkKHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGZ1bGZpbGxlZCA9PT0gXCJmdW5jdGlvblwiID8gZnVsZmlsbGVkKHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QoZXhjZXB0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9yZWplY3RlZChleGNlcHRpb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZWplY3RlZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBtYWtlU3RhY2tUcmFjZUxvbmcoZXhjZXB0aW9uLCBzZWxmKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGVkKGV4Y2VwdGlvbik7XG4gICAgICAgICAgICB9IGNhdGNoIChuZXdFeGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ld0V4Y2VwdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlamVjdChleGNlcHRpb24pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9wcm9ncmVzc2VkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgcHJvZ3Jlc3NlZCA9PT0gXCJmdW5jdGlvblwiID8gcHJvZ3Jlc3NlZCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICB9XG5cbiAgICBuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYucHJvbWlzZURpc3BhdGNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcblxuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShfZnVsZmlsbGVkKHZhbHVlKSk7XG4gICAgICAgIH0sIFwid2hlblwiLCBbZnVuY3Rpb24gKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcblxuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShfcmVqZWN0ZWQoZXhjZXB0aW9uKSk7XG4gICAgICAgIH1dKTtcbiAgICB9KTtcblxuICAgIC8vIFByb2dyZXNzIHByb3BhZ2F0b3IgbmVlZCB0byBiZSBhdHRhY2hlZCBpbiB0aGUgY3VycmVudCB0aWNrLlxuICAgIHNlbGYucHJvbWlzZURpc3BhdGNoKHZvaWQgMCwgXCJ3aGVuXCIsIFt2b2lkIDAsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgbmV3VmFsdWU7XG4gICAgICAgIHZhciB0aHJldyA9IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBfcHJvZ3Jlc3NlZCh2YWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocmV3ID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChRLm9uZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBRLm9uZXJyb3IoZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRocmV3KSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5ub3RpZnkobmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVycyBhbiBvYnNlcnZlciBvbiBhIHByb21pc2UuXG4gKlxuICogR3VhcmFudGVlczpcbiAqXG4gKiAxLiB0aGF0IGZ1bGZpbGxlZCBhbmQgcmVqZWN0ZWQgd2lsbCBiZSBjYWxsZWQgb25seSBvbmNlLlxuICogMi4gdGhhdCBlaXRoZXIgdGhlIGZ1bGZpbGxlZCBjYWxsYmFjayBvciB0aGUgcmVqZWN0ZWQgY2FsbGJhY2sgd2lsbCBiZVxuICogICAgY2FsbGVkLCBidXQgbm90IGJvdGguXG4gKiAzLiB0aGF0IGZ1bGZpbGxlZCBhbmQgcmVqZWN0ZWQgd2lsbCBub3QgYmUgY2FsbGVkIGluIHRoaXMgdHVybi5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgICAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgdG8gb2JzZXJ2ZVxuICogQHBhcmFtIGZ1bGZpbGxlZCAgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdpdGggdGhlIGZ1bGZpbGxlZCB2YWx1ZVxuICogQHBhcmFtIHJlamVjdGVkICAgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdpdGggdGhlIHJlamVjdGlvbiBleGNlcHRpb25cbiAqIEBwYXJhbSBwcm9ncmVzc2VkIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBhbnkgcHJvZ3Jlc3Mgbm90aWZpY2F0aW9uc1xuICogQHJldHVybiBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlIGZyb20gdGhlIGludm9rZWQgY2FsbGJhY2tcbiAqL1xuUS53aGVuID0gd2hlbjtcbmZ1bmN0aW9uIHdoZW4odmFsdWUsIGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzZWQpIHtcbiAgICByZXR1cm4gUSh2YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkLCBwcm9ncmVzc2VkKTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUudGhlblJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbHVlOyB9KTtcbn07XG5cblEudGhlblJlc29sdmUgPSBmdW5jdGlvbiAocHJvbWlzZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gUShwcm9taXNlKS50aGVuUmVzb2x2ZSh2YWx1ZSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS50aGVuUmVqZWN0ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gKCkgeyB0aHJvdyByZWFzb247IH0pO1xufTtcblxuUS50aGVuUmVqZWN0ID0gZnVuY3Rpb24gKHByb21pc2UsIHJlYXNvbikge1xuICAgIHJldHVybiBRKHByb21pc2UpLnRoZW5SZWplY3QocmVhc29uKTtcbn07XG5cbi8qKlxuICogSWYgYW4gb2JqZWN0IGlzIG5vdCBhIHByb21pc2UsIGl0IGlzIGFzIFwibmVhclwiIGFzIHBvc3NpYmxlLlxuICogSWYgYSBwcm9taXNlIGlzIHJlamVjdGVkLCBpdCBpcyBhcyBcIm5lYXJcIiBhcyBwb3NzaWJsZSB0b28uXG4gKiBJZiBpdOKAmXMgYSBmdWxmaWxsZWQgcHJvbWlzZSwgdGhlIGZ1bGZpbGxtZW50IHZhbHVlIGlzIG5lYXJlci5cbiAqIElmIGl04oCZcyBhIGRlZmVycmVkIHByb21pc2UgYW5kIHRoZSBkZWZlcnJlZCBoYXMgYmVlbiByZXNvbHZlZCwgdGhlXG4gKiByZXNvbHV0aW9uIGlzIFwibmVhcmVyXCIuXG4gKiBAcGFyYW0gb2JqZWN0XG4gKiBAcmV0dXJucyBtb3N0IHJlc29sdmVkIChuZWFyZXN0KSBmb3JtIG9mIHRoZSBvYmplY3RcbiAqL1xuXG4vLyBYWFggc2hvdWxkIHdlIHJlLWRvIHRoaXM/XG5RLm5lYXJlciA9IG5lYXJlcjtcbmZ1bmN0aW9uIG5lYXJlcih2YWx1ZSkge1xuICAgIGlmIChpc1Byb21pc2UodmFsdWUpKSB7XG4gICAgICAgIHZhciBpbnNwZWN0ZWQgPSB2YWx1ZS5pbnNwZWN0KCk7XG4gICAgICAgIGlmIChpbnNwZWN0ZWQuc3RhdGUgPT09IFwiZnVsZmlsbGVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnNwZWN0ZWQudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIG9iamVjdCBpcyBhIHByb21pc2UuXG4gKiBPdGhlcndpc2UgaXQgaXMgYSBmdWxmaWxsZWQgdmFsdWUuXG4gKi9cblEuaXNQcm9taXNlID0gaXNQcm9taXNlO1xuZnVuY3Rpb24gaXNQcm9taXNlKG9iamVjdCkge1xuICAgIHJldHVybiBpc09iamVjdChvYmplY3QpICYmXG4gICAgICAgIHR5cGVvZiBvYmplY3QucHJvbWlzZURpc3BhdGNoID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgdHlwZW9mIG9iamVjdC5pbnNwZWN0ID09PSBcImZ1bmN0aW9uXCI7XG59XG5cblEuaXNQcm9taXNlQWxpa2UgPSBpc1Byb21pc2VBbGlrZTtcbmZ1bmN0aW9uIGlzUHJvbWlzZUFsaWtlKG9iamVjdCkge1xuICAgIHJldHVybiBpc09iamVjdChvYmplY3QpICYmIHR5cGVvZiBvYmplY3QudGhlbiA9PT0gXCJmdW5jdGlvblwiO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIG9iamVjdCBpcyBhIHBlbmRpbmcgcHJvbWlzZSwgbWVhbmluZyBub3RcbiAqIGZ1bGZpbGxlZCBvciByZWplY3RlZC5cbiAqL1xuUS5pc1BlbmRpbmcgPSBpc1BlbmRpbmc7XG5mdW5jdGlvbiBpc1BlbmRpbmcob2JqZWN0KSB7XG4gICAgcmV0dXJuIGlzUHJvbWlzZShvYmplY3QpICYmIG9iamVjdC5pbnNwZWN0KCkuc3RhdGUgPT09IFwicGVuZGluZ1wiO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5pc1BlbmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5zcGVjdCgpLnN0YXRlID09PSBcInBlbmRpbmdcIjtcbn07XG5cbi8qKlxuICogQHJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgdmFsdWUgb3IgZnVsZmlsbGVkXG4gKiBwcm9taXNlLlxuICovXG5RLmlzRnVsZmlsbGVkID0gaXNGdWxmaWxsZWQ7XG5mdW5jdGlvbiBpc0Z1bGZpbGxlZChvYmplY3QpIHtcbiAgICByZXR1cm4gIWlzUHJvbWlzZShvYmplY3QpIHx8IG9iamVjdC5pbnNwZWN0KCkuc3RhdGUgPT09IFwiZnVsZmlsbGVkXCI7XG59XG5cblByb21pc2UucHJvdG90eXBlLmlzRnVsZmlsbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmluc3BlY3QoKS5zdGF0ZSA9PT0gXCJmdWxmaWxsZWRcIjtcbn07XG5cbi8qKlxuICogQHJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgcmVqZWN0ZWQgcHJvbWlzZS5cbiAqL1xuUS5pc1JlamVjdGVkID0gaXNSZWplY3RlZDtcbmZ1bmN0aW9uIGlzUmVqZWN0ZWQob2JqZWN0KSB7XG4gICAgcmV0dXJuIGlzUHJvbWlzZShvYmplY3QpICYmIG9iamVjdC5pbnNwZWN0KCkuc3RhdGUgPT09IFwicmVqZWN0ZWRcIjtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuaXNSZWplY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnNwZWN0KCkuc3RhdGUgPT09IFwicmVqZWN0ZWRcIjtcbn07XG5cbi8vLy8gQkVHSU4gVU5IQU5ETEVEIFJFSkVDVElPTiBUUkFDS0lOR1xuXG4vLyBUaGlzIHByb21pc2UgbGlicmFyeSBjb25zdW1lcyBleGNlcHRpb25zIHRocm93biBpbiBoYW5kbGVycyBzbyB0aGV5IGNhbiBiZVxuLy8gaGFuZGxlZCBieSBhIHN1YnNlcXVlbnQgcHJvbWlzZS4gIFRoZSBleGNlcHRpb25zIGdldCBhZGRlZCB0byB0aGlzIGFycmF5IHdoZW5cbi8vIHRoZXkgYXJlIGNyZWF0ZWQsIGFuZCByZW1vdmVkIHdoZW4gdGhleSBhcmUgaGFuZGxlZC4gIE5vdGUgdGhhdCBpbiBFUzYgb3Jcbi8vIHNoaW1tZWQgZW52aXJvbm1lbnRzLCB0aGlzIHdvdWxkIG5hdHVyYWxseSBiZSBhIGBTZXRgLlxudmFyIHVuaGFuZGxlZFJlYXNvbnMgPSBbXTtcbnZhciB1bmhhbmRsZWRSZWplY3Rpb25zID0gW107XG52YXIgdW5oYW5kbGVkUmVhc29uc0Rpc3BsYXllZCA9IGZhbHNlO1xudmFyIHRyYWNrVW5oYW5kbGVkUmVqZWN0aW9ucyA9IHRydWU7XG5mdW5jdGlvbiBkaXNwbGF5VW5oYW5kbGVkUmVhc29ucygpIHtcbiAgICBpZiAoXG4gICAgICAgICF1bmhhbmRsZWRSZWFzb25zRGlzcGxheWVkICYmXG4gICAgICAgIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgIXdpbmRvdy5Ub3VjaCAmJlxuICAgICAgICB3aW5kb3cuY29uc29sZVxuICAgICkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJbUV0gVW5oYW5kbGVkIHJlamVjdGlvbiByZWFzb25zIChzaG91bGQgYmUgZW1wdHkpOlwiLFxuICAgICAgICAgICAgICAgICAgICAgdW5oYW5kbGVkUmVhc29ucyk7XG4gICAgfVxuXG4gICAgdW5oYW5kbGVkUmVhc29uc0Rpc3BsYXllZCA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIGxvZ1VuaGFuZGxlZFJlYXNvbnMoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1bmhhbmRsZWRSZWFzb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByZWFzb24gPSB1bmhhbmRsZWRSZWFzb25zW2ldO1xuICAgICAgICBjb25zb2xlLndhcm4oXCJVbmhhbmRsZWQgcmVqZWN0aW9uIHJlYXNvbjpcIiwgcmVhc29uKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlc2V0VW5oYW5kbGVkUmVqZWN0aW9ucygpIHtcbiAgICB1bmhhbmRsZWRSZWFzb25zLmxlbmd0aCA9IDA7XG4gICAgdW5oYW5kbGVkUmVqZWN0aW9ucy5sZW5ndGggPSAwO1xuICAgIHVuaGFuZGxlZFJlYXNvbnNEaXNwbGF5ZWQgPSBmYWxzZTtcblxuICAgIGlmICghdHJhY2tVbmhhbmRsZWRSZWplY3Rpb25zKSB7XG4gICAgICAgIHRyYWNrVW5oYW5kbGVkUmVqZWN0aW9ucyA9IHRydWU7XG5cbiAgICAgICAgLy8gU2hvdyB1bmhhbmRsZWQgcmVqZWN0aW9uIHJlYXNvbnMgaWYgTm9kZSBleGl0cyB3aXRob3V0IGhhbmRsaW5nIGFuXG4gICAgICAgIC8vIG91dHN0YW5kaW5nIHJlamVjdGlvbi4gIChOb3RlIHRoYXQgQnJvd3NlcmlmeSBwcmVzZW50bHkgcHJvZHVjZXMgYVxuICAgICAgICAvLyBgcHJvY2Vzc2AgZ2xvYmFsIHdpdGhvdXQgdGhlIGBFdmVudEVtaXR0ZXJgIGBvbmAgbWV0aG9kLilcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3Mub24pIHtcbiAgICAgICAgICAgIHByb2Nlc3Mub24oXCJleGl0XCIsIGxvZ1VuaGFuZGxlZFJlYXNvbnMpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiB0cmFja1JlamVjdGlvbihwcm9taXNlLCByZWFzb24pIHtcbiAgICBpZiAoIXRyYWNrVW5oYW5kbGVkUmVqZWN0aW9ucykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdW5oYW5kbGVkUmVqZWN0aW9ucy5wdXNoKHByb21pc2UpO1xuICAgIGlmIChyZWFzb24gJiYgdHlwZW9mIHJlYXNvbi5zdGFjayAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB1bmhhbmRsZWRSZWFzb25zLnB1c2gocmVhc29uLnN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB1bmhhbmRsZWRSZWFzb25zLnB1c2goXCIobm8gc3RhY2spIFwiICsgcmVhc29uKTtcbiAgICB9XG4gICAgZGlzcGxheVVuaGFuZGxlZFJlYXNvbnMoKTtcbn1cblxuZnVuY3Rpb24gdW50cmFja1JlamVjdGlvbihwcm9taXNlKSB7XG4gICAgaWYgKCF0cmFja1VuaGFuZGxlZFJlamVjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBhdCA9IGFycmF5X2luZGV4T2YodW5oYW5kbGVkUmVqZWN0aW9ucywgcHJvbWlzZSk7XG4gICAgaWYgKGF0ICE9PSAtMSkge1xuICAgICAgICB1bmhhbmRsZWRSZWplY3Rpb25zLnNwbGljZShhdCwgMSk7XG4gICAgICAgIHVuaGFuZGxlZFJlYXNvbnMuc3BsaWNlKGF0LCAxKTtcbiAgICB9XG59XG5cblEucmVzZXRVbmhhbmRsZWRSZWplY3Rpb25zID0gcmVzZXRVbmhhbmRsZWRSZWplY3Rpb25zO1xuXG5RLmdldFVuaGFuZGxlZFJlYXNvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gTWFrZSBhIGNvcHkgc28gdGhhdCBjb25zdW1lcnMgY2FuJ3QgaW50ZXJmZXJlIHdpdGggb3VyIGludGVybmFsIHN0YXRlLlxuICAgIHJldHVybiB1bmhhbmRsZWRSZWFzb25zLnNsaWNlKCk7XG59O1xuXG5RLnN0b3BVbmhhbmRsZWRSZWplY3Rpb25UcmFja2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXNldFVuaGFuZGxlZFJlamVjdGlvbnMoKTtcbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2Vzcy5vbikge1xuICAgICAgICBwcm9jZXNzLnJlbW92ZUxpc3RlbmVyKFwiZXhpdFwiLCBsb2dVbmhhbmRsZWRSZWFzb25zKTtcbiAgICB9XG4gICAgdHJhY2tVbmhhbmRsZWRSZWplY3Rpb25zID0gZmFsc2U7XG59O1xuXG5yZXNldFVuaGFuZGxlZFJlamVjdGlvbnMoKTtcblxuLy8vLyBFTkQgVU5IQU5ETEVEIFJFSkVDVElPTiBUUkFDS0lOR1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSByZWplY3RlZCBwcm9taXNlLlxuICogQHBhcmFtIHJlYXNvbiB2YWx1ZSBkZXNjcmliaW5nIHRoZSBmYWlsdXJlXG4gKi9cblEucmVqZWN0ID0gcmVqZWN0O1xuZnVuY3Rpb24gcmVqZWN0KHJlYXNvbikge1xuICAgIHZhciByZWplY3Rpb24gPSBQcm9taXNlKHtcbiAgICAgICAgXCJ3aGVuXCI6IGZ1bmN0aW9uIChyZWplY3RlZCkge1xuICAgICAgICAgICAgLy8gbm90ZSB0aGF0IHRoZSBlcnJvciBoYXMgYmVlbiBoYW5kbGVkXG4gICAgICAgICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB1bnRyYWNrUmVqZWN0aW9uKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlamVjdGVkID8gcmVqZWN0ZWQocmVhc29uKSA6IHRoaXM7XG4gICAgICAgIH1cbiAgICB9LCBmdW5jdGlvbiBmYWxsYmFjaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSwgZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RhdGU6IFwicmVqZWN0ZWRcIiwgcmVhc29uOiByZWFzb24gfTtcbiAgICB9KTtcblxuICAgIC8vIE5vdGUgdGhhdCB0aGUgcmVhc29uIGhhcyBub3QgYmVlbiBoYW5kbGVkLlxuICAgIHRyYWNrUmVqZWN0aW9uKHJlamVjdGlvbiwgcmVhc29uKTtcblxuICAgIHJldHVybiByZWplY3Rpb247XG59XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIGZ1bGZpbGxlZCBwcm9taXNlIGZvciBhbiBpbW1lZGlhdGUgcmVmZXJlbmNlLlxuICogQHBhcmFtIHZhbHVlIGltbWVkaWF0ZSByZWZlcmVuY2VcbiAqL1xuUS5mdWxmaWxsID0gZnVsZmlsbDtcbmZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHtcbiAgICByZXR1cm4gUHJvbWlzZSh7XG4gICAgICAgIFwid2hlblwiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIFwiZ2V0XCI6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVbbmFtZV07XG4gICAgICAgIH0sXG4gICAgICAgIFwic2V0XCI6IGZ1bmN0aW9uIChuYW1lLCByaHMpIHtcbiAgICAgICAgICAgIHZhbHVlW25hbWVdID0gcmhzO1xuICAgICAgICB9LFxuICAgICAgICBcImRlbGV0ZVwiOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgZGVsZXRlIHZhbHVlW25hbWVdO1xuICAgICAgICB9LFxuICAgICAgICBcInBvc3RcIjogZnVuY3Rpb24gKG5hbWUsIGFyZ3MpIHtcbiAgICAgICAgICAgIC8vIE1hcmsgTWlsbGVyIHByb3Bvc2VzIHRoYXQgcG9zdCB3aXRoIG5vIG5hbWUgc2hvdWxkIGFwcGx5IGFcbiAgICAgICAgICAgIC8vIHByb21pc2VkIGZ1bmN0aW9uLlxuICAgICAgICAgICAgaWYgKG5hbWUgPT09IG51bGwgfHwgbmFtZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmFwcGx5KHZvaWQgMCwgYXJncyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVtuYW1lXS5hcHBseSh2YWx1ZSwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiYXBwbHlcIjogZnVuY3Rpb24gKHRoaXNwLCBhcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuYXBwbHkodGhpc3AsIGFyZ3MpO1xuICAgICAgICB9LFxuICAgICAgICBcImtleXNcIjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdF9rZXlzKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0sIHZvaWQgMCwgZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RhdGU6IFwiZnVsZmlsbGVkXCIsIHZhbHVlOiB2YWx1ZSB9O1xuICAgIH0pO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHRoZW5hYmxlcyB0byBRIHByb21pc2VzLlxuICogQHBhcmFtIHByb21pc2UgdGhlbmFibGUgcHJvbWlzZVxuICogQHJldHVybnMgYSBRIHByb21pc2VcbiAqL1xuZnVuY3Rpb24gY29lcmNlKHByb21pc2UpIHtcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHByb21pc2UudGhlbihkZWZlcnJlZC5yZXNvbHZlLCBkZWZlcnJlZC5yZWplY3QsIGRlZmVycmVkLm5vdGlmeSk7XG4gICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGV4Y2VwdGlvbik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn1cblxuLyoqXG4gKiBBbm5vdGF0ZXMgYW4gb2JqZWN0IHN1Y2ggdGhhdCBpdCB3aWxsIG5ldmVyIGJlXG4gKiB0cmFuc2ZlcnJlZCBhd2F5IGZyb20gdGhpcyBwcm9jZXNzIG92ZXIgYW55IHByb21pc2VcbiAqIGNvbW11bmljYXRpb24gY2hhbm5lbC5cbiAqIEBwYXJhbSBvYmplY3RcbiAqIEByZXR1cm5zIHByb21pc2UgYSB3cmFwcGluZyBvZiB0aGF0IG9iamVjdCB0aGF0XG4gKiBhZGRpdGlvbmFsbHkgcmVzcG9uZHMgdG8gdGhlIFwiaXNEZWZcIiBtZXNzYWdlXG4gKiB3aXRob3V0IGEgcmVqZWN0aW9uLlxuICovXG5RLm1hc3RlciA9IG1hc3RlcjtcbmZ1bmN0aW9uIG1hc3RlcihvYmplY3QpIHtcbiAgICByZXR1cm4gUHJvbWlzZSh7XG4gICAgICAgIFwiaXNEZWZcIjogZnVuY3Rpb24gKCkge31cbiAgICB9LCBmdW5jdGlvbiBmYWxsYmFjayhvcCwgYXJncykge1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2gob2JqZWN0LCBvcCwgYXJncyk7XG4gICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gUShvYmplY3QpLmluc3BlY3QoKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBTcHJlYWRzIHRoZSB2YWx1ZXMgb2YgYSBwcm9taXNlZCBhcnJheSBvZiBhcmd1bWVudHMgaW50byB0aGVcbiAqIGZ1bGZpbGxtZW50IGNhbGxiYWNrLlxuICogQHBhcmFtIGZ1bGZpbGxlZCBjYWxsYmFjayB0aGF0IHJlY2VpdmVzIHZhcmlhZGljIGFyZ3VtZW50cyBmcm9tIHRoZVxuICogcHJvbWlzZWQgYXJyYXlcbiAqIEBwYXJhbSByZWplY3RlZCBjYWxsYmFjayB0aGF0IHJlY2VpdmVzIHRoZSBleGNlcHRpb24gaWYgdGhlIHByb21pc2VcbiAqIGlzIHJlamVjdGVkLlxuICogQHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlIG9yIHRocm93biBleGNlcHRpb24gb2ZcbiAqIGVpdGhlciBjYWxsYmFjay5cbiAqL1xuUS5zcHJlYWQgPSBzcHJlYWQ7XG5mdW5jdGlvbiBzcHJlYWQodmFsdWUsIGZ1bGZpbGxlZCwgcmVqZWN0ZWQpIHtcbiAgICByZXR1cm4gUSh2YWx1ZSkuc3ByZWFkKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5zcHJlYWQgPSBmdW5jdGlvbiAoZnVsZmlsbGVkLCByZWplY3RlZCkge1xuICAgIHJldHVybiB0aGlzLmFsbCgpLnRoZW4oZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgICAgIHJldHVybiBmdWxmaWxsZWQuYXBwbHkodm9pZCAwLCBhcnJheSk7XG4gICAgfSwgcmVqZWN0ZWQpO1xufTtcblxuLyoqXG4gKiBUaGUgYXN5bmMgZnVuY3Rpb24gaXMgYSBkZWNvcmF0b3IgZm9yIGdlbmVyYXRvciBmdW5jdGlvbnMsIHR1cm5pbmdcbiAqIHRoZW0gaW50byBhc3luY2hyb25vdXMgZ2VuZXJhdG9ycy4gIEFsdGhvdWdoIGdlbmVyYXRvcnMgYXJlIG9ubHkgcGFydFxuICogb2YgdGhlIG5ld2VzdCBFQ01BU2NyaXB0IDYgZHJhZnRzLCB0aGlzIGNvZGUgZG9lcyBub3QgY2F1c2Ugc3ludGF4XG4gKiBlcnJvcnMgaW4gb2xkZXIgZW5naW5lcy4gIFRoaXMgY29kZSBzaG91bGQgY29udGludWUgdG8gd29yayBhbmQgd2lsbFxuICogaW4gZmFjdCBpbXByb3ZlIG92ZXIgdGltZSBhcyB0aGUgbGFuZ3VhZ2UgaW1wcm92ZXMuXG4gKlxuICogRVM2IGdlbmVyYXRvcnMgYXJlIGN1cnJlbnRseSBwYXJ0IG9mIFY4IHZlcnNpb24gMy4xOSB3aXRoIHRoZVxuICogLS1oYXJtb255LWdlbmVyYXRvcnMgcnVudGltZSBmbGFnIGVuYWJsZWQuICBTcGlkZXJNb25rZXkgaGFzIGhhZCB0aGVtXG4gKiBmb3IgbG9uZ2VyLCBidXQgdW5kZXIgYW4gb2xkZXIgUHl0aG9uLWluc3BpcmVkIGZvcm0uICBUaGlzIGZ1bmN0aW9uXG4gKiB3b3JrcyBvbiBib3RoIGtpbmRzIG9mIGdlbmVyYXRvcnMuXG4gKlxuICogRGVjb3JhdGVzIGEgZ2VuZXJhdG9yIGZ1bmN0aW9uIHN1Y2ggdGhhdDpcbiAqICAtIGl0IG1heSB5aWVsZCBwcm9taXNlc1xuICogIC0gZXhlY3V0aW9uIHdpbGwgY29udGludWUgd2hlbiB0aGF0IHByb21pc2UgaXMgZnVsZmlsbGVkXG4gKiAgLSB0aGUgdmFsdWUgb2YgdGhlIHlpZWxkIGV4cHJlc3Npb24gd2lsbCBiZSB0aGUgZnVsZmlsbGVkIHZhbHVlXG4gKiAgLSBpdCByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZSAod2hlbiB0aGUgZ2VuZXJhdG9yXG4gKiAgICBzdG9wcyBpdGVyYXRpbmcpXG4gKiAgLSB0aGUgZGVjb3JhdGVkIGZ1bmN0aW9uIHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlXG4gKiAgICBvZiB0aGUgZ2VuZXJhdG9yIG9yIHRoZSBmaXJzdCByZWplY3RlZCBwcm9taXNlIGFtb25nIHRob3NlXG4gKiAgICB5aWVsZGVkLlxuICogIC0gaWYgYW4gZXJyb3IgaXMgdGhyb3duIGluIHRoZSBnZW5lcmF0b3IsIGl0IHByb3BhZ2F0ZXMgdGhyb3VnaFxuICogICAgZXZlcnkgZm9sbG93aW5nIHlpZWxkIHVudGlsIGl0IGlzIGNhdWdodCwgb3IgdW50aWwgaXQgZXNjYXBlc1xuICogICAgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiBhbHRvZ2V0aGVyLCBhbmQgaXMgdHJhbnNsYXRlZCBpbnRvIGFcbiAqICAgIHJlamVjdGlvbiBmb3IgdGhlIHByb21pc2UgcmV0dXJuZWQgYnkgdGhlIGRlY29yYXRlZCBnZW5lcmF0b3IuXG4gKi9cblEuYXN5bmMgPSBhc3luYztcbmZ1bmN0aW9uIGFzeW5jKG1ha2VHZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyB3aGVuIHZlcmIgaXMgXCJzZW5kXCIsIGFyZyBpcyBhIHZhbHVlXG4gICAgICAgIC8vIHdoZW4gdmVyYiBpcyBcInRocm93XCIsIGFyZyBpcyBhbiBleGNlcHRpb25cbiAgICAgICAgZnVuY3Rpb24gY29udGludWVyKHZlcmIsIGFyZykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgIGlmIChoYXNFUzZHZW5lcmF0b3JzKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZ2VuZXJhdG9yW3ZlcmJdKGFyZyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXhjZXB0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdoZW4ocmVzdWx0LnZhbHVlLCBjYWxsYmFjaywgZXJyYmFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRTogUmVtb3ZlIHRoaXMgY2FzZSB3aGVuIFNNIGRvZXMgRVM2IGdlbmVyYXRvcnMuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZ2VuZXJhdG9yW3ZlcmJdKGFyZyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N0b3BJdGVyYXRpb24oZXhjZXB0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4Y2VwdGlvbi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXhjZXB0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gd2hlbihyZXN1bHQsIGNhbGxiYWNrLCBlcnJiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgZ2VuZXJhdG9yID0gbWFrZUdlbmVyYXRvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBjb250aW51ZXIuYmluZChjb250aW51ZXIsIFwibmV4dFwiKTtcbiAgICAgICAgdmFyIGVycmJhY2sgPSBjb250aW51ZXIuYmluZChjb250aW51ZXIsIFwidGhyb3dcIik7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH07XG59XG5cbi8qKlxuICogVGhlIHNwYXduIGZ1bmN0aW9uIGlzIGEgc21hbGwgd3JhcHBlciBhcm91bmQgYXN5bmMgdGhhdCBpbW1lZGlhdGVseVxuICogY2FsbHMgdGhlIGdlbmVyYXRvciBhbmQgYWxzbyBlbmRzIHRoZSBwcm9taXNlIGNoYWluLCBzbyB0aGF0IGFueVxuICogdW5oYW5kbGVkIGVycm9ycyBhcmUgdGhyb3duIGluc3RlYWQgb2YgZm9yd2FyZGVkIHRvIHRoZSBlcnJvclxuICogaGFuZGxlci4gVGhpcyBpcyB1c2VmdWwgYmVjYXVzZSBpdCdzIGV4dHJlbWVseSBjb21tb24gdG8gcnVuXG4gKiBnZW5lcmF0b3JzIGF0IHRoZSB0b3AtbGV2ZWwgdG8gd29yayB3aXRoIGxpYnJhcmllcy5cbiAqL1xuUS5zcGF3biA9IHNwYXduO1xuZnVuY3Rpb24gc3Bhd24obWFrZUdlbmVyYXRvcikge1xuICAgIFEuZG9uZShRLmFzeW5jKG1ha2VHZW5lcmF0b3IpKCkpO1xufVxuXG4vLyBGSVhNRTogUmVtb3ZlIHRoaXMgaW50ZXJmYWNlIG9uY2UgRVM2IGdlbmVyYXRvcnMgYXJlIGluIFNwaWRlck1vbmtleS5cbi8qKlxuICogVGhyb3dzIGEgUmV0dXJuVmFsdWUgZXhjZXB0aW9uIHRvIHN0b3AgYW4gYXN5bmNocm9ub3VzIGdlbmVyYXRvci5cbiAqXG4gKiBUaGlzIGludGVyZmFjZSBpcyBhIHN0b3AtZ2FwIG1lYXN1cmUgdG8gc3VwcG9ydCBnZW5lcmF0b3IgcmV0dXJuXG4gKiB2YWx1ZXMgaW4gb2xkZXIgRmlyZWZveC9TcGlkZXJNb25rZXkuICBJbiBicm93c2VycyB0aGF0IHN1cHBvcnQgRVM2XG4gKiBnZW5lcmF0b3JzIGxpa2UgQ2hyb21pdW0gMjksIGp1c3QgdXNlIFwicmV0dXJuXCIgaW4geW91ciBnZW5lcmF0b3JcbiAqIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgdGhlIHJldHVybiB2YWx1ZSBmb3IgdGhlIHN1cnJvdW5kaW5nIGdlbmVyYXRvclxuICogQHRocm93cyBSZXR1cm5WYWx1ZSBleGNlcHRpb24gd2l0aCB0aGUgdmFsdWUuXG4gKiBAZXhhbXBsZVxuICogLy8gRVM2IHN0eWxlXG4gKiBRLmFzeW5jKGZ1bmN0aW9uKiAoKSB7XG4gKiAgICAgIHZhciBmb28gPSB5aWVsZCBnZXRGb29Qcm9taXNlKCk7XG4gKiAgICAgIHZhciBiYXIgPSB5aWVsZCBnZXRCYXJQcm9taXNlKCk7XG4gKiAgICAgIHJldHVybiBmb28gKyBiYXI7XG4gKiB9KVxuICogLy8gT2xkZXIgU3BpZGVyTW9ua2V5IHN0eWxlXG4gKiBRLmFzeW5jKGZ1bmN0aW9uICgpIHtcbiAqICAgICAgdmFyIGZvbyA9IHlpZWxkIGdldEZvb1Byb21pc2UoKTtcbiAqICAgICAgdmFyIGJhciA9IHlpZWxkIGdldEJhclByb21pc2UoKTtcbiAqICAgICAgUS5yZXR1cm4oZm9vICsgYmFyKTtcbiAqIH0pXG4gKi9cblFbXCJyZXR1cm5cIl0gPSBfcmV0dXJuO1xuZnVuY3Rpb24gX3JldHVybih2YWx1ZSkge1xuICAgIHRocm93IG5ldyBRUmV0dXJuVmFsdWUodmFsdWUpO1xufVxuXG4vKipcbiAqIFRoZSBwcm9taXNlZCBmdW5jdGlvbiBkZWNvcmF0b3IgZW5zdXJlcyB0aGF0IGFueSBwcm9taXNlIGFyZ3VtZW50c1xuICogYXJlIHNldHRsZWQgYW5kIHBhc3NlZCBhcyB2YWx1ZXMgKGB0aGlzYCBpcyBhbHNvIHNldHRsZWQgYW5kIHBhc3NlZFxuICogYXMgYSB2YWx1ZSkuICBJdCB3aWxsIGFsc28gZW5zdXJlIHRoYXQgdGhlIHJlc3VsdCBvZiBhIGZ1bmN0aW9uIGlzXG4gKiBhbHdheXMgYSBwcm9taXNlLlxuICpcbiAqIEBleGFtcGxlXG4gKiB2YXIgYWRkID0gUS5wcm9taXNlZChmdW5jdGlvbiAoYSwgYikge1xuICogICAgIHJldHVybiBhICsgYjtcbiAqIH0pO1xuICogYWRkKFEoYSksIFEoQikpO1xuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBkZWNvcmF0ZVxuICogQHJldHVybnMge2Z1bmN0aW9ufSBhIGZ1bmN0aW9uIHRoYXQgaGFzIGJlZW4gZGVjb3JhdGVkLlxuICovXG5RLnByb21pc2VkID0gcHJvbWlzZWQ7XG5mdW5jdGlvbiBwcm9taXNlZChjYWxsYmFjaykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzcHJlYWQoW3RoaXMsIGFsbChhcmd1bWVudHMpXSwgZnVuY3Rpb24gKHNlbGYsIGFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBzZW5kcyBhIG1lc3NhZ2UgdG8gYSB2YWx1ZSBpbiBhIGZ1dHVyZSB0dXJuXG4gKiBAcGFyYW0gb2JqZWN0KiB0aGUgcmVjaXBpZW50XG4gKiBAcGFyYW0gb3AgdGhlIG5hbWUgb2YgdGhlIG1lc3NhZ2Ugb3BlcmF0aW9uLCBlLmcuLCBcIndoZW5cIixcbiAqIEBwYXJhbSBhcmdzIGZ1cnRoZXIgYXJndW1lbnRzIHRvIGJlIGZvcndhcmRlZCB0byB0aGUgb3BlcmF0aW9uXG4gKiBAcmV0dXJucyByZXN1bHQge1Byb21pc2V9IGEgcHJvbWlzZSBmb3IgdGhlIHJlc3VsdCBvZiB0aGUgb3BlcmF0aW9uXG4gKi9cblEuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcbmZ1bmN0aW9uIGRpc3BhdGNoKG9iamVjdCwgb3AsIGFyZ3MpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKG9wLCBhcmdzKTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiAob3AsIGFyZ3MpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICBuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYucHJvbWlzZURpc3BhdGNoKGRlZmVycmVkLnJlc29sdmUsIG9wLCBhcmdzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgb2YgYSBwcm9wZXJ0eSBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBvYmplY3RcbiAqIEBwYXJhbSBuYW1lICAgICAgbmFtZSBvZiBwcm9wZXJ0eSB0byBnZXRcbiAqIEByZXR1cm4gcHJvbWlzZSBmb3IgdGhlIHByb3BlcnR5IHZhbHVlXG4gKi9cblEuZ2V0ID0gZnVuY3Rpb24gKG9iamVjdCwga2V5KSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChcImdldFwiLCBba2V5XSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJnZXRcIiwgW2tleV0pO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5IGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3Igb2JqZWN0IG9iamVjdFxuICogQHBhcmFtIG5hbWUgICAgICBuYW1lIG9mIHByb3BlcnR5IHRvIHNldFxuICogQHBhcmFtIHZhbHVlICAgICBuZXcgdmFsdWUgb2YgcHJvcGVydHlcbiAqIEByZXR1cm4gcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZVxuICovXG5RLnNldCA9IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwic2V0XCIsIFtrZXksIHZhbHVlXSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwic2V0XCIsIFtrZXksIHZhbHVlXSk7XG59O1xuXG4vKipcbiAqIERlbGV0ZXMgYSBwcm9wZXJ0eSBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBvYmplY3RcbiAqIEBwYXJhbSBuYW1lICAgICAgbmFtZSBvZiBwcm9wZXJ0eSB0byBkZWxldGVcbiAqIEByZXR1cm4gcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZVxuICovXG5RLmRlbCA9IC8vIFhYWCBsZWdhY3lcblFbXCJkZWxldGVcIl0gPSBmdW5jdGlvbiAob2JqZWN0LCBrZXkpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwiZGVsZXRlXCIsIFtrZXldKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmRlbCA9IC8vIFhYWCBsZWdhY3lcblByb21pc2UucHJvdG90eXBlW1wiZGVsZXRlXCJdID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwiZGVsZXRlXCIsIFtrZXldKTtcbn07XG5cbi8qKlxuICogSW52b2tlcyBhIG1ldGhvZCBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBvYmplY3RcbiAqIEBwYXJhbSBuYW1lICAgICAgbmFtZSBvZiBtZXRob2QgdG8gaW52b2tlXG4gKiBAcGFyYW0gdmFsdWUgICAgIGEgdmFsdWUgdG8gcG9zdCwgdHlwaWNhbGx5IGFuIGFycmF5IG9mXG4gKiAgICAgICAgICAgICAgICAgIGludm9jYXRpb24gYXJndW1lbnRzIGZvciBwcm9taXNlcyB0aGF0XG4gKiAgICAgICAgICAgICAgICAgIGFyZSB1bHRpbWF0ZWx5IGJhY2tlZCB3aXRoIGByZXNvbHZlYCB2YWx1ZXMsXG4gKiAgICAgICAgICAgICAgICAgIGFzIG9wcG9zZWQgdG8gdGhvc2UgYmFja2VkIHdpdGggVVJMc1xuICogICAgICAgICAgICAgICAgICB3aGVyZWluIHRoZSBwb3N0ZWQgdmFsdWUgY2FuIGJlIGFueVxuICogICAgICAgICAgICAgICAgICBKU09OIHNlcmlhbGl6YWJsZSBvYmplY3QuXG4gKiBAcmV0dXJuIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWVcbiAqL1xuLy8gYm91bmQgbG9jYWxseSBiZWNhdXNlIGl0IGlzIHVzZWQgYnkgb3RoZXIgbWV0aG9kc1xuUS5tYXBwbHkgPSAvLyBYWFggQXMgcHJvcG9zZWQgYnkgXCJSZWRzYW5kcm9cIlxuUS5wb3N0ID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSwgYXJncykge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJwb3N0XCIsIFtuYW1lLCBhcmdzXSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5tYXBwbHkgPSAvLyBYWFggQXMgcHJvcG9zZWQgYnkgXCJSZWRzYW5kcm9cIlxuUHJvbWlzZS5wcm90b3R5cGUucG9zdCA9IGZ1bmN0aW9uIChuYW1lLCBhcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJwb3N0XCIsIFtuYW1lLCBhcmdzXSk7XG59O1xuXG4vKipcbiAqIEludm9rZXMgYSBtZXRob2QgaW4gYSBmdXR1cmUgdHVybi5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgb2JqZWN0XG4gKiBAcGFyYW0gbmFtZSAgICAgIG5hbWUgb2YgbWV0aG9kIHRvIGludm9rZVxuICogQHBhcmFtIC4uLmFyZ3MgICBhcnJheSBvZiBpbnZvY2F0aW9uIGFyZ3VtZW50c1xuICogQHJldHVybiBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlXG4gKi9cblEuc2VuZCA9IC8vIFhYWCBNYXJrIE1pbGxlcidzIHByb3Bvc2VkIHBhcmxhbmNlXG5RLm1jYWxsID0gLy8gWFhYIEFzIHByb3Bvc2VkIGJ5IFwiUmVkc2FuZHJvXCJcblEuaW52b2tlID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSAvKi4uLmFyZ3MqLykge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJwb3N0XCIsIFtuYW1lLCBhcnJheV9zbGljZShhcmd1bWVudHMsIDIpXSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5zZW5kID0gLy8gWFhYIE1hcmsgTWlsbGVyJ3MgcHJvcG9zZWQgcGFybGFuY2VcblByb21pc2UucHJvdG90eXBlLm1jYWxsID0gLy8gWFhYIEFzIHByb3Bvc2VkIGJ5IFwiUmVkc2FuZHJvXCJcblByb21pc2UucHJvdG90eXBlLmludm9rZSA9IGZ1bmN0aW9uIChuYW1lIC8qLi4uYXJncyovKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJwb3N0XCIsIFtuYW1lLCBhcnJheV9zbGljZShhcmd1bWVudHMsIDEpXSk7XG59O1xuXG4vKipcbiAqIEFwcGxpZXMgdGhlIHByb21pc2VkIGZ1bmN0aW9uIGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3IgdGFyZ2V0IGZ1bmN0aW9uXG4gKiBAcGFyYW0gYXJncyAgICAgIGFycmF5IG9mIGFwcGxpY2F0aW9uIGFyZ3VtZW50c1xuICovXG5RLmZhcHBseSA9IGZ1bmN0aW9uIChvYmplY3QsIGFyZ3MpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwiYXBwbHlcIiwgW3ZvaWQgMCwgYXJnc10pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZmFwcGx5ID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcImFwcGx5XCIsIFt2b2lkIDAsIGFyZ3NdKTtcbn07XG5cbi8qKlxuICogQ2FsbHMgdGhlIHByb21pc2VkIGZ1bmN0aW9uIGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3IgdGFyZ2V0IGZ1bmN0aW9uXG4gKiBAcGFyYW0gLi4uYXJncyAgIGFycmF5IG9mIGFwcGxpY2F0aW9uIGFyZ3VtZW50c1xuICovXG5RW1widHJ5XCJdID1cblEuZmNhbGwgPSBmdW5jdGlvbiAob2JqZWN0IC8qIC4uLmFyZ3MqLykge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJhcHBseVwiLCBbdm9pZCAwLCBhcnJheV9zbGljZShhcmd1bWVudHMsIDEpXSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5mY2FsbCA9IGZ1bmN0aW9uICgvKi4uLmFyZ3MqLykge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwiYXBwbHlcIiwgW3ZvaWQgMCwgYXJyYXlfc2xpY2UoYXJndW1lbnRzKV0pO1xufTtcblxuLyoqXG4gKiBCaW5kcyB0aGUgcHJvbWlzZWQgZnVuY3Rpb24sIHRyYW5zZm9ybWluZyByZXR1cm4gdmFsdWVzIGludG8gYSBmdWxmaWxsZWRcbiAqIHByb21pc2UgYW5kIHRocm93biBlcnJvcnMgaW50byBhIHJlamVjdGVkIG9uZS5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgZnVuY3Rpb25cbiAqIEBwYXJhbSAuLi5hcmdzICAgYXJyYXkgb2YgYXBwbGljYXRpb24gYXJndW1lbnRzXG4gKi9cblEuZmJpbmQgPSBmdW5jdGlvbiAob2JqZWN0IC8qLi4uYXJncyovKSB7XG4gICAgdmFyIHByb21pc2UgPSBRKG9iamVjdCk7XG4gICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMsIDEpO1xuICAgIHJldHVybiBmdW5jdGlvbiBmYm91bmQoKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlLmRpc3BhdGNoKFwiYXBwbHlcIiwgW1xuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIGFyZ3MuY29uY2F0KGFycmF5X3NsaWNlKGFyZ3VtZW50cykpXG4gICAgICAgIF0pO1xuICAgIH07XG59O1xuUHJvbWlzZS5wcm90b3R5cGUuZmJpbmQgPSBmdW5jdGlvbiAoLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMpO1xuICAgIHJldHVybiBmdW5jdGlvbiBmYm91bmQoKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlLmRpc3BhdGNoKFwiYXBwbHlcIiwgW1xuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIGFyZ3MuY29uY2F0KGFycmF5X3NsaWNlKGFyZ3VtZW50cykpXG4gICAgICAgIF0pO1xuICAgIH07XG59O1xuXG4vKipcbiAqIFJlcXVlc3RzIHRoZSBuYW1lcyBvZiB0aGUgb3duZWQgcHJvcGVydGllcyBvZiBhIHByb21pc2VkXG4gKiBvYmplY3QgaW4gYSBmdXR1cmUgdHVybi5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgb2JqZWN0XG4gKiBAcmV0dXJuIHByb21pc2UgZm9yIHRoZSBrZXlzIG9mIHRoZSBldmVudHVhbGx5IHNldHRsZWQgb2JqZWN0XG4gKi9cblEua2V5cyA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwia2V5c1wiLCBbXSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwia2V5c1wiLCBbXSk7XG59O1xuXG4vKipcbiAqIFR1cm5zIGFuIGFycmF5IG9mIHByb21pc2VzIGludG8gYSBwcm9taXNlIGZvciBhbiBhcnJheS4gIElmIGFueSBvZlxuICogdGhlIHByb21pc2VzIGdldHMgcmVqZWN0ZWQsIHRoZSB3aG9sZSBhcnJheSBpcyByZWplY3RlZCBpbW1lZGlhdGVseS5cbiAqIEBwYXJhbSB7QXJyYXkqfSBhbiBhcnJheSAob3IgcHJvbWlzZSBmb3IgYW4gYXJyYXkpIG9mIHZhbHVlcyAob3JcbiAqIHByb21pc2VzIGZvciB2YWx1ZXMpXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIGFuIGFycmF5IG9mIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlc1xuICovXG4vLyBCeSBNYXJrIE1pbGxlclxuLy8gaHR0cDovL3dpa2kuZWNtYXNjcmlwdC5vcmcvZG9rdS5waHA/aWQ9c3RyYXdtYW46Y29uY3VycmVuY3kmcmV2PTEzMDg3NzY1MjEjYWxsZnVsZmlsbGVkXG5RLmFsbCA9IGFsbDtcbmZ1bmN0aW9uIGFsbChwcm9taXNlcykge1xuICAgIHJldHVybiB3aGVuKHByb21pc2VzLCBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICAgICAgdmFyIGNvdW50RG93biA9IDA7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgICAgIGFycmF5X3JlZHVjZShwcm9taXNlcywgZnVuY3Rpb24gKHVuZGVmaW5lZCwgcHJvbWlzZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBzbmFwc2hvdDtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBpc1Byb21pc2UocHJvbWlzZSkgJiZcbiAgICAgICAgICAgICAgICAoc25hcHNob3QgPSBwcm9taXNlLmluc3BlY3QoKSkuc3RhdGUgPT09IFwiZnVsZmlsbGVkXCJcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHByb21pc2VzW2luZGV4XSA9IHNuYXBzaG90LnZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICArK2NvdW50RG93bjtcbiAgICAgICAgICAgICAgICB3aGVuKFxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC0tY291bnREb3duID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShwcm9taXNlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdCxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKHByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5ub3RpZnkoeyBpbmRleDogaW5kZXgsIHZhbHVlOiBwcm9ncmVzcyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHZvaWQgMCk7XG4gICAgICAgIGlmIChjb3VudERvd24gPT09IDApIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUocHJvbWlzZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH0pO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5hbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFsbCh0aGlzKTtcbn07XG5cbi8qKlxuICogV2FpdHMgZm9yIGFsbCBwcm9taXNlcyB0byBiZSBzZXR0bGVkLCBlaXRoZXIgZnVsZmlsbGVkIG9yXG4gKiByZWplY3RlZC4gIFRoaXMgaXMgZGlzdGluY3QgZnJvbSBgYWxsYCBzaW5jZSB0aGF0IHdvdWxkIHN0b3BcbiAqIHdhaXRpbmcgYXQgdGhlIGZpcnN0IHJlamVjdGlvbi4gIFRoZSBwcm9taXNlIHJldHVybmVkIGJ5XG4gKiBgYWxsUmVzb2x2ZWRgIHdpbGwgbmV2ZXIgYmUgcmVqZWN0ZWQuXG4gKiBAcGFyYW0gcHJvbWlzZXMgYSBwcm9taXNlIGZvciBhbiBhcnJheSAob3IgYW4gYXJyYXkpIG9mIHByb21pc2VzXG4gKiAob3IgdmFsdWVzKVxuICogQHJldHVybiBhIHByb21pc2UgZm9yIGFuIGFycmF5IG9mIHByb21pc2VzXG4gKi9cblEuYWxsUmVzb2x2ZWQgPSBkZXByZWNhdGUoYWxsUmVzb2x2ZWQsIFwiYWxsUmVzb2x2ZWRcIiwgXCJhbGxTZXR0bGVkXCIpO1xuZnVuY3Rpb24gYWxsUmVzb2x2ZWQocHJvbWlzZXMpIHtcbiAgICByZXR1cm4gd2hlbihwcm9taXNlcywgZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gICAgICAgIHByb21pc2VzID0gYXJyYXlfbWFwKHByb21pc2VzLCBRKTtcbiAgICAgICAgcmV0dXJuIHdoZW4oYWxsKGFycmF5X21hcChwcm9taXNlcywgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB3aGVuKHByb21pc2UsIG5vb3AsIG5vb3ApO1xuICAgICAgICB9KSksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlcztcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cblByb21pc2UucHJvdG90eXBlLmFsbFJlc29sdmVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhbGxSZXNvbHZlZCh0aGlzKTtcbn07XG5cbi8qKlxuICogQHNlZSBQcm9taXNlI2FsbFNldHRsZWRcbiAqL1xuUS5hbGxTZXR0bGVkID0gYWxsU2V0dGxlZDtcbmZ1bmN0aW9uIGFsbFNldHRsZWQocHJvbWlzZXMpIHtcbiAgICByZXR1cm4gUShwcm9taXNlcykuYWxsU2V0dGxlZCgpO1xufVxuXG4vKipcbiAqIFR1cm5zIGFuIGFycmF5IG9mIHByb21pc2VzIGludG8gYSBwcm9taXNlIGZvciBhbiBhcnJheSBvZiB0aGVpciBzdGF0ZXMgKGFzXG4gKiByZXR1cm5lZCBieSBgaW5zcGVjdGApIHdoZW4gdGhleSBoYXZlIGFsbCBzZXR0bGVkLlxuICogQHBhcmFtIHtBcnJheVtBbnkqXX0gdmFsdWVzIGFuIGFycmF5IChvciBwcm9taXNlIGZvciBhbiBhcnJheSkgb2YgdmFsdWVzIChvclxuICogcHJvbWlzZXMgZm9yIHZhbHVlcylcbiAqIEByZXR1cm5zIHtBcnJheVtTdGF0ZV19IGFuIGFycmF5IG9mIHN0YXRlcyBmb3IgdGhlIHJlc3BlY3RpdmUgdmFsdWVzLlxuICovXG5Qcm9taXNlLnByb3RvdHlwZS5hbGxTZXR0bGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gICAgICAgIHJldHVybiBhbGwoYXJyYXlfbWFwKHByb21pc2VzLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICAgICAgcHJvbWlzZSA9IFEocHJvbWlzZSk7XG4gICAgICAgICAgICBmdW5jdGlvbiByZWdhcmRsZXNzKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlLmluc3BlY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4ocmVnYXJkbGVzcywgcmVnYXJkbGVzcyk7XG4gICAgICAgIH0pKTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQ2FwdHVyZXMgdGhlIGZhaWx1cmUgb2YgYSBwcm9taXNlLCBnaXZpbmcgYW4gb3BvcnR1bml0eSB0byByZWNvdmVyXG4gKiB3aXRoIGEgY2FsbGJhY2suICBJZiB0aGUgZ2l2ZW4gcHJvbWlzZSBpcyBmdWxmaWxsZWQsIHRoZSByZXR1cm5lZFxuICogcHJvbWlzZSBpcyBmdWxmaWxsZWQuXG4gKiBAcGFyYW0ge0FueSp9IHByb21pc2UgZm9yIHNvbWV0aGluZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdG8gZnVsZmlsbCB0aGUgcmV0dXJuZWQgcHJvbWlzZSBpZiB0aGVcbiAqIGdpdmVuIHByb21pc2UgaXMgcmVqZWN0ZWRcbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgY2FsbGJhY2tcbiAqL1xuUS5mYWlsID0gLy8gWFhYIGxlZ2FjeVxuUVtcImNhdGNoXCJdID0gZnVuY3Rpb24gKG9iamVjdCwgcmVqZWN0ZWQpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLnRoZW4odm9pZCAwLCByZWplY3RlZCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5mYWlsID0gLy8gWFhYIGxlZ2FjeVxuUHJvbWlzZS5wcm90b3R5cGVbXCJjYXRjaFwiXSA9IGZ1bmN0aW9uIChyZWplY3RlZCkge1xuICAgIHJldHVybiB0aGlzLnRoZW4odm9pZCAwLCByZWplY3RlZCk7XG59O1xuXG4vKipcbiAqIEF0dGFjaGVzIGEgbGlzdGVuZXIgdGhhdCBjYW4gcmVzcG9uZCB0byBwcm9ncmVzcyBub3RpZmljYXRpb25zIGZyb20gYVxuICogcHJvbWlzZSdzIG9yaWdpbmF0aW5nIGRlZmVycmVkLiBUaGlzIGxpc3RlbmVyIHJlY2VpdmVzIHRoZSBleGFjdCBhcmd1bWVudHNcbiAqIHBhc3NlZCB0byBgYGRlZmVycmVkLm5vdGlmeWBgLlxuICogQHBhcmFtIHtBbnkqfSBwcm9taXNlIGZvciBzb21ldGhpbmdcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHRvIHJlY2VpdmUgYW55IHByb2dyZXNzIG5vdGlmaWNhdGlvbnNcbiAqIEByZXR1cm5zIHRoZSBnaXZlbiBwcm9taXNlLCB1bmNoYW5nZWRcbiAqL1xuUS5wcm9ncmVzcyA9IHByb2dyZXNzO1xuZnVuY3Rpb24gcHJvZ3Jlc3Mob2JqZWN0LCBwcm9ncmVzc2VkKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS50aGVuKHZvaWQgMCwgdm9pZCAwLCBwcm9ncmVzc2VkKTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUucHJvZ3Jlc3MgPSBmdW5jdGlvbiAocHJvZ3Jlc3NlZCkge1xuICAgIHJldHVybiB0aGlzLnRoZW4odm9pZCAwLCB2b2lkIDAsIHByb2dyZXNzZWQpO1xufTtcblxuLyoqXG4gKiBQcm92aWRlcyBhbiBvcHBvcnR1bml0eSB0byBvYnNlcnZlIHRoZSBzZXR0bGluZyBvZiBhIHByb21pc2UsXG4gKiByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhlIHByb21pc2UgaXMgZnVsZmlsbGVkIG9yIHJlamVjdGVkLiAgRm9yd2FyZHNcbiAqIHRoZSByZXNvbHV0aW9uIHRvIHRoZSByZXR1cm5lZCBwcm9taXNlIHdoZW4gdGhlIGNhbGxiYWNrIGlzIGRvbmUuXG4gKiBUaGUgY2FsbGJhY2sgY2FuIHJldHVybiBhIHByb21pc2UgdG8gZGVmZXIgY29tcGxldGlvbi5cbiAqIEBwYXJhbSB7QW55Kn0gcHJvbWlzZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdG8gb2JzZXJ2ZSB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgZ2l2ZW5cbiAqIHByb21pc2UsIHRha2VzIG5vIGFyZ3VtZW50cy5cbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJlc29sdXRpb24gb2YgdGhlIGdpdmVuIHByb21pc2Ugd2hlblxuICogYGBmaW5gYCBpcyBkb25lLlxuICovXG5RLmZpbiA9IC8vIFhYWCBsZWdhY3lcblFbXCJmaW5hbGx5XCJdID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gUShvYmplY3QpW1wiZmluYWxseVwiXShjYWxsYmFjayk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5maW4gPSAvLyBYWFggbGVnYWN5XG5Qcm9taXNlLnByb3RvdHlwZVtcImZpbmFsbHlcIl0gPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IFEoY2FsbGJhY2spO1xuICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjay5mY2FsbCgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIC8vIFRPRE8gYXR0ZW1wdCB0byByZWN5Y2xlIHRoZSByZWplY3Rpb24gd2l0aCBcInRoaXNcIi5cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmZjYWxsKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyByZWFzb247XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBUZXJtaW5hdGVzIGEgY2hhaW4gb2YgcHJvbWlzZXMsIGZvcmNpbmcgcmVqZWN0aW9ucyB0byBiZVxuICogdGhyb3duIGFzIGV4Y2VwdGlvbnMuXG4gKiBAcGFyYW0ge0FueSp9IHByb21pc2UgYXQgdGhlIGVuZCBvZiBhIGNoYWluIG9mIHByb21pc2VzXG4gKiBAcmV0dXJucyBub3RoaW5nXG4gKi9cblEuZG9uZSA9IGZ1bmN0aW9uIChvYmplY3QsIGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kb25lKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmRvbmUgPSBmdW5jdGlvbiAoZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3MpIHtcbiAgICB2YXIgb25VbmhhbmRsZWRFcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAvLyBmb3J3YXJkIHRvIGEgZnV0dXJlIHR1cm4gc28gdGhhdCBgYHdoZW5gYFxuICAgICAgICAvLyBkb2VzIG5vdCBjYXRjaCBpdCBhbmQgdHVybiBpdCBpbnRvIGEgcmVqZWN0aW9uLlxuICAgICAgICBuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBtYWtlU3RhY2tUcmFjZUxvbmcoZXJyb3IsIHByb21pc2UpO1xuICAgICAgICAgICAgaWYgKFEub25lcnJvcikge1xuICAgICAgICAgICAgICAgIFEub25lcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gQXZvaWQgdW5uZWNlc3NhcnkgYG5leHRUaWNrYGluZyB2aWEgYW4gdW5uZWNlc3NhcnkgYHdoZW5gLlxuICAgIHZhciBwcm9taXNlID0gZnVsZmlsbGVkIHx8IHJlamVjdGVkIHx8IHByb2dyZXNzID9cbiAgICAgICAgdGhpcy50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzKSA6XG4gICAgICAgIHRoaXM7XG5cbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgcHJvY2VzcyAmJiBwcm9jZXNzLmRvbWFpbikge1xuICAgICAgICBvblVuaGFuZGxlZEVycm9yID0gcHJvY2Vzcy5kb21haW4uYmluZChvblVuaGFuZGxlZEVycm9yKTtcbiAgICB9XG5cbiAgICBwcm9taXNlLnRoZW4odm9pZCAwLCBvblVuaGFuZGxlZEVycm9yKTtcbn07XG5cbi8qKlxuICogQ2F1c2VzIGEgcHJvbWlzZSB0byBiZSByZWplY3RlZCBpZiBpdCBkb2VzIG5vdCBnZXQgZnVsZmlsbGVkIGJlZm9yZVxuICogc29tZSBtaWxsaXNlY29uZHMgdGltZSBvdXQuXG4gKiBAcGFyYW0ge0FueSp9IHByb21pc2VcbiAqIEBwYXJhbSB7TnVtYmVyfSBtaWxsaXNlY29uZHMgdGltZW91dFxuICogQHBhcmFtIHtTdHJpbmd9IGN1c3RvbSBlcnJvciBtZXNzYWdlIChvcHRpb25hbClcbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJlc29sdXRpb24gb2YgdGhlIGdpdmVuIHByb21pc2UgaWYgaXQgaXNcbiAqIGZ1bGZpbGxlZCBiZWZvcmUgdGhlIHRpbWVvdXQsIG90aGVyd2lzZSByZWplY3RlZC5cbiAqL1xuUS50aW1lb3V0ID0gZnVuY3Rpb24gKG9iamVjdCwgbXMsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLnRpbWVvdXQobXMsIG1lc3NhZ2UpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uIChtcywgbWVzc2FnZSkge1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgdmFyIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBkZWZlcnJlZC5yZWplY3QobmV3IEVycm9yKG1lc3NhZ2UgfHwgXCJUaW1lZCBvdXQgYWZ0ZXIgXCIgKyBtcyArIFwiIG1zXCIpKTtcbiAgICB9LCBtcyk7XG5cbiAgICB0aGlzLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHZhbHVlKTtcbiAgICB9LCBmdW5jdGlvbiAoZXhjZXB0aW9uKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXhjZXB0aW9uKTtcbiAgICB9LCBkZWZlcnJlZC5ub3RpZnkpO1xuXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgZ2l2ZW4gdmFsdWUgKG9yIHByb21pc2VkIHZhbHVlKSwgc29tZVxuICogbWlsbGlzZWNvbmRzIGFmdGVyIGl0IHJlc29sdmVkLiBQYXNzZXMgcmVqZWN0aW9ucyBpbW1lZGlhdGVseS5cbiAqIEBwYXJhbSB7QW55Kn0gcHJvbWlzZVxuICogQHBhcmFtIHtOdW1iZXJ9IG1pbGxpc2Vjb25kc1xuICogQHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgZ2l2ZW4gcHJvbWlzZSBhZnRlciBtaWxsaXNlY29uZHNcbiAqIHRpbWUgaGFzIGVsYXBzZWQgc2luY2UgdGhlIHJlc29sdXRpb24gb2YgdGhlIGdpdmVuIHByb21pc2UuXG4gKiBJZiB0aGUgZ2l2ZW4gcHJvbWlzZSByZWplY3RzLCB0aGF0IGlzIHBhc3NlZCBpbW1lZGlhdGVseS5cbiAqL1xuUS5kZWxheSA9IGZ1bmN0aW9uIChvYmplY3QsIHRpbWVvdXQpIHtcbiAgICBpZiAodGltZW91dCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRpbWVvdXQgPSBvYmplY3Q7XG4gICAgICAgIG9iamVjdCA9IHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kZWxheSh0aW1lb3V0KTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmRlbGF5ID0gZnVuY3Rpb24gKHRpbWVvdXQpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUodmFsdWUpO1xuICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFBhc3NlcyBhIGNvbnRpbnVhdGlvbiB0byBhIE5vZGUgZnVuY3Rpb24sIHdoaWNoIGlzIGNhbGxlZCB3aXRoIHRoZSBnaXZlblxuICogYXJndW1lbnRzIHByb3ZpZGVkIGFzIGFuIGFycmF5LCBhbmQgcmV0dXJucyBhIHByb21pc2UuXG4gKlxuICogICAgICBRLm5mYXBwbHkoRlMucmVhZEZpbGUsIFtfX2ZpbGVuYW1lXSlcbiAqICAgICAgLnRoZW4oZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAqICAgICAgfSlcbiAqXG4gKi9cblEubmZhcHBseSA9IGZ1bmN0aW9uIChjYWxsYmFjaywgYXJncykge1xuICAgIHJldHVybiBRKGNhbGxiYWNrKS5uZmFwcGx5KGFyZ3MpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUubmZhcHBseSA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICB2YXIgbm9kZUFyZ3MgPSBhcnJheV9zbGljZShhcmdzKTtcbiAgICBub2RlQXJncy5wdXNoKGRlZmVycmVkLm1ha2VOb2RlUmVzb2x2ZXIoKSk7XG4gICAgdGhpcy5mYXBwbHkobm9kZUFyZ3MpLmZhaWwoZGVmZXJyZWQucmVqZWN0KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbi8qKlxuICogUGFzc2VzIGEgY29udGludWF0aW9uIHRvIGEgTm9kZSBmdW5jdGlvbiwgd2hpY2ggaXMgY2FsbGVkIHdpdGggdGhlIGdpdmVuXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgaW5kaXZpZHVhbGx5LCBhbmQgcmV0dXJucyBhIHByb21pc2UuXG4gKiBAZXhhbXBsZVxuICogUS5uZmNhbGwoRlMucmVhZEZpbGUsIF9fZmlsZW5hbWUpXG4gKiAudGhlbihmdW5jdGlvbiAoY29udGVudCkge1xuICogfSlcbiAqXG4gKi9cblEubmZjYWxsID0gZnVuY3Rpb24gKGNhbGxiYWNrIC8qLi4uYXJncyovKSB7XG4gICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMsIDEpO1xuICAgIHJldHVybiBRKGNhbGxiYWNrKS5uZmFwcGx5KGFyZ3MpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUubmZjYWxsID0gZnVuY3Rpb24gKC8qLi4uYXJncyovKSB7XG4gICAgdmFyIG5vZGVBcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzKTtcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIG5vZGVBcmdzLnB1c2goZGVmZXJyZWQubWFrZU5vZGVSZXNvbHZlcigpKTtcbiAgICB0aGlzLmZhcHBseShub2RlQXJncykuZmFpbChkZWZlcnJlZC5yZWplY3QpO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuLyoqXG4gKiBXcmFwcyBhIE5vZGVKUyBjb250aW51YXRpb24gcGFzc2luZyBmdW5jdGlvbiBhbmQgcmV0dXJucyBhbiBlcXVpdmFsZW50XG4gKiB2ZXJzaW9uIHRoYXQgcmV0dXJucyBhIHByb21pc2UuXG4gKiBAZXhhbXBsZVxuICogUS5uZmJpbmQoRlMucmVhZEZpbGUsIF9fZmlsZW5hbWUpKFwidXRmLThcIilcbiAqIC50aGVuKGNvbnNvbGUubG9nKVxuICogLmRvbmUoKVxuICovXG5RLm5mYmluZCA9XG5RLmRlbm9kZWlmeSA9IGZ1bmN0aW9uIChjYWxsYmFjayAvKi4uLmFyZ3MqLykge1xuICAgIHZhciBiYXNlQXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5vZGVBcmdzID0gYmFzZUFyZ3MuY29uY2F0KGFycmF5X3NsaWNlKGFyZ3VtZW50cykpO1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgICAgICBub2RlQXJncy5wdXNoKGRlZmVycmVkLm1ha2VOb2RlUmVzb2x2ZXIoKSk7XG4gICAgICAgIFEoY2FsbGJhY2spLmZhcHBseShub2RlQXJncykuZmFpbChkZWZlcnJlZC5yZWplY3QpO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUubmZiaW5kID1cblByb21pc2UucHJvdG90eXBlLmRlbm9kZWlmeSA9IGZ1bmN0aW9uICgvKi4uLmFyZ3MqLykge1xuICAgIHZhciBhcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzKTtcbiAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgcmV0dXJuIFEuZGVub2RlaWZ5LmFwcGx5KHZvaWQgMCwgYXJncyk7XG59O1xuXG5RLm5iaW5kID0gZnVuY3Rpb24gKGNhbGxiYWNrLCB0aGlzcCAvKi4uLmFyZ3MqLykge1xuICAgIHZhciBiYXNlQXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5vZGVBcmdzID0gYmFzZUFyZ3MuY29uY2F0KGFycmF5X3NsaWNlKGFyZ3VtZW50cykpO1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgICAgICBub2RlQXJncy5wdXNoKGRlZmVycmVkLm1ha2VOb2RlUmVzb2x2ZXIoKSk7XG4gICAgICAgIGZ1bmN0aW9uIGJvdW5kKCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KHRoaXNwLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIFEoYm91bmQpLmZhcHBseShub2RlQXJncykuZmFpbChkZWZlcnJlZC5yZWplY3QpO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUubmJpbmQgPSBmdW5jdGlvbiAoLyp0aGlzcCwgLi4uYXJncyovKSB7XG4gICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMsIDApO1xuICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICByZXR1cm4gUS5uYmluZC5hcHBseSh2b2lkIDAsIGFyZ3MpO1xufTtcblxuLyoqXG4gKiBDYWxscyBhIG1ldGhvZCBvZiBhIE5vZGUtc3R5bGUgb2JqZWN0IHRoYXQgYWNjZXB0cyBhIE5vZGUtc3R5bGVcbiAqIGNhbGxiYWNrIHdpdGggYSBnaXZlbiBhcnJheSBvZiBhcmd1bWVudHMsIHBsdXMgYSBwcm92aWRlZCBjYWxsYmFjay5cbiAqIEBwYXJhbSBvYmplY3QgYW4gb2JqZWN0IHRoYXQgaGFzIHRoZSBuYW1lZCBtZXRob2RcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG5hbWUgb2YgdGhlIG1ldGhvZCBvZiBvYmplY3RcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIG1ldGhvZDsgdGhlIGNhbGxiYWNrXG4gKiB3aWxsIGJlIHByb3ZpZGVkIGJ5IFEgYW5kIGFwcGVuZGVkIHRvIHRoZXNlIGFyZ3VtZW50cy5cbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9yIGVycm9yXG4gKi9cblEubm1hcHBseSA9IC8vIFhYWCBBcyBwcm9wb3NlZCBieSBcIlJlZHNhbmRyb1wiXG5RLm5wb3N0ID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSwgYXJncykge1xuICAgIHJldHVybiBRKG9iamVjdCkubnBvc3QobmFtZSwgYXJncyk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5ubWFwcGx5ID0gLy8gWFhYIEFzIHByb3Bvc2VkIGJ5IFwiUmVkc2FuZHJvXCJcblByb21pc2UucHJvdG90eXBlLm5wb3N0ID0gZnVuY3Rpb24gKG5hbWUsIGFyZ3MpIHtcbiAgICB2YXIgbm9kZUFyZ3MgPSBhcnJheV9zbGljZShhcmdzIHx8IFtdKTtcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIG5vZGVBcmdzLnB1c2goZGVmZXJyZWQubWFrZU5vZGVSZXNvbHZlcigpKTtcbiAgICB0aGlzLmRpc3BhdGNoKFwicG9zdFwiLCBbbmFtZSwgbm9kZUFyZ3NdKS5mYWlsKGRlZmVycmVkLnJlamVjdCk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG4vKipcbiAqIENhbGxzIGEgbWV0aG9kIG9mIGEgTm9kZS1zdHlsZSBvYmplY3QgdGhhdCBhY2NlcHRzIGEgTm9kZS1zdHlsZVxuICogY2FsbGJhY2ssIGZvcndhcmRpbmcgdGhlIGdpdmVuIHZhcmlhZGljIGFyZ3VtZW50cywgcGx1cyBhIHByb3ZpZGVkXG4gKiBjYWxsYmFjayBhcmd1bWVudC5cbiAqIEBwYXJhbSBvYmplY3QgYW4gb2JqZWN0IHRoYXQgaGFzIHRoZSBuYW1lZCBtZXRob2RcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG5hbWUgb2YgdGhlIG1ldGhvZCBvZiBvYmplY3RcbiAqIEBwYXJhbSAuLi5hcmdzIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBtZXRob2Q7IHRoZSBjYWxsYmFjayB3aWxsXG4gKiBiZSBwcm92aWRlZCBieSBRIGFuZCBhcHBlbmRlZCB0byB0aGVzZSBhcmd1bWVudHMuXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSB2YWx1ZSBvciBlcnJvclxuICovXG5RLm5zZW5kID0gLy8gWFhYIEJhc2VkIG9uIE1hcmsgTWlsbGVyJ3MgcHJvcG9zZWQgXCJzZW5kXCJcblEubm1jYWxsID0gLy8gWFhYIEJhc2VkIG9uIFwiUmVkc2FuZHJvJ3NcIiBwcm9wb3NhbFxuUS5uaW52b2tlID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSAvKi4uLmFyZ3MqLykge1xuICAgIHZhciBub2RlQXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMik7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICBub2RlQXJncy5wdXNoKGRlZmVycmVkLm1ha2VOb2RlUmVzb2x2ZXIoKSk7XG4gICAgUShvYmplY3QpLmRpc3BhdGNoKFwicG9zdFwiLCBbbmFtZSwgbm9kZUFyZ3NdKS5mYWlsKGRlZmVycmVkLnJlamVjdCk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5uc2VuZCA9IC8vIFhYWCBCYXNlZCBvbiBNYXJrIE1pbGxlcidzIHByb3Bvc2VkIFwic2VuZFwiXG5Qcm9taXNlLnByb3RvdHlwZS5ubWNhbGwgPSAvLyBYWFggQmFzZWQgb24gXCJSZWRzYW5kcm8nc1wiIHByb3Bvc2FsXG5Qcm9taXNlLnByb3RvdHlwZS5uaW52b2tlID0gZnVuY3Rpb24gKG5hbWUgLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgbm9kZUFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMsIDEpO1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgbm9kZUFyZ3MucHVzaChkZWZlcnJlZC5tYWtlTm9kZVJlc29sdmVyKCkpO1xuICAgIHRoaXMuZGlzcGF0Y2goXCJwb3N0XCIsIFtuYW1lLCBub2RlQXJnc10pLmZhaWwoZGVmZXJyZWQucmVqZWN0KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbi8qKlxuICogSWYgYSBmdW5jdGlvbiB3b3VsZCBsaWtlIHRvIHN1cHBvcnQgYm90aCBOb2RlIGNvbnRpbnVhdGlvbi1wYXNzaW5nLXN0eWxlIGFuZFxuICogcHJvbWlzZS1yZXR1cm5pbmctc3R5bGUsIGl0IGNhbiBlbmQgaXRzIGludGVybmFsIHByb21pc2UgY2hhaW4gd2l0aFxuICogYG5vZGVpZnkobm9kZWJhY2spYCwgZm9yd2FyZGluZyB0aGUgb3B0aW9uYWwgbm9kZWJhY2sgYXJndW1lbnQuICBJZiB0aGUgdXNlclxuICogZWxlY3RzIHRvIHVzZSBhIG5vZGViYWNrLCB0aGUgcmVzdWx0IHdpbGwgYmUgc2VudCB0aGVyZS4gIElmIHRoZXkgZG8gbm90XG4gKiBwYXNzIGEgbm9kZWJhY2ssIHRoZXkgd2lsbCByZWNlaXZlIHRoZSByZXN1bHQgcHJvbWlzZS5cbiAqIEBwYXJhbSBvYmplY3QgYSByZXN1bHQgKG9yIGEgcHJvbWlzZSBmb3IgYSByZXN1bHQpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBub2RlYmFjayBhIE5vZGUuanMtc3R5bGUgY2FsbGJhY2tcbiAqIEByZXR1cm5zIGVpdGhlciB0aGUgcHJvbWlzZSBvciBub3RoaW5nXG4gKi9cblEubm9kZWlmeSA9IG5vZGVpZnk7XG5mdW5jdGlvbiBub2RlaWZ5KG9iamVjdCwgbm9kZWJhY2spIHtcbiAgICByZXR1cm4gUShvYmplY3QpLm5vZGVpZnkobm9kZWJhY2spO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5ub2RlaWZ5ID0gZnVuY3Rpb24gKG5vZGViYWNrKSB7XG4gICAgaWYgKG5vZGViYWNrKSB7XG4gICAgICAgIHRoaXMudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBub2RlYmFjayhudWxsLCB2YWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbm9kZWJhY2soZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn07XG5cbi8vIEFsbCBjb2RlIGJlZm9yZSB0aGlzIHBvaW50IHdpbGwgYmUgZmlsdGVyZWQgZnJvbSBzdGFjayB0cmFjZXMuXG52YXIgcUVuZGluZ0xpbmUgPSBjYXB0dXJlTGluZSgpO1xuXG5yZXR1cm4gUTtcblxufSk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBJZiBvYmouaGFzT3duUHJvcGVydHkgaGFzIGJlZW4gb3ZlcnJpZGRlbiwgdGhlbiBjYWxsaW5nXG4vLyBvYmouaGFzT3duUHJvcGVydHkocHJvcCkgd2lsbCBicmVhay5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzA3XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICB2YXIgb2JqID0ge307XG5cbiAgaWYgKHR5cGVvZiBxcyAhPT0gJ3N0cmluZycgfHwgcXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciByZWdleHAgPSAvXFwrL2c7XG4gIHFzID0gcXMuc3BsaXQoc2VwKTtcblxuICB2YXIgbWF4S2V5cyA9IDEwMDA7XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heEtleXMgPT09ICdudW1iZXInKSB7XG4gICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cztcbiAgfVxuXG4gIHZhciBsZW4gPSBxcy5sZW5ndGg7XG4gIC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxuICBpZiAobWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cykge1xuICAgIGxlbiA9IG1heEtleXM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHggPSBxc1tpXS5yZXBsYWNlKHJlZ2V4cCwgJyUyMCcpLFxuICAgICAgICBpZHggPSB4LmluZGV4T2YoZXEpLFxuICAgICAgICBrc3RyLCB2c3RyLCBrLCB2O1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBrc3RyID0geC5zdWJzdHIoMCwgaWR4KTtcbiAgICAgIHZzdHIgPSB4LnN1YnN0cihpZHggKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAga3N0ciA9IHg7XG4gICAgICB2c3RyID0gJyc7XG4gICAgfVxuXG4gICAgayA9IGRlY29kZVVSSUNvbXBvbmVudChrc3RyKTtcbiAgICB2ID0gZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShvYmosIGspKSB7XG4gICAgICBvYmpba10gPSB2O1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICBvYmpba10ucHVzaCh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tdID0gW29ialtrXSwgdl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeVByaW1pdGl2ZSA9IGZ1bmN0aW9uKHYpIHtcbiAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gdjtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIHYgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBpc0Zpbml0ZSh2KSA/IHYgOiAnJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBzZXAsIGVxLCBuYW1lKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgb2JqID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG1hcChvYmplY3RLZXlzKG9iaiksIGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUoaykpICsgZXE7XG4gICAgICBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICAgIHJldHVybiBtYXAob2JqW2tdLCBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XG4gICAgICAgIH0pLmpvaW4oc2VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqW2tdKSk7XG4gICAgICB9XG4gICAgfSkuam9pbihzZXApO1xuXG4gIH1cblxuICBpZiAoIW5hbWUpIHJldHVybiAnJztcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgK1xuICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmopKTtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5mdW5jdGlvbiBtYXAgKHhzLCBmKSB7XG4gIGlmICh4cy5tYXApIHJldHVybiB4cy5tYXAoZik7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgIHJlcy5wdXNoKGYoeHNbaV0sIGkpKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHJlcy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9lbmNvZGUnKTtcbiIsIihmdW5jdGlvbigpIHtcbiAgdmFyIE1hcmtlZFlBTUxFcnJvciwgZXZlbnRzLCBub2RlcywgcmFtbCwgdXRpbCwgX3JlZixcbiAgICBfX2hhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSxcbiAgICBfX2V4dGVuZHMgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKF9faGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcbiAgICBfX2JpbmQgPSBmdW5jdGlvbihmbiwgbWUpeyByZXR1cm4gZnVuY3Rpb24oKXsgcmV0dXJuIGZuLmFwcGx5KG1lLCBhcmd1bWVudHMpOyB9OyB9O1xuXG4gIGV2ZW50cyA9IHJlcXVpcmUoJy4vZXZlbnRzJyk7XG5cbiAgTWFya2VkWUFNTEVycm9yID0gcmVxdWlyZSgnLi9lcnJvcnMnKS5NYXJrZWRZQU1MRXJyb3I7XG5cbiAgbm9kZXMgPSByZXF1aXJlKCcuL25vZGVzJyk7XG5cbiAgcmFtbCA9IHJlcXVpcmUoJy4vcmFtbCcpO1xuXG4gIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuICB0aGlzLkNvbXBvc2VyRXJyb3IgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbXBvc2VyRXJyb3IsIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBDb21wb3NlckVycm9yKCkge1xuICAgICAgX3JlZiA9IENvbXBvc2VyRXJyb3IuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gX3JlZjtcbiAgICB9XG5cbiAgICByZXR1cm4gQ29tcG9zZXJFcnJvcjtcblxuICB9KShNYXJrZWRZQU1MRXJyb3IpO1xuXG4gIHRoaXMuQ29tcG9zZXIgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gQ29tcG9zZXIoKSB7XG4gICAgICB0aGlzLmNvbXBvc2VSYW1sVHJlZSA9IF9fYmluZCh0aGlzLmNvbXBvc2VSYW1sVHJlZSwgdGhpcyk7XG4gICAgICB0aGlzLmFuY2hvcnMgPSB7fTtcbiAgICAgIHRoaXMuZmlsZXNUb1JlYWQgPSBbXTtcbiAgICB9XG5cbiAgICBDb21wb3Nlci5wcm90b3R5cGUuY2hlY2tfbm9kZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuY2hlY2tfZXZlbnQoZXZlbnRzLlN0cmVhbVN0YXJ0RXZlbnQpKSB7XG4gICAgICAgIHRoaXMuZ2V0X2V2ZW50KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gIXRoaXMuY2hlY2tfZXZlbnQoZXZlbnRzLlN0cmVhbUVuZEV2ZW50KTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBHZXQgdGhlIHJvb3Qgbm9kZSBvZiB0aGUgbmV4dCBkb2N1bWVudC5cbiAgICAqL1xuXG5cbiAgICBDb21wb3Nlci5wcm90b3R5cGUuZ2V0X25vZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5jaGVja19ldmVudChldmVudHMuU3RyZWFtRW5kRXZlbnQpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvc2VfZG9jdW1lbnQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ29tcG9zZXIucHJvdG90eXBlLmdldFlhbWxSb290ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZG9jdW1lbnQsIGV2ZW50O1xuICAgICAgdGhpcy5nZXRfZXZlbnQoKTtcbiAgICAgIGRvY3VtZW50ID0gbnVsbDtcbiAgICAgIGlmICghdGhpcy5jaGVja19ldmVudChldmVudHMuU3RyZWFtRW5kRXZlbnQpKSB7XG4gICAgICAgIGRvY3VtZW50ID0gdGhpcy5jb21wb3NlX2RvY3VtZW50KCk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuY2hlY2tfZXZlbnQoZXZlbnRzLlN0cmVhbUVuZEV2ZW50KSkge1xuICAgICAgICBldmVudCA9IHRoaXMuZ2V0X2V2ZW50KCk7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLkNvbXBvc2VyRXJyb3IoJ2RvY3VtZW50IHNjYW4nLCBkb2N1bWVudC5zdGFydF9tYXJrLCAnZXhwZWN0ZWQgYSBzaW5nbGUgZG9jdW1lbnQgaW4gdGhlIHN0cmVhbSBidXQgZm91bmQgYW5vdGhlciBkb2N1bWVudCcsIGV2ZW50LnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgdGhpcy5nZXRfZXZlbnQoKTtcbiAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICB9O1xuXG4gICAgQ29tcG9zZXIucHJvdG90eXBlLmNvbXBvc2VSYW1sVHJlZSA9IGZ1bmN0aW9uKG5vZGUsIHNldHRpbmdzKSB7XG4gICAgICBpZiAoc2V0dGluZ3MudmFsaWRhdGUgfHwgc2V0dGluZ3MudHJhbnNmb3JtKSB7XG4gICAgICAgIHRoaXMubG9hZF9zY2hlbWFzKG5vZGUpO1xuICAgICAgICB0aGlzLmxvYWRfdHJhaXRzKG5vZGUpO1xuICAgICAgICB0aGlzLmxvYWRfdHlwZXMobm9kZSk7XG4gICAgICAgIHRoaXMubG9hZF9zZWN1cml0eV9zY2hlbWVzKG5vZGUpO1xuICAgICAgfVxuICAgICAgaWYgKHNldHRpbmdzLnZhbGlkYXRlKSB7XG4gICAgICAgIHRoaXMudmFsaWRhdGVfZG9jdW1lbnQobm9kZSk7XG4gICAgICB9XG4gICAgICBpZiAoc2V0dGluZ3MudHJhbnNmb3JtKSB7XG4gICAgICAgIHRoaXMuYXBwbHlfdHlwZXMobm9kZSk7XG4gICAgICAgIHRoaXMuYXBwbHlfdHJhaXRzKG5vZGUpO1xuICAgICAgICB0aGlzLmFwcGx5X3NjaGVtYXMobm9kZSk7XG4gICAgICAgIHRoaXMuYXBwbHlfcHJvdG9jb2xzKG5vZGUpO1xuICAgICAgICB0aGlzLmpvaW5fcmVzb3VyY2VzKG5vZGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcblxuICAgIENvbXBvc2VyLnByb3RvdHlwZS5jb21wb3NlX2RvY3VtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbm9kZTtcbiAgICAgIHRoaXMuZ2V0X2V2ZW50KCk7XG4gICAgICBub2RlID0gdGhpcy5jb21wb3NlX25vZGUoKTtcbiAgICAgIHRoaXMuZ2V0X2V2ZW50KCk7XG4gICAgICB0aGlzLmFuY2hvcnMgPSB7fTtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG5cbiAgICBDb21wb3Nlci5wcm90b3R5cGUuZ2V0UGVuZGluZ0ZpbGVzTGlzdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmlsZXNUb1JlYWQ7XG4gICAgfTtcblxuICAgIENvbXBvc2VyLnByb3RvdHlwZS5jb21wb3NlX25vZGUgPSBmdW5jdGlvbihwYXJlbnQsIGluZGV4KSB7XG4gICAgICB2YXIgYW5jaG9yLCBldmVudCwgbm9kZTtcbiAgICAgIGlmICh0aGlzLmNoZWNrX2V2ZW50KGV2ZW50cy5BbGlhc0V2ZW50KSkge1xuICAgICAgICBldmVudCA9IHRoaXMuZ2V0X2V2ZW50KCk7XG4gICAgICAgIGFuY2hvciA9IGV2ZW50LmFuY2hvcjtcbiAgICAgICAgaWYgKCEoYW5jaG9yIGluIHRoaXMuYW5jaG9ycykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Db21wb3NlckVycm9yKG51bGwsIG51bGwsIFwiZm91bmQgdW5kZWZpbmVkIGFsaWFzIFwiICsgYW5jaG9yLCBldmVudC5zdGFydF9tYXJrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hbmNob3JzW2FuY2hvcl0uY2xvbmUoKTtcbiAgICAgIH1cbiAgICAgIGV2ZW50ID0gdGhpcy5wZWVrX2V2ZW50KCk7XG4gICAgICBhbmNob3IgPSBldmVudC5hbmNob3I7XG4gICAgICBpZiAoYW5jaG9yICE9PSBudWxsICYmIGFuY2hvciBpbiB0aGlzLmFuY2hvcnMpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuQ29tcG9zZXJFcnJvcihcImZvdW5kIGR1cGxpY2F0ZSBhbmNob3IgXCIgKyBhbmNob3IgKyBcIjsgZmlyc3Qgb2NjdXJlbmNlXCIsIHRoaXMuYW5jaG9yc1thbmNob3JdLnN0YXJ0X21hcmssICdzZWNvbmQgb2NjdXJyZW5jZScsIGV2ZW50LnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgdGhpcy5kZXNjZW5kX3Jlc29sdmVyKHBhcmVudCwgaW5kZXgpO1xuICAgICAgaWYgKHRoaXMuY2hlY2tfZXZlbnQoZXZlbnRzLlNjYWxhckV2ZW50KSkge1xuICAgICAgICBub2RlID0gdGhpcy5jb21wb3NlX3NjYWxhcl9ub2RlKGFuY2hvciwgcGFyZW50LCBpbmRleCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuY2hlY2tfZXZlbnQoZXZlbnRzLlNlcXVlbmNlU3RhcnRFdmVudCkpIHtcbiAgICAgICAgbm9kZSA9IHRoaXMuY29tcG9zZV9zZXF1ZW5jZV9ub2RlKGFuY2hvcik7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuY2hlY2tfZXZlbnQoZXZlbnRzLk1hcHBpbmdTdGFydEV2ZW50KSkge1xuICAgICAgICBub2RlID0gdGhpcy5jb21wb3NlX21hcHBpbmdfbm9kZShhbmNob3IpO1xuICAgICAgfVxuICAgICAgdGhpcy5hc2NlbmRfcmVzb2x2ZXIoKTtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG5cbiAgICBDb21wb3Nlci5wcm90b3R5cGUuY29tcG9zZV9maXhlZF9zY2FsYXJfbm9kZSA9IGZ1bmN0aW9uKGFuY2hvciwgdmFsdWUpIHtcbiAgICAgIHZhciBldmVudCwgbm9kZTtcbiAgICAgIGV2ZW50ID0gdGhpcy5nZXRfZXZlbnQoKTtcbiAgICAgIG5vZGUgPSBuZXcgbm9kZXMuU2NhbGFyTm9kZSgndGFnOnlhbWwub3JnLDIwMDI6c3RyJywgdmFsdWUsIGV2ZW50LnN0YXJ0X21hcmssIGV2ZW50LmVuZF9tYXJrLCBldmVudC5zdHlsZSk7XG4gICAgICBpZiAoYW5jaG9yICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuYW5jaG9yc1thbmNob3JdID0gbm9kZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG5cbiAgICBDb21wb3Nlci5wcm90b3R5cGUuY29tcG9zZV9zY2FsYXJfbm9kZSA9IGZ1bmN0aW9uKGFuY2hvciwgcGFyZW50LCBrZXkpIHtcbiAgICAgIHZhciBldmVudCwgZXh0ZW5zaW9uLCBmaWxlVHlwZSwgbm9kZSwgdGFnO1xuICAgICAgZXZlbnQgPSB0aGlzLmdldF9ldmVudCgpO1xuICAgICAgdGFnID0gZXZlbnQudGFnO1xuICAgICAgbm9kZSA9IHt9O1xuICAgICAgaWYgKHRhZyA9PT0gbnVsbCB8fCB0YWcgPT09ICchJykge1xuICAgICAgICB0YWcgPSB0aGlzLnJlc29sdmUobm9kZXMuU2NhbGFyTm9kZSwgZXZlbnQudmFsdWUsIGV2ZW50LmltcGxpY2l0KTtcbiAgICAgIH1cbiAgICAgIGlmIChldmVudC50YWcgPT09ICchaW5jbHVkZScpIHtcbiAgICAgICAgaWYgKGV2ZW50LnZhbHVlLm1hdGNoKC9eXFxzKiQvKSkge1xuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLkNvbXBvc2VyRXJyb3IoJ3doaWxlIGNvbXBvc2luZyBzY2FsYXIgb3V0IG9mICFpbmNsdWRlJywgbnVsbCwgXCJmaWxlIG5hbWUvVVJMIGNhbm5vdCBiZSBudWxsXCIsIGV2ZW50LnN0YXJ0X21hcmspO1xuICAgICAgICB9XG4gICAgICAgIGV4dGVuc2lvbiA9IGV2ZW50LnZhbHVlLnNwbGl0KCcuJykucG9wKCk7XG4gICAgICAgIGlmIChleHRlbnNpb24gPT09ICd5YW1sJyB8fCBleHRlbnNpb24gPT09ICd5bWwnIHx8IGV4dGVuc2lvbiA9PT0gJ3JhbWwnKSB7XG4gICAgICAgICAgZmlsZVR5cGUgPSAnZnJhZ21lbnQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpbGVUeXBlID0gJ3NjYWxhcic7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maWxlc1RvUmVhZC5wdXNoKHtcbiAgICAgICAgICB0YXJnZXRVcmk6IGV2ZW50LnZhbHVlLFxuICAgICAgICAgIHR5cGU6IGZpbGVUeXBlLFxuICAgICAgICAgIHBhcmVudE5vZGU6IHBhcmVudCxcbiAgICAgICAgICBwYXJlbnRLZXk6IGtleSxcbiAgICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgICAgaW5jbHVkaW5nQ29udGV4dDogdGhpcy5zcmMsXG4gICAgICAgICAgdGFyZ2V0RmlsZVVyaTogZXZlbnQudmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIG5vZGUgPSB2b2lkIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlID0gbmV3IG5vZGVzLlNjYWxhck5vZGUodGFnLCBldmVudC52YWx1ZSwgZXZlbnQuc3RhcnRfbWFyaywgZXZlbnQuZW5kX21hcmssIGV2ZW50LnN0eWxlKTtcbiAgICAgIH1cbiAgICAgIGlmIChhbmNob3IgJiYgbm9kZSkge1xuICAgICAgICB0aGlzLmFuY2hvcnNbYW5jaG9yXSA9IG5vZGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuXG4gICAgQ29tcG9zZXIucHJvdG90eXBlLmNvbXBvc2Vfc2VxdWVuY2Vfbm9kZSA9IGZ1bmN0aW9uKGFuY2hvcikge1xuICAgICAgdmFyIGVuZF9ldmVudCwgaW5kZXgsIG5vZGUsIHN0YXJ0X2V2ZW50LCB0YWcsIHZhbHVlO1xuICAgICAgc3RhcnRfZXZlbnQgPSB0aGlzLmdldF9ldmVudCgpO1xuICAgICAgdGFnID0gc3RhcnRfZXZlbnQudGFnO1xuICAgICAgaWYgKHRhZyA9PT0gbnVsbCB8fCB0YWcgPT09ICchJykge1xuICAgICAgICB0YWcgPSB0aGlzLnJlc29sdmUobm9kZXMuU2VxdWVuY2VOb2RlLCBudWxsLCBzdGFydF9ldmVudC5pbXBsaWNpdCk7XG4gICAgICB9XG4gICAgICBub2RlID0gbmV3IG5vZGVzLlNlcXVlbmNlTm9kZSh0YWcsIFtdLCBzdGFydF9ldmVudC5zdGFydF9tYXJrLCBudWxsLCBzdGFydF9ldmVudC5mbG93X3N0eWxlKTtcbiAgICAgIGluZGV4ID0gMDtcbiAgICAgIGlmIChhbmNob3IpIHtcbiAgICAgICAgdGhpcy5hbmNob3JzW2FuY2hvcl0gPSBub2RlO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCF0aGlzLmNoZWNrX2V2ZW50KGV2ZW50cy5TZXF1ZW5jZUVuZEV2ZW50KSkge1xuICAgICAgICBpZiAodmFsdWUgPSB0aGlzLmNvbXBvc2Vfbm9kZShub2RlLCBpbmRleCkpIHtcbiAgICAgICAgICBub2RlLnZhbHVlW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4Kys7XG4gICAgICB9XG4gICAgICBlbmRfZXZlbnQgPSB0aGlzLmdldF9ldmVudCgpO1xuICAgICAgbm9kZS5lbmRfbWFyayA9IGVuZF9ldmVudC5lbmRfbWFyaztcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG5cbiAgICBDb21wb3Nlci5wcm90b3R5cGUuY29tcG9zZV9tYXBwaW5nX25vZGUgPSBmdW5jdGlvbihhbmNob3IpIHtcbiAgICAgIHZhciBlbmRfZXZlbnQsIGl0ZW1fa2V5LCBpdGVtX3ZhbHVlLCBub2RlLCBzdGFydF9ldmVudCwgdGFnO1xuICAgICAgc3RhcnRfZXZlbnQgPSB0aGlzLmdldF9ldmVudCgpO1xuICAgICAgdGFnID0gc3RhcnRfZXZlbnQudGFnO1xuICAgICAgaWYgKHRhZyA9PT0gbnVsbCB8fCB0YWcgPT09ICchJykge1xuICAgICAgICB0YWcgPSB0aGlzLnJlc29sdmUobm9kZXMuTWFwcGluZ05vZGUsIG51bGwsIHN0YXJ0X2V2ZW50LmltcGxpY2l0KTtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBuZXcgbm9kZXMuTWFwcGluZ05vZGUodGFnLCBbXSwgc3RhcnRfZXZlbnQuc3RhcnRfbWFyaywgbnVsbCwgc3RhcnRfZXZlbnQuZmxvd19zdHlsZSk7XG4gICAgICBpZiAoYW5jaG9yICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuYW5jaG9yc1thbmNob3JdID0gbm9kZTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICghdGhpcy5jaGVja19ldmVudChldmVudHMuTWFwcGluZ0VuZEV2ZW50KSkge1xuICAgICAgICBpdGVtX2tleSA9IHRoaXMuY29tcG9zZV9ub2RlKG5vZGUpO1xuICAgICAgICBpZiAoIXV0aWwuaXNTY2FsYXIoaXRlbV9rZXkpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuQ29tcG9zZXJFcnJvcignd2hpbGUgY29tcG9zaW5nIG1hcHBpbmcga2V5JywgbnVsbCwgXCJvbmx5IHNjYWxhciBtYXAga2V5cyBhcmUgYWxsb3dlZCBpbiBSQU1MXCIsIGl0ZW1fa2V5LnN0YXJ0X21hcmspO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtX3ZhbHVlID0gdGhpcy5jb21wb3NlX25vZGUobm9kZSwgaXRlbV9rZXkpKSB7XG4gICAgICAgICAgbm9kZS52YWx1ZS5wdXNoKFtpdGVtX2tleSwgaXRlbV92YWx1ZV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbmRfZXZlbnQgPSB0aGlzLmdldF9ldmVudCgpO1xuICAgICAgbm9kZS5lbmRfbWFyayA9IGVuZF9ldmVudC5lbmRfbWFyaztcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG5cbiAgICByZXR1cm4gQ29tcG9zZXI7XG5cbiAgfSkoKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIihmdW5jdGlvbigpIHtcbiAgdmFyIE1hcmtlZFlBTUxFcnJvciwgbm9kZXMsIHV0aWwsIF9yZWYsIF9yZWYxLFxuICAgIF9faGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LFxuICAgIF9fZXh0ZW5kcyA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoX19oYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuICAgIF9faW5kZXhPZiA9IFtdLmluZGV4T2YgfHwgZnVuY3Rpb24oaXRlbSkgeyBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7IGlmIChpIGluIHRoaXMgJiYgdGhpc1tpXSA9PT0gaXRlbSkgcmV0dXJuIGk7IH0gcmV0dXJuIC0xOyB9O1xuXG4gIE1hcmtlZFlBTUxFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3JzJykuTWFya2VkWUFNTEVycm9yO1xuXG4gIG5vZGVzID0gcmVxdWlyZSgnLi9ub2RlcycpO1xuXG4gIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuICB0aGlzLkNvbnN0cnVjdG9yRXJyb3IgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbnN0cnVjdG9yRXJyb3IsIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBDb25zdHJ1Y3RvckVycm9yKCkge1xuICAgICAgX3JlZiA9IENvbnN0cnVjdG9yRXJyb3IuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gX3JlZjtcbiAgICB9XG5cbiAgICByZXR1cm4gQ29uc3RydWN0b3JFcnJvcjtcblxuICB9KShNYXJrZWRZQU1MRXJyb3IpO1xuXG4gIHRoaXMuQmFzZUNvbnN0cnVjdG9yID0gKGZ1bmN0aW9uKCkge1xuICAgIEJhc2VDb25zdHJ1Y3Rvci5wcm90b3R5cGUueWFtbF9jb25zdHJ1Y3RvcnMgPSB7fTtcblxuICAgIEJhc2VDb25zdHJ1Y3Rvci5wcm90b3R5cGUueWFtbF9tdWx0aV9jb25zdHJ1Y3RvcnMgPSB7fTtcblxuICAgIEJhc2VDb25zdHJ1Y3Rvci5hZGRfY29uc3RydWN0b3IgPSBmdW5jdGlvbih0YWcsIGNvbnN0cnVjdG9yKSB7XG4gICAgICBpZiAoIXRoaXMucHJvdG90eXBlLmhhc093blByb3BlcnR5KCd5YW1sX2NvbnN0cnVjdG9ycycpKSB7XG4gICAgICAgIHRoaXMucHJvdG90eXBlLnlhbWxfY29uc3RydWN0b3JzID0gdXRpbC5leHRlbmQoe30sIHRoaXMucHJvdG90eXBlLnlhbWxfY29uc3RydWN0b3JzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnByb3RvdHlwZS55YW1sX2NvbnN0cnVjdG9yc1t0YWddID0gY29uc3RydWN0b3I7XG4gICAgfTtcblxuICAgIEJhc2VDb25zdHJ1Y3Rvci5hZGRfbXVsdGlfY29uc3RydWN0b3IgPSBmdW5jdGlvbih0YWdfcHJlZml4LCBtdWx0aV9jb25zdHJ1Y3Rvcikge1xuICAgICAgaWYgKCF0aGlzLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgneWFtbF9tdWx0aV9jb25zdHJ1Y3RvcnMnKSkge1xuICAgICAgICB0aGlzLnByb3RvdHlwZS55YW1sX211bHRpX2NvbnN0cnVjdG9ycyA9IHV0aWwuZXh0ZW5kKHt9LCB0aGlzLnByb3RvdHlwZS55YW1sX211bHRpX2NvbnN0cnVjdG9ycyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5wcm90b3R5cGUueWFtbF9tdWx0aV9jb25zdHJ1Y3RvcnNbdGFnX3ByZWZpeF0gPSBtdWx0aV9jb25zdHJ1Y3RvcjtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gQmFzZUNvbnN0cnVjdG9yKCkge1xuICAgICAgdGhpcy5jb25zdHJ1Y3RlZF9vYmplY3RzID0ge307XG4gICAgICB0aGlzLmNvbnN0cnVjdGluZ19ub2RlcyA9IFtdO1xuICAgICAgdGhpcy5kZWZlcnJlZF9jb25zdHJ1Y3RvcnMgPSBbXTtcbiAgICB9XG5cbiAgICBCYXNlQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdF9kb2N1bWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBkYXRhO1xuICAgICAgdGhpcy5hcHBseUFzdFRyYW5zZm9ybWF0aW9ucyhub2RlKTtcbiAgICAgIGRhdGEgPSB0aGlzLmNvbnN0cnVjdF9vYmplY3Qobm9kZSk7XG4gICAgICB3aGlsZSAoIXV0aWwuaXNfZW1wdHkodGhpcy5kZWZlcnJlZF9jb25zdHJ1Y3RvcnMpKSB7XG4gICAgICAgIHRoaXMuZGVmZXJyZWRfY29uc3RydWN0b3JzLnBvcCgpKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmFwcGx5VHJhbnNmb3JtYXRpb25zKGRhdGEpO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcblxuICAgIEJhc2VDb25zdHJ1Y3Rvci5wcm90b3R5cGUuZGVmZXIgPSBmdW5jdGlvbihmKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWZlcnJlZF9jb25zdHJ1Y3RvcnMucHVzaChmKTtcbiAgICB9O1xuXG4gICAgQmFzZUNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3Rfb2JqZWN0ID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIGNvbnN0cnVjdG9yLCBvYmplY3QsIHRhZ19wcmVmaXgsIHRhZ19zdWZmaXgsIF9yZWYxO1xuICAgICAgaWYgKG5vZGUudW5pcXVlX2lkIGluIHRoaXMuY29uc3RydWN0ZWRfb2JqZWN0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3RlZF9vYmplY3RzW25vZGUudW5pcXVlX2lkXTtcbiAgICAgIH1cbiAgICAgIGlmIChfcmVmMSA9IG5vZGUudW5pcXVlX2lkLCBfX2luZGV4T2YuY2FsbCh0aGlzLmNvbnN0cnVjdGluZ19ub2RlcywgX3JlZjEpID49IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuQ29uc3RydWN0b3JFcnJvcihudWxsLCBudWxsLCAnZm91bmQgdW5jb25zdHJ1Y3RhYmxlIHJlY3Vyc2l2ZSBub2RlJywgbm9kZS5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29uc3RydWN0aW5nX25vZGVzLnB1c2gobm9kZS51bmlxdWVfaWQpO1xuICAgICAgY29uc3RydWN0b3IgPSBudWxsO1xuICAgICAgdGFnX3N1ZmZpeCA9IG51bGw7XG4gICAgICBpZiAobm9kZS50YWcgaW4gdGhpcy55YW1sX2NvbnN0cnVjdG9ycykge1xuICAgICAgICBjb25zdHJ1Y3RvciA9IHRoaXMueWFtbF9jb25zdHJ1Y3RvcnNbbm9kZS50YWddO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh0YWdfcHJlZml4IGluIHRoaXMueWFtbF9tdWx0aV9jb25zdHJ1Y3RvcnMpIHtcbiAgICAgICAgICBpZiAobm9kZS50YWcuaW5kZXhPZih0YWdfcHJlZml4ID09PSAwKSkge1xuICAgICAgICAgICAgdGFnX3N1ZmZpeCA9IG5vZGUudGFnLnNsaWNlKHRhZ19wcmVmaXgubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yID0gdGhpcy55YW1sX211bHRpX2NvbnN0cnVjdG9yc1t0YWdfcHJlZml4XTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uc3RydWN0b3IgPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChudWxsIGluIHRoaXMueWFtbF9tdWx0aV9jb25zdHJ1Y3RvcnMpIHtcbiAgICAgICAgICAgIHRhZ19zdWZmaXggPSBub2RlLnRhZztcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yID0gdGhpcy55YW1sX211bHRpX2NvbnN0cnVjdG9yc1tudWxsXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG51bGwgaW4gdGhpcy55YW1sX2NvbnN0cnVjdG9ycykge1xuICAgICAgICAgICAgY29uc3RydWN0b3IgPSB0aGlzLnlhbWxfY29uc3RydWN0b3JzW251bGxdO1xuICAgICAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIG5vZGVzLlNjYWxhck5vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yID0gdGhpcy5jb25zdHJ1Y3Rfc2NhbGFyO1xuICAgICAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIG5vZGVzLlNlcXVlbmNlTm9kZSkge1xuICAgICAgICAgICAgY29uc3RydWN0b3IgPSB0aGlzLmNvbnN0cnVjdF9zZXF1ZW5jZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBub2Rlcy5NYXBwaW5nTm9kZSkge1xuICAgICAgICAgICAgY29uc3RydWN0b3IgPSB0aGlzLmNvbnN0cnVjdF9tYXBwaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb2JqZWN0ID0gY29uc3RydWN0b3IuY2FsbCh0aGlzLCB0YWdfc3VmZml4ICE9IG51bGwgPyB0YWdfc3VmZml4IDogbm9kZSwgbm9kZSk7XG4gICAgICB0aGlzLmNvbnN0cnVjdGVkX29iamVjdHNbbm9kZS51bmlxdWVfaWRdID0gb2JqZWN0O1xuICAgICAgdGhpcy5jb25zdHJ1Y3Rpbmdfbm9kZXMucG9wKCk7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH07XG5cbiAgICBCYXNlQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdF9zY2FsYXIgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICBpZiAoIShub2RlIGluc3RhbmNlb2Ygbm9kZXMuU2NhbGFyTm9kZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuQ29uc3RydWN0b3JFcnJvcihudWxsLCBudWxsLCBcImV4cGVjdGVkIGEgc2NhbGFyIG5vZGUgYnV0IGZvdW5kIFwiICsgbm9kZS5pZCwgbm9kZS5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlLnZhbHVlO1xuICAgIH07XG5cbiAgICBCYXNlQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdF9zZXF1ZW5jZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBjaGlsZCwgX2ksIF9sZW4sIF9yZWYxLCBfcmVzdWx0cztcbiAgICAgIGlmICghKG5vZGUgaW5zdGFuY2VvZiBub2Rlcy5TZXF1ZW5jZU5vZGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLkNvbnN0cnVjdG9yRXJyb3IobnVsbCwgbnVsbCwgXCJleHBlY3RlZCBhbiBhcnJheSBub2RlIGJ1dCBmb3VuZCBcIiArIG5vZGUuaWQsIG5vZGUuc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICBfcmVmMSA9IG5vZGUudmFsdWU7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBjaGlsZCA9IF9yZWYxW19pXTtcbiAgICAgICAgX3Jlc3VsdHMucHVzaCh0aGlzLmNvbnN0cnVjdF9vYmplY3QoY2hpbGQpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuXG4gICAgQmFzZUNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RfbWFwcGluZyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBrZXksIGtleV9pdGVtLCBrZXlfaXRlbV92YWx1ZSwga2V5X25vZGUsIG1hcHBpbmcsIHZhbHVlLCB2YWx1ZV9ub2RlLCBfaSwgX2osIF9sZW4sIF9sZW4xLCBfcmVmMSwgX3JlZjIsIF9yZWYzO1xuICAgICAgaWYgKCEobm9kZSBpbnN0YW5jZW9mIG5vZGVzLk1hcHBpbmdOb2RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Db25zdHJ1Y3RvckVycm9yKG51bGwsIG51bGwsIFwiZXhwZWN0ZWQgYSBtYXAgbm9kZSBidXQgZm91bmQgXCIgKyBub2RlLmlkLCBub2RlLnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgbWFwcGluZyA9IHt9O1xuICAgICAgX3JlZjEgPSBub2RlLnZhbHVlO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBfcmVmMiA9IF9yZWYxW19pXSwga2V5X25vZGUgPSBfcmVmMlswXSwgdmFsdWVfbm9kZSA9IF9yZWYyWzFdO1xuICAgICAgICBrZXkgPSB0aGlzLmNvbnN0cnVjdF9vYmplY3Qoa2V5X25vZGUpO1xuICAgICAgICB2YWx1ZSA9IHRoaXMuY29uc3RydWN0X29iamVjdCh2YWx1ZV9ub2RlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnICYmIGtleV9ub2RlLnRhZyA9PT0gJ3RhZzp5YW1sLm9yZywyMDAyOnNlcScpIHtcbiAgICAgICAgICBfcmVmMyA9IGtleV9ub2RlLnZhbHVlO1xuICAgICAgICAgIGZvciAoX2ogPSAwLCBfbGVuMSA9IF9yZWYzLmxlbmd0aDsgX2ogPCBfbGVuMTsgX2orKykge1xuICAgICAgICAgICAga2V5X2l0ZW0gPSBfcmVmM1tfal07XG4gICAgICAgICAgICBrZXlfaXRlbV92YWx1ZSA9IHRoaXMuY29uc3RydWN0X29iamVjdChrZXlfaXRlbSk7XG4gICAgICAgICAgICBtYXBwaW5nW2tleV9pdGVtX3ZhbHVlXSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLkNvbnN0cnVjdG9yRXJyb3IoJ3doaWxlIGNvbnN0cnVjdGluZyBhIG1hcCcsIG5vZGUuc3RhcnRfbWFyaywgJ2ZvdW5kIHVuaGFzaGFibGUga2V5Jywga2V5X25vZGUuc3RhcnRfbWFyayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWFwcGluZ1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXBwaW5nO1xuICAgIH07XG5cbiAgICBCYXNlQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdF9wYWlycyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBrZXksIGtleV9ub2RlLCBwYWlycywgdmFsdWUsIHZhbHVlX25vZGUsIF9pLCBfbGVuLCBfcmVmMSwgX3JlZjI7XG4gICAgICBpZiAoIShub2RlIGluc3RhbmNlb2Ygbm9kZXMuTWFwcGluZ05vZGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLkNvbnN0cnVjdG9yRXJyb3IobnVsbCwgbnVsbCwgXCJleHBlY3RlZCBhIG1hcCBub2RlIGJ1dCBmb3VuZCBcIiArIG5vZGUuaWQsIG5vZGUuc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICBwYWlycyA9IFtdO1xuICAgICAgX3JlZjEgPSBub2RlLnZhbHVlO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBfcmVmMiA9IF9yZWYxW19pXSwga2V5X25vZGUgPSBfcmVmMlswXSwgdmFsdWVfbm9kZSA9IF9yZWYyWzFdO1xuICAgICAgICBrZXkgPSB0aGlzLmNvbnN0cnVjdF9vYmplY3Qoa2V5X25vZGUpO1xuICAgICAgICB2YWx1ZSA9IHRoaXMuY29uc3RydWN0X29iamVjdCh2YWx1ZV9ub2RlKTtcbiAgICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhaXJzO1xuICAgIH07XG5cbiAgICByZXR1cm4gQmFzZUNvbnN0cnVjdG9yO1xuXG4gIH0pKCk7XG5cbiAgdGhpcy5Db25zdHJ1Y3RvciA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICB2YXIgQk9PTF9WQUxVRVMsIFRJTUVTVEFNUF9QQVJUUywgVElNRVNUQU1QX1JFR0VYO1xuXG4gICAgX19leHRlbmRzKENvbnN0cnVjdG9yLCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gQ29uc3RydWN0b3IoKSB7XG4gICAgICBfcmVmMSA9IENvbnN0cnVjdG9yLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIF9yZWYxO1xuICAgIH1cblxuICAgIEJPT0xfVkFMVUVTID0ge1xuICAgICAgXCJ0cnVlXCI6IHRydWUsXG4gICAgICBcImZhbHNlXCI6IGZhbHNlXG4gICAgfTtcblxuICAgIFRJTUVTVEFNUF9SRUdFWCA9IC9eKFswLTldWzAtOV1bMC05XVswLTldKS0oWzAtOV1bMC05XT8pLShbMC05XVswLTldPykoPzooPzpbVHRdfFtcXHgyMFxcdF0rKShbMC05XVswLTldPyk6KFswLTldWzAtOV0pOihbMC05XVswLTldKSg/OlxcLihbMC05XSopKT8oPzpbXFx4MjBcXHRdKihafChbLStdKShbMC05XVswLTldPykoPzo6KFswLTldWzAtOV0pKT8pKT8pPyQvO1xuXG4gICAgVElNRVNUQU1QX1BBUlRTID0ge1xuICAgICAgeWVhcjogMSxcbiAgICAgIG1vbnRoOiAyLFxuICAgICAgZGF5OiAzLFxuICAgICAgaG91cjogNCxcbiAgICAgIG1pbnV0ZTogNSxcbiAgICAgIHNlY29uZDogNixcbiAgICAgIGZyYWN0aW9uOiA3LFxuICAgICAgdHo6IDgsXG4gICAgICB0el9zaWduOiA5LFxuICAgICAgdHpfaG91cjogMTAsXG4gICAgICB0el9taW51dGU6IDExXG4gICAgfTtcblxuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS55YW1sX2NvbnN0cnVjdG9ycyA9IHt9O1xuXG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlLnlhbWxfbXVsdGlfY29uc3RydWN0b3JzID0ge307XG5cbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0X3NjYWxhciA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBrZXlfbm9kZSwgdmFsdWVfbm9kZSwgX2ksIF9sZW4sIF9yZWYyLCBfcmVmMztcbiAgICAgIGlmIChub2RlIGluc3RhbmNlb2Ygbm9kZXMuTWFwcGluZ05vZGUpIHtcbiAgICAgICAgX3JlZjIgPSBub2RlLnZhbHVlO1xuICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYyLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgX3JlZjMgPSBfcmVmMltfaV0sIGtleV9ub2RlID0gX3JlZjNbMF0sIHZhbHVlX25vZGUgPSBfcmVmM1sxXTtcbiAgICAgICAgICBpZiAoa2V5X25vZGUudGFnID09PSAndGFnOnlhbWwub3JnLDIwMDI6dmFsdWUnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rfc2NhbGFyKHZhbHVlX25vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIENvbnN0cnVjdG9yLl9fc3VwZXJfXy5jb25zdHJ1Y3Rfc2NhbGFyLmNhbGwodGhpcywgbm9kZSk7XG4gICAgfTtcblxuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5mbGF0dGVuX21hcHBpbmcgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgaW5kZXgsIGtleV9ub2RlLCBtZXJnZSwgc3VibWVyZ2UsIHN1Ym5vZGUsIHZhbHVlLCB2YWx1ZV9ub2RlLCBfaSwgX2osIF9sZW4sIF9sZW4xLCBfcmVmMiwgX3JlZjM7XG4gICAgICBtZXJnZSA9IFtdO1xuICAgICAgaW5kZXggPSAwO1xuICAgICAgd2hpbGUgKGluZGV4IDwgbm9kZS52YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgX3JlZjIgPSBub2RlLnZhbHVlW2luZGV4XSwga2V5X25vZGUgPSBfcmVmMlswXSwgdmFsdWVfbm9kZSA9IF9yZWYyWzFdO1xuICAgICAgICBpZiAoa2V5X25vZGUudGFnID09PSAndGFnOnlhbWwub3JnLDIwMDI6bWVyZ2UnKSB7XG4gICAgICAgICAgbm9kZS52YWx1ZS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgIGlmICh2YWx1ZV9ub2RlIGluc3RhbmNlb2Ygbm9kZXMuTWFwcGluZ05vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuZmxhdHRlbl9tYXBwaW5nKHZhbHVlX25vZGUpO1xuICAgICAgICAgICAgbWVyZ2UgPSBtZXJnZS5jb25jYXQodmFsdWVfbm9kZS52YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZV9ub2RlIGluc3RhbmNlb2Ygbm9kZXMuU2VxdWVuY2VOb2RlKSB7XG4gICAgICAgICAgICBzdWJtZXJnZSA9IFtdO1xuICAgICAgICAgICAgX3JlZjMgPSB2YWx1ZV9ub2RlLnZhbHVlO1xuICAgICAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgICAgICBzdWJub2RlID0gX3JlZjNbX2ldO1xuICAgICAgICAgICAgICBpZiAoIShzdWJub2RlIGluc3RhbmNlb2Ygbm9kZXMuTWFwcGluZ05vZGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuQ29uc3RydWN0b3JFcnJvcignd2hpbGUgY29uc3RydWN0aW5nIGEgbWFwJywgbm9kZS5zdGFydF9tYXJrLCBcImV4cGVjdGVkIGEgbWFwIGZvciBtZXJnaW5nLCBidXQgZm91bmQgXCIgKyBzdWJub2RlLmlkLCBzdWJub2RlLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuZmxhdHRlbl9tYXBwaW5nKHN1Ym5vZGUpO1xuICAgICAgICAgICAgICBzdWJtZXJnZS5wdXNoKHN1Ym5vZGUudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3VibWVyZ2UucmV2ZXJzZSgpO1xuICAgICAgICAgICAgZm9yIChfaiA9IDAsIF9sZW4xID0gc3VibWVyZ2UubGVuZ3RoOyBfaiA8IF9sZW4xOyBfaisrKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gc3VibWVyZ2VbX2pdO1xuICAgICAgICAgICAgICBtZXJnZSA9IG1lcmdlLmNvbmNhdCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLkNvbnN0cnVjdG9yRXJyb3IoJ3doaWxlIGNvbnN0cnVjdGluZyBhIG1hcCcsIG5vZGUuc3RhcnRfbWFyaywgXCJleHBlY3RlZCBhIG1hcCBvciBhbiBhcnJheSBvZiBtYXBzIGZvciAgICAgICAgICAgIG1lcmdpbmcgYnV0IGZvdW5kIFwiICsgdmFsdWVfbm9kZS5pZCwgdmFsdWVfbm9kZS5zdGFydF9tYXJrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5X25vZGUudGFnID09PSAndGFnOnlhbWwub3JnLDIwMDI6dmFsdWUnKSB7XG4gICAgICAgICAga2V5X25vZGUudGFnID0gJ3RhZzp5YW1sLm9yZywyMDAyOnN0cic7XG4gICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbmRleCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWVyZ2UubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBub2RlLnZhbHVlID0gbWVyZ2UuY29uY2F0KG5vZGUudmFsdWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0X21hcHBpbmcgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIG5vZGVzLk1hcHBpbmdOb2RlKSB7XG4gICAgICAgIHRoaXMuZmxhdHRlbl9tYXBwaW5nKG5vZGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIENvbnN0cnVjdG9yLl9fc3VwZXJfXy5jb25zdHJ1Y3RfbWFwcGluZy5jYWxsKHRoaXMsIG5vZGUpO1xuICAgIH07XG5cbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0X3lhbWxfbnVsbCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHRoaXMuY29uc3RydWN0X3NjYWxhcihub2RlKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0X3lhbWxfYm9vbCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciB2YWx1ZTtcbiAgICAgIHZhbHVlID0gdGhpcy5jb25zdHJ1Y3Rfc2NhbGFyKG5vZGUpO1xuICAgICAgcmV0dXJuIEJPT0xfVkFMVUVTW3ZhbHVlLnRvTG93ZXJDYXNlKCldO1xuICAgIH07XG5cbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0X3lhbWxfaW50ID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIGJhc2UsIGRpZ2l0LCBkaWdpdHMsIHBhcnQsIHNpZ24sIHZhbHVlLCBfaSwgX2xlbiwgX3JlZjI7XG4gICAgICB2YWx1ZSA9IHRoaXMuY29uc3RydWN0X3NjYWxhcihub2RlKTtcbiAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXy9nLCAnJyk7XG4gICAgICBzaWduID0gdmFsdWVbMF0gPT09ICctJyA/IC0xIDogMTtcbiAgICAgIGlmIChfcmVmMiA9IHZhbHVlWzBdLCBfX2luZGV4T2YuY2FsbCgnKy0nLCBfcmVmMikgPj0gMCkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDEpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID09PSAnMCcpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlLmluZGV4T2YoJzBiJykgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgMik7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlLmluZGV4T2YoJzB4JykgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgMTYpO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZS5pbmRleE9mKCcwbycpID09PSAwKSB7XG4gICAgICAgIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIDgpO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZVswXSA9PT0gJzAnKSB7XG4gICAgICAgIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsdWUsIDgpO1xuICAgICAgfSBlbHNlIGlmIChfX2luZGV4T2YuY2FsbCh2YWx1ZSwgJzonKSA+PSAwKSB7XG4gICAgICAgIGRpZ2l0cyA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgX2ksIF9sZW4sIF9yZWYzLCBfcmVzdWx0cztcbiAgICAgICAgICBfcmVmMyA9IHZhbHVlLnNwbGl0KC86L2cpO1xuICAgICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgICAgcGFydCA9IF9yZWYzW19pXTtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2gocGFyc2VJbnQocGFydCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIGRpZ2l0cy5yZXZlcnNlKCk7XG4gICAgICAgIGJhc2UgPSAxO1xuICAgICAgICB2YWx1ZSA9IDA7XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gZGlnaXRzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgZGlnaXQgPSBkaWdpdHNbX2ldO1xuICAgICAgICAgIHZhbHVlICs9IGRpZ2l0ICogYmFzZTtcbiAgICAgICAgICBiYXNlICo9IDYwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaWduICogdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2lnbiAqIHBhcnNlSW50KHZhbHVlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdF95YW1sX2Zsb2F0ID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIGJhc2UsIGRpZ2l0LCBkaWdpdHMsIHBhcnQsIHNpZ24sIHZhbHVlLCBfaSwgX2xlbiwgX3JlZjI7XG4gICAgICB2YWx1ZSA9IHRoaXMuY29uc3RydWN0X3NjYWxhcihub2RlKTtcbiAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXy9nLCAnJykudG9Mb3dlckNhc2UoKTtcbiAgICAgIHNpZ24gPSB2YWx1ZVswXSA9PT0gJy0nID8gLTEgOiAxO1xuICAgICAgaWYgKF9yZWYyID0gdmFsdWVbMF0sIF9faW5kZXhPZi5jYWxsKCcrLScsIF9yZWYyKSA+PSAwKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMSk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPT09ICcuaW5mJykge1xuICAgICAgICByZXR1cm4gc2lnbiAqIEluZmluaXR5O1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJy5uYW4nKSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgICB9IGVsc2UgaWYgKF9faW5kZXhPZi5jYWxsKHZhbHVlLCAnOicpID49IDApIHtcbiAgICAgICAgZGlnaXRzID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBfaSwgX2xlbiwgX3JlZjMsIF9yZXN1bHRzO1xuICAgICAgICAgIF9yZWYzID0gdmFsdWUuc3BsaXQoLzovZyk7XG4gICAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgICBwYXJ0ID0gX3JlZjNbX2ldO1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChwYXJzZUZsb2F0KHBhcnQpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgICB9KSgpO1xuICAgICAgICBkaWdpdHMucmV2ZXJzZSgpO1xuICAgICAgICBiYXNlID0gMTtcbiAgICAgICAgdmFsdWUgPSAwLjA7XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gZGlnaXRzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgZGlnaXQgPSBkaWdpdHNbX2ldO1xuICAgICAgICAgIHZhbHVlICs9IGRpZ2l0ICogYmFzZTtcbiAgICAgICAgICBiYXNlICo9IDYwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaWduICogdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2lnbiAqIHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0X3lhbWxfYmluYXJ5ID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIGVycm9yLCB2YWx1ZTtcbiAgICAgIHZhbHVlID0gdGhpcy5jb25zdHJ1Y3Rfc2NhbGFyKG5vZGUpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93ICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGF0b2IodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyKHZhbHVlLCAnYmFzZTY0JykudG9TdHJpbmcoJ2FzY2lpJyk7XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgZXJyb3IgPSBfZXJyb3I7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLkNvbnN0cnVjdG9yRXJyb3IobnVsbCwgbnVsbCwgXCJmYWlsZWQgdG8gZGVjb2RlIGJhc2U2NCBkYXRhOiBcIiArIGVycm9yLCBub2RlLnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0X3lhbWxfdGltZXN0YW1wID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIGRhdGUsIGRheSwgZnJhY3Rpb24sIGhvdXIsIGluZGV4LCBrZXksIG1hdGNoLCBtaWxsaXNlY29uZCwgbWludXRlLCBtb250aCwgc2Vjb25kLCB0el9ob3VyLCB0el9taW51dGUsIHR6X3NpZ24sIHZhbHVlLCB2YWx1ZXMsIHllYXI7XG4gICAgICB2YWx1ZSA9IHRoaXMuY29uc3RydWN0X3NjYWxhcihub2RlKTtcbiAgICAgIG1hdGNoID0gbm9kZS52YWx1ZS5tYXRjaChUSU1FU1RBTVBfUkVHRVgpO1xuICAgICAgdmFsdWVzID0ge307XG4gICAgICBmb3IgKGtleSBpbiBUSU1FU1RBTVBfUEFSVFMpIHtcbiAgICAgICAgaW5kZXggPSBUSU1FU1RBTVBfUEFSVFNba2V5XTtcbiAgICAgICAgdmFsdWVzW2tleV0gPSBtYXRjaFtpbmRleF07XG4gICAgICB9XG4gICAgICB5ZWFyID0gcGFyc2VJbnQodmFsdWVzLnllYXIpO1xuICAgICAgbW9udGggPSBwYXJzZUludCh2YWx1ZXMubW9udGgpIC0gMTtcbiAgICAgIGRheSA9IHBhcnNlSW50KHZhbHVlcy5kYXkpO1xuICAgICAgaWYgKCF2YWx1ZXMuaG91cikge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGgsIGRheSkpO1xuICAgICAgfVxuICAgICAgaG91ciA9IHBhcnNlSW50KHZhbHVlcy5ob3VyKTtcbiAgICAgIG1pbnV0ZSA9IHBhcnNlSW50KHZhbHVlcy5taW51dGUpO1xuICAgICAgc2Vjb25kID0gcGFyc2VJbnQodmFsdWVzLnNlY29uZCk7XG4gICAgICBtaWxsaXNlY29uZCA9IDA7XG4gICAgICBpZiAodmFsdWVzLmZyYWN0aW9uKSB7XG4gICAgICAgIGZyYWN0aW9uID0gdmFsdWVzLmZyYWN0aW9uLnNsaWNlKDAsIDYpO1xuICAgICAgICB3aGlsZSAoZnJhY3Rpb24ubGVuZ3RoIDwgNikge1xuICAgICAgICAgIGZyYWN0aW9uICs9ICcwJztcbiAgICAgICAgfVxuICAgICAgICBmcmFjdGlvbiA9IHBhcnNlSW50KGZyYWN0aW9uKTtcbiAgICAgICAgbWlsbGlzZWNvbmQgPSBNYXRoLnJvdW5kKGZyYWN0aW9uIC8gMTAwMCk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWVzLnR6X3NpZ24pIHtcbiAgICAgICAgdHpfc2lnbiA9IHZhbHVlcy50el9zaWduID09PSAnLScgPyAxIDogLTE7XG4gICAgICAgIGlmICh0el9ob3VyID0gcGFyc2VJbnQodmFsdWVzLnR6X2hvdXIpKSB7XG4gICAgICAgICAgaG91ciArPSB0el9zaWduICogdHpfaG91cjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHpfbWludXRlID0gcGFyc2VJbnQodmFsdWVzLnR6X21pbnV0ZSkpIHtcbiAgICAgICAgICBtaW51dGUgKz0gdHpfc2lnbiAqIHR6X21pbnV0ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCkpO1xuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfTtcblxuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RfeWFtbF9wYWlyX2xpc3QgPSBmdW5jdGlvbih0eXBlLCBub2RlKSB7XG4gICAgICB2YXIgbGlzdCxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuICAgICAgbGlzdCA9IFtdO1xuICAgICAgaWYgKCEobm9kZSBpbnN0YW5jZW9mIG5vZGVzLlNlcXVlbmNlTm9kZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuQ29uc3RydWN0b3JFcnJvcihcIndoaWxlIGNvbnN0cnVjdGluZyBcIiArIHR5cGUsIG5vZGUuc3RhcnRfbWFyaywgXCJleHBlY3RlZCBhbiBhcnJheSBidXQgZm91bmQgXCIgKyBub2RlLmlkLCBub2RlLnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgdGhpcy5kZWZlcihmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGtleSwga2V5X25vZGUsIHN1Ym5vZGUsIHZhbHVlLCB2YWx1ZV9ub2RlLCBfaSwgX2xlbiwgX3JlZjIsIF9yZWYzLCBfcmVzdWx0cztcbiAgICAgICAgX3JlZjIgPSBub2RlLnZhbHVlO1xuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYyLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgc3Vibm9kZSA9IF9yZWYyW19pXTtcbiAgICAgICAgICBpZiAoIShzdWJub2RlIGluc3RhbmNlb2Ygbm9kZXMuTWFwcGluZ05vZGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Db25zdHJ1Y3RvckVycm9yKFwid2hpbGUgY29uc3RydWN0aW5nIFwiICsgdHlwZSwgbm9kZS5zdGFydF9tYXJrLCBcImV4cGVjdGVkIGEgbWFwIG9mIGxlbmd0aCAxIGJ1dCBmb3VuZCBcIiArIHN1Ym5vZGUuaWQsIHN1Ym5vZGUuc3RhcnRfbWFyayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdWJub2RlLnZhbHVlLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuQ29uc3RydWN0b3JFcnJvcihcIndoaWxlIGNvbnN0cnVjdGluZyBcIiArIHR5cGUsIG5vZGUuc3RhcnRfbWFyaywgXCJleHBlY3RlZCBhIG1hcCBvZiBsZW5ndGggMSBidXQgZm91bmQgXCIgKyBzdWJub2RlLmlkLCBzdWJub2RlLnN0YXJ0X21hcmspO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfcmVmMyA9IHN1Ym5vZGUudmFsdWVbMF0sIGtleV9ub2RlID0gX3JlZjNbMF0sIHZhbHVlX25vZGUgPSBfcmVmM1sxXTtcbiAgICAgICAgICBrZXkgPSBfdGhpcy5jb25zdHJ1Y3Rfb2JqZWN0KGtleV9ub2RlKTtcbiAgICAgICAgICB2YWx1ZSA9IF90aGlzLmNvbnN0cnVjdF9vYmplY3QodmFsdWVfbm9kZSk7XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaChsaXN0LnB1c2goW2tleSwgdmFsdWVdKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbGlzdDtcbiAgICB9O1xuXG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdF95YW1sX29tYXAgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3RfeWFtbF9wYWlyX2xpc3QoJ2FuIG9yZGVyZWQgbWFwJywgbm9kZSk7XG4gICAgfTtcblxuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RfeWFtbF9wYWlycyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdF95YW1sX3BhaXJfbGlzdCgncGFpcnMnLCBub2RlKTtcbiAgICB9O1xuXG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdF95YW1sX3NldCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBkYXRhLFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG4gICAgICBkYXRhID0gW107XG4gICAgICB0aGlzLmRlZmVyKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaXRlbSwgX3Jlc3VsdHM7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoaXRlbSBpbiBfdGhpcy5jb25zdHJ1Y3RfbWFwcGluZyhub2RlKSkge1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2goZGF0YS5wdXNoKGl0ZW0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH07XG5cbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0X3lhbWxfc3RyID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0X3NjYWxhcihub2RlKTtcbiAgICB9O1xuXG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdF95YW1sX3NlcSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBkYXRhLFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG4gICAgICBkYXRhID0gW107XG4gICAgICB0aGlzLmRlZmVyKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaXRlbSwgX2ksIF9sZW4sIF9yZWYyLCBfcmVzdWx0cztcbiAgICAgICAgX3JlZjIgPSBfdGhpcy5jb25zdHJ1Y3Rfc2VxdWVuY2Uobm9kZSk7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjIubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICBpdGVtID0gX3JlZjJbX2ldO1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2goZGF0YS5wdXNoKGl0ZW0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH07XG5cbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0X3lhbWxfbWFwID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIGRhdGEsXG4gICAgICAgIF90aGlzID0gdGhpcztcbiAgICAgIGRhdGEgPSB7fTtcbiAgICAgIHRoaXMuZGVmZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBrZXksIHZhbHVlLCBfcmVmMiwgX3Jlc3VsdHM7XG4gICAgICAgIF9yZWYyID0gX3RoaXMuY29uc3RydWN0X21hcHBpbmcobm9kZSk7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoa2V5IGluIF9yZWYyKSB7XG4gICAgICAgICAgdmFsdWUgPSBfcmVmMltrZXldO1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2goZGF0YVtrZXldID0gdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcblxuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RfeWFtbF9vYmplY3QgPSBmdW5jdGlvbihub2RlLCBrbGFzcykge1xuICAgICAgdmFyIGRhdGEsXG4gICAgICAgIF90aGlzID0gdGhpcztcbiAgICAgIGRhdGEgPSBuZXcga2xhc3M7XG4gICAgICB0aGlzLmRlZmVyKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIga2V5LCB2YWx1ZSwgX3JlZjIsIF9yZXN1bHRzO1xuICAgICAgICBfcmVmMiA9IF90aGlzLmNvbnN0cnVjdF9tYXBwaW5nKG5vZGUsIHRydWUpO1xuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGtleSBpbiBfcmVmMikge1xuICAgICAgICAgIHZhbHVlID0gX3JlZjJba2V5XTtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKGRhdGFba2V5XSA9IHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH07XG5cbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0X3VuZGVmaW5lZCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHRocm93IG5ldyBleHBvcnRzLkNvbnN0cnVjdG9yRXJyb3IobnVsbCwgbnVsbCwgXCJjb3VsZCBub3QgZGV0ZXJtaW5lIGEgY29uc3RydWN0b3IgZm9yIHRoZSB0YWcgXCIgKyBub2RlLnRhZywgbm9kZS5zdGFydF9tYXJrKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuXG4gIH0pKHRoaXMuQmFzZUNvbnN0cnVjdG9yKTtcblxuICB0aGlzLkNvbnN0cnVjdG9yLmFkZF9jb25zdHJ1Y3RvcigndGFnOnlhbWwub3JnLDIwMDI6bnVsbCcsIHRoaXMuQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdF95YW1sX251bGwpO1xuXG4gIHRoaXMuQ29uc3RydWN0b3IuYWRkX2NvbnN0cnVjdG9yKCd0YWc6eWFtbC5vcmcsMjAwMjpib29sJywgdGhpcy5Db25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0X3lhbWxfYm9vbCk7XG5cbiAgdGhpcy5Db25zdHJ1Y3Rvci5hZGRfY29uc3RydWN0b3IoJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsIHRoaXMuQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdF95YW1sX2ludCk7XG5cbiAgdGhpcy5Db25zdHJ1Y3Rvci5hZGRfY29uc3RydWN0b3IoJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0JywgdGhpcy5Db25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0X3lhbWxfZmxvYXQpO1xuXG4gIHRoaXMuQ29uc3RydWN0b3IuYWRkX2NvbnN0cnVjdG9yKCd0YWc6eWFtbC5vcmcsMjAwMjpiaW5hcnknLCB0aGlzLkNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RfeWFtbF9iaW5hcnkpO1xuXG4gIHRoaXMuQ29uc3RydWN0b3IuYWRkX2NvbnN0cnVjdG9yKCd0YWc6eWFtbC5vcmcsMjAwMjp0aW1lc3RhbXAnLCB0aGlzLkNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RfeWFtbF90aW1lc3RhbXApO1xuXG4gIHRoaXMuQ29uc3RydWN0b3IuYWRkX2NvbnN0cnVjdG9yKCd0YWc6eWFtbC5vcmcsMjAwMjpvbWFwJywgdGhpcy5Db25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0X3lhbWxfb21hcCk7XG5cbiAgdGhpcy5Db25zdHJ1Y3Rvci5hZGRfY29uc3RydWN0b3IoJ3RhZzp5YW1sLm9yZywyMDAyOnBhaXJzJywgdGhpcy5Db25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0X3lhbWxfcGFpcnMpO1xuXG4gIHRoaXMuQ29uc3RydWN0b3IuYWRkX2NvbnN0cnVjdG9yKCd0YWc6eWFtbC5vcmcsMjAwMjpzZXQnLCB0aGlzLkNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RfeWFtbF9zZXQpO1xuXG4gIHRoaXMuQ29uc3RydWN0b3IuYWRkX2NvbnN0cnVjdG9yKCd0YWc6eWFtbC5vcmcsMjAwMjpzdHInLCB0aGlzLkNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RfeWFtbF9zdHIpO1xuXG4gIHRoaXMuQ29uc3RydWN0b3IuYWRkX2NvbnN0cnVjdG9yKCd0YWc6eWFtbC5vcmcsMjAwMjpzZXEnLCB0aGlzLkNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RfeWFtbF9zZXEpO1xuXG4gIHRoaXMuQ29uc3RydWN0b3IuYWRkX2NvbnN0cnVjdG9yKCd0YWc6eWFtbC5vcmcsMjAwMjptYXAnLCB0aGlzLkNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RfeWFtbF9tYXApO1xuXG4gIHRoaXMuQ29uc3RydWN0b3IuYWRkX2NvbnN0cnVjdG9yKG51bGwsIHRoaXMuQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdF91bmRlZmluZWQpO1xuXG4gIG1vZHVsZS5leHBvcnRzLkNvbnN0cnVjdG9yID0gdGhpcy5Db25zdHJ1Y3RvcjtcblxuICBtb2R1bGUuZXhwb3J0cy5Db25zdHJ1Y3RvckVycm9yID0gdGhpcy5Db25zdHJ1Y3RvckVycm9yO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiKGZ1bmN0aW9uKCkge1xuICB2YXIgX3JlZixcbiAgICBfX2luZGV4T2YgPSBbXS5pbmRleE9mIHx8IGZ1bmN0aW9uKGl0ZW0pIHsgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykgeyBpZiAoaSBpbiB0aGlzICYmIHRoaXNbaV0gPT09IGl0ZW0pIHJldHVybiBpOyB9IHJldHVybiAtMTsgfSxcbiAgICBfX2hhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSxcbiAgICBfX2V4dGVuZHMgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKF9faGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfTtcblxuICB0aGlzLk1hcmsgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gTWFyayhuYW1lLCBsaW5lLCBjb2x1bW4sIGJ1ZmZlciwgcG9pbnRlcikge1xuICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgIHRoaXMubGluZSA9IGxpbmU7XG4gICAgICB0aGlzLmNvbHVtbiA9IGNvbHVtbjtcbiAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgdGhpcy5wb2ludGVyID0gcG9pbnRlcjtcbiAgICB9XG5cbiAgICBNYXJrLnByb3RvdHlwZS5nZXRfc25pcHBldCA9IGZ1bmN0aW9uKGluZGVudCwgbWF4X2xlbmd0aCkge1xuICAgICAgdmFyIGJyZWFrX2NoYXJzLCBlbmQsIGhlYWQsIHN0YXJ0LCB0YWlsLCBfcmVmLCBfcmVmMTtcbiAgICAgIGlmIChpbmRlbnQgPT0gbnVsbCkge1xuICAgICAgICBpbmRlbnQgPSA0O1xuICAgICAgfVxuICAgICAgaWYgKG1heF9sZW5ndGggPT0gbnVsbCkge1xuICAgICAgICBtYXhfbGVuZ3RoID0gNzU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5idWZmZXIgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGJyZWFrX2NoYXJzID0gJ1xceDAwXFxyXFxuXFx4ODVcXHUyMDI4XFx1MjAyOSc7XG4gICAgICBoZWFkID0gJyc7XG4gICAgICBzdGFydCA9IHRoaXMucG9pbnRlcjtcbiAgICAgIHdoaWxlIChzdGFydCA+IDAgJiYgKF9yZWYgPSB0aGlzLmJ1ZmZlcltzdGFydCAtIDFdLCBfX2luZGV4T2YuY2FsbChicmVha19jaGFycywgX3JlZikgPCAwKSkge1xuICAgICAgICBzdGFydC0tO1xuICAgICAgICBpZiAodGhpcy5wb2ludGVyIC0gc3RhcnQgPiBtYXhfbGVuZ3RoIC8gMiAtIDEpIHtcbiAgICAgICAgICBoZWFkID0gJyAuLi4gJztcbiAgICAgICAgICBzdGFydCArPSA1O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0YWlsID0gJyc7XG4gICAgICBlbmQgPSB0aGlzLnBvaW50ZXI7XG4gICAgICB3aGlsZSAoZW5kIDwgdGhpcy5idWZmZXIubGVuZ3RoICYmIChfcmVmMSA9IHRoaXMuYnVmZmVyW2VuZF0sIF9faW5kZXhPZi5jYWxsKGJyZWFrX2NoYXJzLCBfcmVmMSkgPCAwKSkge1xuICAgICAgICBlbmQrKztcbiAgICAgICAgaWYgKGVuZCAtIHRoaXMucG9pbnRlciA+IG1heF9sZW5ndGggLyAyIC0gMSkge1xuICAgICAgICAgIHRhaWwgPSAnIC4uLiAnO1xuICAgICAgICAgIGVuZCAtPSA1O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJcIiArICgobmV3IEFycmF5KGluZGVudCkpLmpvaW4oJyAnKSkgKyBoZWFkICsgdGhpcy5idWZmZXIuc2xpY2Uoc3RhcnQsIGVuZCkgKyB0YWlsICsgXCJcXG5cIiArICgobmV3IEFycmF5KGluZGVudCArIHRoaXMucG9pbnRlciAtIHN0YXJ0ICsgaGVhZC5sZW5ndGgpKS5qb2luKCcgJykpICsgXCJeXCI7XG4gICAgfTtcblxuICAgIE1hcmsucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc25pcHBldCwgd2hlcmU7XG4gICAgICBzbmlwcGV0ID0gdGhpcy5nZXRfc25pcHBldCgpO1xuICAgICAgd2hlcmUgPSBcIiAgaW4gXFxcIlwiICsgdGhpcy5uYW1lICsgXCJcXFwiLCBsaW5lIFwiICsgKHRoaXMubGluZSArIDEpICsgXCIsIGNvbHVtbiBcIiArICh0aGlzLmNvbHVtbiArIDEpO1xuICAgICAgaWYgKHNuaXBwZXQpIHtcbiAgICAgICAgcmV0dXJuIHdoZXJlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwiXCIgKyB3aGVyZSArIFwiOlxcblwiICsgc25pcHBldDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIE1hcms7XG5cbiAgfSkoKTtcblxuICB0aGlzLllBTUxFcnJvciA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoWUFNTEVycm9yLCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gWUFNTEVycm9yKCkge1xuICAgICAgWUFNTEVycm9yLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiBZQU1MRXJyb3I7XG5cbiAgfSkoRXJyb3IpO1xuXG4gIHRoaXMuTWFya2VkWUFNTEVycm9yID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYXJrZWRZQU1MRXJyb3IsIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBNYXJrZWRZQU1MRXJyb3IoY29udGV4dCwgY29udGV4dF9tYXJrLCBtZXNzYWdlLCBwcm9ibGVtX21hcmssIG5vdGUpIHtcbiAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICB0aGlzLmNvbnRleHRfbWFyayA9IGNvbnRleHRfbWFyaztcbiAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICB0aGlzLnByb2JsZW1fbWFyayA9IHByb2JsZW1fbWFyaztcbiAgICAgIHRoaXMubm90ZSA9IG5vdGU7XG4gICAgICBNYXJrZWRZQU1MRXJyb3IuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcyk7XG4gICAgICBpZiAoIXRoaXMubWVzc2FnZSkge1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLmNvbnRleHQ7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMucHJvYmxlbV9tYXJrKSB7XG4gICAgICAgIHRoaXMucHJvYmxlbV9tYXJrID0gdGhpcy5jb250ZXh0X21hcms7XG4gICAgICB9XG4gICAgfVxuXG4gICAgTWFya2VkWUFNTEVycm9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxpbmVzO1xuICAgICAgbGluZXMgPSBbXTtcbiAgICAgIGlmICh0aGlzLmNvbnRleHQgIT0gbnVsbCkge1xuICAgICAgICBsaW5lcy5wdXNoKHRoaXMuY29udGV4dCk7XG4gICAgICB9XG4gICAgICBpZiAoKHRoaXMuY29udGV4dF9tYXJrICE9IG51bGwpICYmICgodGhpcy5tZXNzYWdlID09IG51bGwpIHx8ICh0aGlzLnByb2JsZW1fbWFyayA9PSBudWxsKSB8fCB0aGlzLmNvbnRleHRfbWFyay5uYW1lICE9PSB0aGlzLnByb2JsZW1fbWFyay5uYW1lIHx8IHRoaXMuY29udGV4dF9tYXJrLmxpbmUgIT09IHRoaXMucHJvYmxlbV9tYXJrLmxpbmUgfHwgdGhpcy5jb250ZXh0X21hcmsuY29sdW1uICE9PSB0aGlzLnByb2JsZW1fbWFyay5jb2x1bW4pKSB7XG4gICAgICAgIGxpbmVzLnB1c2godGhpcy5jb250ZXh0X21hcmsudG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5tZXNzYWdlICE9IG51bGwpIHtcbiAgICAgICAgbGluZXMucHVzaCh0aGlzLm1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucHJvYmxlbV9tYXJrICE9IG51bGwpIHtcbiAgICAgICAgbGluZXMucHVzaCh0aGlzLnByb2JsZW1fbWFyay50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm5vdGUgIT0gbnVsbCkge1xuICAgICAgICBsaW5lcy5wdXNoKHRoaXMubm90ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGluZXMuam9pbignXFxuJyk7XG4gICAgfTtcblxuICAgIHJldHVybiBNYXJrZWRZQU1MRXJyb3I7XG5cbiAgfSkodGhpcy5ZQU1MRXJyb3IpO1xuXG4gIC8qXG4gIFRoZSBWYWxpZGF0b3IgdGhyb3dzIHRoZXNlLlxuICAqL1xuXG5cbiAgdGhpcy5WYWxpZGF0aW9uRXJyb3IgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFZhbGlkYXRpb25FcnJvciwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIFZhbGlkYXRpb25FcnJvcigpIHtcbiAgICAgIF9yZWYgPSBWYWxpZGF0aW9uRXJyb3IuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gX3JlZjtcbiAgICB9XG5cbiAgICByZXR1cm4gVmFsaWRhdGlvbkVycm9yO1xuXG4gIH0pKHRoaXMuTWFya2VkWUFNTEVycm9yKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIihmdW5jdGlvbigpIHtcbiAgdmFyIF9yZWYsIF9yZWYxLCBfcmVmMiwgX3JlZjMsIF9yZWY0LCBfcmVmNSwgX3JlZjYsXG4gICAgX19oYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksXG4gICAgX19leHRlbmRzID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChfX2hhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH07XG5cbiAgdGhpcy5FdmVudCA9IChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBFdmVudChzdGFydF9tYXJrLCBlbmRfbWFyaykge1xuICAgICAgdGhpcy5zdGFydF9tYXJrID0gc3RhcnRfbWFyaztcbiAgICAgIHRoaXMuZW5kX21hcmsgPSBlbmRfbWFyaztcbiAgICB9XG5cbiAgICByZXR1cm4gRXZlbnQ7XG5cbiAgfSkoKTtcblxuICB0aGlzLk5vZGVFdmVudCA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTm9kZUV2ZW50LCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gTm9kZUV2ZW50KGFuY2hvciwgc3RhcnRfbWFyaywgZW5kX21hcmspIHtcbiAgICAgIHRoaXMuYW5jaG9yID0gYW5jaG9yO1xuICAgICAgdGhpcy5zdGFydF9tYXJrID0gc3RhcnRfbWFyaztcbiAgICAgIHRoaXMuZW5kX21hcmsgPSBlbmRfbWFyaztcbiAgICB9XG5cbiAgICByZXR1cm4gTm9kZUV2ZW50O1xuXG4gIH0pKHRoaXMuRXZlbnQpO1xuXG4gIHRoaXMuQ29sbGVjdGlvblN0YXJ0RXZlbnQgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbGxlY3Rpb25TdGFydEV2ZW50LCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gQ29sbGVjdGlvblN0YXJ0RXZlbnQoYW5jaG9yLCB0YWcsIGltcGxpY2l0LCBzdGFydF9tYXJrLCBlbmRfbWFyaykge1xuICAgICAgdGhpcy5hbmNob3IgPSBhbmNob3I7XG4gICAgICB0aGlzLnRhZyA9IHRhZztcbiAgICAgIHRoaXMuaW1wbGljaXQgPSBpbXBsaWNpdDtcbiAgICAgIHRoaXMuc3RhcnRfbWFyayA9IHN0YXJ0X21hcms7XG4gICAgICB0aGlzLmVuZF9tYXJrID0gZW5kX21hcms7XG4gICAgfVxuXG4gICAgcmV0dXJuIENvbGxlY3Rpb25TdGFydEV2ZW50O1xuXG4gIH0pKHRoaXMuTm9kZUV2ZW50KTtcblxuICB0aGlzLkNvbGxlY3Rpb25FbmRFdmVudCA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29sbGVjdGlvbkVuZEV2ZW50LCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gQ29sbGVjdGlvbkVuZEV2ZW50KCkge1xuICAgICAgX3JlZiA9IENvbGxlY3Rpb25FbmRFdmVudC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfcmVmO1xuICAgIH1cblxuICAgIHJldHVybiBDb2xsZWN0aW9uRW5kRXZlbnQ7XG5cbiAgfSkodGhpcy5FdmVudCk7XG5cbiAgdGhpcy5TdHJlYW1TdGFydEV2ZW50ID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdHJlYW1TdGFydEV2ZW50LCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gU3RyZWFtU3RhcnRFdmVudChzdGFydF9tYXJrLCBlbmRfbWFyaywgZXhwbGljaXQsIHZlcnNpb24sIHRhZ3MpIHtcbiAgICAgIHRoaXMuc3RhcnRfbWFyayA9IHN0YXJ0X21hcms7XG4gICAgICB0aGlzLmVuZF9tYXJrID0gZW5kX21hcms7XG4gICAgICB0aGlzLmV4cGxpY2l0ID0gZXhwbGljaXQ7XG4gICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgdGhpcy50YWdzID0gdGFncztcbiAgICB9XG5cbiAgICByZXR1cm4gU3RyZWFtU3RhcnRFdmVudDtcblxuICB9KSh0aGlzLkV2ZW50KTtcblxuICB0aGlzLlN0cmVhbUVuZEV2ZW50ID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdHJlYW1FbmRFdmVudCwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIFN0cmVhbUVuZEV2ZW50KCkge1xuICAgICAgX3JlZjEgPSBTdHJlYW1FbmRFdmVudC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfcmVmMTtcbiAgICB9XG5cbiAgICByZXR1cm4gU3RyZWFtRW5kRXZlbnQ7XG5cbiAgfSkodGhpcy5FdmVudCk7XG5cbiAgdGhpcy5Eb2N1bWVudFN0YXJ0RXZlbnQgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERvY3VtZW50U3RhcnRFdmVudCwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIERvY3VtZW50U3RhcnRFdmVudChzdGFydF9tYXJrLCBlbmRfbWFyaywgZXhwbGljaXQsIHZlcnNpb24sIHRhZ3MpIHtcbiAgICAgIHRoaXMuc3RhcnRfbWFyayA9IHN0YXJ0X21hcms7XG4gICAgICB0aGlzLmVuZF9tYXJrID0gZW5kX21hcms7XG4gICAgICB0aGlzLmV4cGxpY2l0ID0gZXhwbGljaXQ7XG4gICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgdGhpcy50YWdzID0gdGFncztcbiAgICB9XG5cbiAgICByZXR1cm4gRG9jdW1lbnRTdGFydEV2ZW50O1xuXG4gIH0pKHRoaXMuRXZlbnQpO1xuXG4gIHRoaXMuRG9jdW1lbnRFbmRFdmVudCA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRG9jdW1lbnRFbmRFdmVudCwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIERvY3VtZW50RW5kRXZlbnQoc3RhcnRfbWFyaywgZW5kX21hcmssIGV4cGxpY2l0KSB7XG4gICAgICB0aGlzLnN0YXJ0X21hcmsgPSBzdGFydF9tYXJrO1xuICAgICAgdGhpcy5lbmRfbWFyayA9IGVuZF9tYXJrO1xuICAgICAgdGhpcy5leHBsaWNpdCA9IGV4cGxpY2l0O1xuICAgIH1cblxuICAgIHJldHVybiBEb2N1bWVudEVuZEV2ZW50O1xuXG4gIH0pKHRoaXMuRXZlbnQpO1xuXG4gIHRoaXMuQWxpYXNFdmVudCA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWxpYXNFdmVudCwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIEFsaWFzRXZlbnQoKSB7XG4gICAgICBfcmVmMiA9IEFsaWFzRXZlbnQuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gX3JlZjI7XG4gICAgfVxuXG4gICAgcmV0dXJuIEFsaWFzRXZlbnQ7XG5cbiAgfSkodGhpcy5Ob2RlRXZlbnQpO1xuXG4gIHRoaXMuU2NhbGFyRXZlbnQgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNjYWxhckV2ZW50LCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gU2NhbGFyRXZlbnQoYW5jaG9yLCB0YWcsIGltcGxpY2l0LCB2YWx1ZSwgc3RhcnRfbWFyaywgZW5kX21hcmssIHN0eWxlKSB7XG4gICAgICB0aGlzLmFuY2hvciA9IGFuY2hvcjtcbiAgICAgIHRoaXMudGFnID0gdGFnO1xuICAgICAgdGhpcy5pbXBsaWNpdCA9IGltcGxpY2l0O1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgdGhpcy5zdGFydF9tYXJrID0gc3RhcnRfbWFyaztcbiAgICAgIHRoaXMuZW5kX21hcmsgPSBlbmRfbWFyaztcbiAgICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gU2NhbGFyRXZlbnQ7XG5cbiAgfSkodGhpcy5Ob2RlRXZlbnQpO1xuXG4gIHRoaXMuU2VxdWVuY2VTdGFydEV2ZW50ID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTZXF1ZW5jZVN0YXJ0RXZlbnQsIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBTZXF1ZW5jZVN0YXJ0RXZlbnQoKSB7XG4gICAgICBfcmVmMyA9IFNlcXVlbmNlU3RhcnRFdmVudC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfcmVmMztcbiAgICB9XG5cbiAgICByZXR1cm4gU2VxdWVuY2VTdGFydEV2ZW50O1xuXG4gIH0pKHRoaXMuQ29sbGVjdGlvblN0YXJ0RXZlbnQpO1xuXG4gIHRoaXMuU2VxdWVuY2VFbmRFdmVudCA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2VxdWVuY2VFbmRFdmVudCwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIFNlcXVlbmNlRW5kRXZlbnQoKSB7XG4gICAgICBfcmVmNCA9IFNlcXVlbmNlRW5kRXZlbnQuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gX3JlZjQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIFNlcXVlbmNlRW5kRXZlbnQ7XG5cbiAgfSkodGhpcy5Db2xsZWN0aW9uRW5kRXZlbnQpO1xuXG4gIHRoaXMuTWFwcGluZ1N0YXJ0RXZlbnQgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1hcHBpbmdTdGFydEV2ZW50LCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gTWFwcGluZ1N0YXJ0RXZlbnQoKSB7XG4gICAgICBfcmVmNSA9IE1hcHBpbmdTdGFydEV2ZW50Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIF9yZWY1O1xuICAgIH1cblxuICAgIHJldHVybiBNYXBwaW5nU3RhcnRFdmVudDtcblxuICB9KSh0aGlzLkNvbGxlY3Rpb25TdGFydEV2ZW50KTtcblxuICB0aGlzLk1hcHBpbmdFbmRFdmVudCA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFwcGluZ0VuZEV2ZW50LCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gTWFwcGluZ0VuZEV2ZW50KCkge1xuICAgICAgX3JlZjYgPSBNYXBwaW5nRW5kRXZlbnQuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gX3JlZjY7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1hcHBpbmdFbmRFdmVudDtcblxuICB9KSh0aGlzLkNvbGxlY3Rpb25FbmRFdmVudCk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIoZnVuY3Rpb24oKSB7XG4gIHZhciBNYXJrZWRZQU1MRXJyb3IsIG5vZGVzLCBfcmVmLFxuICAgIF9faGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LFxuICAgIF9fZXh0ZW5kcyA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoX19oYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9O1xuXG4gIE1hcmtlZFlBTUxFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3JzJykuTWFya2VkWUFNTEVycm9yO1xuXG4gIG5vZGVzID0gcmVxdWlyZSgnLi9ub2RlcycpO1xuXG4gIC8qXG4gIFRoZSBUcmFpdHMgdGhyb3dzIHRoZXNlLlxuICAqL1xuXG5cbiAgdGhpcy5Kb2luRXJyb3IgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEpvaW5FcnJvciwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIEpvaW5FcnJvcigpIHtcbiAgICAgIF9yZWYgPSBKb2luRXJyb3IuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gX3JlZjtcbiAgICB9XG5cbiAgICByZXR1cm4gSm9pbkVycm9yO1xuXG4gIH0pKE1hcmtlZFlBTUxFcnJvcik7XG5cbiAgLypcbiAgVGhlIEpvaW5lciBjbGFzcyBncm91cHMgcmVzb3VyY2VzIHVuZGVyIHJlc291cmNlIHByb3BlcnR5IGFuZCBncm91cHMgbWV0aG9kcyB1bmRlciBvcGVyYXRpb25zIHByb3BlcnR5XG4gICovXG5cblxuICB0aGlzLkpvaW5lciA9IChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBKb2luZXIoKSB7fVxuXG4gICAgSm9pbmVyLnByb3RvdHlwZS5qb2luX3Jlc291cmNlcyA9IGZ1bmN0aW9uKG5vZGUsIGNhbGwpIHtcbiAgICAgIHZhciByZXNvdXJjZXMsIHJlc291cmNlc0FycmF5LCByZXNvdXJjZXNOYW1lLCByZXNvdXJjZXNWYWx1ZSxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuICAgICAgaWYgKGNhbGwgPT0gbnVsbCkge1xuICAgICAgICBjYWxsID0gMDtcbiAgICAgIH1cbiAgICAgIHJlc291cmNlcyA9IFtdO1xuICAgICAgaWYgKG5vZGUgIT0gbnVsbCA/IG5vZGUudmFsdWUgOiB2b2lkIDApIHtcbiAgICAgICAgcmVzb3VyY2VzID0gbm9kZS52YWx1ZS5maWx0ZXIoZnVuY3Rpb24oY2hpbGROb2RlKSB7XG4gICAgICAgICAgdmFyIF9yZWYxO1xuICAgICAgICAgIHJldHVybiAoX3JlZjEgPSBjaGlsZE5vZGVbMF0pICE9IG51bGwgPyBfcmVmMS52YWx1ZS5tYXRjaCgvXlxcLy8pIDogdm9pZCAwO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJlc291cmNlc0FycmF5ID0gW107XG4gICAgICBpZiAocmVzb3VyY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKG5vZGUgIT0gbnVsbCA/IG5vZGUudmFsdWUgOiB2b2lkIDApIHtcbiAgICAgICAgICBub2RlLnZhbHVlID0gbm9kZS52YWx1ZS5maWx0ZXIoZnVuY3Rpb24oY2hpbGROb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gIWNoaWxkTm9kZVswXS52YWx1ZS5tYXRjaCgvXlxcLy8pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJlc291cmNlc05hbWUgPSBuZXcgbm9kZXMuU2NhbGFyTm9kZSgndGFnOnlhbWwub3JnLDIwMDI6c3RyJywgJ3Jlc291cmNlcycsIHJlc291cmNlc1swXVswXS5zdGFydF9tYXJrLCByZXNvdXJjZXNbcmVzb3VyY2VzLmxlbmd0aCAtIDFdWzFdLmVuZF9tYXJrKTtcbiAgICAgICAgcmVzb3VyY2VzLmZvckVhY2goZnVuY3Rpb24ocmVzb3VyY2UpIHtcbiAgICAgICAgICB2YXIgcmVsYXRpdmVVcmlOYW1lLCByZWxhdGl2ZVVyaVZhbHVlO1xuICAgICAgICAgIHJlbGF0aXZlVXJpTmFtZSA9IG5ldyBub2Rlcy5TY2FsYXJOb2RlKCd0YWc6eWFtbC5vcmcsMjAwMjpzdHInLCAncmVsYXRpdmVVcmknLCByZXNvdXJjZVswXS5zdGFydF9tYXJrLCByZXNvdXJjZVsxXS5lbmRfbWFyayk7XG4gICAgICAgICAgcmVsYXRpdmVVcmlWYWx1ZSA9IG5ldyBub2Rlcy5TY2FsYXJOb2RlKCd0YWc6eWFtbC5vcmcsMjAwMjpzdHInLCByZXNvdXJjZVswXS52YWx1ZSwgcmVzb3VyY2VbMF0uc3RhcnRfbWFyaywgcmVzb3VyY2VbMV0uZW5kX21hcmspO1xuICAgICAgICAgIGlmIChyZXNvdXJjZVsxXS50YWcgPT09IFwidGFnOnlhbWwub3JnLDIwMDI6bnVsbFwiKSB7XG4gICAgICAgICAgICByZXNvdXJjZVsxXSA9IG5ldyBub2Rlcy5NYXBwaW5nTm9kZSgndGFnOnlhbWwub3JnLDIwMDI6bWFwJywgW10sIHJlc291cmNlWzBdLnN0YXJ0X21hcmssIHJlc291cmNlWzFdLmVuZF9tYXJrKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb3VyY2VbMV0udmFsdWUucHVzaChbcmVsYXRpdmVVcmlOYW1lLCByZWxhdGl2ZVVyaVZhbHVlXSk7XG4gICAgICAgICAgcmVzb3VyY2VzQXJyYXkucHVzaChyZXNvdXJjZVsxXSk7XG4gICAgICAgICAgX3RoaXMuam9pbl9tZXRob2RzKHJlc291cmNlWzFdKTtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuam9pbl9yZXNvdXJjZXMocmVzb3VyY2VbMV0sICsrY2FsbCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXNvdXJjZXNWYWx1ZSA9IG5ldyBub2Rlcy5TZXF1ZW5jZU5vZGUoJ3RhZzp5YW1sLm9yZywyMDAyOnNlcScsIHJlc291cmNlc0FycmF5LCByZXNvdXJjZXNbMF1bMF0uc3RhcnRfbWFyaywgcmVzb3VyY2VzW3Jlc291cmNlcy5sZW5ndGggLSAxXVsxXS5lbmRfbWFyayk7XG4gICAgICAgIHJldHVybiBub2RlLnZhbHVlLnB1c2goW3Jlc291cmNlc05hbWUsIHJlc291cmNlc1ZhbHVlXSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIEpvaW5lci5wcm90b3R5cGUuam9pbl9tZXRob2RzID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIG1ldGhvZHMsIG1ldGhvZHNBcnJheSwgbWV0aG9kc05hbWUsIG1ldGhvZHNWYWx1ZSxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuICAgICAgbWV0aG9kcyA9IFtdO1xuICAgICAgaWYgKG5vZGUgJiYgbm9kZS52YWx1ZSkge1xuICAgICAgICBtZXRob2RzID0gbm9kZS52YWx1ZS5maWx0ZXIoZnVuY3Rpb24oY2hpbGROb2RlKSB7XG4gICAgICAgICAgdmFyIF9yZWYxO1xuICAgICAgICAgIHJldHVybiBfdGhpcy5pc0h0dHBNZXRob2QoKF9yZWYxID0gY2hpbGROb2RlWzBdKSAhPSBudWxsID8gX3JlZjEudmFsdWUgOiB2b2lkIDApO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIG1ldGhvZHNBcnJheSA9IFtdO1xuICAgICAgaWYgKG1ldGhvZHMubGVuZ3RoID4gMCkge1xuICAgICAgICBub2RlLnZhbHVlID0gbm9kZS52YWx1ZS5maWx0ZXIoZnVuY3Rpb24oY2hpbGROb2RlKSB7XG4gICAgICAgICAgcmV0dXJuICFfdGhpcy5pc0h0dHBNZXRob2QoY2hpbGROb2RlWzBdLnZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG1ldGhvZHNOYW1lID0gbmV3IG5vZGVzLlNjYWxhck5vZGUoJ3RhZzp5YW1sLm9yZywyMDAyOnN0cicsICdtZXRob2RzJywgbWV0aG9kc1swXVswXS5zdGFydF9tYXJrLCBtZXRob2RzW21ldGhvZHMubGVuZ3RoIC0gMV1bMV0uZW5kX21hcmspO1xuICAgICAgICBtZXRob2RzLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgICAgdmFyIG1ldGhvZE5hbWUsIG1ldGhvZFZhbHVlO1xuICAgICAgICAgIG1ldGhvZE5hbWUgPSBuZXcgbm9kZXMuU2NhbGFyTm9kZSgndGFnOnlhbWwub3JnLDIwMDI6c3RyJywgJ21ldGhvZCcsIG1ldGhvZFswXS5zdGFydF9tYXJrLCBtZXRob2RbMV0uZW5kX21hcmspO1xuICAgICAgICAgIG1ldGhvZFZhbHVlID0gbmV3IG5vZGVzLlNjYWxhck5vZGUoJ3RhZzp5YW1sLm9yZywyMDAyOnN0cicsIG1ldGhvZFswXS52YWx1ZSwgbWV0aG9kWzBdLnN0YXJ0X21hcmssIG1ldGhvZFsxXS5lbmRfbWFyayk7XG4gICAgICAgICAgaWYgKG1ldGhvZFsxXS50YWcgPT09ICd0YWc6eWFtbC5vcmcsMjAwMjpudWxsJykge1xuICAgICAgICAgICAgbWV0aG9kWzFdID0gbmV3IG5vZGVzLk1hcHBpbmdOb2RlKCd0YWc6eWFtbC5vcmcsMjAwMjptYXAnLCBbXSwgbWV0aG9kWzFdLnN0YXJ0X21hcmssIG1ldGhvZFsxXS5lbmRfbWFyayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1ldGhvZFsxXS52YWx1ZS5wdXNoKFttZXRob2ROYW1lLCBtZXRob2RWYWx1ZV0pO1xuICAgICAgICAgIHJldHVybiBtZXRob2RzQXJyYXkucHVzaChtZXRob2RbMV0pO1xuICAgICAgICB9KTtcbiAgICAgICAgbWV0aG9kc1ZhbHVlID0gbmV3IG5vZGVzLlNlcXVlbmNlTm9kZSgndGFnOnlhbWwub3JnLDIwMDI6c2VxJywgbWV0aG9kc0FycmF5LCBtZXRob2RzWzBdWzBdLnN0YXJ0X21hcmssIG1ldGhvZHNbbWV0aG9kcy5sZW5ndGggLSAxXVsxXS5lbmRfbWFyayk7XG4gICAgICAgIHJldHVybiBub2RlLnZhbHVlLnB1c2goW21ldGhvZHNOYW1lLCBtZXRob2RzVmFsdWVdKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIEpvaW5lcjtcblxuICB9KSgpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiKGZ1bmN0aW9uKCkge1xuICB2YXIgY29tcG9zZXIsIGNvbnN0cnVjdCwgam9pbmVyLCBwYXJzZXIsIHByb3RvY29scywgcmVhZGVyLCByZXNvbHZlciwgc2Nhbm5lciwgc2NoZW1hcywgc2VjdXJpdHlTY2hlbWVzLCB0cmFpdHMsIHRyYW5zZm9ybWF0aW9ucywgdHlwZXMsIHV0aWwsIHZhbGlkYXRvcjtcblxuICB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbiAgcmVhZGVyID0gcmVxdWlyZSgnLi9yZWFkZXInKTtcblxuICBzY2FubmVyID0gcmVxdWlyZSgnLi9zY2FubmVyJyk7XG5cbiAgcGFyc2VyID0gcmVxdWlyZSgnLi9wYXJzZXInKTtcblxuICBjb21wb3NlciA9IHJlcXVpcmUoJy4vY29tcG9zZXInKTtcblxuICByZXNvbHZlciA9IHJlcXVpcmUoJy4vcmVzb2x2ZXInKTtcblxuICBjb25zdHJ1Y3QgPSByZXF1aXJlKCcuL2NvbnN0cnVjdCcpO1xuXG4gIHZhbGlkYXRvciA9IHJlcXVpcmUoJy4vdmFsaWRhdG9yJyk7XG5cbiAgam9pbmVyID0gcmVxdWlyZSgnLi9qb2luZXInKTtcblxuICB0cmFpdHMgPSByZXF1aXJlKCcuL3RyYWl0cycpO1xuXG4gIHR5cGVzID0gcmVxdWlyZSgnLi9yZXNvdXJjZVR5cGVzJyk7XG5cbiAgc2NoZW1hcyA9IHJlcXVpcmUoJy4vc2NoZW1hcycpO1xuXG4gIHByb3RvY29scyA9IHJlcXVpcmUoJy4vcHJvdG9jb2xzJyk7XG5cbiAgc2VjdXJpdHlTY2hlbWVzID0gcmVxdWlyZSgnLi9zZWN1cml0eVNjaGVtZXMnKTtcblxuICB0cmFuc2Zvcm1hdGlvbnMgPSByZXF1aXJlKCcuL3RyYW5zZm9ybWF0aW9ucycpO1xuXG4gIHRoaXMubWFrZV9sb2FkZXIgPSBmdW5jdGlvbihSZWFkZXIsIFNjYW5uZXIsIFBhcnNlciwgQ29tcG9zZXIsIFJlc29sdmVyLCBWYWxpZGF0b3IsIFJlc291cmNlVHlwZXMsIFRyYWl0cywgU2NoZW1hcywgUHJvdG9jb2xzLCBKb2luZXIsIFNlY3VyaXR5U2NoZW1lcywgQ29uc3RydWN0b3IsIFRyYW5zZm9ybWF0aW9ucykge1xuICAgIGlmIChSZWFkZXIgPT0gbnVsbCkge1xuICAgICAgUmVhZGVyID0gcmVhZGVyLlJlYWRlcjtcbiAgICB9XG4gICAgaWYgKFNjYW5uZXIgPT0gbnVsbCkge1xuICAgICAgU2Nhbm5lciA9IHNjYW5uZXIuU2Nhbm5lcjtcbiAgICB9XG4gICAgaWYgKFBhcnNlciA9PSBudWxsKSB7XG4gICAgICBQYXJzZXIgPSBwYXJzZXIuUGFyc2VyO1xuICAgIH1cbiAgICBpZiAoQ29tcG9zZXIgPT0gbnVsbCkge1xuICAgICAgQ29tcG9zZXIgPSBjb21wb3Nlci5Db21wb3NlcjtcbiAgICB9XG4gICAgaWYgKFJlc29sdmVyID09IG51bGwpIHtcbiAgICAgIFJlc29sdmVyID0gcmVzb2x2ZXIuUmVzb2x2ZXI7XG4gICAgfVxuICAgIGlmIChWYWxpZGF0b3IgPT0gbnVsbCkge1xuICAgICAgVmFsaWRhdG9yID0gdmFsaWRhdG9yLlZhbGlkYXRvcjtcbiAgICB9XG4gICAgaWYgKFJlc291cmNlVHlwZXMgPT0gbnVsbCkge1xuICAgICAgUmVzb3VyY2VUeXBlcyA9IHR5cGVzLlJlc291cmNlVHlwZXM7XG4gICAgfVxuICAgIGlmIChUcmFpdHMgPT0gbnVsbCkge1xuICAgICAgVHJhaXRzID0gdHJhaXRzLlRyYWl0cztcbiAgICB9XG4gICAgaWYgKFNjaGVtYXMgPT0gbnVsbCkge1xuICAgICAgU2NoZW1hcyA9IHNjaGVtYXMuU2NoZW1hcztcbiAgICB9XG4gICAgaWYgKFByb3RvY29scyA9PSBudWxsKSB7XG4gICAgICBQcm90b2NvbHMgPSBwcm90b2NvbHMuUHJvdG9jb2xzO1xuICAgIH1cbiAgICBpZiAoSm9pbmVyID09IG51bGwpIHtcbiAgICAgIEpvaW5lciA9IGpvaW5lci5Kb2luZXI7XG4gICAgfVxuICAgIGlmIChTZWN1cml0eVNjaGVtZXMgPT0gbnVsbCkge1xuICAgICAgU2VjdXJpdHlTY2hlbWVzID0gc2VjdXJpdHlTY2hlbWVzLlNlY3VyaXR5U2NoZW1lcztcbiAgICB9XG4gICAgaWYgKENvbnN0cnVjdG9yID09IG51bGwpIHtcbiAgICAgIENvbnN0cnVjdG9yID0gY29uc3RydWN0LkNvbnN0cnVjdG9yO1xuICAgIH1cbiAgICBpZiAoVHJhbnNmb3JtYXRpb25zID09IG51bGwpIHtcbiAgICAgIFRyYW5zZm9ybWF0aW9ucyA9IHRyYW5zZm9ybWF0aW9ucy5UcmFuc2Zvcm1hdGlvbnM7XG4gICAgfVxuICAgIHJldHVybiAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29tcG9uZW50LCBjb21wb25lbnRzO1xuXG4gICAgICBjb21wb25lbnRzID0gW1JlYWRlciwgU2Nhbm5lciwgQ29tcG9zZXIsIFRyYW5zZm9ybWF0aW9ucywgUGFyc2VyLCBSZXNvbHZlciwgVmFsaWRhdG9yLCBUcmFpdHMsIFJlc291cmNlVHlwZXMsIFNjaGVtYXMsIFByb3RvY29scywgSm9pbmVyLCBDb25zdHJ1Y3RvciwgU2VjdXJpdHlTY2hlbWVzXTtcblxuICAgICAgdXRpbC5leHRlbmQuYXBwbHkodXRpbCwgW19DbGFzcy5wcm90b3R5cGVdLmNvbmNhdCgoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfaSwgX2xlbiwgX3Jlc3VsdHM7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gY29tcG9uZW50cy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIGNvbXBvbmVudCA9IGNvbXBvbmVudHNbX2ldO1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2goY29tcG9uZW50LnByb3RvdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgfSkoKSkpO1xuXG4gICAgICBmdW5jdGlvbiBfQ2xhc3Moc3RyZWFtLCBsb2NhdGlvbiwgc2V0dGluZ3MsIHBhcmVudCkge1xuICAgICAgICB2YXIgX2ksIF9sZW4sIF9yZWY7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50ICE9IG51bGwgPyBwYXJlbnQgOiBudWxsO1xuICAgICAgICBjb21wb25lbnRzWzBdLmNhbGwodGhpcywgc3RyZWFtLCBsb2NhdGlvbik7XG4gICAgICAgIGNvbXBvbmVudHNbMV0uY2FsbCh0aGlzLCBzZXR0aW5ncyk7XG4gICAgICAgIGNvbXBvbmVudHNbMl0uY2FsbCh0aGlzLCBzZXR0aW5ncyk7XG4gICAgICAgIGNvbXBvbmVudHNbM10uY2FsbCh0aGlzLCBzZXR0aW5ncyk7XG4gICAgICAgIF9yZWYgPSBjb21wb25lbnRzLnNsaWNlKDQpO1xuICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICBjb21wb25lbnQgPSBfcmVmW19pXTtcbiAgICAgICAgICBjb21wb25lbnQuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gX0NsYXNzO1xuXG4gICAgfSkoKTtcbiAgfTtcblxuICB0aGlzLkxvYWRlciA9IHRoaXMubWFrZV9sb2FkZXIoKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIihmdW5jdGlvbigpIHtcbiAgdmFyIE1hcmtlZFlBTUxFcnJvciwgdW5pcXVlX2lkLCBfcmVmLCBfcmVmMSwgX3JlZjIsXG4gICAgX19oYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksXG4gICAgX19leHRlbmRzID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChfX2hhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH07XG5cbiAgTWFya2VkWUFNTEVycm9yID0gcmVxdWlyZSgnLi9lcnJvcnMnKS5NYXJrZWRZQU1MRXJyb3I7XG5cbiAgdW5pcXVlX2lkID0gMDtcblxuICB0aGlzLkFwcGxpY2F0aW9uRXJyb3IgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFwcGxpY2F0aW9uRXJyb3IsIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBBcHBsaWNhdGlvbkVycm9yKCkge1xuICAgICAgX3JlZiA9IEFwcGxpY2F0aW9uRXJyb3IuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gX3JlZjtcbiAgICB9XG5cbiAgICByZXR1cm4gQXBwbGljYXRpb25FcnJvcjtcblxuICB9KShNYXJrZWRZQU1MRXJyb3IpO1xuXG4gIHRoaXMuTm9kZSA9IChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBOb2RlKHRhZywgdmFsdWUsIHN0YXJ0X21hcmssIGVuZF9tYXJrKSB7XG4gICAgICB0aGlzLnRhZyA9IHRhZztcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIHRoaXMuc3RhcnRfbWFyayA9IHN0YXJ0X21hcms7XG4gICAgICB0aGlzLmVuZF9tYXJrID0gZW5kX21hcms7XG4gICAgICB0aGlzLnVuaXF1ZV9pZCA9IFwibm9kZV9cIiArICh1bmlxdWVfaWQrKyk7XG4gICAgfVxuXG4gICAgTm9kZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0ZW1wO1xuICAgICAgdGVtcCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMudGFnLCB0aGlzLnZhbHVlLCB0aGlzLnN0YXJ0X21hcmssIHRoaXMuZW5kX21hcmspO1xuICAgICAgcmV0dXJuIHRlbXA7XG4gICAgfTtcblxuICAgIHJldHVybiBOb2RlO1xuXG4gIH0pKCk7XG5cbiAgdGhpcy5TY2FsYXJOb2RlID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTY2FsYXJOb2RlLCBfc3VwZXIpO1xuXG4gICAgU2NhbGFyTm9kZS5wcm90b3R5cGUuaWQgPSAnc2NhbGFyJztcblxuICAgIGZ1bmN0aW9uIFNjYWxhck5vZGUodGFnLCB2YWx1ZSwgc3RhcnRfbWFyaywgZW5kX21hcmssIHN0eWxlKSB7XG4gICAgICB0aGlzLnRhZyA9IHRhZztcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIHRoaXMuc3RhcnRfbWFyayA9IHN0YXJ0X21hcms7XG4gICAgICB0aGlzLmVuZF9tYXJrID0gZW5kX21hcms7XG4gICAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgICBTY2FsYXJOb2RlLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIFNjYWxhck5vZGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdGVtcDtcbiAgICAgIHRlbXAgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLnRhZywgdGhpcy52YWx1ZSwgdGhpcy5zdGFydF9tYXJrLCB0aGlzLmVuZF9tYXJrLCB0aGlzLnN0eWxlKTtcbiAgICAgIHJldHVybiB0ZW1wO1xuICAgIH07XG5cbiAgICBTY2FsYXJOb2RlLnByb3RvdHlwZS5jbG9uZVJlbW92ZUlzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jbG9uZSgpO1xuICAgIH07XG5cbiAgICBTY2FsYXJOb2RlLnByb3RvdHlwZS5jb21iaW5lID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgaWYgKHRoaXMudGFnID09PSAndGFnOnlhbWwub3JnLDIwMDI6bnVsbCcgJiYgbm9kZS50YWcgPT09ICd0YWc6eWFtbC5vcmcsMjAwMjptYXAnKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBuZXcgZXhwb3J0cy5NYXBwaW5nTm9kZSgndGFnOnlhbWwub3JnLDIwMDI6bWFwJywgW10sIG5vZGUuc3RhcnRfbWFyaywgbm9kZS5lbmRfbWFyayk7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlLmNvbWJpbmUobm9kZSk7XG4gICAgICB9IGVsc2UgaWYgKCEobm9kZSBpbnN0YW5jZW9mIGV4cG9ydHMuU2NhbGFyTm9kZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuQXBwbGljYXRpb25FcnJvcignd2hpbGUgYXBwbHlpbmcgbm9kZScsIG51bGwsICdkaWZmZXJlbnQgWUFNTCBzdHJ1Y3R1cmVzJywgdGhpcy5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnZhbHVlID0gbm9kZS52YWx1ZTtcbiAgICB9O1xuXG4gICAgU2NhbGFyTm9kZS5wcm90b3R5cGUucmVtb3ZlX3F1ZXN0aW9uX21hcmtfcHJvcGVydGllcyA9IGZ1bmN0aW9uKCkge307XG5cbiAgICByZXR1cm4gU2NhbGFyTm9kZTtcblxuICB9KSh0aGlzLk5vZGUpO1xuXG4gIHRoaXMuQ29sbGVjdGlvbk5vZGUgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbGxlY3Rpb25Ob2RlLCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gQ29sbGVjdGlvbk5vZGUodGFnLCB2YWx1ZSwgc3RhcnRfbWFyaywgZW5kX21hcmssIGZsb3dfc3R5bGUpIHtcbiAgICAgIHRoaXMudGFnID0gdGFnO1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgdGhpcy5zdGFydF9tYXJrID0gc3RhcnRfbWFyaztcbiAgICAgIHRoaXMuZW5kX21hcmsgPSBlbmRfbWFyaztcbiAgICAgIHRoaXMuZmxvd19zdHlsZSA9IGZsb3dfc3R5bGU7XG4gICAgICBDb2xsZWN0aW9uTm9kZS5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gQ29sbGVjdGlvbk5vZGU7XG5cbiAgfSkodGhpcy5Ob2RlKTtcblxuICB0aGlzLlNlcXVlbmNlTm9kZSA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2VxdWVuY2VOb2RlLCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gU2VxdWVuY2VOb2RlKCkge1xuICAgICAgX3JlZjEgPSBTZXF1ZW5jZU5vZGUuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gX3JlZjE7XG4gICAgfVxuXG4gICAgU2VxdWVuY2VOb2RlLnByb3RvdHlwZS5pZCA9ICdzZXF1ZW5jZSc7XG5cbiAgICBTZXF1ZW5jZU5vZGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaXRlbSwgaXRlbXMsIHRlbXAsIHZhbHVlLCBfaSwgX2xlbiwgX3JlZjI7XG4gICAgICBpdGVtcyA9IFtdO1xuICAgICAgX3JlZjIgPSB0aGlzLnZhbHVlO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBpdGVtID0gX3JlZjJbX2ldO1xuICAgICAgICB2YWx1ZSA9IGl0ZW0uY2xvbmUoKTtcbiAgICAgICAgaXRlbXMucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICB0ZW1wID0gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy50YWcsIGl0ZW1zLCB0aGlzLnN0YXJ0X21hcmssIHRoaXMuZW5kX21hcmssIHRoaXMuZmxvd19zdHlsZSk7XG4gICAgICByZXR1cm4gdGVtcDtcbiAgICB9O1xuXG4gICAgU2VxdWVuY2VOb2RlLnByb3RvdHlwZS5jbG9uZVJlbW92ZUlzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jbG9uZSgpO1xuICAgIH07XG5cbiAgICBTZXF1ZW5jZU5vZGUucHJvdG90eXBlLmNvbWJpbmUgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgcHJvcGVydHksIHZhbHVlLCBfaSwgX2xlbiwgX3JlZjIsIF9yZXN1bHRzO1xuICAgICAgaWYgKCEobm9kZSBpbnN0YW5jZW9mIGV4cG9ydHMuU2VxdWVuY2VOb2RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5BcHBsaWNhdGlvbkVycm9yKCd3aGlsZSBhcHBseWluZyBub2RlJywgbnVsbCwgJ2RpZmZlcmVudCBZQU1MIHN0cnVjdHVyZXMnLCB0aGlzLnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgX3JlZjIgPSBub2RlLnZhbHVlO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjIubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgcHJvcGVydHkgPSBfcmVmMltfaV07XG4gICAgICAgIHZhbHVlID0gcHJvcGVydHkuY2xvbmUoKTtcbiAgICAgICAgX3Jlc3VsdHMucHVzaCh0aGlzLnZhbHVlLnB1c2godmFsdWUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuXG4gICAgU2VxdWVuY2VOb2RlLnByb3RvdHlwZS5yZW1vdmVfcXVlc3Rpb25fbWFya19wcm9wZXJ0aWVzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaXRlbSwgX2ksIF9sZW4sIF9yZWYyLCBfcmVzdWx0cztcbiAgICAgIF9yZWYyID0gdGhpcy52YWx1ZTtcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYyLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBfcmVmMltfaV07XG4gICAgICAgIF9yZXN1bHRzLnB1c2goaXRlbS5yZW1vdmVfcXVlc3Rpb25fbWFya19wcm9wZXJ0aWVzKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2VxdWVuY2VOb2RlO1xuXG4gIH0pKHRoaXMuQ29sbGVjdGlvbk5vZGUpO1xuXG4gIHRoaXMuTWFwcGluZ05vZGUgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1hcHBpbmdOb2RlLCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gTWFwcGluZ05vZGUoKSB7XG4gICAgICBfcmVmMiA9IE1hcHBpbmdOb2RlLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIF9yZWYyO1xuICAgIH1cblxuICAgIE1hcHBpbmdOb2RlLnByb3RvdHlwZS5pZCA9ICdtYXBwaW5nJztcblxuICAgIE1hcHBpbmdOb2RlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG5hbWUsIHByb3BlcnRpZXMsIHByb3BlcnR5LCB0ZW1wLCB2YWx1ZSwgX2ksIF9sZW4sIF9yZWYzO1xuICAgICAgcHJvcGVydGllcyA9IFtdO1xuICAgICAgX3JlZjMgPSB0aGlzLnZhbHVlO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBwcm9wZXJ0eSA9IF9yZWYzW19pXTtcbiAgICAgICAgbmFtZSA9IHByb3BlcnR5WzBdLmNsb25lKCk7XG4gICAgICAgIHZhbHVlID0gcHJvcGVydHlbMV0uY2xvbmUoKTtcbiAgICAgICAgcHJvcGVydGllcy5wdXNoKFtuYW1lLCB2YWx1ZV0pO1xuICAgICAgfVxuICAgICAgdGVtcCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMudGFnLCBwcm9wZXJ0aWVzLCB0aGlzLnN0YXJ0X21hcmssIHRoaXMuZW5kX21hcmssIHRoaXMuZmxvd19zdHlsZSk7XG4gICAgICByZXR1cm4gdGVtcDtcbiAgICB9O1xuXG4gICAgTWFwcGluZ05vZGUucHJvdG90eXBlLmNsb25lUmVtb3ZlSXMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBuYW1lLCBwcm9wZXJ0aWVzLCBwcm9wZXJ0eSwgdGVtcCwgdmFsdWUsIF9pLCBfbGVuLCBfcmVmMywgX3JlZjQ7XG4gICAgICBwcm9wZXJ0aWVzID0gW107XG4gICAgICBfcmVmMyA9IHRoaXMudmFsdWU7XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIHByb3BlcnR5ID0gX3JlZjNbX2ldO1xuICAgICAgICBuYW1lID0gcHJvcGVydHlbMF0uY2xvbmVSZW1vdmVJcygpO1xuICAgICAgICB2YWx1ZSA9IHByb3BlcnR5WzFdLmNsb25lUmVtb3ZlSXMoKTtcbiAgICAgICAgaWYgKChfcmVmNCA9IG5hbWUudmFsdWUpICE9PSAnaXMnKSB7XG4gICAgICAgICAgcHJvcGVydGllcy5wdXNoKFtuYW1lLCB2YWx1ZV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0ZW1wID0gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy50YWcsIHByb3BlcnRpZXMsIHRoaXMuc3RhcnRfbWFyaywgdGhpcy5lbmRfbWFyaywgdGhpcy5mbG93X3N0eWxlKTtcbiAgICAgIHJldHVybiB0ZW1wO1xuICAgIH07XG5cbiAgICBNYXBwaW5nTm9kZS5wcm90b3R5cGUuY2xvbmVGb3JUcmFpdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG5hbWUsIHByb3BlcnRpZXMsIHByb3BlcnR5LCB0ZW1wLCB2YWx1ZSwgX2ksIF9sZW4sIF9yZWYzLCBfcmVmNDtcbiAgICAgIHByb3BlcnRpZXMgPSBbXTtcbiAgICAgIF9yZWYzID0gdGhpcy52YWx1ZTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgcHJvcGVydHkgPSBfcmVmM1tfaV07XG4gICAgICAgIG5hbWUgPSBwcm9wZXJ0eVswXS5jbG9uZSgpO1xuICAgICAgICB2YWx1ZSA9IHByb3BlcnR5WzFdLmNsb25lKCk7XG4gICAgICAgIGlmICgoX3JlZjQgPSBuYW1lLnZhbHVlKSAhPT0gJ3VzYWdlJyAmJiBfcmVmNCAhPT0gJ2Rpc3BsYXlOYW1lJykge1xuICAgICAgICAgIHByb3BlcnRpZXMucHVzaChbbmFtZSwgdmFsdWVdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGVtcCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMudGFnLCBwcm9wZXJ0aWVzLCB0aGlzLnN0YXJ0X21hcmssIHRoaXMuZW5kX21hcmssIHRoaXMuZmxvd19zdHlsZSk7XG4gICAgICByZXR1cm4gdGVtcDtcbiAgICB9O1xuXG4gICAgTWFwcGluZ05vZGUucHJvdG90eXBlLmNsb25lRm9yUmVzb3VyY2VUeXBlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbmFtZSwgcHJvcGVydGllcywgcHJvcGVydHksIHRlbXAsIHZhbHVlLCBfaSwgX2xlbiwgX3JlZjMsIF9yZWY0O1xuICAgICAgcHJvcGVydGllcyA9IFtdO1xuICAgICAgX3JlZjMgPSB0aGlzLnZhbHVlO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBwcm9wZXJ0eSA9IF9yZWYzW19pXTtcbiAgICAgICAgbmFtZSA9IHByb3BlcnR5WzBdLmNsb25lUmVtb3ZlSXMoKTtcbiAgICAgICAgdmFsdWUgPSBwcm9wZXJ0eVsxXS5jbG9uZVJlbW92ZUlzKCk7XG4gICAgICAgIGlmICgoX3JlZjQgPSBuYW1lLnZhbHVlKSAhPT0gJ2lzJyAmJiBfcmVmNCAhPT0gJ3R5cGUnICYmIF9yZWY0ICE9PSAndXNhZ2UnICYmIF9yZWY0ICE9PSAnZGlzcGxheU5hbWUnKSB7XG4gICAgICAgICAgcHJvcGVydGllcy5wdXNoKFtuYW1lLCB2YWx1ZV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0ZW1wID0gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy50YWcsIHByb3BlcnRpZXMsIHRoaXMuc3RhcnRfbWFyaywgdGhpcy5lbmRfbWFyaywgdGhpcy5mbG93X3N0eWxlKTtcbiAgICAgIHJldHVybiB0ZW1wO1xuICAgIH07XG5cbiAgICBNYXBwaW5nTm9kZS5wcm90b3R5cGUuY29tYmluZSA9IGZ1bmN0aW9uKHJlc291cmNlTm9kZSkge1xuICAgICAgdmFyIG5hbWUsIG5vZGVfaGFzX3Byb3BlcnR5LCBub25OdWxsTm9kZSwgb3duTm9kZVByb3BlcnR5LCBvd25Ob2RlUHJvcGVydHlOYW1lLCByZXNvdXJjZVByb3BlcnR5LCBfaSwgX2xlbiwgX3JlZjMsIF9yZXN1bHRzO1xuICAgICAgaWYgKHJlc291cmNlTm9kZS50YWcgPT09ICd0YWc6eWFtbC5vcmcsMjAwMjpudWxsJykge1xuICAgICAgICByZXNvdXJjZU5vZGUgPSBuZXcgZXhwb3J0cy5NYXBwaW5nTm9kZSgndGFnOnlhbWwub3JnLDIwMDI6bWFwJywgW10sIHJlc291cmNlTm9kZS5zdGFydF9tYXJrLCByZXNvdXJjZU5vZGUuZW5kX21hcmspO1xuICAgICAgfVxuICAgICAgaWYgKCEocmVzb3VyY2VOb2RlIGluc3RhbmNlb2YgZXhwb3J0cy5NYXBwaW5nTm9kZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuQXBwbGljYXRpb25FcnJvcignd2hpbGUgYXBwbHlpbmcgbm9kZScsIG51bGwsICdkaWZmZXJlbnQgWUFNTCBzdHJ1Y3R1cmVzJywgdGhpcy5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIF9yZWYzID0gcmVzb3VyY2VOb2RlLnZhbHVlO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgcmVzb3VyY2VQcm9wZXJ0eSA9IF9yZWYzW19pXTtcbiAgICAgICAgbmFtZSA9IHJlc291cmNlUHJvcGVydHlbMF0udmFsdWU7XG4gICAgICAgIG5vZGVfaGFzX3Byb3BlcnR5ID0gdGhpcy52YWx1ZS5zb21lKGZ1bmN0aW9uKHNvbWVQcm9wZXJ0eSkge1xuICAgICAgICAgIHJldHVybiAoc29tZVByb3BlcnR5WzBdLnZhbHVlID09PSBuYW1lKSB8fCAoKHNvbWVQcm9wZXJ0eVswXS52YWx1ZSArICc/JykgPT09IG5hbWUpIHx8IChzb21lUHJvcGVydHlbMF0udmFsdWUgPT09IChuYW1lICsgJz8nKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobm9kZV9oYXNfcHJvcGVydHkpIHtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBfaiwgX2xlbjEsIF9yZWY0LCBfcmVzdWx0czE7XG4gICAgICAgICAgICBfcmVmNCA9IHRoaXMudmFsdWU7XG4gICAgICAgICAgICBfcmVzdWx0czEgPSBbXTtcbiAgICAgICAgICAgIGZvciAoX2ogPSAwLCBfbGVuMSA9IF9yZWY0Lmxlbmd0aDsgX2ogPCBfbGVuMTsgX2orKykge1xuICAgICAgICAgICAgICBvd25Ob2RlUHJvcGVydHkgPSBfcmVmNFtfal07XG4gICAgICAgICAgICAgIG93bk5vZGVQcm9wZXJ0eU5hbWUgPSBvd25Ob2RlUHJvcGVydHlbMF0udmFsdWU7XG4gICAgICAgICAgICAgIGlmICgob3duTm9kZVByb3BlcnR5TmFtZSA9PT0gbmFtZSkgfHwgKChvd25Ob2RlUHJvcGVydHlOYW1lICsgJz8nKSA9PT0gbmFtZSkgfHwgKG93bk5vZGVQcm9wZXJ0eU5hbWUgPT09IChuYW1lICsgJz8nKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoKG93bk5vZGVQcm9wZXJ0eVsxXS50YWcgPT09ICd0YWc6eWFtbC5vcmcsMjAwMjpudWxsJykgJiYgKHJlc291cmNlUHJvcGVydHlbMV0udGFnID09PSAndGFnOnlhbWwub3JnLDIwMDI6bWFwJykpIHtcbiAgICAgICAgICAgICAgICAgIG5vbk51bGxOb2RlID0gbmV3IGV4cG9ydHMuTWFwcGluZ05vZGUoJ3RhZzp5YW1sLm9yZywyMDAyOm1hcCcsIFtdLCBvd25Ob2RlUHJvcGVydHlbMV0uc3RhcnRfbWFyaywgb3duTm9kZVByb3BlcnR5WzFdLmVuZF9tYXJrKTtcbiAgICAgICAgICAgICAgICAgIG93bk5vZGVQcm9wZXJ0eVsxXSA9IG5vbk51bGxOb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvd25Ob2RlUHJvcGVydHlbMV0uY29tYmluZShyZXNvdXJjZVByb3BlcnR5WzFdKTtcbiAgICAgICAgICAgICAgICBpZiAoISgob3duTm9kZVByb3BlcnR5WzBdLnZhbHVlLnNsaWNlKC0xKSA9PT0gJz8nKSAmJiAocmVzb3VyY2VQcm9wZXJ0eVswXS52YWx1ZS5zbGljZSgtMSkgPT09ICc/JykpKSB7XG4gICAgICAgICAgICAgICAgICBpZiAob3duTm9kZVByb3BlcnR5WzBdLnZhbHVlLnNsaWNlKC0xKSA9PT0gJz8nKSB7XG4gICAgICAgICAgICAgICAgICAgIF9yZXN1bHRzMS5wdXNoKG93bk5vZGVQcm9wZXJ0eVswXS52YWx1ZSA9IG93bk5vZGVQcm9wZXJ0eVswXS52YWx1ZS5zbGljZSgwLCAtMSkpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3Jlc3VsdHMxLnB1c2godm9pZCAwKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgX3Jlc3VsdHMxLnB1c2godm9pZCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX3Jlc3VsdHMxLnB1c2godm9pZCAwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9yZXN1bHRzMTtcbiAgICAgICAgICB9KS5jYWxsKHRoaXMpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKHRoaXMudmFsdWUucHVzaChbcmVzb3VyY2VQcm9wZXJ0eVswXS5jbG9uZSgpLCByZXNvdXJjZVByb3BlcnR5WzFdLmNsb25lKCldKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuXG4gICAgTWFwcGluZ05vZGUucHJvdG90eXBlLnJlbW92ZV9xdWVzdGlvbl9tYXJrX3Byb3BlcnRpZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwcm9wZXJ0eSwgX2ksIF9sZW4sIF9yZWYzLCBfcmVzdWx0cztcbiAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnZhbHVlLmZpbHRlcihmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm4gcHJvcGVydHlbMF0udmFsdWUuc2xpY2UoLTEpICE9PSAnPyc7XG4gICAgICB9KTtcbiAgICAgIF9yZWYzID0gdGhpcy52YWx1ZTtcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIHByb3BlcnR5ID0gX3JlZjNbX2ldO1xuICAgICAgICBfcmVzdWx0cy5wdXNoKHByb3BlcnR5WzFdLnJlbW92ZV9xdWVzdGlvbl9tYXJrX3Byb3BlcnRpZXMoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfTtcblxuICAgIHJldHVybiBNYXBwaW5nTm9kZTtcblxuICB9KSh0aGlzLkNvbGxlY3Rpb25Ob2RlKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIihmdW5jdGlvbigpIHtcbiAgdmFyIE1hcmtlZFlBTUxFcnJvciwgZXZlbnRzLCB0b2tlbnMsIF9yZWYsXG4gICAgX19oYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksXG4gICAgX19leHRlbmRzID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChfX2hhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG4gICAgX19zbGljZSA9IFtdLnNsaWNlO1xuXG4gIGV2ZW50cyA9IHJlcXVpcmUoJy4vZXZlbnRzJyk7XG5cbiAgTWFya2VkWUFNTEVycm9yID0gcmVxdWlyZSgnLi9lcnJvcnMnKS5NYXJrZWRZQU1MRXJyb3I7XG5cbiAgdG9rZW5zID0gcmVxdWlyZSgnLi90b2tlbnMnKTtcblxuICB0aGlzLlBhcnNlckVycm9yID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQYXJzZXJFcnJvciwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIFBhcnNlckVycm9yKCkge1xuICAgICAgX3JlZiA9IFBhcnNlckVycm9yLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIF9yZWY7XG4gICAgfVxuXG4gICAgcmV0dXJuIFBhcnNlckVycm9yO1xuXG4gIH0pKE1hcmtlZFlBTUxFcnJvcik7XG5cbiAgdGhpcy5QYXJzZXIgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIERFRkFVTFRfVEFHUztcblxuICAgIERFRkFVTFRfVEFHUyA9IHtcbiAgICAgICchJzogJyEnLFxuICAgICAgJyEhJzogJ3RhZzp5YW1sLm9yZywyMDAyOidcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gUGFyc2VyKCkge1xuICAgICAgdGhpcy5jdXJyZW50X2V2ZW50ID0gbnVsbDtcbiAgICAgIHRoaXMueWFtbF92ZXJzaW9uID0gbnVsbDtcbiAgICAgIHRoaXMudGFnX2hhbmRsZXMgPSB7fTtcbiAgICAgIHRoaXMuc3RhdGVzID0gW107XG4gICAgICB0aGlzLm1hcmtzID0gW107XG4gICAgICB0aGlzLnN0YXRlID0gJ3BhcnNlX3N0cmVhbV9zdGFydCc7XG4gICAgfVxuXG4gICAgLypcbiAgICBSZXNldCB0aGUgc3RhdGUgYXR0cmlidXRlcy5cbiAgICAqL1xuXG5cbiAgICBQYXJzZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc3RhdGVzID0gW107XG4gICAgICByZXR1cm4gdGhpcy5zdGF0ZSA9IG51bGw7XG4gICAgfTtcblxuICAgIC8qXG4gICAgQ2hlY2sgdGhlIHR5cGUgb2YgdGhlIG5leHQgZXZlbnQuXG4gICAgKi9cblxuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5jaGVja19ldmVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNob2ljZSwgY2hvaWNlcywgX2ksIF9sZW47XG4gICAgICBjaG9pY2VzID0gMSA8PSBhcmd1bWVudHMubGVuZ3RoID8gX19zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkgOiBbXTtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRfZXZlbnQgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuY3VycmVudF9ldmVudCA9IHRoaXNbdGhpcy5zdGF0ZV0oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY3VycmVudF9ldmVudCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoY2hvaWNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IGNob2ljZXMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICBjaG9pY2UgPSBjaG9pY2VzW19pXTtcbiAgICAgICAgICBpZiAodGhpcy5jdXJyZW50X2V2ZW50IGluc3RhbmNlb2YgY2hvaWNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBHZXQgdGhlIG5leHQgZXZlbnQuXG4gICAgKi9cblxuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wZWVrX2V2ZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5jdXJyZW50X2V2ZW50ID09PSBudWxsICYmICh0aGlzLnN0YXRlICE9IG51bGwpKSB7XG4gICAgICAgIHRoaXMuY3VycmVudF9ldmVudCA9IHRoaXNbdGhpcy5zdGF0ZV0oKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRfZXZlbnQ7XG4gICAgfTtcblxuICAgIC8qXG4gICAgR2V0IHRoZSBldmVudCBhbmQgcHJvY2VlZCBmdXJ0aGVyLlxuICAgICovXG5cblxuICAgIFBhcnNlci5wcm90b3R5cGUuZ2V0X2V2ZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZXZlbnQ7XG4gICAgICBpZiAodGhpcy5jdXJyZW50X2V2ZW50ID09PSBudWxsICYmICh0aGlzLnN0YXRlICE9IG51bGwpKSB7XG4gICAgICAgIHRoaXMuY3VycmVudF9ldmVudCA9IHRoaXNbdGhpcy5zdGF0ZV0oKTtcbiAgICAgIH1cbiAgICAgIGV2ZW50ID0gdGhpcy5jdXJyZW50X2V2ZW50O1xuICAgICAgdGhpcy5jdXJyZW50X2V2ZW50ID0gbnVsbDtcbiAgICAgIHJldHVybiBldmVudDtcbiAgICB9O1xuXG4gICAgLypcbiAgICBQYXJzZSB0aGUgc3RyZWFtIHN0YXJ0LlxuICAgICovXG5cblxuICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2Vfc3RyZWFtX3N0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZXZlbnQsIHRva2VuO1xuICAgICAgdG9rZW4gPSB0aGlzLmdldF90b2tlbigpO1xuICAgICAgZXZlbnQgPSBuZXcgZXZlbnRzLlN0cmVhbVN0YXJ0RXZlbnQodG9rZW4uc3RhcnRfbWFyaywgdG9rZW4uZW5kX21hcmspO1xuICAgICAgdGhpcy5zdGF0ZSA9ICdwYXJzZV9pbXBsaWNpdF9kb2N1bWVudF9zdGFydCc7XG4gICAgICByZXR1cm4gZXZlbnQ7XG4gICAgfTtcblxuICAgIC8qXG4gICAgUGFyc2UgYW4gaW1wbGljaXQgZG9jdW1lbnQuXG4gICAgKi9cblxuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZV9pbXBsaWNpdF9kb2N1bWVudF9zdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGVuZF9tYXJrLCBldmVudCwgc3RhcnRfbWFyaywgdG9rZW47XG4gICAgICBpZiAoIXRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLkRpcmVjdGl2ZVRva2VuLCB0b2tlbnMuRG9jdW1lbnRTdGFydFRva2VuLCB0b2tlbnMuU3RyZWFtRW5kVG9rZW4pKSB7XG4gICAgICAgIHRoaXMudGFnX2hhbmRsZXMgPSBERUZBVUxUX1RBR1M7XG4gICAgICAgIHRva2VuID0gdGhpcy5wZWVrX3Rva2VuKCk7XG4gICAgICAgIHN0YXJ0X21hcmsgPSBlbmRfbWFyayA9IHRva2VuLnN0YXJ0X21hcms7XG4gICAgICAgIGV2ZW50ID0gbmV3IGV2ZW50cy5Eb2N1bWVudFN0YXJ0RXZlbnQoc3RhcnRfbWFyaywgZW5kX21hcmssIGZhbHNlKTtcbiAgICAgICAgdGhpcy5zdGF0ZXMucHVzaCgncGFyc2VfZG9jdW1lbnRfZW5kJyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAncGFyc2VfYmxvY2tfbm9kZSc7XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlX2RvY3VtZW50X3N0YXJ0KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qXG4gICAgUGFyc2UgYW4gZXhwbGljaXQgZG9jdW1lbnQuXG4gICAgKi9cblxuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZV9kb2N1bWVudF9zdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGVuZF9tYXJrLCBldmVudCwgc3RhcnRfbWFyaywgdGFncywgdG9rZW4sIHZlcnNpb24sIF9yZWYxO1xuICAgICAgd2hpbGUgKHRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLkRvY3VtZW50RW5kVG9rZW4pKSB7XG4gICAgICAgIHRoaXMuZ2V0X3Rva2VuKCk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLlN0cmVhbUVuZFRva2VuKSkge1xuICAgICAgICBzdGFydF9tYXJrID0gdGhpcy5wZWVrX3Rva2VuKCkuc3RhcnRfbWFyaztcbiAgICAgICAgX3JlZjEgPSB0aGlzLnByb2Nlc3NfZGlyZWN0aXZlcygpLCB2ZXJzaW9uID0gX3JlZjFbMF0sIHRhZ3MgPSBfcmVmMVsxXTtcbiAgICAgICAgaWYgKCF0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5Eb2N1bWVudFN0YXJ0VG9rZW4pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuUGFyc2VyRXJyb3IoXCJleHBlY3RlZCAnPGRvY3VtZW50IHN0YXJ0PicsIGJ1dCBmb3VuZCBcIiArICh0aGlzLnBlZWtfdG9rZW4oKS5pZCksIHRoaXMucGVla190b2tlbigpLnN0YXJ0X21hcmspO1xuICAgICAgICB9XG4gICAgICAgIHRva2VuID0gdGhpcy5nZXRfdG9rZW4oKTtcbiAgICAgICAgZW5kX21hcmsgPSB0b2tlbi5lbmRfbWFyaztcbiAgICAgICAgZXZlbnQgPSBuZXcgZXZlbnRzLkRvY3VtZW50U3RhcnRFdmVudChzdGFydF9tYXJrLCBlbmRfbWFyaywgdHJ1ZSwgdmVyc2lvbiwgdGFncyk7XG4gICAgICAgIHRoaXMuc3RhdGVzLnB1c2goJ3BhcnNlX2RvY3VtZW50X2VuZCcpO1xuICAgICAgICB0aGlzLnN0YXRlID0gJ3BhcnNlX2RvY3VtZW50X2NvbnRlbnQnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9rZW4gPSB0aGlzLmdldF90b2tlbigpO1xuICAgICAgICBldmVudCA9IG5ldyBldmVudHMuU3RyZWFtRW5kRXZlbnQodG9rZW4uc3RhcnRfbWFyaywgdG9rZW4uZW5kX21hcmspO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NlcnRpb24gZXJyb3IsIHN0YXRlcyBzaG91bGQgYmUgZW1wdHknKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tYXJrcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc2VydGlvbiBlcnJvciwgbWFya3Mgc2hvdWxkIGJlIGVtcHR5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXZlbnQ7XG4gICAgfTtcblxuICAgIC8qXG4gICAgUGFyc2UgdGhlIGRvY3VtZW50IGVuZC5cbiAgICAqL1xuXG5cbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlX2RvY3VtZW50X2VuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGVuZF9tYXJrLCBldmVudCwgZXhwbGljaXQsIHN0YXJ0X21hcmssIHRva2VuO1xuICAgICAgdG9rZW4gPSB0aGlzLnBlZWtfdG9rZW4oKTtcbiAgICAgIHN0YXJ0X21hcmsgPSBlbmRfbWFyayA9IHRva2VuLnN0YXJ0X21hcms7XG4gICAgICBleHBsaWNpdCA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLkRvY3VtZW50RW5kVG9rZW4pKSB7XG4gICAgICAgIHRva2VuID0gdGhpcy5nZXRfdG9rZW4oKTtcbiAgICAgICAgZW5kX21hcmsgPSB0b2tlbi5lbmRfbWFyaztcbiAgICAgICAgZXhwbGljaXQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgZXZlbnQgPSBuZXcgZXZlbnRzLkRvY3VtZW50RW5kRXZlbnQoc3RhcnRfbWFyaywgZW5kX21hcmssIGV4cGxpY2l0KTtcbiAgICAgIHRoaXMuc3RhdGUgPSAncGFyc2VfZG9jdW1lbnRfc3RhcnQnO1xuICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH07XG5cbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlX2RvY3VtZW50X2NvbnRlbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBldmVudDtcbiAgICAgIGlmICh0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5EaXJlY3RpdmVUb2tlbiwgdG9rZW5zLkRvY3VtZW50U3RhcnRUb2tlbiwgdG9rZW5zLkRvY3VtZW50RW5kVG9rZW4sIHRva2Vucy5TdHJlYW1FbmRUb2tlbikpIHtcbiAgICAgICAgZXZlbnQgPSB0aGlzLnByb2Nlc3NfZW1wdHlfc2NhbGFyKHRoaXMucGVla190b2tlbigpLnN0YXJ0X21hcmspO1xuICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5zdGF0ZXMucG9wKCk7XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlX2Jsb2NrX25vZGUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wcm9jZXNzX2RpcmVjdGl2ZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBoYW5kbGUsIG1ham9yLCBtaW5vciwgcHJlZml4LCB0YWdfaGFuZGxlc19jb3B5LCB0b2tlbiwgdmFsdWUsIF9yZWYxLCBfcmVmMiwgX3JlZjM7XG4gICAgICB0aGlzLnlhbWxfdmVyc2lvbiA9IG51bGw7XG4gICAgICB0aGlzLnRhZ19oYW5kbGVzID0ge307XG4gICAgICB3aGlsZSAodGhpcy5jaGVja190b2tlbih0b2tlbnMuRGlyZWN0aXZlVG9rZW4pKSB7XG4gICAgICAgIHRva2VuID0gdGhpcy5nZXRfdG9rZW4oKTtcbiAgICAgICAgaWYgKHRva2VuLm5hbWUgPT09ICdZQU1MJykge1xuICAgICAgICAgIGlmICh0aGlzLnlhbWxfdmVyc2lvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuUGFyc2VyRXJyb3IobnVsbCwgbnVsbCwgJ2ZvdW5kIGR1cGxpY2F0ZSBZQU1MIGRpcmVjdGl2ZScsIHRva2VuLnN0YXJ0X21hcmspO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfcmVmMSA9IHRva2VuLnZhbHVlLCBtYWpvciA9IF9yZWYxWzBdLCBtaW5vciA9IF9yZWYxWzFdO1xuICAgICAgICAgIGlmIChtYWpvciAhPT0gMSB8fCBtaW5vciAhPT0gMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuUGFyc2VyRXJyb3IobnVsbCwgbnVsbCwgJ2ZvdW5kIGluY29tcGF0aWJsZSBZQU1MIGRvY3VtZW50ICh2ZXJzaW9uIDEuMiBpcyByZXF1aXJlZCknLCB0b2tlbi5zdGFydF9tYXJrKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy55YW1sX3ZlcnNpb24gPSB0b2tlbi52YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0b2tlbi5uYW1lID09PSAnVEFHJykge1xuICAgICAgICAgIF9yZWYyID0gdG9rZW4udmFsdWUsIGhhbmRsZSA9IF9yZWYyWzBdLCBwcmVmaXggPSBfcmVmMlsxXTtcbiAgICAgICAgICBpZiAoaGFuZGxlIGluIHRoaXMudGFnX2hhbmRsZXMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlBhcnNlckVycm9yKG51bGwsIG51bGwsIFwiZHVwbGljYXRlIHRhZyBoYW5kbGUgXCIgKyBoYW5kbGUsIHRva2VuLnN0YXJ0X21hcmspO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnRhZ19oYW5kbGVzW2hhbmRsZV0gPSBwcmVmaXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRhZ19oYW5kbGVzX2NvcHkgPSBudWxsO1xuICAgICAgX3JlZjMgPSB0aGlzLnRhZ19oYW5kbGVzO1xuICAgICAgZm9yIChoYW5kbGUgaW4gX3JlZjMpIHtcbiAgICAgICAgaWYgKCFfX2hhc1Byb3AuY2FsbChfcmVmMywgaGFuZGxlKSkgY29udGludWU7XG4gICAgICAgIHByZWZpeCA9IF9yZWYzW2hhbmRsZV07XG4gICAgICAgIGlmICh0YWdfaGFuZGxlc19jb3B5ID09IG51bGwpIHtcbiAgICAgICAgICB0YWdfaGFuZGxlc19jb3B5ID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdGFnX2hhbmRsZXNfY29weVtoYW5kbGVdID0gcHJlZml4O1xuICAgICAgfVxuICAgICAgdmFsdWUgPSBbdGhpcy55YW1sX3ZlcnNpb24sIHRhZ19oYW5kbGVzX2NvcHldO1xuICAgICAgZm9yIChoYW5kbGUgaW4gREVGQVVMVF9UQUdTKSB7XG4gICAgICAgIGlmICghX19oYXNQcm9wLmNhbGwoREVGQVVMVF9UQUdTLCBoYW5kbGUpKSBjb250aW51ZTtcbiAgICAgICAgcHJlZml4ID0gREVGQVVMVF9UQUdTW2hhbmRsZV07XG4gICAgICAgIGlmICghKHByZWZpeCBpbiB0aGlzLnRhZ19oYW5kbGVzKSkge1xuICAgICAgICAgIHRoaXMudGFnX2hhbmRsZXNbaGFuZGxlXSA9IHByZWZpeDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG5cbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlX2Jsb2NrX25vZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlX25vZGUodHJ1ZSk7XG4gICAgfTtcblxuICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VfZmxvd19ub2RlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZV9ub2RlKCk7XG4gICAgfTtcblxuICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VfYmxvY2tfbm9kZV9vcl9pbmRlbnRsZXNzX3NlcXVlbmNlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZV9ub2RlKHRydWUsIHRydWUpO1xuICAgIH07XG5cbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlX25vZGUgPSBmdW5jdGlvbihibG9jaywgaW5kZW50bGVzc19zZXF1ZW5jZSkge1xuICAgICAgdmFyIGFuY2hvciwgZW5kX21hcmssIGV2ZW50LCBoYW5kbGUsIGltcGxpY2l0LCBub2RlLCBzdGFydF9tYXJrLCBzdWZmaXgsIHRhZywgdGFnX21hcmssIHRva2VuO1xuICAgICAgaWYgKGJsb2NrID09IG51bGwpIHtcbiAgICAgICAgYmxvY2sgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChpbmRlbnRsZXNzX3NlcXVlbmNlID09IG51bGwpIHtcbiAgICAgICAgaW5kZW50bGVzc19zZXF1ZW5jZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLkFsaWFzVG9rZW4pKSB7XG4gICAgICAgIHRva2VuID0gdGhpcy5nZXRfdG9rZW4oKTtcbiAgICAgICAgZXZlbnQgPSBuZXcgZXZlbnRzLkFsaWFzRXZlbnQodG9rZW4udmFsdWUsIHRva2VuLnN0YXJ0X21hcmssIHRva2VuLmVuZF9tYXJrKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuc3RhdGVzLnBvcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYW5jaG9yID0gbnVsbDtcbiAgICAgICAgdGFnID0gbnVsbDtcbiAgICAgICAgc3RhcnRfbWFyayA9IGVuZF9tYXJrID0gdGFnX21hcmsgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5jaGVja190b2tlbih0b2tlbnMuQW5jaG9yVG9rZW4pKSB7XG4gICAgICAgICAgdG9rZW4gPSB0aGlzLmdldF90b2tlbigpO1xuICAgICAgICAgIHN0YXJ0X21hcmsgPSB0b2tlbi5zdGFydF9tYXJrO1xuICAgICAgICAgIGVuZF9tYXJrID0gdG9rZW4uZW5kX21hcms7XG4gICAgICAgICAgYW5jaG9yID0gdG9rZW4udmFsdWU7XG4gICAgICAgICAgaWYgKHRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLlRhZ1Rva2VuKSkge1xuICAgICAgICAgICAgdG9rZW4gPSB0aGlzLmdldF90b2tlbigpO1xuICAgICAgICAgICAgdGFnX21hcmsgPSB0b2tlbi5zdGFydF9tYXJrO1xuICAgICAgICAgICAgZW5kX21hcmsgPSB0b2tlbi5lbmRfbWFyaztcbiAgICAgICAgICAgIHRhZyA9IHRva2VuLnZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5UYWdUb2tlbikpIHtcbiAgICAgICAgICB0b2tlbiA9IHRoaXMuZ2V0X3Rva2VuKCk7XG4gICAgICAgICAgc3RhcnRfbWFyayA9IHRhZ19tYXJrID0gdG9rZW4uc3RhcnRfbWFyaztcbiAgICAgICAgICBlbmRfbWFyayA9IHRva2VuLmVuZF9tYXJrO1xuICAgICAgICAgIHRhZyA9IHRva2VuLnZhbHVlO1xuICAgICAgICAgIGlmICh0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5BbmNob3JUb2tlbikpIHtcbiAgICAgICAgICAgIHRva2VuID0gdGhpcy5nZXRfdG9rZW4oKTtcbiAgICAgICAgICAgIGVuZF9tYXJrID0gdG9rZW4uZW5kX21hcms7XG4gICAgICAgICAgICBhbmNob3IgPSB0b2tlbi52YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhZyAhPT0gbnVsbCkge1xuICAgICAgICAgIGhhbmRsZSA9IHRhZ1swXSwgc3VmZml4ID0gdGFnWzFdO1xuICAgICAgICAgIGlmIChoYW5kbGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICghKGhhbmRsZSBpbiB0aGlzLnRhZ19oYW5kbGVzKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5QYXJzZXJFcnJvcignd2hpbGUgcGFyc2luZyBhIG5vZGUnLCBzdGFydF9tYXJrLCBcImZvdW5kIHVuZGVmaW5lZCB0YWcgaGFuZGxlIFwiICsgaGFuZGxlLCB0YWdfbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YWcgPSB0aGlzLnRhZ19oYW5kbGVzW2hhbmRsZV0gKyBzdWZmaXg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhZyA9IHN1ZmZpeDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0X21hcmsgPT09IG51bGwpIHtcbiAgICAgICAgICBzdGFydF9tYXJrID0gZW5kX21hcmsgPSB0aGlzLnBlZWtfdG9rZW4oKS5zdGFydF9tYXJrO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50ID0gbnVsbDtcbiAgICAgICAgaW1wbGljaXQgPSB0YWcgPT09IG51bGwgfHwgdGFnID09PSAnISc7XG4gICAgICAgIGlmIChpbmRlbnRsZXNzX3NlcXVlbmNlICYmIHRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLkJsb2NrRW50cnlUb2tlbikpIHtcbiAgICAgICAgICBlbmRfbWFyayA9IHRoaXMucGVla190b2tlbigpLmVuZF9tYXJrO1xuICAgICAgICAgIGV2ZW50ID0gbmV3IGV2ZW50cy5TZXF1ZW5jZVN0YXJ0RXZlbnQoYW5jaG9yLCB0YWcsIGltcGxpY2l0LCBzdGFydF9tYXJrLCBlbmRfbWFyayk7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9ICdwYXJzZV9pbmRlbnRsZXNzX3NlcXVlbmNlX2VudHJ5JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5jaGVja190b2tlbih0b2tlbnMuU2NhbGFyVG9rZW4pKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHRoaXMuZ2V0X3Rva2VuKCk7XG4gICAgICAgICAgICBlbmRfbWFyayA9IHRva2VuLmVuZF9tYXJrO1xuICAgICAgICAgICAgaWYgKCh0b2tlbi5wbGFpbiAmJiB0YWcgPT09IG51bGwpIHx8IHRhZyA9PT0gJyEnKSB7XG4gICAgICAgICAgICAgIGltcGxpY2l0ID0gW3RydWUsIGZhbHNlXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGFnID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIGltcGxpY2l0ID0gW2ZhbHNlLCB0cnVlXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGltcGxpY2l0ID0gW2ZhbHNlLCBmYWxzZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldmVudCA9IG5ldyBldmVudHMuU2NhbGFyRXZlbnQoYW5jaG9yLCB0YWcsIGltcGxpY2l0LCB0b2tlbi52YWx1ZSwgc3RhcnRfbWFyaywgZW5kX21hcmssIHRva2VuLnN0eWxlKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLnN0YXRlcy5wb3AoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLkZsb3dTZXF1ZW5jZVN0YXJ0VG9rZW4pKSB7XG4gICAgICAgICAgICBlbmRfbWFyayA9IHRoaXMucGVla190b2tlbigpLmVuZF9tYXJrO1xuICAgICAgICAgICAgZXZlbnQgPSBuZXcgZXZlbnRzLlNlcXVlbmNlU3RhcnRFdmVudChhbmNob3IsIHRhZywgaW1wbGljaXQsIHN0YXJ0X21hcmssIGVuZF9tYXJrLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAncGFyc2VfZmxvd19zZXF1ZW5jZV9maXJzdF9lbnRyeSc7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5GbG93TWFwcGluZ1N0YXJ0VG9rZW4pKSB7XG4gICAgICAgICAgICBlbmRfbWFyayA9IHRoaXMucGVla190b2tlbigpLmVuZF9tYXJrO1xuICAgICAgICAgICAgZXZlbnQgPSBuZXcgZXZlbnRzLk1hcHBpbmdTdGFydEV2ZW50KGFuY2hvciwgdGFnLCBpbXBsaWNpdCwgc3RhcnRfbWFyaywgZW5kX21hcmssIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9ICdwYXJzZV9mbG93X21hcHBpbmdfZmlyc3Rfa2V5JztcbiAgICAgICAgICB9IGVsc2UgaWYgKGJsb2NrICYmIHRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLkJsb2NrU2VxdWVuY2VTdGFydFRva2VuKSkge1xuICAgICAgICAgICAgZW5kX21hcmsgPSB0aGlzLnBlZWtfdG9rZW4oKS5lbmRfbWFyaztcbiAgICAgICAgICAgIGV2ZW50ID0gbmV3IGV2ZW50cy5TZXF1ZW5jZVN0YXJ0RXZlbnQoYW5jaG9yLCB0YWcsIGltcGxpY2l0LCBzdGFydF9tYXJrLCBlbmRfbWFyaywgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9ICdwYXJzZV9ibG9ja19zZXF1ZW5jZV9maXJzdF9lbnRyeSc7XG4gICAgICAgICAgfSBlbHNlIGlmIChibG9jayAmJiB0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5CbG9ja01hcHBpbmdTdGFydFRva2VuKSkge1xuICAgICAgICAgICAgZW5kX21hcmsgPSB0aGlzLnBlZWtfdG9rZW4oKS5lbmRfbWFyaztcbiAgICAgICAgICAgIGV2ZW50ID0gbmV3IGV2ZW50cy5NYXBwaW5nU3RhcnRFdmVudChhbmNob3IsIHRhZywgaW1wbGljaXQsIHN0YXJ0X21hcmssIGVuZF9tYXJrLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gJ3BhcnNlX2Jsb2NrX21hcHBpbmdfZmlyc3Rfa2V5JztcbiAgICAgICAgICB9IGVsc2UgaWYgKGFuY2hvciAhPT0gbnVsbCB8fCB0YWcgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGV2ZW50ID0gbmV3IGV2ZW50cy5TY2FsYXJFdmVudChhbmNob3IsIHRhZywgW2ltcGxpY2l0LCBmYWxzZV0sICcnLCBzdGFydF9tYXJrLCBlbmRfbWFyayk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5zdGF0ZXMucG9wKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChibG9jaykge1xuICAgICAgICAgICAgICBub2RlID0gJ2Jsb2NrJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5vZGUgPSAnZmxvdyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b2tlbiA9IHRoaXMucGVla190b2tlbigpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuUGFyc2VyRXJyb3IoXCJ3aGlsZSBwYXJzaW5nIGEgXCIgKyBub2RlICsgXCIgbm9kZVwiLCBzdGFydF9tYXJrLCBcImV4cGVjdGVkIHRoZSBub2RlIGNvbnRlbnQsIGJ1dCBmb3VuZCBcIiArIHRva2VuLmlkLCB0b2tlbi5zdGFydF9tYXJrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBldmVudDtcbiAgICB9O1xuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZV9ibG9ja19zZXF1ZW5jZV9maXJzdF9lbnRyeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRva2VuO1xuICAgICAgdG9rZW4gPSB0aGlzLmdldF90b2tlbigpO1xuICAgICAgdGhpcy5tYXJrcy5wdXNoKHRva2VuLnN0YXJ0X21hcmspO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VfYmxvY2tfc2VxdWVuY2VfZW50cnkoKTtcbiAgICB9O1xuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZV9ibG9ja19zZXF1ZW5jZV9lbnRyeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGV2ZW50LCB0b2tlbjtcbiAgICAgIGlmICh0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5CbG9ja0VudHJ5VG9rZW4pKSB7XG4gICAgICAgIHRva2VuID0gdGhpcy5nZXRfdG9rZW4oKTtcbiAgICAgICAgaWYgKCF0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5CbG9ja0VudHJ5VG9rZW4sIHRva2Vucy5CbG9ja0VuZFRva2VuKSkge1xuICAgICAgICAgIHRoaXMuc3RhdGVzLnB1c2goJ3BhcnNlX2Jsb2NrX3NlcXVlbmNlX2VudHJ5Jyk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VfYmxvY2tfbm9kZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSAncGFyc2VfYmxvY2tfc2VxdWVuY2VfZW50cnknO1xuICAgICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NfZW1wdHlfc2NhbGFyKHRva2VuLmVuZF9tYXJrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5CbG9ja0VuZFRva2VuKSkge1xuICAgICAgICB0b2tlbiA9IHRoaXMucGVla190b2tlbigpO1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5QYXJzZXJFcnJvcignd2hpbGUgcGFyc2luZyBhIGJsb2NrIGNvbGxlY3Rpb24nLCB0aGlzLm1hcmtzLnNsaWNlKC0xKVswXSwgXCJleHBlY3RlZCA8YmxvY2sgZW5kPiwgYnV0IGZvdW5kIFwiICsgdG9rZW4uaWQsIHRva2VuLnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgdG9rZW4gPSB0aGlzLmdldF90b2tlbigpO1xuICAgICAgZXZlbnQgPSBuZXcgZXZlbnRzLlNlcXVlbmNlRW5kRXZlbnQodG9rZW4uc3RhcnRfbWFyaywgdG9rZW4uZW5kX21hcmspO1xuICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuc3RhdGVzLnBvcCgpO1xuICAgICAgdGhpcy5tYXJrcy5wb3AoKTtcbiAgICAgIHJldHVybiBldmVudDtcbiAgICB9O1xuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZV9pbmRlbnRsZXNzX3NlcXVlbmNlX2VudHJ5ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZXZlbnQsIHRva2VuO1xuICAgICAgaWYgKHRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLkJsb2NrRW50cnlUb2tlbikpIHtcbiAgICAgICAgdG9rZW4gPSB0aGlzLmdldF90b2tlbigpO1xuICAgICAgICBpZiAoIXRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLkJsb2NrRW50cnlUb2tlbiwgdG9rZW5zLktleVRva2VuLCB0b2tlbnMuVmFsdWVUb2tlbiwgdG9rZW5zLkJsb2NrRW5kVG9rZW4pKSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZXMucHVzaCgncGFyc2VfaW5kZW50bGVzc19zZXF1ZW5jZV9lbnRyeScpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlX2Jsb2NrX25vZGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gJ3BhcnNlX2luZGVudGxlc3Nfc2VxdWVuY2VfZW50cnknO1xuICAgICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NfZW1wdHlfc2NhbGFyKHRva2VuLmVuZF9tYXJrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdG9rZW4gPSB0aGlzLnBlZWtfdG9rZW4oKTtcbiAgICAgIGV2ZW50ID0gbmV3IGV2ZW50cy5TZXF1ZW5jZUVuZEV2ZW50KHRva2VuLnN0YXJ0X21hcmssIHRva2VuLnN0YXJ0X21hcmspO1xuICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuc3RhdGVzLnBvcCgpO1xuICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH07XG5cbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlX2Jsb2NrX21hcHBpbmdfZmlyc3Rfa2V5ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdG9rZW47XG4gICAgICB0b2tlbiA9IHRoaXMuZ2V0X3Rva2VuKCk7XG4gICAgICB0aGlzLm1hcmtzLnB1c2godG9rZW4uc3RhcnRfbWFyayk7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZV9ibG9ja19tYXBwaW5nX2tleSgpO1xuICAgIH07XG5cbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlX2Jsb2NrX21hcHBpbmdfa2V5ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZXZlbnQsIHRva2VuO1xuICAgICAgaWYgKHRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLktleVRva2VuKSkge1xuICAgICAgICB0b2tlbiA9IHRoaXMuZ2V0X3Rva2VuKCk7XG4gICAgICAgIGlmICghdGhpcy5jaGVja190b2tlbih0b2tlbnMuS2V5VG9rZW4sIHRva2Vucy5WYWx1ZVRva2VuLCB0b2tlbnMuQmxvY2tFbmRUb2tlbikpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlcy5wdXNoKCdwYXJzZV9ibG9ja19tYXBwaW5nX3ZhbHVlJyk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VfYmxvY2tfbm9kZV9vcl9pbmRlbnRsZXNzX3NlcXVlbmNlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9ICdwYXJzZV9ibG9ja19tYXBwaW5nX3ZhbHVlJztcbiAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzX2VtcHR5X3NjYWxhcih0b2tlbi5lbmRfbWFyayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5jaGVja190b2tlbih0b2tlbnMuQmxvY2tFbmRUb2tlbikpIHtcbiAgICAgICAgdG9rZW4gPSB0aGlzLnBlZWtfdG9rZW4oKTtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuUGFyc2VyRXJyb3IoJ3doaWxlIHBhcnNpbmcgYSBibG9jayBtYXBwaW5nJywgdGhpcy5tYXJrcy5zbGljZSgtMSlbMF0sIFwiZXhwZWN0ZWQgPGJsb2NrIGVuZD4sIGJ1dCBmb3VuZCBcIiArIHRva2VuLmlkLCB0b2tlbi5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIHRva2VuID0gdGhpcy5nZXRfdG9rZW4oKTtcbiAgICAgIGV2ZW50ID0gbmV3IGV2ZW50cy5NYXBwaW5nRW5kRXZlbnQodG9rZW4uc3RhcnRfbWFyaywgdG9rZW4uZW5kX21hcmspO1xuICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuc3RhdGVzLnBvcCgpO1xuICAgICAgdGhpcy5tYXJrcy5wb3AoKTtcbiAgICAgIHJldHVybiBldmVudDtcbiAgICB9O1xuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZV9ibG9ja19tYXBwaW5nX3ZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdG9rZW47XG4gICAgICBpZiAodGhpcy5jaGVja190b2tlbih0b2tlbnMuVmFsdWVUb2tlbikpIHtcbiAgICAgICAgdG9rZW4gPSB0aGlzLmdldF90b2tlbigpO1xuICAgICAgICBpZiAoIXRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLktleVRva2VuLCB0b2tlbnMuVmFsdWVUb2tlbiwgdG9rZW5zLkJsb2NrRW5kVG9rZW4pKSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZXMucHVzaCgncGFyc2VfYmxvY2tfbWFwcGluZ19rZXknKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZV9ibG9ja19ub2RlX29yX2luZGVudGxlc3Nfc2VxdWVuY2UoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gJ3BhcnNlX2Jsb2NrX21hcHBpbmdfa2V5JztcbiAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzX2VtcHR5X3NjYWxhcih0b2tlbi5lbmRfbWFyayk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAncGFyc2VfYmxvY2tfbWFwcGluZ19rZXknO1xuICAgICAgICB0b2tlbiA9IHRoaXMucGVla190b2tlbigpO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzX2VtcHR5X3NjYWxhcih0b2tlbi5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZV9mbG93X3NlcXVlbmNlX2ZpcnN0X2VudHJ5ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdG9rZW47XG4gICAgICB0b2tlbiA9IHRoaXMuZ2V0X3Rva2VuKCk7XG4gICAgICB0aGlzLm1hcmtzLnB1c2godG9rZW4uc3RhcnRfbWFyayk7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZV9mbG93X3NlcXVlbmNlX2VudHJ5KHRydWUpO1xuICAgIH07XG5cbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlX2Zsb3dfc2VxdWVuY2VfZW50cnkgPSBmdW5jdGlvbihmaXJzdCkge1xuICAgICAgdmFyIGV2ZW50LCB0b2tlbjtcbiAgICAgIGlmIChmaXJzdCA9PSBudWxsKSB7XG4gICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLkZsb3dTZXF1ZW5jZUVuZFRva2VuKSkge1xuICAgICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgICAgaWYgKHRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLkZsb3dFbnRyeVRva2VuKSkge1xuICAgICAgICAgICAgdGhpcy5nZXRfdG9rZW4oKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnBlZWtfdG9rZW4oKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlBhcnNlckVycm9yKCd3aGlsZSBwYXJzaW5nIGEgZmxvdyBzZXF1ZW5jZScsIHRoaXMubWFya3Muc2xpY2UoLTEpWzBdLCBcImV4cGVjdGVkICcsJyBvciAnXScsIGJ1dCBnb3QgXCIgKyB0b2tlbi5pZCwgdG9rZW4uc3RhcnRfbWFyayk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5LZXlUb2tlbikpIHtcbiAgICAgICAgICB0b2tlbiA9IHRoaXMucGVla190b2tlbigpO1xuICAgICAgICAgIGV2ZW50ID0gbmV3IGV2ZW50cy5NYXBwaW5nU3RhcnRFdmVudChudWxsLCBudWxsLCB0cnVlLCB0b2tlbi5zdGFydF9tYXJrLCB0b2tlbi5lbmRfbWFyaywgdHJ1ZSk7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9ICdwYXJzZV9mbG93X3NlcXVlbmNlX2VudHJ5X21hcHBpbmdfa2V5JztcbiAgICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLkZsb3dTZXF1ZW5jZUVuZFRva2VuKSkge1xuICAgICAgICAgIHRoaXMuc3RhdGVzLnB1c2goJ3BhcnNlX2Zsb3dfc2VxdWVuY2VfZW50cnknKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZV9mbG93X25vZGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdG9rZW4gPSB0aGlzLmdldF90b2tlbigpO1xuICAgICAgZXZlbnQgPSBuZXcgZXZlbnRzLlNlcXVlbmNlRW5kRXZlbnQodG9rZW4uc3RhcnRfbWFyaywgdG9rZW4uZW5kX21hcmspO1xuICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuc3RhdGVzLnBvcCgpO1xuICAgICAgdGhpcy5tYXJrcy5wb3AoKTtcbiAgICAgIHJldHVybiBldmVudDtcbiAgICB9O1xuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZV9mbG93X3NlcXVlbmNlX2VudHJ5X21hcHBpbmdfa2V5ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdG9rZW47XG4gICAgICB0b2tlbiA9IHRoaXMuZ2V0X3Rva2VuKCk7XG4gICAgICBpZiAoIXRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLlZhbHVlVG9rZW4sIHRva2Vucy5GbG93RW50cnlUb2tlbiwgdG9rZW5zLkZsb3dTZXF1ZW5jZUVuZFRva2VuKSkge1xuICAgICAgICB0aGlzLnN0YXRlcy5wdXNoKCdwYXJzZV9mbG93X3NlcXVlbmNlX2VudHJ5X21hcHBpbmdfdmFsdWUnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VfZmxvd19ub2RlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXRlID0gJ3BhcnNlX2Zsb3dfc2VxdWVuY2VfZW50cnlfbWFwcGluZ192YWx1ZSc7XG4gICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NfZW1wdHlfc2NhbGFyKHRva2VuLmVuZF9tYXJrKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZV9mbG93X3NlcXVlbmNlX2VudHJ5X21hcHBpbmdfdmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0b2tlbjtcbiAgICAgIGlmICh0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5WYWx1ZVRva2VuKSkge1xuICAgICAgICB0b2tlbiA9IHRoaXMuZ2V0X3Rva2VuKCk7XG4gICAgICAgIGlmICghdGhpcy5jaGVja190b2tlbih0b2tlbnMuRmxvd0VudHJ5VG9rZW4sIHRva2Vucy5GbG93U2VxdWVuY2VFbmRUb2tlbikpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlcy5wdXNoKCdwYXJzZV9mbG93X3NlcXVlbmNlX2VudHJ5X21hcHBpbmdfZW5kJyk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VfZmxvd19ub2RlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9ICdwYXJzZV9mbG93X3NlcXVlbmNlX2VudHJ5X21hcHBpbmdfZW5kJztcbiAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzX2VtcHR5X3NjYWxhcih0b2tlbi5lbmRfbWFyayk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAncGFyc2VfZmxvd19zZXF1ZW5jZV9lbnRyeV9tYXBwaW5nX2VuZCc7XG4gICAgICAgIHRva2VuID0gdGhpcy5wZWVrX3Rva2VuKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NfZW1wdHlfc2NhbGFyKHRva2VuLnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlX2Zsb3dfc2VxdWVuY2VfZW50cnlfbWFwcGluZ19lbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0b2tlbjtcbiAgICAgIHRoaXMuc3RhdGUgPSAncGFyc2VfZmxvd19zZXF1ZW5jZV9lbnRyeSc7XG4gICAgICB0b2tlbiA9IHRoaXMucGVla190b2tlbigpO1xuICAgICAgcmV0dXJuIG5ldyBldmVudHMuTWFwcGluZ0VuZEV2ZW50KHRva2VuLnN0YXJ0X21hcmssIHRva2VuLnN0YXJ0X21hcmspO1xuICAgIH07XG5cbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlX2Zsb3dfbWFwcGluZ19maXJzdF9rZXkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0b2tlbjtcbiAgICAgIHRva2VuID0gdGhpcy5nZXRfdG9rZW4oKTtcbiAgICAgIHRoaXMubWFya3MucHVzaCh0b2tlbi5zdGFydF9tYXJrKTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlX2Zsb3dfbWFwcGluZ19rZXkodHJ1ZSk7XG4gICAgfTtcblxuICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VfZmxvd19tYXBwaW5nX2tleSA9IGZ1bmN0aW9uKGZpcnN0KSB7XG4gICAgICB2YXIgZXZlbnQsIHRva2VuO1xuICAgICAgaWYgKGZpcnN0ID09IG51bGwpIHtcbiAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5jaGVja190b2tlbih0b2tlbnMuRmxvd01hcHBpbmdFbmRUb2tlbikpIHtcbiAgICAgICAgaWYgKCFmaXJzdCkge1xuICAgICAgICAgIGlmICh0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5GbG93RW50cnlUb2tlbikpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0X3Rva2VuKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRva2VuID0gdGhpcy5wZWVrX3Rva2VuKCk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5QYXJzZXJFcnJvcignd2hpbGUgcGFyc2luZyBhIGZsb3cgbWFwcGluZycsIHRoaXMubWFya3Muc2xpY2UoLTEpWzBdLCBcImV4cGVjdGVkICcsJyBvciAnfScsIGJ1dCBnb3QgXCIgKyB0b2tlbi5pZCwgdG9rZW4uc3RhcnRfbWFyayk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5LZXlUb2tlbikpIHtcbiAgICAgICAgICB0b2tlbiA9IHRoaXMuZ2V0X3Rva2VuKCk7XG4gICAgICAgICAgaWYgKCF0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5WYWx1ZVRva2VuLCB0b2tlbnMuRmxvd0VudHJ5VG9rZW4sIHRva2Vucy5GbG93TWFwcGluZ0VuZFRva2VuKSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZXMucHVzaCgncGFyc2VfZmxvd19tYXBwaW5nX3ZhbHVlJyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZV9mbG93X25vZGUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9ICdwYXJzZV9mbG93X21hcHBpbmdfdmFsdWUnO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc19lbXB0eV9zY2FsYXIodG9rZW4uZW5kX21hcmspO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5jaGVja190b2tlbih0b2tlbnMuRmxvd01hcHBpbmdFbmRUb2tlbikpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlcy5wdXNoKCdwYXJzZV9mbG93X21hcHBpbmdfZW1wdHlfdmFsdWUnKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZV9mbG93X25vZGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdG9rZW4gPSB0aGlzLmdldF90b2tlbigpO1xuICAgICAgZXZlbnQgPSBuZXcgZXZlbnRzLk1hcHBpbmdFbmRFdmVudCh0b2tlbi5zdGFydF9tYXJrLCB0b2tlbi5lbmRfbWFyayk7XG4gICAgICB0aGlzLnN0YXRlID0gdGhpcy5zdGF0ZXMucG9wKCk7XG4gICAgICB0aGlzLm1hcmtzLnBvcCgpO1xuICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH07XG5cbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlX2Zsb3dfbWFwcGluZ192YWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRva2VuO1xuICAgICAgaWYgKHRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLlZhbHVlVG9rZW4pKSB7XG4gICAgICAgIHRva2VuID0gdGhpcy5nZXRfdG9rZW4oKTtcbiAgICAgICAgaWYgKCF0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5GbG93RW50cnlUb2tlbiwgdG9rZW5zLkZsb3dNYXBwaW5nRW5kVG9rZW4pKSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZXMucHVzaCgncGFyc2VfZmxvd19tYXBwaW5nX2tleScpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlX2Zsb3dfbm9kZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSAncGFyc2VfZmxvd19tYXBwaW5nX2tleSc7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc19lbXB0eV9zY2FsYXIodG9rZW4uZW5kX21hcmspO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXRlID0gJ3BhcnNlX2Zsb3dfbWFwcGluZ19rZXknO1xuICAgICAgICB0b2tlbiA9IHRoaXMucGVla190b2tlbigpO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzX2VtcHR5X3NjYWxhcih0b2tlbi5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZV9mbG93X21hcHBpbmdfZW1wdHlfdmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSAncGFyc2VfZmxvd19tYXBwaW5nX2tleSc7XG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzX2VtcHR5X3NjYWxhcih0aGlzLnBlZWtfdG9rZW4oKS5zdGFydF9tYXJrKTtcbiAgICB9O1xuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wcm9jZXNzX2VtcHR5X3NjYWxhciA9IGZ1bmN0aW9uKG1hcmspIHtcbiAgICAgIHJldHVybiBuZXcgZXZlbnRzLlNjYWxhckV2ZW50KG51bGwsIG51bGwsIFt0cnVlLCBmYWxzZV0sICcnLCBtYXJrLCBtYXJrKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFBhcnNlcjtcblxuICB9KSgpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiKGZ1bmN0aW9uKCkge1xuICB2YXIgTWFya2VkWUFNTEVycm9yLCBub2RlcywgdXJsLCB1dGlsLFxuICAgIF9fYmluZCA9IGZ1bmN0aW9uKGZuLCBtZSl7IHJldHVybiBmdW5jdGlvbigpeyByZXR1cm4gZm4uYXBwbHkobWUsIGFyZ3VtZW50cyk7IH07IH07XG5cbiAgdXJsID0gcmVxdWlyZSgndXJsJyk7XG5cbiAgTWFya2VkWUFNTEVycm9yID0gcmVxdWlyZSgnLi9lcnJvcnMnKS5NYXJrZWRZQU1MRXJyb3I7XG5cbiAgbm9kZXMgPSByZXF1aXJlKCcuL25vZGVzJyk7XG5cbiAgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4gIC8qXG4gIFRoZSBQcm90b2NvbHMgY2xhc3MgZGVhbHMgd2l0aCBhcHBseWluZyBwcm90b2NvbHMgdG8gbWV0aG9kcyBhY2NvcmRpbmcgdG8gdGhlIHNwZWNcbiAgKi9cblxuXG4gIHRoaXMuUHJvdG9jb2xzID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFByb3RvY29scygpIHtcbiAgICAgIHRoaXMuYXBwbHlfcHJvdG9jb2xzID0gX19iaW5kKHRoaXMuYXBwbHlfcHJvdG9jb2xzLCB0aGlzKTtcbiAgICB9XG5cbiAgICBQcm90b2NvbHMucHJvdG90eXBlLmFwcGx5X3Byb3RvY29scyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBwcm90b2NvbHM7XG4gICAgICBpZiAocHJvdG9jb2xzID0gdGhpcy5hcHBseV9wcm90b2NvbHNfdG9fcm9vdChub2RlKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBseV9wcm90b2NvbHNfdG9fcmVzb3VyY2VzKG5vZGUsIHByb3RvY29scyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFByb3RvY29scy5wcm90b3R5cGUuYXBwbHlfcHJvdG9jb2xzX3RvX3Jvb3QgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgYmFzZVVyaSwgcGFyc2VkQmFzZVVyaSwgcHJvdG9jb2wsIHByb3RvY29scztcbiAgICAgIGlmICh0aGlzLmhhc19wcm9wZXJ0eShub2RlLCAncHJvdG9jb2xzJykpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0X3Byb3BlcnR5KG5vZGUsICdwcm90b2NvbHMnKTtcbiAgICAgIH1cbiAgICAgIGlmICghKGJhc2VVcmkgPSB0aGlzLnByb3BlcnR5X3ZhbHVlKG5vZGUsICdiYXNlVXJpJykpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHBhcnNlZEJhc2VVcmkgPSB1cmwucGFyc2UoYmFzZVVyaSk7XG4gICAgICBwcm90b2NvbCA9IChwYXJzZWRCYXNlVXJpLnByb3RvY29sIHx8ICdodHRwOicpLnNsaWNlKDAsIC0xKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgcHJvdG9jb2xzID0gW25ldyBub2Rlcy5TY2FsYXJOb2RlKCd0YWc6eWFtbC5vcmcsMjAwMjpzdHInLCAncHJvdG9jb2xzJywgbm9kZS5zdGFydF9tYXJrLCBub2RlLmVuZF9tYXJrKSwgbmV3IG5vZGVzLlNlcXVlbmNlTm9kZSgndGFnOnlhbWwub3JnLDIwMDI6c2VxJywgW25ldyBub2Rlcy5TY2FsYXJOb2RlKCd0YWc6eWFtbC5vcmcsMjAwMjpzdHInLCBwcm90b2NvbCwgbm9kZS5zdGFydF9tYXJrLCBub2RlLmVuZF9tYXJrKV0sIG5vZGUuc3RhcnRfbWFyaywgbm9kZS5lbmRfbWFyayldO1xuICAgICAgbm9kZS52YWx1ZS5wdXNoKHByb3RvY29scyk7XG4gICAgICByZXR1cm4gcHJvdG9jb2xzWzFdO1xuICAgIH07XG5cbiAgICBQcm90b2NvbHMucHJvdG90eXBlLmFwcGx5X3Byb3RvY29sc190b19yZXNvdXJjZXMgPSBmdW5jdGlvbihub2RlLCBwcm90b2NvbHMpIHtcbiAgICAgIHZhciByZXNvdXJjZSwgX2ksIF9sZW4sIF9yZWYsIF9yZXN1bHRzO1xuICAgICAgX3JlZiA9IHRoaXMuY2hpbGRfcmVzb3VyY2VzKG5vZGUpO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICByZXNvdXJjZSA9IF9yZWZbX2ldO1xuICAgICAgICB0aGlzLmFwcGx5X3Byb3RvY29sc190b19yZXNvdXJjZXMocmVzb3VyY2UsIHByb3RvY29scyk7XG4gICAgICAgIF9yZXN1bHRzLnB1c2godGhpcy5hcHBseV9wcm90b2NvbHNfdG9fbWV0aG9kcyhyZXNvdXJjZSwgcHJvdG9jb2xzKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfTtcblxuICAgIFByb3RvY29scy5wcm90b3R5cGUuYXBwbHlfcHJvdG9jb2xzX3RvX21ldGhvZHMgPSBmdW5jdGlvbihub2RlLCBwcm90b2NvbHMpIHtcbiAgICAgIHZhciBtZXRob2QsIF9pLCBfbGVuLCBfcmVmLCBfcmVzdWx0cztcbiAgICAgIF9yZWYgPSB0aGlzLmNoaWxkX21ldGhvZHMobm9kZVsxXSk7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIG1ldGhvZCA9IF9yZWZbX2ldO1xuICAgICAgICBpZiAoIXRoaXMuaGFzX3Byb3BlcnR5KG1ldGhvZFsxXSwgJ3Byb3RvY29scycpKSB7XG4gICAgICAgICAgaWYgKCF1dGlsLmlzTWFwcGluZyhtZXRob2RbMV0pKSB7XG4gICAgICAgICAgICBtZXRob2RbMV0gPSBuZXcgbm9kZXMuTWFwcGluZ05vZGUoJ3RhZzp5YW1sLm9yZywyMDAyOm1hcCcsIFtdLCBtZXRob2RbMV0uc3RhcnRfbWFyaywgbWV0aG9kWzFdLmVuZF9tYXJrKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaChtZXRob2RbMV0udmFsdWUucHVzaChbbmV3IG5vZGVzLlNjYWxhck5vZGUoJ3RhZzp5YW1sLm9yZywyMDAyOnN0cicsICdwcm90b2NvbHMnLCBtZXRob2RbMF0uc3RhcnRfbWFyaywgbWV0aG9kWzBdLmVuZF9tYXJrKSwgcHJvdG9jb2xzLmNsb25lKCldKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaCh2b2lkIDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfTtcblxuICAgIHJldHVybiBQcm90b2NvbHM7XG5cbiAgfSkoKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIihmdW5jdGlvbigpIHtcbiAgdmFyIGRlZmF1bHRTZXR0aW5ncywgdXRpbCwgX3JlZixcbiAgICBfX2hhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSxcbiAgICBfX2V4dGVuZHMgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKF9faGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfTtcblxuICB0aGlzLmVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5cbiAgdGhpcy5sb2FkZXIgPSByZXF1aXJlKCcuL2xvYWRlcicpO1xuXG4gIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuICB0aGlzLkZpbGVFcnJvciA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRmlsZUVycm9yLCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gRmlsZUVycm9yKCkge1xuICAgICAgX3JlZiA9IEZpbGVFcnJvci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfcmVmO1xuICAgIH1cblxuICAgIHJldHVybiBGaWxlRXJyb3I7XG5cbiAgfSkodGhpcy5lcnJvcnMuTWFya2VkWUFNTEVycm9yKTtcblxuICB0aGlzLkZpbGVSZWFkZXIgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gRmlsZVJlYWRlcihyZWFkRmlsZUFzeW5jT3ZlcnJpZGUpIHtcbiAgICAgIHRoaXMucSA9IHJlcXVpcmUoJ3EnKTtcbiAgICAgIHRoaXMudXJsID0gcmVxdWlyZSgndXJsJyk7XG4gICAgICBpZiAocmVhZEZpbGVBc3luY092ZXJyaWRlKSB7XG4gICAgICAgIHRoaXMucmVhZEZpbGVBc3luY092ZXJyaWRlID0gcmVhZEZpbGVBc3luY092ZXJyaWRlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgUmVhZCBmaWxlIGVpdGhlciBsb2NhbGx5IG9yIGZyb20gdGhlIG5ldHdvcmsuXG4gICAgKi9cblxuXG4gICAgRmlsZVJlYWRlci5wcm90b3R5cGUucmVhZEZpbGVBc3luYyA9IGZ1bmN0aW9uKGZpbGUpIHtcbiAgICAgIHZhciB0YXJnZXJVcmw7XG4gICAgICBpZiAodGhpcy5yZWFkRmlsZUFzeW5jT3ZlcnJpZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZEZpbGVBc3luY092ZXJyaWRlKGZpbGUpO1xuICAgICAgfVxuICAgICAgdGFyZ2VyVXJsID0gdGhpcy51cmwucGFyc2UoZmlsZSk7XG4gICAgICBpZiAodGFyZ2VyVXJsLnByb3RvY29sICE9IG51bGwpIHtcbiAgICAgICAgaWYgKCF0YXJnZXJVcmwucHJvdG9jb2wubWF0Y2goL15odHRwcz8vaSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5GaWxlRXJyb3IoXCJ3aGlsZSByZWFkaW5nIFwiICsgZmlsZSwgbnVsbCwgXCJ1bmtub3duIHByb3RvY29sIFwiICsgdGFyZ2VyVXJsLnByb3RvY29sLCB0aGlzLnN0YXJ0X21hcmspO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoRmlsZUFzeW5jKGZpbGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaEZpbGVBc3luYyhmaWxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaExvY2FsRmlsZUFzeW5jKGZpbGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qXG4gICAgUmVhZCBmaWxlIGZyb20gdGhlIGRpc2suXG4gICAgKi9cblxuXG4gICAgRmlsZVJlYWRlci5wcm90b3R5cGUuZmV0Y2hMb2NhbEZpbGVBc3luYyA9IGZ1bmN0aW9uKGZpbGUpIHtcbiAgICAgIHZhciBkZWZlcnJlZCxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuICAgICAgZGVmZXJyZWQgPSB0aGlzLnEuZGVmZXIoKTtcbiAgICAgIHJlcXVpcmUoJ2ZzJykucmVhZEZpbGUoZmlsZSwgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucmVqZWN0KG5ldyBleHBvcnRzLkZpbGVFcnJvcihcIndoaWxlIHJlYWRpbmcgXCIgKyBmaWxlLCBudWxsLCBcImNhbm5vdCByZWFkIFwiICsgZmlsZSArIFwiIChcIiArIGVyciArIFwiKVwiLCBfdGhpcy5zdGFydF9tYXJrKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGRlZmVycmVkLnJlc29sdmUoZGF0YS50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBSZWFkIGZpbGUgZnJvbSB0aGUgbmV0d29yay5cbiAgICAqL1xuXG5cbiAgICBGaWxlUmVhZGVyLnByb3RvdHlwZS5mZXRjaEZpbGVBc3luYyA9IGZ1bmN0aW9uKGZpbGUpIHtcbiAgICAgIHZhciBkZWZlcnJlZCwgZXJyb3IsIHhocixcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuICAgICAgZGVmZXJyZWQgPSB0aGlzLnEuZGVmZXIoKTtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdyAhPT0gbnVsbCkge1xuICAgICAgICB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHhociA9IG5ldyAocmVxdWlyZSgneG1saHR0cHJlcXVlc3QnKS5YTUxIdHRwUmVxdWVzdCkoKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHhoci5vcGVuKCdHRVQnLCBmaWxlLCBmYWxzZSk7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdBY2NlcHQnLCAnYXBwbGljYXRpb24vcmFtbCt5YW1sLCAqLyonKTtcbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgaWYgKCh0eXBlb2YgeGhyLnN0YXR1cyA9PT0gJ251bWJlcicgJiYgeGhyLnN0YXR1cyA9PT0gMjAwKSB8fCAodHlwZW9mIHhoci5zdGF0dXMgPT09ICdzdHJpbmcnICYmIHhoci5zdGF0dXMubWF0Y2goL14yMDAvaSkpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBkZWZlcnJlZC5yZXNvbHZlKHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkLnJlamVjdChuZXcgZXhwb3J0cy5GaWxlRXJyb3IoXCJ3aGlsZSBmZXRjaGluZyBcIiArIGZpbGUsIG51bGwsIFwiY2Fubm90IGZldGNoIFwiICsgZmlsZSArIFwiIChcIiArIHhoci5zdGF0dXNUZXh0ICsgXCIpXCIsIF90aGlzLnN0YXJ0X21hcmspKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHhoci5zZW5kKG51bGwpO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICBlcnJvciA9IF9lcnJvcjtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuRmlsZUVycm9yKFwid2hpbGUgZmV0Y2hpbmcgXCIgKyBmaWxlLCBudWxsLCBcImNhbm5vdCBmZXRjaCBcIiArIGZpbGUgKyBcIiAoXCIgKyBlcnJvciArIFwiKSwgY2hlY2sgdGhhdCB0aGUgc2VydmVyIGlzIHVwIGFuZCB0aGF0IENPUlMgaXMgZW5hYmxlZFwiLCB0aGlzLnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gRmlsZVJlYWRlcjtcblxuICB9KSgpO1xuXG4gIC8qXG4gIE9PIHZlcnNpb24gb2YgdGhlIHBhcnNlciwgc3RhdGljIGZ1bmN0aW9ucyB3aWxsIGJlIHJlbW92ZWQgYWZ0ZXIgY29uc3VtZXJzIG1vdmUgb24gdG8gdXNlIHRoZSBPTyB2ZXJzaW9uXG4gIE9PIHdpbGwgb2ZmZXIgY2FjaGluZ1xuICAqL1xuXG5cbiAgdGhpcy5SYW1sUGFyc2VyID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFJhbWxQYXJzZXIoc2V0dGluZ3MpIHtcbiAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncyAhPSBudWxsID8gc2V0dGluZ3MgOiBkZWZhdWx0U2V0dGluZ3M7XG4gICAgICB0aGlzLnEgPSByZXF1aXJlKCdxJyk7XG4gICAgICB0aGlzLnVybCA9IHJlcXVpcmUoJ3VybCcpO1xuICAgICAgdGhpcy5ub2RlcyA9IHJlcXVpcmUoJy4vbm9kZXMnKTtcbiAgICAgIHRoaXMubG9hZERlZmF1bHRTZXR0aW5ncyhzZXR0aW5ncyk7XG4gICAgfVxuXG4gICAgUmFtbFBhcnNlci5wcm90b3R5cGUubG9hZERlZmF1bHRTZXR0aW5ncyA9IGZ1bmN0aW9uKHNldHRpbmdzKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGRlZmF1bHRTZXR0aW5ncykuZm9yRWFjaChmdW5jdGlvbihzZXR0aW5nTmFtZSkge1xuICAgICAgICBpZiAoIShzZXR0aW5nTmFtZSBpbiBzZXR0aW5ncykpIHtcbiAgICAgICAgICByZXR1cm4gc2V0dGluZ3Nbc2V0dGluZ05hbWVdID0gZGVmYXVsdFNldHRpbmdzW3NldHRpbmdOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIFJhbWxQYXJzZXIucHJvdG90eXBlLmxvYWRGaWxlID0gZnVuY3Rpb24oZmlsZSwgc2V0dGluZ3MpIHtcbiAgICAgIHZhciBlcnJvcixcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuICAgICAgaWYgKHNldHRpbmdzID09IG51bGwpIHtcbiAgICAgICAgc2V0dGluZ3MgPSB0aGlzLnNldHRpbmdzO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHNldHRpbmdzLnJlYWRlci5yZWFkRmlsZUFzeW5jKGZpbGUpLnRoZW4oZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLmxvYWQoc3RyZWFtLCBmaWxlLCBzZXR0aW5ncyk7XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgIGVycm9yID0gX2Vycm9yO1xuICAgICAgICByZXR1cm4gdGhpcy5xLmZjYWxsKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLkZpbGVFcnJvcihcIndoaWxlIGZldGNoaW5nIFwiICsgZmlsZSwgbnVsbCwgXCJjYW5ub3QgZmV0Y2ggXCIgKyBmaWxlICsgXCIgKFwiICsgZXJyb3IgKyBcIilcIiwgbnVsbCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBSYW1sUGFyc2VyLnByb3RvdHlwZS5jb21wb3NlRmlsZSA9IGZ1bmN0aW9uKGZpbGUsIHNldHRpbmdzLCBwYXJlbnQpIHtcbiAgICAgIHZhciBlcnJvcixcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuICAgICAgaWYgKHNldHRpbmdzID09IG51bGwpIHtcbiAgICAgICAgc2V0dGluZ3MgPSB0aGlzLnNldHRpbmdzO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHNldHRpbmdzLnJlYWRlci5yZWFkRmlsZUFzeW5jKGZpbGUpLnRoZW4oZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLmNvbXBvc2Uoc3RyZWFtLCBmaWxlLCBzZXR0aW5ncywgcGFyZW50KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgZXJyb3IgPSBfZXJyb3I7XG4gICAgICAgIHJldHVybiB0aGlzLnEuZmNhbGwoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuRmlsZUVycm9yKFwid2hpbGUgZmV0Y2hpbmcgXCIgKyBmaWxlLCBudWxsLCBcImNhbm5vdCBmZXRjaCBcIiArIGZpbGUgKyBcIiAoXCIgKyBlcnJvciArIFwiKVwiLCBudWxsKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFJhbWxQYXJzZXIucHJvdG90eXBlLmNvbXBvc2UgPSBmdW5jdGlvbihzdHJlYW0sIGxvY2F0aW9uLCBzZXR0aW5ncywgcGFyZW50KSB7XG4gICAgICBpZiAoc2V0dGluZ3MgPT0gbnVsbCkge1xuICAgICAgICBzZXR0aW5ncyA9IHRoaXMuc2V0dGluZ3M7XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50ID09IG51bGwpIHtcbiAgICAgICAgcGFyZW50ID0ge1xuICAgICAgICAgIHNyYzogbG9jYXRpb25cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHNldHRpbmdzLmNvbXBvc2UgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlU3RyZWFtKHN0cmVhbSwgbG9jYXRpb24sIHNldHRpbmdzLCBwYXJlbnQpO1xuICAgIH07XG5cbiAgICBSYW1sUGFyc2VyLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24oc3RyZWFtLCBsb2NhdGlvbiwgc2V0dGluZ3MpIHtcbiAgICAgIGlmIChzZXR0aW5ncyA9PSBudWxsKSB7XG4gICAgICAgIHNldHRpbmdzID0gdGhpcy5zZXR0aW5ncztcbiAgICAgIH1cbiAgICAgIHNldHRpbmdzLmNvbXBvc2UgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VTdHJlYW0oc3RyZWFtLCBsb2NhdGlvbiwgc2V0dGluZ3MsIHtcbiAgICAgICAgc3JjOiBsb2NhdGlvblxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIFJhbWxQYXJzZXIucHJvdG90eXBlLnBhcnNlU3RyZWFtID0gZnVuY3Rpb24oc3RyZWFtLCBsb2NhdGlvbiwgc2V0dGluZ3MsIHBhcmVudCkge1xuICAgICAgdmFyIGxvYWRlcixcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuICAgICAgaWYgKHNldHRpbmdzID09IG51bGwpIHtcbiAgICAgICAgc2V0dGluZ3MgPSB0aGlzLnNldHRpbmdzO1xuICAgICAgfVxuICAgICAgbG9hZGVyID0gbmV3IGV4cG9ydHMubG9hZGVyLkxvYWRlcihzdHJlYW0sIGxvY2F0aW9uLCBzZXR0aW5ncywgcGFyZW50KTtcbiAgICAgIHJldHVybiB0aGlzLnEuZmNhbGwoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBsb2FkZXIuZ2V0WWFtbFJvb3QoKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24ocGFydGlhbFRyZWUpIHtcbiAgICAgICAgdmFyIGZpbGVzO1xuICAgICAgICBmaWxlcyA9IGxvYWRlci5nZXRQZW5kaW5nRmlsZXNMaXN0KCk7XG4gICAgICAgIHJldHVybiBfdGhpcy5nZXRQZW5kaW5nRmlsZXMobG9hZGVyLCBwYXJ0aWFsVHJlZSwgZmlsZXMpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbihmdWxseUFzc2VtYmxlZFRyZWUpIHtcbiAgICAgICAgbG9hZGVyLmNvbXBvc2VSYW1sVHJlZShmdWxseUFzc2VtYmxlZFRyZWUsIHNldHRpbmdzKTtcbiAgICAgICAgaWYgKHNldHRpbmdzLmNvbXBvc2UpIHtcbiAgICAgICAgICBpZiAoZnVsbHlBc3NlbWJsZWRUcmVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2FkZXIuY29uc3RydWN0X2RvY3VtZW50KGZ1bGx5QXNzZW1ibGVkVHJlZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZnVsbHlBc3NlbWJsZWRUcmVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgUmFtbFBhcnNlci5wcm90b3R5cGUuZ2V0UGVuZGluZ0ZpbGVzID0gZnVuY3Rpb24obG9hZGVyLCBub2RlLCBmaWxlcykge1xuICAgICAgdmFyIGZpbGUsIGxhc3RWaXNpdGVkTm9kZSwgbG9jLCBfaSwgX2xlbixcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuICAgICAgbG9jID0gW107XG4gICAgICBsYXN0VmlzaXRlZE5vZGUgPSB2b2lkIDA7XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IGZpbGVzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGZpbGUgPSBmaWxlc1tfaV07XG4gICAgICAgIGxvYy5wdXNoKHRoaXMuZ2V0UGVuZGluZ0ZpbGUobG9hZGVyLCBmaWxlKS50aGVuKGZ1bmN0aW9uKG92ZXJ3cml0aW5nbm9kZSkge1xuICAgICAgICAgIGlmIChvdmVyd3JpdGluZ25vZGUgJiYgIWxhc3RWaXNpdGVkTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIGxhc3RWaXNpdGVkTm9kZSA9IG92ZXJ3cml0aW5nbm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnEuYWxsKGxvYykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGxhc3RWaXNpdGVkTm9kZSkge1xuICAgICAgICAgIHJldHVybiBsYXN0VmlzaXRlZE5vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBSYW1sUGFyc2VyLnByb3RvdHlwZS5nZXRQZW5kaW5nRmlsZSA9IGZ1bmN0aW9uKGxvYWRlciwgZmlsZUluZm8pIHtcbiAgICAgIHZhciBlcnJvciwgZXZlbnQsIGZpbGVVcmksIGtleSwgbm9kZSxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuICAgICAgbm9kZSA9IGZpbGVJbmZvLnBhcmVudE5vZGU7XG4gICAgICBldmVudCA9IGZpbGVJbmZvLmV2ZW50O1xuICAgICAga2V5ID0gZmlsZUluZm8ucGFyZW50S2V5O1xuICAgICAgZmlsZVVyaSA9IGZpbGVJbmZvLnRhcmdldEZpbGVVcmk7XG4gICAgICBpZiAoZmlsZUluZm8uaW5jbHVkaW5nQ29udGV4dCkge1xuICAgICAgICBmaWxlVXJpID0gdGhpcy51cmwucmVzb2x2ZShmaWxlSW5mby5pbmNsdWRpbmdDb250ZXh0LCBmaWxlSW5mby50YXJnZXRGaWxlVXJpKTtcbiAgICAgIH1cbiAgICAgIGlmIChsb2FkZXIucGFyZW50ICYmIHRoaXMuaXNJbkluY2x1ZGVUYWdzU3RhY2soZmlsZVVyaSwgbG9hZGVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5GaWxlRXJyb3IoJ3doaWxlIGNvbXBvc2luZyBzY2FsYXIgb3V0IG9mICFpbmNsdWRlJywgbnVsbCwgXCJkZXRlY3RlZCBjaXJjdWxhciAhaW5jbHVkZSBvZiBcIiArIGV2ZW50LnZhbHVlLCBldmVudC5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChmaWxlSW5mby50eXBlID09PSAnZnJhZ21lbnQnKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3MucmVhZGVyLnJlYWRGaWxlQXN5bmMoZmlsZVVyaSkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5jb21wb3NlKHJlc3VsdCwgZmlsZVVyaSwge1xuICAgICAgICAgICAgICB2YWxpZGF0ZTogZmFsc2UsXG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogZmFsc2UsXG4gICAgICAgICAgICAgIGNvbXBvc2U6IHRydWVcbiAgICAgICAgICAgIH0sIGxvYWRlcik7XG4gICAgICAgICAgfSkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmFwcGVuZE5ld05vZGVUb1BhcmVudChub2RlLCBrZXksIHZhbHVlKTtcbiAgICAgICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuYWRkQ29udGV4dFRvRXJyb3IoZXJyb3IsIGV2ZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy5yZWFkZXIucmVhZEZpbGVBc3luYyhmaWxlVXJpKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICAgICAgdmFsdWUgPSBuZXcgX3RoaXMubm9kZXMuU2NhbGFyTm9kZSgndGFnOnlhbWwub3JnLDIwMDI6c3RyJywgcmVzdWx0LCBldmVudC5zdGFydF9tYXJrLCBldmVudC5lbmRfbWFyaywgZXZlbnQuc3R5bGUpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmFwcGVuZE5ld05vZGVUb1BhcmVudChub2RlLCBrZXksIHZhbHVlKTtcbiAgICAgICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuYWRkQ29udGV4dFRvRXJyb3IoZXJyb3IsIGV2ZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgIGVycm9yID0gX2Vycm9yO1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRDb250ZXh0VG9FcnJvcihlcnJvciwgZXZlbnQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBSYW1sUGFyc2VyLnByb3RvdHlwZS5hZGRDb250ZXh0VG9FcnJvciA9IGZ1bmN0aW9uKGVycm9yLCBldmVudCkge1xuICAgICAgaWYgKGVycm9yLmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiRmlsZUVycm9yXCIpIHtcbiAgICAgICAgaWYgKCFlcnJvci5wcm9ibGVtX21hcmspIHtcbiAgICAgICAgICBlcnJvci5wcm9ibGVtX21hcmsgPSBldmVudC5zdGFydF9tYXJrO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuRmlsZUVycm9yKCd3aGlsZSByZWFkaW5nIGZpbGUnLCBudWxsLCBcImVycm9yOiBcIiArIGVycm9yLCBldmVudC5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgUmFtbFBhcnNlci5wcm90b3R5cGUuaXNJbkluY2x1ZGVUYWdzU3RhY2sgPSBmdW5jdGlvbihpbmNsdWRlLCBwYXJlbnQpIHtcbiAgICAgIHdoaWxlIChwYXJlbnQgPSBwYXJlbnQucGFyZW50KSB7XG4gICAgICAgIGlmIChwYXJlbnQuc3JjID09PSBpbmNsdWRlKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgUmFtbFBhcnNlci5wcm90b3R5cGUuYXBwZW5kTmV3Tm9kZVRvUGFyZW50ID0gZnVuY3Rpb24obm9kZSwga2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgaWYgKHV0aWwuaXNTZXF1ZW5jZShub2RlKSkge1xuICAgICAgICAgIG5vZGUudmFsdWVba2V5XSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUudmFsdWUucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gUmFtbFBhcnNlcjtcblxuICB9KSgpO1xuXG4gIC8qXG4gICAgdmFsaWRhdGUgY29udHJvbHMgd2hldGhlciB0aGUgc3RyZWFtIG11c3QgYmUgcHJvY2Vzc2VkIGFzIGFcbiAgKi9cblxuXG4gIGRlZmF1bHRTZXR0aW5ncyA9IHtcbiAgICB2YWxpZGF0ZTogdHJ1ZSxcbiAgICB0cmFuc2Zvcm06IHRydWUsXG4gICAgY29tcG9zZTogdHJ1ZSxcbiAgICByZWFkZXI6IG5ldyBleHBvcnRzLkZpbGVSZWFkZXIobnVsbClcbiAgfTtcblxuICAvKlxuICBQYXJzZSB0aGUgZmlyc3QgUkFNTCBkb2N1bWVudCBpbiBhIHN0cmVhbSBhbmQgcHJvZHVjZSB0aGUgY29ycmVzcG9uZGluZ1xuICBKYXZhc2NyaXB0IG9iamVjdC5cbiAgKi9cblxuXG4gIHRoaXMubG9hZEZpbGUgPSBmdW5jdGlvbihmaWxlLCBzZXR0aW5ncykge1xuICAgIHZhciBwYXJzZXI7XG4gICAgaWYgKHNldHRpbmdzID09IG51bGwpIHtcbiAgICAgIHNldHRpbmdzID0gZGVmYXVsdFNldHRpbmdzO1xuICAgIH1cbiAgICBwYXJzZXIgPSBuZXcgZXhwb3J0cy5SYW1sUGFyc2VyKHNldHRpbmdzKTtcbiAgICByZXR1cm4gcGFyc2VyLmxvYWRGaWxlKGZpbGUsIHNldHRpbmdzKTtcbiAgfTtcblxuICAvKlxuICBQYXJzZSB0aGUgZmlyc3QgUkFNTCBkb2N1bWVudCBpbiBhIGZpbGUgYW5kIHByb2R1Y2UgdGhlIGNvcnJlc3BvbmRpbmdcbiAgcmVwcmVzZW50YXRpb24gdHJlZS5cbiAgKi9cblxuXG4gIHRoaXMuY29tcG9zZUZpbGUgPSBmdW5jdGlvbihmaWxlLCBzZXR0aW5ncywgcGFyZW50KSB7XG4gICAgdmFyIHBhcnNlcjtcbiAgICBpZiAoc2V0dGluZ3MgPT0gbnVsbCkge1xuICAgICAgc2V0dGluZ3MgPSBkZWZhdWx0U2V0dGluZ3M7XG4gICAgfVxuICAgIGlmIChwYXJlbnQgPT0gbnVsbCkge1xuICAgICAgcGFyZW50ID0gZmlsZTtcbiAgICB9XG4gICAgcGFyc2VyID0gbmV3IGV4cG9ydHMuUmFtbFBhcnNlcihzZXR0aW5ncyk7XG4gICAgcmV0dXJuIHBhcnNlci5jb21wb3NlRmlsZShmaWxlLCBzZXR0aW5ncywgcGFyZW50KTtcbiAgfTtcblxuICAvKlxuICBQYXJzZSB0aGUgZmlyc3QgUkFNTCBkb2N1bWVudCBpbiBhIHN0cmVhbSBhbmQgcHJvZHVjZSB0aGUgY29ycmVzcG9uZGluZ1xuICByZXByZXNlbnRhdGlvbiB0cmVlLlxuICAqL1xuXG5cbiAgdGhpcy5jb21wb3NlID0gZnVuY3Rpb24oc3RyZWFtLCBsb2NhdGlvbiwgc2V0dGluZ3MsIHBhcmVudCkge1xuICAgIHZhciBwYXJzZXI7XG4gICAgaWYgKHNldHRpbmdzID09IG51bGwpIHtcbiAgICAgIHNldHRpbmdzID0gZGVmYXVsdFNldHRpbmdzO1xuICAgIH1cbiAgICBpZiAocGFyZW50ID09IG51bGwpIHtcbiAgICAgIHBhcmVudCA9IGxvY2F0aW9uO1xuICAgIH1cbiAgICBwYXJzZXIgPSBuZXcgZXhwb3J0cy5SYW1sUGFyc2VyKHNldHRpbmdzKTtcbiAgICByZXR1cm4gcGFyc2VyLmNvbXBvc2Uoc3RyZWFtLCBsb2NhdGlvbiwgc2V0dGluZ3MsIHBhcmVudCk7XG4gIH07XG5cbiAgLypcbiAgUGFyc2UgdGhlIGZpcnN0IFJBTUwgZG9jdW1lbnQgaW4gYSBzdHJlYW0gYW5kIHByb2R1Y2UgdGhlIGNvcnJlc3BvbmRpbmdcbiAgSmF2YXNjcmlwdCBvYmplY3QuXG4gICovXG5cblxuICB0aGlzLmxvYWQgPSBmdW5jdGlvbihzdHJlYW0sIGxvY2F0aW9uLCBzZXR0aW5ncykge1xuICAgIHZhciBwYXJzZXI7XG4gICAgaWYgKHNldHRpbmdzID09IG51bGwpIHtcbiAgICAgIHNldHRpbmdzID0gZGVmYXVsdFNldHRpbmdzO1xuICAgIH1cbiAgICBwYXJzZXIgPSBuZXcgZXhwb3J0cy5SYW1sUGFyc2VyKHNldHRpbmdzKTtcbiAgICByZXR1cm4gcGFyc2VyLmxvYWQoc3RyZWFtLCBsb2NhdGlvbiwgc2V0dGluZ3MsIG51bGwpO1xuICB9O1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiKGZ1bmN0aW9uKCkge1xuICB2YXIgTWFyaywgTWFya2VkWUFNTEVycm9yLCBfcmVmLCBfcmVmMSxcbiAgICBfX2hhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSxcbiAgICBfX2V4dGVuZHMgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKF9faGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcbiAgICBfX2luZGV4T2YgPSBbXS5pbmRleE9mIHx8IGZ1bmN0aW9uKGl0ZW0pIHsgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykgeyBpZiAoaSBpbiB0aGlzICYmIHRoaXNbaV0gPT09IGl0ZW0pIHJldHVybiBpOyB9IHJldHVybiAtMTsgfTtcblxuICBfcmVmID0gcmVxdWlyZSgnLi9lcnJvcnMnKSwgTWFyayA9IF9yZWYuTWFyaywgTWFya2VkWUFNTEVycm9yID0gX3JlZi5NYXJrZWRZQU1MRXJyb3I7XG5cbiAgdGhpcy5SZWFkZXJFcnJvciA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVhZGVyRXJyb3IsIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBSZWFkZXJFcnJvcigpIHtcbiAgICAgIF9yZWYxID0gUmVhZGVyRXJyb3IuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gX3JlZjE7XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlYWRlckVycm9yO1xuXG4gIH0pKE1hcmtlZFlBTUxFcnJvcik7XG5cbiAgLypcbiAgUmVhZGVyOlxuICAgIGNoZWNrcyBpZiBjaGFyYWN0ZXJzIGFyZSB3aXRoaW4gdGhlIGFsbG93ZWQgcmFuZ2VcbiAgICBhZGQgJ1xceDAwJyB0byB0aGUgZW5kXG4gICovXG5cblxuICB0aGlzLlJlYWRlciA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgTk9OX1BSSU5UQUJMRTtcblxuICAgIE5PTl9QUklOVEFCTEUgPSAvW15cXHgwOVxceDBBXFx4MERcXHgyMC1cXHg3RVxceDg1XFx4QTAtXFx1RDdGRlxcdUUwMDAtXFx1RkZGRF0vO1xuXG4gICAgZnVuY3Rpb24gUmVhZGVyKHN0cmluZywgc3JjKSB7XG4gICAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICAgIHRoaXMuc3JjID0gc3JjO1xuICAgICAgdGhpcy5saW5lID0gMDtcbiAgICAgIHRoaXMuY29sdW1uID0gMDtcbiAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgdGhpcy5zdHJpbmcgKz0gJ1xceDAwJztcbiAgICB9XG5cbiAgICBSZWFkZXIucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbihpbmRleCkge1xuICAgICAgaWYgKGluZGV4ID09IG51bGwpIHtcbiAgICAgICAgaW5kZXggPSAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nW3RoaXMuaW5kZXggKyBpbmRleF07XG4gICAgfTtcblxuICAgIFJlYWRlci5wcm90b3R5cGUucHJlZml4ID0gZnVuY3Rpb24obGVuZ3RoKSB7XG4gICAgICBpZiAobGVuZ3RoID09IG51bGwpIHtcbiAgICAgICAgbGVuZ3RoID0gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnN0cmluZy5zbGljZSh0aGlzLmluZGV4LCB0aGlzLmluZGV4ICsgbGVuZ3RoKTtcbiAgICB9O1xuXG4gICAgUmVhZGVyLnByb3RvdHlwZS5mb3J3YXJkID0gZnVuY3Rpb24obGVuZ3RoKSB7XG4gICAgICB2YXIgY2hhciwgX3Jlc3VsdHM7XG4gICAgICBpZiAobGVuZ3RoID09IG51bGwpIHtcbiAgICAgICAgbGVuZ3RoID0gMTtcbiAgICAgIH1cbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICB3aGlsZSAobGVuZ3RoKSB7XG4gICAgICAgIGNoYXIgPSB0aGlzLnN0cmluZ1t0aGlzLmluZGV4XTtcbiAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICBpZiAoX19pbmRleE9mLmNhbGwoJ1xcblxceDg1XFx1MjA4MlxcdTIwMjknLCBjaGFyKSA+PSAwIHx8IChjaGFyID09PSAnXFxyJyAmJiB0aGlzLnN0cmluZ1t0aGlzLmluZGV4XSAhPT0gJ1xcbicpKSB7XG4gICAgICAgICAgdGhpcy5saW5lKys7XG4gICAgICAgICAgdGhpcy5jb2x1bW4gPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY2hlY2tfcHJpbnRhYmxlKGNoYXIpO1xuICAgICAgICAgIHRoaXMuY29sdW1uKys7XG4gICAgICAgIH1cbiAgICAgICAgX3Jlc3VsdHMucHVzaChsZW5ndGgtLSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfTtcblxuICAgIFJlYWRlci5wcm90b3R5cGUuY3JlYXRlX21hcmsgPSBmdW5jdGlvbihsaW5lLCBjb2x1bW4pIHtcbiAgICAgIGlmIChsaW5lID09IG51bGwpIHtcbiAgICAgICAgbGluZSA9IHRoaXMubGluZTtcbiAgICAgIH1cbiAgICAgIGlmIChjb2x1bW4gPT0gbnVsbCkge1xuICAgICAgICBjb2x1bW4gPSB0aGlzLmNvbHVtbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgTWFyayh0aGlzLnNyYywgbGluZSwgY29sdW1uLCB0aGlzLnN0cmluZywgdGhpcy5pbmRleCk7XG4gICAgfTtcblxuICAgIFJlYWRlci5wcm90b3R5cGUuZ2V0X21hcmsgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZV9tYXJrKCk7XG4gICAgfTtcblxuICAgIFJlYWRlci5wcm90b3R5cGUuY2hlY2tfcHJpbnRhYmxlID0gZnVuY3Rpb24oY2hhcikge1xuICAgICAgaWYgKE5PTl9QUklOVEFCTEUuZXhlYyhjaGFyKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5SZWFkZXJFcnJvcignd2hpbGUgcmVhZGluZyBmaWxlJywgbnVsbCwgXCJub24gcHJpbnRhYmxlIGNoYXJhY3RlcnMgYXJlIG5vdCBhbGxvd2VkIGNvbHVtbjogXCIgKyAodGhpcy5nZXRfbWFyaygpLmNvbHVtbiksIHRoaXMuZ2V0X21hcmsoKSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBSZWFkZXI7XG5cbiAgfSkoKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIihmdW5jdGlvbigpIHtcbiAgdmFyIFlBTUxFcnJvciwgbm9kZXMsIHV0aWwsIF9yZWYsIF9yZWYxLFxuICAgIF9faGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LFxuICAgIF9fZXh0ZW5kcyA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoX19oYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuICAgIF9faW5kZXhPZiA9IFtdLmluZGV4T2YgfHwgZnVuY3Rpb24oaXRlbSkgeyBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7IGlmIChpIGluIHRoaXMgJiYgdGhpc1tpXSA9PT0gaXRlbSkgcmV0dXJuIGk7IH0gcmV0dXJuIC0xOyB9O1xuXG4gIG5vZGVzID0gcmVxdWlyZSgnLi9ub2RlcycpO1xuXG4gIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuICBZQU1MRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9ycycpLllBTUxFcnJvcjtcblxuICB0aGlzLlJlc29sdmVyRXJyb3IgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlc29sdmVyRXJyb3IsIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBSZXNvbHZlckVycm9yKCkge1xuICAgICAgX3JlZiA9IFJlc29sdmVyRXJyb3IuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gX3JlZjtcbiAgICB9XG5cbiAgICByZXR1cm4gUmVzb2x2ZXJFcnJvcjtcblxuICB9KShZQU1MRXJyb3IpO1xuXG4gIHRoaXMuQmFzZVJlc29sdmVyID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBERUZBVUxUX01BUFBJTkdfVEFHLCBERUZBVUxUX1NDQUxBUl9UQUcsIERFRkFVTFRfU0VRVUVOQ0VfVEFHO1xuXG4gICAgREVGQVVMVF9TQ0FMQVJfVEFHID0gJ3RhZzp5YW1sLm9yZywyMDAyOnN0cic7XG5cbiAgICBERUZBVUxUX1NFUVVFTkNFX1RBRyA9ICd0YWc6eWFtbC5vcmcsMjAwMjpzZXEnO1xuXG4gICAgREVGQVVMVF9NQVBQSU5HX1RBRyA9ICd0YWc6eWFtbC5vcmcsMjAwMjptYXAnO1xuXG4gICAgQmFzZVJlc29sdmVyLnByb3RvdHlwZS55YW1sX2ltcGxpY2l0X3Jlc29sdmVycyA9IHt9O1xuXG4gICAgQmFzZVJlc29sdmVyLnByb3RvdHlwZS55YW1sX3BhdGhfcmVzb2x2ZXJzID0ge307XG5cbiAgICBCYXNlUmVzb2x2ZXIuYWRkX2ltcGxpY2l0X3Jlc29sdmVyID0gZnVuY3Rpb24odGFnLCByZWdleHAsIGZpcnN0KSB7XG4gICAgICB2YXIgY2hhciwgX2Jhc2UsIF9pLCBfbGVuLCBfcmVzdWx0cztcbiAgICAgIGlmIChmaXJzdCA9PSBudWxsKSB7XG4gICAgICAgIGZpcnN0ID0gW251bGxdO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgneWFtbF9pbXBsaWNpdF9yZXNvbHZlcnMnKSkge1xuICAgICAgICB0aGlzLnByb3RvdHlwZS55YW1sX2ltcGxpY2l0X3Jlc29sdmVycyA9IHV0aWwuZXh0ZW5kKHt9LCB0aGlzLnByb3RvdHlwZS55YW1sX2ltcGxpY2l0X3Jlc29sdmVycyk7XG4gICAgICB9XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBmaXJzdC5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBjaGFyID0gZmlyc3RbX2ldO1xuICAgICAgICBfcmVzdWx0cy5wdXNoKCgoX2Jhc2UgPSB0aGlzLnByb3RvdHlwZS55YW1sX2ltcGxpY2l0X3Jlc29sdmVycylbY2hhcl0gIT0gbnVsbCA/IChfYmFzZSA9IHRoaXMucHJvdG90eXBlLnlhbWxfaW1wbGljaXRfcmVzb2x2ZXJzKVtjaGFyXSA6IF9iYXNlW2NoYXJdID0gW10pLnB1c2goW3RhZywgcmVnZXhwXSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBCYXNlUmVzb2x2ZXIoKSB7XG4gICAgICB0aGlzLnJlc29sdmVyX2V4YWN0X3BhdGhzID0gW107XG4gICAgICB0aGlzLnJlc29sdmVyX3ByZWZpeF9wYXRocyA9IFtdO1xuICAgIH1cblxuICAgIEJhc2VSZXNvbHZlci5wcm90b3R5cGUuZGVzY2VuZF9yZXNvbHZlciA9IGZ1bmN0aW9uKGN1cnJlbnRfbm9kZSwgY3VycmVudF9pbmRleCkge1xuICAgICAgdmFyIGRlcHRoLCBleGFjdF9wYXRocywga2luZCwgcGF0aCwgcHJlZml4X3BhdGhzLCBfaSwgX2osIF9sZW4sIF9sZW4xLCBfcmVmMSwgX3JlZjIsIF9yZWYzLCBfcmVmNDtcbiAgICAgIGlmICh1dGlsLmlzX2VtcHR5KHRoaXMueWFtbF9wYXRoX3Jlc29sdmVycykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXhhY3RfcGF0aHMgPSB7fTtcbiAgICAgIHByZWZpeF9wYXRocyA9IFtdO1xuICAgICAgaWYgKGN1cnJlbnRfbm9kZSkge1xuICAgICAgICBkZXB0aCA9IHRoaXMucmVzb2x2ZXJfcHJlZml4X3BhdGhzLmxlbmd0aDtcbiAgICAgICAgX3JlZjEgPSB0aGlzLnJlc29sdmVyX3ByZWZpeF9wYXRocy5zbGljZSgtMSlbMF07XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjEubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICBfcmVmMiA9IF9yZWYxW19pXSwgcGF0aCA9IF9yZWYyWzBdLCBraW5kID0gX3JlZjJbMV07XG4gICAgICAgICAgaWYgKHRoaXMuY2hlY2tfcmVzb2x2ZXJfcHJlZml4KGRlcHRoLCBwYXRoLCBraW5kLCBjdXJyZW50X25vZGUsIGN1cnJlbnRfaW5kZXgpKSB7XG4gICAgICAgICAgICBpZiAocGF0aC5sZW5ndGggPiBkZXB0aCkge1xuICAgICAgICAgICAgICBwcmVmaXhfcGF0aHMucHVzaChbcGF0aCwga2luZF0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZXhhY3RfcGF0aHNba2luZF0gPSB0aGlzLnlhbWxfcGF0aF9yZXNvbHZlcnNbcGF0aF1ba2luZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfcmVmMyA9IHRoaXMueWFtbF9wYXRoX3Jlc29sdmVycztcbiAgICAgICAgZm9yIChfaiA9IDAsIF9sZW4xID0gX3JlZjMubGVuZ3RoOyBfaiA8IF9sZW4xOyBfaisrKSB7XG4gICAgICAgICAgX3JlZjQgPSBfcmVmM1tfal0sIHBhdGggPSBfcmVmNFswXSwga2luZCA9IF9yZWY0WzFdO1xuICAgICAgICAgIGlmICghcGF0aCkge1xuICAgICAgICAgICAgZXhhY3RfcGF0aHNba2luZF0gPSB0aGlzLnlhbWxfcGF0aF9yZXNvbHZlcnNbcGF0aF1ba2luZF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByZWZpeF9wYXRocy5wdXNoKFtwYXRoLCBraW5kXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnJlc29sdmVyX2V4YWN0X3BhdGhzLnB1c2goZXhhY3RfcGF0aHMpO1xuICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZXJfcHJlZml4X3BhdGhzLnB1c2gocHJlZml4X3BhdGhzKTtcbiAgICB9O1xuXG4gICAgQmFzZVJlc29sdmVyLnByb3RvdHlwZS5hc2NlbmRfcmVzb2x2ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh1dGlsLmlzX2VtcHR5KHRoaXMueWFtbF9wYXRoX3Jlc29sdmVycykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5yZXNvbHZlcl9leGFjdF9wYXRocy5wb3AoKTtcbiAgICAgIHJldHVybiB0aGlzLnJlc29sdmVyX3ByZWZpeF9wYXRocy5wb3AoKTtcbiAgICB9O1xuXG4gICAgQmFzZVJlc29sdmVyLnByb3RvdHlwZS5jaGVja19yZXNvbHZlcl9wcmVmaXggPSBmdW5jdGlvbihkZXB0aCwgcGF0aCwga2luZCwgY3VycmVudF9ub2RlLCBjdXJyZW50X2luZGV4KSB7XG4gICAgICB2YXIgaW5kZXhfY2hlY2ssIG5vZGVfY2hlY2ssIF9yZWYxO1xuICAgICAgX3JlZjEgPSBwYXRoW2RlcHRoIC0gMV0sIG5vZGVfY2hlY2sgPSBfcmVmMVswXSwgaW5kZXhfY2hlY2sgPSBfcmVmMVsxXTtcbiAgICAgIGlmICh0eXBlb2Ygbm9kZV9jaGVjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRfbm9kZS50YWcgIT09IG5vZGVfY2hlY2spIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobm9kZV9jaGVjayAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoIShjdXJyZW50X25vZGUgaW5zdGFuY2VvZiBub2RlX2NoZWNrKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGluZGV4X2NoZWNrID09PSB0cnVlICYmIGN1cnJlbnRfaW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKChpbmRleF9jaGVjayA9PT0gZmFsc2UgfHwgaW5kZXhfY2hlY2sgPT09IG51bGwpICYmIGN1cnJlbnRfaW5kZXggPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBpbmRleF9jaGVjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKCEoY3VycmVudF9pbmRleCBpbnN0YW5jZW9mIG5vZGVzLlNjYWxhck5vZGUpICYmIGluZGV4X2NoZWNrID09PSBjdXJyZW50X2luZGV4LnZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbmRleF9jaGVjayA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKGluZGV4X2NoZWNrICE9PSBjdXJyZW50X2luZGV4KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgQmFzZVJlc29sdmVyLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24oa2luZCwgdmFsdWUsIGltcGxpY2l0KSB7XG4gICAgICB2YXIgZW1wdHksIGV4YWN0X3BhdGhzLCBrLCByZWdleHAsIHJlc29sdmVycywgdGFnLCBfaSwgX2xlbiwgX3JlZjEsIF9yZWYyLCBfcmVmMywgX3JlZjQ7XG4gICAgICBpZiAoa2luZCA9PT0gbm9kZXMuU2NhbGFyTm9kZSAmJiBpbXBsaWNpdFswXSkge1xuICAgICAgICBpZiAodmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgcmVzb2x2ZXJzID0gKF9yZWYxID0gdGhpcy55YW1sX2ltcGxpY2l0X3Jlc29sdmVyc1snJ10pICE9IG51bGwgPyBfcmVmMSA6IFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmVycyA9IChfcmVmMiA9IHRoaXMueWFtbF9pbXBsaWNpdF9yZXNvbHZlcnNbdmFsdWVbMF1dKSAhPSBudWxsID8gX3JlZjIgOiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlcnMgPSByZXNvbHZlcnMuY29uY2F0KChfcmVmMyA9IHRoaXMueWFtbF9pbXBsaWNpdF9yZXNvbHZlcnNbbnVsbF0pICE9IG51bGwgPyBfcmVmMyA6IFtdKTtcbiAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSByZXNvbHZlcnMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICBfcmVmNCA9IHJlc29sdmVyc1tfaV0sIHRhZyA9IF9yZWY0WzBdLCByZWdleHAgPSBfcmVmNFsxXTtcbiAgICAgICAgICBpZiAodmFsdWUubWF0Y2gocmVnZXhwKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRhZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW1wbGljaXQgPSBpbXBsaWNpdFsxXTtcbiAgICAgIH1cbiAgICAgIGVtcHR5ID0gdHJ1ZTtcbiAgICAgIGZvciAoayBpbiB0aGlzLnlhbWxfcGF0aF9yZXNvbHZlcnMpIHtcbiAgICAgICAgaWYgKHt9W2tdID09IG51bGwpIHtcbiAgICAgICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWVtcHR5KSB7XG4gICAgICAgIGV4YWN0X3BhdGhzID0gdGhpcy5yZXNvbHZlcl9leGFjdF9wYXRocy5zbGljZSgtMSlbMF07XG4gICAgICAgIGlmIChfX2luZGV4T2YuY2FsbChleGFjdF9wYXRocywga2luZCkgPj0gMCkge1xuICAgICAgICAgIHJldHVybiBleGFjdF9wYXRoc1traW5kXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX19pbmRleE9mLmNhbGwoZXhhY3RfcGF0aHMsIG51bGwpID49IDApIHtcbiAgICAgICAgICByZXR1cm4gZXhhY3RfcGF0aHNbbnVsbF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChraW5kID09PSBub2Rlcy5TY2FsYXJOb2RlKSB7XG4gICAgICAgIHJldHVybiBERUZBVUxUX1NDQUxBUl9UQUc7XG4gICAgICB9XG4gICAgICBpZiAoa2luZCA9PT0gbm9kZXMuU2VxdWVuY2VOb2RlKSB7XG4gICAgICAgIHJldHVybiBERUZBVUxUX1NFUVVFTkNFX1RBRztcbiAgICAgIH1cbiAgICAgIGlmIChraW5kID09PSBub2Rlcy5NYXBwaW5nTm9kZSkge1xuICAgICAgICByZXR1cm4gREVGQVVMVF9NQVBQSU5HX1RBRztcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIEJhc2VSZXNvbHZlcjtcblxuICB9KSgpO1xuXG4gIHRoaXMuUmVzb2x2ZXIgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlc29sdmVyLCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gUmVzb2x2ZXIoKSB7XG4gICAgICBfcmVmMSA9IFJlc29sdmVyLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIF9yZWYxO1xuICAgIH1cblxuICAgIHJldHVybiBSZXNvbHZlcjtcblxuICB9KSh0aGlzLkJhc2VSZXNvbHZlcik7XG5cbiAgdGhpcy5SZXNvbHZlci5hZGRfaW1wbGljaXRfcmVzb2x2ZXIoJ3RhZzp5YW1sLm9yZywyMDAyOmJvb2wnLCAvXig/OnRydWV8VHJ1ZXxUUlVFfGZhbHNlfEZhbHNlfEZBTFNFKSQvLCAndFRmRicpO1xuXG4gIHRoaXMuUmVzb2x2ZXIuYWRkX2ltcGxpY2l0X3Jlc29sdmVyKCd0YWc6eWFtbC5vcmcsMjAwMjpmbG9hdCcsIC9eKD86Wy0rXT8oPzpbMC05XVswLTlfXSopXFwuWzAtOV9dKig/OltlRV1bLStdWzAtOV0rKT98XFwuWzAtOV9dKyg/OltlRV1bLStdWzAtOV0rKT98Wy0rXT9bMC05XVswLTlfXSooPzo6WzAtNV0/WzAtOV0pK1xcLlswLTlfXSp8Wy0rXT9cXC4oPzppbmZ8SW5mfElORil8XFwuKD86bmFufE5hTnxOQU4pKSQvLCAnLSswMTIzNDU2Nzg5LicpO1xuXG4gIHRoaXMuUmVzb2x2ZXIuYWRkX2ltcGxpY2l0X3Jlc29sdmVyKCd0YWc6eWFtbC5vcmcsMjAwMjppbnQnLCAvXig/OlstK10/MGJbMDFfXSt8Wy0rXT8wWzAtN19dK3xbLStdPyg/OjB8WzEtOV1bMC05X10qKXxbLStdPzB4WzAtOWEtZkEtRl9dK3xbLStdPzBvWzAtN19dK3xbLStdP1sxLTldWzAtOV9dKig/OjpbMC01XT9bMC05XSkrKSQvLCAnLSswMTIzNDU2Nzg5Jyk7XG5cbiAgdGhpcy5SZXNvbHZlci5hZGRfaW1wbGljaXRfcmVzb2x2ZXIoJ3RhZzp5YW1sLm9yZywyMDAyOm1lcmdlJywgL14oPzo8PCkkLywgJzwnKTtcblxuICB0aGlzLlJlc29sdmVyLmFkZF9pbXBsaWNpdF9yZXNvbHZlcigndGFnOnlhbWwub3JnLDIwMDI6bnVsbCcsIC9eKD86fnxudWxsfE51bGx8TlVMTHwpJC8sIFsnficsICduJywgJ04nLCAnJ10pO1xuXG4gIHRoaXMuUmVzb2x2ZXIuYWRkX2ltcGxpY2l0X3Jlc29sdmVyKCd0YWc6eWFtbC5vcmcsMjAwMjp0aW1lc3RhbXAnLCAvXig/OlswLTldWzAtOV1bMC05XVswLTldLVswLTldWzAtOV0tWzAtOV1bMC05XXxbMC05XVswLTldWzAtOV1bMC05XS1bMC05XVswLTldPy1bMC05XVswLTldPyg/OltUdF18W1xceDIwXFx0XSspWzAtOV1bMC05XT86WzAtOV1bMC05XTpbMC05XVswLTldKD86XFwuWzAtOV0qKT8oPzpbXFx4MjBcXHRdKig/Olp8Wy0rXVswLTldWzAtOV0/KD86OlswLTldWzAtOV0pPykpPykkLywgJzAxMjM0NTY3ODknKTtcblxuICB0aGlzLlJlc29sdmVyLmFkZF9pbXBsaWNpdF9yZXNvbHZlcigndGFnOnlhbWwub3JnLDIwMDI6dmFsdWUnLCAvXig/Oj0pJC8sICc9Jyk7XG5cbiAgdGhpcy5SZXNvbHZlci5hZGRfaW1wbGljaXRfcmVzb2x2ZXIoJ3RhZzp5YW1sLm9yZywyMDAyOnlhbWwnLCAvXig/OiF8JnxcXCopJC8sICchJionKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIihmdW5jdGlvbigpIHtcbiAgdmFyIE1hcmtlZFlBTUxFcnJvciwgbm9kZXMsIHV0aWwsIF9yZWYsXG4gICAgX19oYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksXG4gICAgX19leHRlbmRzID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChfX2hhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG4gICAgX19iaW5kID0gZnVuY3Rpb24oZm4sIG1lKXsgcmV0dXJuIGZ1bmN0aW9uKCl7IHJldHVybiBmbi5hcHBseShtZSwgYXJndW1lbnRzKTsgfTsgfTtcblxuICBNYXJrZWRZQU1MRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9ycycpLk1hcmtlZFlBTUxFcnJvcjtcblxuICBub2RlcyA9IHJlcXVpcmUoJy4vbm9kZXMnKTtcblxuICB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbiAgLypcbiAgVGhlIFJlc291cmNlVHlwZXMgdGhyb3dzIHRoZXNlLlxuICAqL1xuXG5cbiAgdGhpcy5SZXNvdXJjZVR5cGVFcnJvciA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVzb3VyY2VUeXBlRXJyb3IsIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBSZXNvdXJjZVR5cGVFcnJvcigpIHtcbiAgICAgIF9yZWYgPSBSZXNvdXJjZVR5cGVFcnJvci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfcmVmO1xuICAgIH1cblxuICAgIHJldHVybiBSZXNvdXJjZVR5cGVFcnJvcjtcblxuICB9KShNYXJrZWRZQU1MRXJyb3IpO1xuXG4gIC8qXG4gIFRoZSBSZXNvdXJjZVR5cGVzIGNsYXNzIGRlYWxzIHdpdGggYXBwbHlpbmcgUmVzb3VyY2VUeXBlcyB0byByZXNvdXJjZXMgYWNjb3JkaW5nIHRvIHRoZSBzcGVjXG4gICovXG5cblxuICB0aGlzLlJlc291cmNlVHlwZXMgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gUmVzb3VyY2VUeXBlcygpIHtcbiAgICAgIHRoaXMuYXBwbHlfcGFyYW1ldGVyc190b190eXBlID0gX19iaW5kKHRoaXMuYXBwbHlfcGFyYW1ldGVyc190b190eXBlLCB0aGlzKTtcbiAgICAgIHRoaXMuYXBwbHlfdHlwZSA9IF9fYmluZCh0aGlzLmFwcGx5X3R5cGUsIHRoaXMpO1xuICAgICAgdGhpcy5hcHBseV90eXBlcyA9IF9fYmluZCh0aGlzLmFwcGx5X3R5cGVzLCB0aGlzKTtcbiAgICAgIHRoaXMuZ2V0X3R5cGUgPSBfX2JpbmQodGhpcy5nZXRfdHlwZSwgdGhpcyk7XG4gICAgICB0aGlzLmhhc190eXBlcyA9IF9fYmluZCh0aGlzLmhhc190eXBlcywgdGhpcyk7XG4gICAgICB0aGlzLmxvYWRfdHlwZXMgPSBfX2JpbmQodGhpcy5sb2FkX3R5cGVzLCB0aGlzKTtcbiAgICAgIHRoaXMuZGVjbGFyZWRUeXBlcyA9IHt9O1xuICAgIH1cblxuICAgIFJlc291cmNlVHlwZXMucHJvdG90eXBlLmxvYWRfdHlwZXMgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgYWxsVHlwZXMsXG4gICAgICAgIF90aGlzID0gdGhpcztcbiAgICAgIHRoaXMubG9hZF9kZWZhdWx0X21lZGlhX3R5cGUobm9kZSk7XG4gICAgICBpZiAodGhpcy5oYXNfcHJvcGVydHkobm9kZSwgJ3Jlc291cmNlVHlwZXMnKSkge1xuICAgICAgICBhbGxUeXBlcyA9IHRoaXMucHJvcGVydHlfdmFsdWUobm9kZSwgJ3Jlc291cmNlVHlwZXMnKTtcbiAgICAgICAgaWYgKGFsbFR5cGVzICYmIHR5cGVvZiBhbGxUeXBlcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICByZXR1cm4gYWxsVHlwZXMuZm9yRWFjaChmdW5jdGlvbih0eXBlX2l0ZW0pIHtcbiAgICAgICAgICAgIGlmICh0eXBlX2l0ZW0gJiYgdHlwZW9mIHR5cGVfaXRlbSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHR5cGVfaXRlbS52YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHR5cGVfaXRlbS52YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZGVjbGFyZWRUeXBlc1t0eXBlWzBdLnZhbHVlXSA9IHR5cGU7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIFJlc291cmNlVHlwZXMucHJvdG90eXBlLmhhc190eXBlcyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLmRlY2xhcmVkVHlwZXMpLmxlbmd0aCA9PT0gMCAmJiB0aGlzLmhhc19wcm9wZXJ0eShub2RlLCAncmVzb3VyY2VUeXBlcycpKSB7XG4gICAgICAgIHRoaXMubG9hZF90eXBlcyhub2RlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmRlY2xhcmVkVHlwZXMpLmxlbmd0aCA+IDA7XG4gICAgfTtcblxuICAgIFJlc291cmNlVHlwZXMucHJvdG90eXBlLmdldF90eXBlID0gZnVuY3Rpb24odHlwZU5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlY2xhcmVkVHlwZXNbdHlwZU5hbWVdO1xuICAgIH07XG5cbiAgICBSZXNvdXJjZVR5cGVzLnByb3RvdHlwZS5hcHBseV90eXBlcyA9IGZ1bmN0aW9uKG5vZGUsIHJlc291cmNlVXJpKSB7XG4gICAgICB2YXIgcmVzb3VyY2VzLFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG4gICAgICBpZiAocmVzb3VyY2VVcmkgPT0gbnVsbCkge1xuICAgICAgICByZXNvdXJjZVVyaSA9IFwiXCI7XG4gICAgICB9XG4gICAgICBpZiAoIXV0aWwuaXNNYXBwaW5nKG5vZGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmhhc190eXBlcyhub2RlKSkge1xuICAgICAgICByZXNvdXJjZXMgPSB0aGlzLmNoaWxkX3Jlc291cmNlcyhub2RlKTtcbiAgICAgICAgcmV0dXJuIHJlc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uKHJlc291cmNlKSB7XG4gICAgICAgICAgdmFyIHR5cGU7XG4gICAgICAgICAgX3RoaXMuYXBwbHlfZGVmYXVsdF9tZWRpYV90eXBlX3RvX3Jlc291cmNlKHJlc291cmNlWzFdKTtcbiAgICAgICAgICBpZiAoX3RoaXMuaGFzX3Byb3BlcnR5KHJlc291cmNlWzFdLCAndHlwZScpKSB7XG4gICAgICAgICAgICB0eXBlID0gX3RoaXMuZ2V0X3Byb3BlcnR5KHJlc291cmNlWzFdLCAndHlwZScpO1xuICAgICAgICAgICAgX3RoaXMuYXBwbHlfdHlwZShyZXNvdXJjZVVyaSArIHJlc291cmNlWzBdLnZhbHVlLCByZXNvdXJjZSwgdHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBfdGhpcy5hcHBseV90eXBlcyhyZXNvdXJjZVsxXSwgcmVzb3VyY2VVcmkgKyByZXNvdXJjZVswXS52YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb3VyY2VzID0gdGhpcy5jaGlsZF9yZXNvdXJjZXMobm9kZSk7XG4gICAgICAgIHJldHVybiByZXNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbihyZXNvdXJjZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5hcHBseV9kZWZhdWx0X21lZGlhX3R5cGVfdG9fcmVzb3VyY2UocmVzb3VyY2VbMV0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgUmVzb3VyY2VUeXBlcy5wcm90b3R5cGUuYXBwbHlfdHlwZSA9IGZ1bmN0aW9uKHJlc291cmNlVXJpLCByZXNvdXJjZSwgdHlwZUtleSkge1xuICAgICAgdmFyIHRlbXBUeXBlO1xuICAgICAgdGVtcFR5cGUgPSB0aGlzLnJlc29sdmVfaW5oZXJpdGFuY2VfY2hhaW4ocmVzb3VyY2VVcmksIHR5cGVLZXkpO1xuICAgICAgdGVtcFR5cGUuY29tYmluZShyZXNvdXJjZVsxXSk7XG4gICAgICByZXNvdXJjZVsxXSA9IHRlbXBUeXBlO1xuICAgICAgcmV0dXJuIHJlc291cmNlWzFdLnJlbW92ZV9xdWVzdGlvbl9tYXJrX3Byb3BlcnRpZXMoKTtcbiAgICB9O1xuXG4gICAgUmVzb3VyY2VUeXBlcy5wcm90b3R5cGUucmVzb2x2ZV9pbmhlcml0YW5jZV9jaGFpbiA9IGZ1bmN0aW9uKHJlc291cmNlVXJpLCB0eXBlS2V5KSB7XG4gICAgICB2YXIgYmFzZVR5cGUsIGNoaWxkVHlwZSwgY2hpbGRUeXBlTmFtZSwgY2hpbGRUeXBlUHJvcGVydHksIGNvbXBpbGVkVHlwZXMsIGluaGVyaXRzRnJvbSwgcGFyZW50VHlwZSwgcGFyZW50VHlwZU5hbWUsIHBhdGhUb0NpcmN1bGFyUmVmLCByZXN1bHQsIHJvb3RUeXBlLCB0eXBlc1RvQXBwbHk7XG4gICAgICBjaGlsZFR5cGVOYW1lID0gdGhpcy5rZXlfb3JfdmFsdWUodHlwZUtleSk7XG4gICAgICBjaGlsZFR5cGUgPSB0aGlzLmFwcGx5X3BhcmFtZXRlcnNfdG9fdHlwZShyZXNvdXJjZVVyaSwgY2hpbGRUeXBlTmFtZSwgdHlwZUtleSk7XG4gICAgICB0eXBlc1RvQXBwbHkgPSBbY2hpbGRUeXBlTmFtZV07XG4gICAgICBjb21waWxlZFR5cGVzID0ge307XG4gICAgICBjb21waWxlZFR5cGVzW2NoaWxkVHlwZU5hbWVdID0gY2hpbGRUeXBlO1xuICAgICAgdGhpcy5hcHBseV9kZWZhdWx0X21lZGlhX3R5cGVfdG9fcmVzb3VyY2UoY2hpbGRUeXBlKTtcbiAgICAgIHRoaXMuYXBwbHlfdHJhaXRzX3RvX3Jlc291cmNlKHJlc291cmNlVXJpLCBjaGlsZFR5cGUsIGZhbHNlKTtcbiAgICAgIHdoaWxlICh0aGlzLmhhc19wcm9wZXJ0eShjaGlsZFR5cGUsICd0eXBlJykpIHtcbiAgICAgICAgdHlwZUtleSA9IHRoaXMuZ2V0X3Byb3BlcnR5KGNoaWxkVHlwZSwgJ3R5cGUnKTtcbiAgICAgICAgcGFyZW50VHlwZU5hbWUgPSB0aGlzLmtleV9vcl92YWx1ZSh0eXBlS2V5KTtcbiAgICAgICAgaWYgKHBhcmVudFR5cGVOYW1lIGluIGNvbXBpbGVkVHlwZXMpIHtcbiAgICAgICAgICBwYXRoVG9DaXJjdWxhclJlZiA9IHR5cGVzVG9BcHBseS5jb25jYXQocGFyZW50VHlwZU5hbWUpLmpvaW4oJyAtPiAnKTtcbiAgICAgICAgICBjaGlsZFR5cGVQcm9wZXJ0eSA9IHRoaXMuZ2V0X3R5cGUoY2hpbGRUeXBlTmFtZSlbMF07XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuUmVzb3VyY2VUeXBlRXJyb3IoJ3doaWxlIGFwcGx5aW5nIHJlc291cmNlVHlwZXMnLCBudWxsLCBcImNpcmN1bGFyIHJlZmVyZW5jZSBvZiBcXFwiXCIgKyBwYXJlbnRUeXBlTmFtZSArIFwiXFxcIiBoYXMgYmVlbiBkZXRlY3RlZDogXCIgKyBwYXRoVG9DaXJjdWxhclJlZiwgY2hpbGRUeXBlUHJvcGVydHkuc3RhcnRfbWFyayk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50VHlwZSA9IHRoaXMuYXBwbHlfcGFyYW1ldGVyc190b190eXBlKHJlc291cmNlVXJpLCBwYXJlbnRUeXBlTmFtZSwgdHlwZUtleSk7XG4gICAgICAgIHRoaXMuYXBwbHlfZGVmYXVsdF9tZWRpYV90eXBlX3RvX3Jlc291cmNlKHBhcmVudFR5cGUpO1xuICAgICAgICB0aGlzLmFwcGx5X3RyYWl0c190b19yZXNvdXJjZShyZXNvdXJjZVVyaSwgcGFyZW50VHlwZSwgZmFsc2UpO1xuICAgICAgICBjaGlsZFR5cGVOYW1lID0gcGFyZW50VHlwZU5hbWU7XG4gICAgICAgIGNoaWxkVHlwZSA9IHBhcmVudFR5cGU7XG4gICAgICAgIGNvbXBpbGVkVHlwZXNbY2hpbGRUeXBlTmFtZV0gPSBjaGlsZFR5cGU7XG4gICAgICAgIHR5cGVzVG9BcHBseS5wdXNoKGNoaWxkVHlwZU5hbWUpO1xuICAgICAgfVxuICAgICAgcm9vdFR5cGUgPSB0eXBlc1RvQXBwbHkucG9wKCk7XG4gICAgICBiYXNlVHlwZSA9IGNvbXBpbGVkVHlwZXNbcm9vdFR5cGVdLmNsb25lRm9yUmVzb3VyY2VUeXBlKCk7XG4gICAgICByZXN1bHQgPSBiYXNlVHlwZTtcbiAgICAgIHdoaWxlIChpbmhlcml0c0Zyb20gPSB0eXBlc1RvQXBwbHkucG9wKCkpIHtcbiAgICAgICAgYmFzZVR5cGUgPSBjb21waWxlZFR5cGVzW2luaGVyaXRzRnJvbV0uY2xvbmVGb3JSZXNvdXJjZVR5cGUoKTtcbiAgICAgICAgcmVzdWx0LmNvbWJpbmUoYmFzZVR5cGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgUmVzb3VyY2VUeXBlcy5wcm90b3R5cGUuYXBwbHlfcGFyYW1ldGVyc190b190eXBlID0gZnVuY3Rpb24ocmVzb3VyY2VVcmksIHR5cGVOYW1lLCB0eXBlS2V5KSB7XG4gICAgICB2YXIgcGFyYW1ldGVycywgdHlwZTtcbiAgICAgIGlmICghKHR5cGVOYW1lICE9IG51bGwgPyB0eXBlTmFtZS50cmltKCkgOiB2b2lkIDApKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlJlc291cmNlVHlwZUVycm9yKCd3aGlsZSBhcHBseWluZyByZXNvdXJjZSB0eXBlJywgbnVsbCwgJ3Jlc291cmNlIHR5cGUgbmFtZSBtdXN0IGJlIHByb3ZpZGVkJywgdHlwZUtleS5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIGlmICghKHR5cGUgPSB0aGlzLmdldF90eXBlKHR5cGVOYW1lKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuUmVzb3VyY2VUeXBlRXJyb3IoJ3doaWxlIGFwcGx5aW5nIHJlc291cmNlIHR5cGUnLCBudWxsLCBcInRoZXJlIGlzIG5vIHJlc291cmNlIHR5cGUgbmFtZWQgXCIgKyB0eXBlTmFtZSwgdHlwZUtleS5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIHR5cGUgPSB0eXBlWzFdLmNsb25lKCk7XG4gICAgICBwYXJhbWV0ZXJzID0gdGhpcy5fZ2V0X3BhcmFtZXRlcnNfZnJvbV90eXBlX2tleShyZXNvdXJjZVVyaSwgdHlwZUtleSk7XG4gICAgICB0aGlzLmFwcGx5X3BhcmFtZXRlcnModHlwZSwgcGFyYW1ldGVycywgdHlwZUtleSk7XG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9O1xuXG4gICAgUmVzb3VyY2VUeXBlcy5wcm90b3R5cGUuX2dldF9wYXJhbWV0ZXJzX2Zyb21fdHlwZV9rZXkgPSBmdW5jdGlvbihyZXNvdXJjZVVyaSwgdHlwZUtleSkge1xuICAgICAgdmFyIHBhcmFtZXRlciwgcGFyYW1ldGVycywgcmVzZXJ2ZWQsIHJlc3VsdCwgX2ksIF9sZW4sIF9yZWYxO1xuICAgICAgcmVzdWx0ID0ge307XG4gICAgICByZXNlcnZlZCA9IHtcbiAgICAgICAgcmVzb3VyY2VQYXRoOiByZXNvdXJjZVVyaS5yZXBsYWNlKC9cXC9cXC8qL2csICcvJyksXG4gICAgICAgIHJlc291cmNlUGF0aE5hbWU6IHRoaXMuZXh0cmFjdFJlc291cmNlUGF0aE5hbWUocmVzb3VyY2VVcmkpXG4gICAgICB9O1xuICAgICAgaWYgKHV0aWwuaXNNYXBwaW5nKHR5cGVLZXkpKSB7XG4gICAgICAgIHBhcmFtZXRlcnMgPSB0aGlzLnZhbHVlX29yX3VuZGVmaW5lZCh0eXBlS2V5KTtcbiAgICAgICAgaWYgKHV0aWwuaXNNYXBwaW5nKHBhcmFtZXRlcnNbMF1bMV0pKSB7XG4gICAgICAgICAgX3JlZjEgPSBwYXJhbWV0ZXJzWzBdWzFdLnZhbHVlO1xuICAgICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjEubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICAgIHBhcmFtZXRlciA9IF9yZWYxW19pXTtcbiAgICAgICAgICAgIGlmIChwYXJhbWV0ZXJbMF0udmFsdWUgaW4gcmVzZXJ2ZWQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuUmVzb3VyY2VUeXBlRXJyb3IoJ3doaWxlIGFwcGx5aW5nIHBhcmFtZXRlcnMnLCBudWxsLCBcImludmFsaWQgcGFyYW1ldGVyIG5hbWU6IFwiICsgcGFyYW1ldGVyWzBdLnZhbHVlICsgXCIgaXMgcmVzZXJ2ZWRcIiwgcGFyYW1ldGVyWzBdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W3BhcmFtZXRlclswXS52YWx1ZV0gPSBwYXJhbWV0ZXJbMV0udmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdXRpbC5leHRlbmQocmVzdWx0LCByZXNlcnZlZCk7XG4gICAgfTtcblxuICAgIHJldHVybiBSZXNvdXJjZVR5cGVzO1xuXG4gIH0pKCk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIoZnVuY3Rpb24oKSB7XG4gIHZhciBNYXJrZWRZQU1MRXJyb3IsIFNpbXBsZUtleSwgdG9rZW5zLCB1dGlsLCBfcmVmLFxuICAgIF9faGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LFxuICAgIF9fZXh0ZW5kcyA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoX19oYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuICAgIF9fc2xpY2UgPSBbXS5zbGljZSxcbiAgICBfX2luZGV4T2YgPSBbXS5pbmRleE9mIHx8IGZ1bmN0aW9uKGl0ZW0pIHsgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykgeyBpZiAoaSBpbiB0aGlzICYmIHRoaXNbaV0gPT09IGl0ZW0pIHJldHVybiBpOyB9IHJldHVybiAtMTsgfTtcblxuICBNYXJrZWRZQU1MRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9ycycpLk1hcmtlZFlBTUxFcnJvcjtcblxuICB0b2tlbnMgPSByZXF1aXJlKCcuL3Rva2VucycpO1xuXG4gIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuICAvKlxuICBUaGUgU2Nhbm5lciB0aHJvd3MgdGhlc2UuXG4gICovXG5cblxuICB0aGlzLlNjYW5uZXJFcnJvciA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2Nhbm5lckVycm9yLCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gU2Nhbm5lckVycm9yKCkge1xuICAgICAgX3JlZiA9IFNjYW5uZXJFcnJvci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfcmVmO1xuICAgIH1cblxuICAgIHJldHVybiBTY2FubmVyRXJyb3I7XG5cbiAgfSkoTWFya2VkWUFNTEVycm9yKTtcblxuICAvKlxuICBSZXByZXNlbnRzIGEgcG9zc2libGUgc2ltcGxlIGtleS5cbiAgKi9cblxuXG4gIFNpbXBsZUtleSA9IChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBTaW1wbGVLZXkodG9rZW5fbnVtYmVyLCByZXF1aXJlZCwgaW5kZXgsIGxpbmUsIGNvbHVtbiwgbWFyaykge1xuICAgICAgdGhpcy50b2tlbl9udW1iZXIgPSB0b2tlbl9udW1iZXI7XG4gICAgICB0aGlzLnJlcXVpcmVkID0gcmVxdWlyZWQ7XG4gICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICB0aGlzLmxpbmUgPSBsaW5lO1xuICAgICAgdGhpcy5jb2x1bW4gPSBjb2x1bW47XG4gICAgICB0aGlzLm1hcmsgPSBtYXJrO1xuICAgIH1cblxuICAgIHJldHVybiBTaW1wbGVLZXk7XG5cbiAgfSkoKTtcblxuICAvKlxuICBUaGUgU2Nhbm5lciBjbGFzcyBkZWFscyB3aXRoIGNvbnZlcnRpbmcgYSBZQU1MIHN0cmVhbSBpbnRvIGEgdG9rZW4gc3RyZWFtLlxuICAqL1xuXG5cbiAgdGhpcy5TY2FubmVyID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBDX0xCLCBDX05VTUJFUlMsIENfV1MsIEVTQ0FQRV9DT0RFUywgRVNDQVBFX1JFUExBQ0VNRU5UUywgUkFNTF9WRVJTSU9OLCBSQU1MX1ZFUlNJT05fUkU7XG5cbiAgICBDX0xCID0gJ1xcclxcblxceDg1XFx1MjAyOFxcdTIwMjknO1xuXG4gICAgQ19XUyA9ICdcXHQgJztcblxuICAgIENfTlVNQkVSUyA9ICcwMTIzNDU2Nzg5JztcblxuICAgIEVTQ0FQRV9SRVBMQUNFTUVOVFMgPSB7XG4gICAgICAnMCc6ICdcXHgwMCcsXG4gICAgICAnYSc6ICdcXHgwNycsXG4gICAgICAnYic6ICdcXHgwOCcsXG4gICAgICAndCc6ICdcXHgwOScsXG4gICAgICAnXFx0JzogJ1xceDA5JyxcbiAgICAgICduJzogJ1xceDBBJyxcbiAgICAgICd2JzogJ1xceDBCJyxcbiAgICAgICdmJzogJ1xceDBDJyxcbiAgICAgICdyJzogJ1xceDBEJyxcbiAgICAgICdlJzogJ1xceDFCJyxcbiAgICAgICcgJzogJ1xceDIwJyxcbiAgICAgICdcIic6ICdcIicsXG4gICAgICAnXFxcXCc6ICdcXFxcJyxcbiAgICAgICdOJzogJ1xceDg1JyxcbiAgICAgICdfJzogJ1xceEEwJyxcbiAgICAgICdMJzogJ1xcdTIwMjgnLFxuICAgICAgJ1AnOiAnXFx1MjAyOSdcbiAgICB9O1xuXG4gICAgRVNDQVBFX0NPREVTID0ge1xuICAgICAgJ3gnOiAyLFxuICAgICAgJ3UnOiA0LFxuICAgICAgJ1UnOiA4XG4gICAgfTtcblxuICAgIFJBTUxfVkVSU0lPTiA9ICcjJVJBTUwgMC44JztcblxuICAgIFJBTUxfVkVSU0lPTl9SRSA9IC9eIyVSQU1MIC4rJC87XG5cbiAgICAvKlxuICAgIEluaXRpYWxpc2UgdGhlIFNjYW5uZXJcbiAgICAqL1xuXG5cbiAgICBmdW5jdGlvbiBTY2FubmVyKHNldHRpbmdzKSB7XG4gICAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMucmFtbEhlYWRlckZvdW5kID0gIXRoaXMuc2V0dGluZ3MudmFsaWRhdGU7XG4gICAgICB0aGlzLmZsb3dfbGV2ZWwgPSAwO1xuICAgICAgdGhpcy50b2tlbnMgPSBbXTtcbiAgICAgIHRoaXMuZmV0Y2hfc3RyZWFtX3N0YXJ0KCk7XG4gICAgICB0aGlzLnRva2Vuc190YWtlbiA9IDA7XG4gICAgICB0aGlzLmluZGVudCA9IC0xO1xuICAgICAgdGhpcy5pbmRlbnRzID0gW107XG4gICAgICB0aGlzLmFsbG93X3NpbXBsZV9rZXkgPSB0cnVlO1xuICAgICAgdGhpcy5wb3NzaWJsZV9zaW1wbGVfa2V5cyA9IHt9O1xuICAgIH1cblxuICAgIC8qXG4gICAgQ2hlY2sgaWYgdGhlIG5leHQgdG9rZW4gaXMgb25lIG9mIHRoZSBnaXZlbiB0eXBlcy5cbiAgICAqL1xuXG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5jaGVja190b2tlbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNob2ljZSwgY2hvaWNlcywgX2ksIF9sZW47XG4gICAgICBjaG9pY2VzID0gMSA8PSBhcmd1bWVudHMubGVuZ3RoID8gX19zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkgOiBbXTtcbiAgICAgIHdoaWxlICh0aGlzLm5lZWRfbW9yZV90b2tlbnMoKSkge1xuICAgICAgICB0aGlzLmZldGNoX21vcmVfdG9rZW5zKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50b2tlbnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIGlmIChjaG9pY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gY2hvaWNlcy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIGNob2ljZSA9IGNob2ljZXNbX2ldO1xuICAgICAgICAgIGlmICh0aGlzLnRva2Vuc1swXSBpbnN0YW5jZW9mIGNob2ljZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qXG4gICAgUmV0dXJuIHRoZSBuZXh0IHRva2VuLCBidXQgZG8gbm90IGRlbGV0ZSBpdCBmcm9tIHRoZSBxdWV1ZS5cbiAgICAqL1xuXG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5wZWVrX3Rva2VuID0gZnVuY3Rpb24oKSB7XG4gICAgICB3aGlsZSAodGhpcy5uZWVkX21vcmVfdG9rZW5zKCkpIHtcbiAgICAgICAgdGhpcy5mZXRjaF9tb3JlX3Rva2VucygpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMudG9rZW5zLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b2tlbnNbMF07XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qXG4gICAgUmV0dXJuIHRoZSBuZXh0IHRva2VuLCBhbmQgcmVtb3ZlIGl0IGZyb20gdGhlIHF1ZXVlLlxuICAgICovXG5cblxuICAgIFNjYW5uZXIucHJvdG90eXBlLmdldF90b2tlbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgd2hpbGUgKHRoaXMubmVlZF9tb3JlX3Rva2VucygpKSB7XG4gICAgICAgIHRoaXMuZmV0Y2hfbW9yZV90b2tlbnMoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnRva2Vucy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgdGhpcy50b2tlbnNfdGFrZW4rKztcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5zLnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFNjYW5uZXIucHJvdG90eXBlLm5lZWRfbW9yZV90b2tlbnMgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMudG9rZW5zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhbGVfcG9zc2libGVfc2ltcGxlX2tleXMoKTtcbiAgICAgIGlmICh0aGlzLm5leHRfcG9zc2libGVfc2ltcGxlX2tleSgpID09PSB0aGlzLnRva2Vuc190YWtlbikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuZmV0Y2hfbW9yZV90b2tlbnMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjaGFyO1xuICAgICAgdGhpcy5zY2FuX3RvX25leHRfdG9rZW4oKTtcbiAgICAgIHRoaXMuc3RhbGVfcG9zc2libGVfc2ltcGxlX2tleXMoKTtcbiAgICAgIHRoaXMudW53aW5kX2luZGVudCh0aGlzLmNvbHVtbik7XG4gICAgICBjaGFyID0gdGhpcy5wZWVrKCk7XG4gICAgICBpZiAoY2hhciA9PT0gJ1xceDAwJykge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaF9zdHJlYW1fZW5kKCk7XG4gICAgICB9XG4gICAgICBpZiAoY2hhciA9PT0gJyUnICYmIHRoaXMuY2hlY2tfZGlyZWN0aXZlKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hfZGlyZWN0aXZlKCk7XG4gICAgICB9XG4gICAgICBpZiAoY2hhciA9PT0gJy0nICYmIHRoaXMuY2hlY2tfZG9jdW1lbnRfc3RhcnQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaF9kb2N1bWVudF9zdGFydCgpO1xuICAgICAgfVxuICAgICAgaWYgKGNoYXIgPT09ICcuJyAmJiB0aGlzLmNoZWNrX2RvY3VtZW50X2VuZCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoX2RvY3VtZW50X2VuZCgpO1xuICAgICAgfVxuICAgICAgaWYgKGNoYXIgPT09ICdbJykge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaF9mbG93X3NlcXVlbmNlX3N0YXJ0KCk7XG4gICAgICB9XG4gICAgICBpZiAoY2hhciA9PT0gJ3snKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoX2Zsb3dfbWFwcGluZ19zdGFydCgpO1xuICAgICAgfVxuICAgICAgaWYgKGNoYXIgPT09ICddJykge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaF9mbG93X3NlcXVlbmNlX2VuZCgpO1xuICAgICAgfVxuICAgICAgaWYgKGNoYXIgPT09ICd9Jykge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaF9mbG93X21hcHBpbmdfZW5kKCk7XG4gICAgICB9XG4gICAgICBpZiAoY2hhciA9PT0gJywnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoX2Zsb3dfZW50cnkoKTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGFyID09PSAnLScgJiYgdGhpcy5jaGVja19ibG9ja19lbnRyeSgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoX2Jsb2NrX2VudHJ5KCk7XG4gICAgICB9XG4gICAgICBpZiAoY2hhciA9PT0gJz8nICYmIHRoaXMuY2hlY2tfa2V5KCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hfa2V5KCk7XG4gICAgICB9XG4gICAgICBpZiAoY2hhciA9PT0gJzonICYmIHRoaXMuY2hlY2tfdmFsdWUoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaF92YWx1ZSgpO1xuICAgICAgfVxuICAgICAgaWYgKGNoYXIgPT09ICcqJykge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaF9hbGlhcygpO1xuICAgICAgfVxuICAgICAgaWYgKGNoYXIgPT09ICcmJykge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaF9hbmNob3IoKTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGFyID09PSAnIScpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hfdGFnKCk7XG4gICAgICB9XG4gICAgICBpZiAoY2hhciA9PT0gJ3wnICYmIHRoaXMuZmxvd19sZXZlbCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaF9saXRlcmFsKCk7XG4gICAgICB9XG4gICAgICBpZiAoY2hhciA9PT0gJz4nICYmIHRoaXMuZmxvd19sZXZlbCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaF9mb2xkZWQoKTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGFyID09PSAnXFwnJykge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaF9zaW5nbGUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGFyID09PSAnXCInKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoX2RvdWJsZSgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY2hlY2tfcGxhaW4oKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaF9wbGFpbigpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuU2Nhbm5lckVycm9yKCd3aGlsZSBzY2FubmluZyBmb3IgdGhlIG5leHQgdG9rZW4nLCBudWxsLCBcImZvdW5kIGNoYXJhY3RlciBcIiArIGNoYXIgKyBcIiB0aGF0IGNhbm5vdCBzdGFydCBhbnkgdG9rZW5cIiwgdGhpcy5nZXRfbWFyaygpKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBSZXR1cm4gdGhlIG51bWJlciBvZiB0aGUgbmVhcmVzdCBwb3NzaWJsZSBzaW1wbGUga2V5LlxuICAgICovXG5cblxuICAgIFNjYW5uZXIucHJvdG90eXBlLm5leHRfcG9zc2libGVfc2ltcGxlX2tleSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGtleSwgbGV2ZWwsIG1pbl90b2tlbl9udW1iZXIsIF9yZWYxO1xuICAgICAgbWluX3Rva2VuX251bWJlciA9IG51bGw7XG4gICAgICBfcmVmMSA9IHRoaXMucG9zc2libGVfc2ltcGxlX2tleXM7XG4gICAgICBmb3IgKGxldmVsIGluIF9yZWYxKSB7XG4gICAgICAgIGlmICghX19oYXNQcm9wLmNhbGwoX3JlZjEsIGxldmVsKSkgY29udGludWU7XG4gICAgICAgIGtleSA9IF9yZWYxW2xldmVsXTtcbiAgICAgICAgaWYgKG1pbl90b2tlbl9udW1iZXIgPT09IG51bGwgfHwga2V5LnRva2VuX251bWJlciA8IG1pbl90b2tlbl9udW1iZXIpIHtcbiAgICAgICAgICBtaW5fdG9rZW5fbnVtYmVyID0ga2V5LnRva2VuX251bWJlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1pbl90b2tlbl9udW1iZXI7XG4gICAgfTtcblxuICAgIC8qXG4gICAgUmVtb3ZlIGVudHJpZXMgdGhhdCBhcmUgbm8gbG9uZ2VyIHBvc3NpYmxlIHNpbXBsZSBrZXlzLiAgQWNjb3JkaW5nIHRvIHRoZVxuICAgIFlBTUwgc3BlYywgc2ltcGxlIGtleXM6XG4gICAgICBzaG91bGQgYmUgbGltaXRlZCB0byBhIHNpbmdsZSBsaW5lXG4gICAgICBzaG91bGQgYmUgbm8gbG9uZ2VyIHRoYW4gMTAyNCBjaGFyYWN0ZXJzXG4gICAgRGlzYWJsaW5nIHRoaXMgcHJvY2VkdXJlIHdpbGwgYWxsb3cgc2ltcGxlIGtleXMgb2YgYW55IGxlbmd0aCBhbmQgaGVpZ2h0XG4gICAgKG1heSBjYXVzZSBwcm9ibGVtcyBpZiBpbmRlbnRhdGlvbiBpcyBicm9rZW4gdGhvdWdoKS5cbiAgICAqL1xuXG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5zdGFsZV9wb3NzaWJsZV9zaW1wbGVfa2V5cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGtleSwgbGV2ZWwsIF9yZWYxLCBfcmVzdWx0cztcbiAgICAgIF9yZWYxID0gdGhpcy5wb3NzaWJsZV9zaW1wbGVfa2V5cztcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKGxldmVsIGluIF9yZWYxKSB7XG4gICAgICAgIGlmICghX19oYXNQcm9wLmNhbGwoX3JlZjEsIGxldmVsKSkgY29udGludWU7XG4gICAgICAgIGtleSA9IF9yZWYxW2xldmVsXTtcbiAgICAgICAgaWYgKGtleS5saW5lID09PSB0aGlzLmxpbmUgJiYgdGhpcy5pbmRleCAtIGtleS5pbmRleCA8PSAxMDI0KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFrZXkucmVxdWlyZWQpIHtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKGRlbGV0ZSB0aGlzLnBvc3NpYmxlX3NpbXBsZV9rZXlzW2xldmVsXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuU2Nhbm5lckVycm9yKCd3aGlsZSBzY2FubmluZyBhIHNpbXBsZSBrZXknLCBrZXkubWFyaywgJ2NvdWxkIG5vdCBmaW5kIGV4cGVjdGVkIFxcJzpcXCcnLCB0aGlzLmdldF9tYXJrKCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfTtcblxuICAgIC8qXG4gICAgVGhlIG5leHQgdG9rZW4gbWF5IHN0YXJ0IGEgc2ltcGxlIGtleS4gIFdlIGNoZWNrIGlmIGl0J3MgcG9zc2libGUgYW5kIHNhdmVcbiAgICBpdHMgcG9zaXRpb24uICBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBmb3IgQUxJQVMsIEFOQ0hPUiwgVEFHLFxuICAgIFNDQUxBUiAoZmxvdyksJ1snIGFuZCAneycuXG4gICAgKi9cblxuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuc2F2ZV9wb3NzaWJsZV9zaW1wbGVfa2V5ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVxdWlyZWQsIHRva2VuX251bWJlcjtcbiAgICAgIHJlcXVpcmVkID0gdGhpcy5mbG93X2xldmVsID09PSAwICYmIHRoaXMuaW5kZW50ID09PSB0aGlzLmNvbHVtbjtcbiAgICAgIGlmIChyZXF1aXJlZCAmJiAhdGhpcy5hbGxvd19zaW1wbGVfa2V5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbG9naWMgZmFpbHVyZScpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmFsbG93X3NpbXBsZV9rZXkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5yZW1vdmVfcG9zc2libGVfc2ltcGxlX2tleSgpO1xuICAgICAgdG9rZW5fbnVtYmVyID0gdGhpcy50b2tlbnNfdGFrZW4gKyB0aGlzLnRva2Vucy5sZW5ndGg7XG4gICAgICByZXR1cm4gdGhpcy5wb3NzaWJsZV9zaW1wbGVfa2V5c1t0aGlzLmZsb3dfbGV2ZWxdID0gbmV3IFNpbXBsZUtleSh0b2tlbl9udW1iZXIsIHJlcXVpcmVkLCB0aGlzLmluZGV4LCB0aGlzLmxpbmUsIHRoaXMuY29sdW1uLCB0aGlzLmdldF9tYXJrKCkpO1xuICAgIH07XG5cbiAgICAvKlxuICAgIFJlbW92ZSB0aGUgc2F2ZWQgcG9zc2libGUgc2ltcGxlIGtleSBhdCB0aGUgY3VycmVudCBmbG93IGxldmVsLlxuICAgICovXG5cblxuICAgIFNjYW5uZXIucHJvdG90eXBlLnJlbW92ZV9wb3NzaWJsZV9zaW1wbGVfa2V5ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIga2V5O1xuICAgICAgaWYgKCEoa2V5ID0gdGhpcy5wb3NzaWJsZV9zaW1wbGVfa2V5c1t0aGlzLmZsb3dfbGV2ZWxdKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIWtleS5yZXF1aXJlZCkge1xuICAgICAgICByZXR1cm4gZGVsZXRlIHRoaXMucG9zc2libGVfc2ltcGxlX2tleXNbdGhpcy5mbG93X2xldmVsXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlNjYW5uZXJFcnJvcignd2hpbGUgc2Nhbm5pbmcgYSBzaW1wbGUga2V5Jywga2V5Lm1hcmssICdjb3VsZCBub3QgZmluZCBleHBlY3RlZCBcXCc6XFwnJywgdGhpcy5nZXRfbWFyaygpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLypcbiAgICBJbiBmbG93IGNvbnRleHQsIHRva2VucyBzaG91bGQgcmVzcGVjdCBpbmRlbnRhdGlvbi5cbiAgICBBY3R1YWxseSB0aGUgY29uZGl0aW9uIHNob3VsZCBiZSBgc2VsZi5pbmRlbnQgPj0gY29sdW1uYCBhY2NvcmRpbmcgdG9cbiAgICB0aGUgc3BlYy4gQnV0IHRoaXMgY29uZGl0aW9uIHdpbGwgcHJvaGliaXQgaW50dWl0aXZlbHkgY29ycmVjdFxuICAgIGNvbnN0cnVjdGlvbnMgc3VjaCBhc1xuICAgICAga2V5IDoge1xuICAgICAgfVxuICAgICovXG5cblxuICAgIFNjYW5uZXIucHJvdG90eXBlLnVud2luZF9pbmRlbnQgPSBmdW5jdGlvbihjb2x1bW4pIHtcbiAgICAgIHZhciBtYXJrLCBfcmVzdWx0cztcbiAgICAgIGlmICh0aGlzLmZsb3dfbGV2ZWwgIT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIHdoaWxlICh0aGlzLmluZGVudCA+IGNvbHVtbikge1xuICAgICAgICBtYXJrID0gdGhpcy5nZXRfbWFyaygpO1xuICAgICAgICB0aGlzLmluZGVudCA9IHRoaXMuaW5kZW50cy5wb3AoKTtcbiAgICAgICAgX3Jlc3VsdHMucHVzaCh0aGlzLnRva2Vucy5wdXNoKG5ldyB0b2tlbnMuQmxvY2tFbmRUb2tlbihtYXJrLCBtYXJrKSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH07XG5cbiAgICAvKlxuICAgIENoZWNrIGlmIHdlIG5lZWQgdG8gaW5jcmVhc2UgaW5kZW50YXRpb24uXG4gICAgKi9cblxuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuYWRkX2luZGVudCA9IGZ1bmN0aW9uKGNvbHVtbikge1xuICAgICAgaWYgKCEoY29sdW1uID4gdGhpcy5pbmRlbnQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5kZW50cy5wdXNoKHRoaXMuaW5kZW50KTtcbiAgICAgIHRoaXMuaW5kZW50ID0gY29sdW1uO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIFNjYW5uZXIucHJvdG90eXBlLmZldGNoX3N0cmVhbV9zdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG1hcms7XG4gICAgICBtYXJrID0gdGhpcy5nZXRfbWFyaygpO1xuICAgICAgcmV0dXJuIHRoaXMudG9rZW5zLnB1c2gobmV3IHRva2Vucy5TdHJlYW1TdGFydFRva2VuKG1hcmssIG1hcmssIHRoaXMuZW5jb2RpbmcpKTtcbiAgICB9O1xuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuZmV0Y2hfc3RyZWFtX2VuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG1hcms7XG4gICAgICB0aGlzLnVud2luZF9pbmRlbnQoLTEpO1xuICAgICAgdGhpcy5yZW1vdmVfcG9zc2libGVfc2ltcGxlX2tleSgpO1xuICAgICAgdGhpcy5hbGxvd19wb3NzaWJsZV9zaW1wbGVfa2V5ID0gZmFsc2U7XG4gICAgICB0aGlzLnBvc3NpYmxlX3NpbXBsZV9rZXlzID0ge307XG4gICAgICBtYXJrID0gdGhpcy5nZXRfbWFyaygpO1xuICAgICAgdGhpcy50b2tlbnMucHVzaChuZXcgdG9rZW5zLlN0cmVhbUVuZFRva2VuKG1hcmssIG1hcmspKTtcbiAgICAgIHJldHVybiB0aGlzLmRvbmUgPSB0cnVlO1xuICAgIH07XG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5mZXRjaF9kaXJlY3RpdmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMudW53aW5kX2luZGVudCgtMSk7XG4gICAgICB0aGlzLnJlbW92ZV9wb3NzaWJsZV9zaW1wbGVfa2V5KCk7XG4gICAgICB0aGlzLmFsbG93X3NpbXBsZV9rZXkgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzLnRva2Vucy5wdXNoKHRoaXMuc2Nhbl9kaXJlY3RpdmUoKSk7XG4gICAgfTtcblxuICAgIFNjYW5uZXIucHJvdG90eXBlLmZldGNoX2RvY3VtZW50X3N0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5mZXRjaF9kb2N1bWVudF9pbmRpY2F0b3IodG9rZW5zLkRvY3VtZW50U3RhcnRUb2tlbik7XG4gICAgfTtcblxuICAgIFNjYW5uZXIucHJvdG90eXBlLmZldGNoX2RvY3VtZW50X2VuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hfZG9jdW1lbnRfaW5kaWNhdG9yKHRva2Vucy5Eb2N1bWVudEVuZFRva2VuKTtcbiAgICB9O1xuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuZmV0Y2hfZG9jdW1lbnRfaW5kaWNhdG9yID0gZnVuY3Rpb24oVG9rZW5DbGFzcykge1xuICAgICAgdmFyIHN0YXJ0X21hcms7XG4gICAgICB0aGlzLnVud2luZF9pbmRlbnQoLTEpO1xuICAgICAgdGhpcy5yZW1vdmVfcG9zc2libGVfc2ltcGxlX2tleSgpO1xuICAgICAgdGhpcy5hbGxvd19zaW1wbGVfa2V5ID0gZmFsc2U7XG4gICAgICBzdGFydF9tYXJrID0gdGhpcy5nZXRfbWFyaygpO1xuICAgICAgdGhpcy5mb3J3YXJkKDMpO1xuICAgICAgcmV0dXJuIHRoaXMudG9rZW5zLnB1c2gobmV3IFRva2VuQ2xhc3Moc3RhcnRfbWFyaywgdGhpcy5nZXRfbWFyaygpKSk7XG4gICAgfTtcblxuICAgIFNjYW5uZXIucHJvdG90eXBlLmZldGNoX2Zsb3dfc2VxdWVuY2Vfc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmZldGNoX2Zsb3dfY29sbGVjdGlvbl9zdGFydCh0b2tlbnMuRmxvd1NlcXVlbmNlU3RhcnRUb2tlbik7XG4gICAgfTtcblxuICAgIFNjYW5uZXIucHJvdG90eXBlLmZldGNoX2Zsb3dfbWFwcGluZ19zdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hfZmxvd19jb2xsZWN0aW9uX3N0YXJ0KHRva2Vucy5GbG93TWFwcGluZ1N0YXJ0VG9rZW4pO1xuICAgIH07XG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5mZXRjaF9mbG93X2NvbGxlY3Rpb25fc3RhcnQgPSBmdW5jdGlvbihUb2tlbkNsYXNzKSB7XG4gICAgICB2YXIgc3RhcnRfbWFyaztcbiAgICAgIHRoaXMuc2F2ZV9wb3NzaWJsZV9zaW1wbGVfa2V5KCk7XG4gICAgICB0aGlzLmZsb3dfbGV2ZWwrKztcbiAgICAgIHRoaXMuYWxsb3dfc2ltcGxlX2tleSA9IHRydWU7XG4gICAgICBzdGFydF9tYXJrID0gdGhpcy5nZXRfbWFyaygpO1xuICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICByZXR1cm4gdGhpcy50b2tlbnMucHVzaChuZXcgVG9rZW5DbGFzcyhzdGFydF9tYXJrLCB0aGlzLmdldF9tYXJrKCkpKTtcbiAgICB9O1xuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuZmV0Y2hfZmxvd19zZXF1ZW5jZV9lbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmZldGNoX2Zsb3dfY29sbGVjdGlvbl9lbmQodG9rZW5zLkZsb3dTZXF1ZW5jZUVuZFRva2VuKTtcbiAgICB9O1xuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuZmV0Y2hfZmxvd19tYXBwaW5nX2VuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hfZmxvd19jb2xsZWN0aW9uX2VuZCh0b2tlbnMuRmxvd01hcHBpbmdFbmRUb2tlbik7XG4gICAgfTtcblxuICAgIFNjYW5uZXIucHJvdG90eXBlLmZldGNoX2Zsb3dfY29sbGVjdGlvbl9lbmQgPSBmdW5jdGlvbihUb2tlbkNsYXNzKSB7XG4gICAgICB2YXIgc3RhcnRfbWFyaztcbiAgICAgIHRoaXMucmVtb3ZlX3Bvc3NpYmxlX3NpbXBsZV9rZXkoKTtcbiAgICAgIHRoaXMuZmxvd19sZXZlbC0tO1xuICAgICAgdGhpcy5hbGxvd19zaW1wbGVfa2V5ID0gZmFsc2U7XG4gICAgICBzdGFydF9tYXJrID0gdGhpcy5nZXRfbWFyaygpO1xuICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICByZXR1cm4gdGhpcy50b2tlbnMucHVzaChuZXcgVG9rZW5DbGFzcyhzdGFydF9tYXJrLCB0aGlzLmdldF9tYXJrKCkpKTtcbiAgICB9O1xuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuZmV0Y2hfZmxvd19lbnRyeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHN0YXJ0X21hcms7XG4gICAgICB0aGlzLmFsbG93X3NpbXBsZV9rZXkgPSB0cnVlO1xuICAgICAgdGhpcy5yZW1vdmVfcG9zc2libGVfc2ltcGxlX2tleSgpO1xuICAgICAgc3RhcnRfbWFyayA9IHRoaXMuZ2V0X21hcmsoKTtcbiAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgcmV0dXJuIHRoaXMudG9rZW5zLnB1c2gobmV3IHRva2Vucy5GbG93RW50cnlUb2tlbihzdGFydF9tYXJrLCB0aGlzLmdldF9tYXJrKCkpKTtcbiAgICB9O1xuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuZmV0Y2hfYmxvY2tfZW50cnkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBtYXJrLCBzdGFydF9tYXJrO1xuICAgICAgaWYgKHRoaXMuZmxvd19sZXZlbCA9PT0gMCkge1xuICAgICAgICBpZiAoIXRoaXMuYWxsb3dfc2ltcGxlX2tleSkge1xuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlNjYW5uZXJFcnJvcihudWxsLCBudWxsLCAnc2VxdWVuY2UgZW50cmllcyBhcmUgbm90IGFsbG93ZWQgaGVyZScsIHRoaXMuZ2V0X21hcmsoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYWRkX2luZGVudCh0aGlzLmNvbHVtbikpIHtcbiAgICAgICAgICBtYXJrID0gdGhpcy5nZXRfbWFyaygpO1xuICAgICAgICAgIHRoaXMudG9rZW5zLnB1c2gobmV3IHRva2Vucy5CbG9ja1NlcXVlbmNlU3RhcnRUb2tlbihtYXJrLCBtYXJrKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuYWxsb3dfc2ltcGxlX2tleSA9IHRydWU7XG4gICAgICB0aGlzLnJlbW92ZV9wb3NzaWJsZV9zaW1wbGVfa2V5KCk7XG4gICAgICBzdGFydF9tYXJrID0gdGhpcy5nZXRfbWFyaygpO1xuICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICByZXR1cm4gdGhpcy50b2tlbnMucHVzaChuZXcgdG9rZW5zLkJsb2NrRW50cnlUb2tlbihzdGFydF9tYXJrLCB0aGlzLmdldF9tYXJrKCkpKTtcbiAgICB9O1xuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuZmV0Y2hfa2V5ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbWFyaywgc3RhcnRfbWFyaztcbiAgICAgIGlmICh0aGlzLmZsb3dfbGV2ZWwgPT09IDApIHtcbiAgICAgICAgaWYgKCF0aGlzLmFsbG93X3NpbXBsZV9rZXkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5TY2FubmVyRXJyb3IobnVsbCwgbnVsbCwgJ21hcHBpbmcga2V5cyBhcmUgbm90IGFsbG93ZWQgaGVyZScsIHRoaXMuZ2V0X21hcmsoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYWRkX2luZGVudCh0aGlzLmNvbHVtbikpIHtcbiAgICAgICAgICBtYXJrID0gdGhpcy5nZXRfbWFyaygpO1xuICAgICAgICAgIHRoaXMudG9rZW5zLnB1c2gobmV3IHRva2Vucy5CbG9ja01hcHBpbmdTdGFydFRva2VuKG1hcmssIG1hcmspKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5hbGxvd19zaW1wbGVfa2V5ID0gIXRoaXMuZmxvd19sZXZlbDtcbiAgICAgIHRoaXMucmVtb3ZlX3Bvc3NpYmxlX3NpbXBsZV9rZXkoKTtcbiAgICAgIHN0YXJ0X21hcmsgPSB0aGlzLmdldF9tYXJrKCk7XG4gICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgIHJldHVybiB0aGlzLnRva2Vucy5wdXNoKG5ldyB0b2tlbnMuS2V5VG9rZW4oc3RhcnRfbWFyaywgdGhpcy5nZXRfbWFyaygpKSk7XG4gICAgfTtcblxuICAgIFNjYW5uZXIucHJvdG90eXBlLmZldGNoX3ZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIga2V5LCBtYXJrLCBzdGFydF9tYXJrO1xuICAgICAgaWYgKGtleSA9IHRoaXMucG9zc2libGVfc2ltcGxlX2tleXNbdGhpcy5mbG93X2xldmVsXSkge1xuICAgICAgICBkZWxldGUgdGhpcy5wb3NzaWJsZV9zaW1wbGVfa2V5c1t0aGlzLmZsb3dfbGV2ZWxdO1xuICAgICAgICB0aGlzLnRva2Vucy5zcGxpY2Uoa2V5LnRva2VuX251bWJlciAtIHRoaXMudG9rZW5zX3Rha2VuLCAwLCBuZXcgdG9rZW5zLktleVRva2VuKGtleS5tYXJrLCBrZXkubWFyaykpO1xuICAgICAgICBpZiAodGhpcy5mbG93X2xldmVsID09PSAwKSB7XG4gICAgICAgICAgaWYgKHRoaXMuYWRkX2luZGVudChrZXkuY29sdW1uKSkge1xuICAgICAgICAgICAgdGhpcy50b2tlbnMuc3BsaWNlKGtleS50b2tlbl9udW1iZXIgLSB0aGlzLnRva2Vuc190YWtlbiwgMCwgbmV3IHRva2Vucy5CbG9ja01hcHBpbmdTdGFydFRva2VuKGtleS5tYXJrLCBrZXkubWFyaykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFsbG93X3NpbXBsZV9rZXkgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmZsb3dfbGV2ZWwgPT09IDApIHtcbiAgICAgICAgICBpZiAoIXRoaXMuYWxsb3dfc2ltcGxlX2tleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuU2Nhbm5lckVycm9yKG51bGwsIG51bGwsICdtYXBwaW5nIHZhbHVlcyBhcmUgbm90IGFsbG93ZWQgaGVyZScsIHRoaXMuZ2V0X21hcmsoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLmFkZF9pbmRlbnQodGhpcy5jb2x1bW4pKSB7XG4gICAgICAgICAgICBtYXJrID0gdGhpcy5nZXRfbWFyaygpO1xuICAgICAgICAgICAgdGhpcy50b2tlbnMucHVzaChuZXcgdG9rZW5zLkJsb2NrTWFwcGluZ1N0YXJ0VG9rZW4obWFyaywgbWFyaykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFsbG93X3NpbXBsZV9rZXkgPSAhdGhpcy5mbG93X2xldmVsO1xuICAgICAgICB0aGlzLnJlbW92ZV9wb3NzaWJsZV9zaW1wbGVfa2V5KCk7XG4gICAgICB9XG4gICAgICBzdGFydF9tYXJrID0gdGhpcy5nZXRfbWFyaygpO1xuICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICByZXR1cm4gdGhpcy50b2tlbnMucHVzaChuZXcgdG9rZW5zLlZhbHVlVG9rZW4oc3RhcnRfbWFyaywgdGhpcy5nZXRfbWFyaygpKSk7XG4gICAgfTtcblxuICAgIFNjYW5uZXIucHJvdG90eXBlLmZldGNoX2FsaWFzID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnNhdmVfcG9zc2libGVfc2ltcGxlX2tleSgpO1xuICAgICAgdGhpcy5hbGxvd19zaW1wbGVfa2V5ID0gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcy50b2tlbnMucHVzaCh0aGlzLnNjYW5fYW5jaG9yKHRva2Vucy5BbGlhc1Rva2VuKSk7XG4gICAgfTtcblxuICAgIFNjYW5uZXIucHJvdG90eXBlLmZldGNoX2FuY2hvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zYXZlX3Bvc3NpYmxlX3NpbXBsZV9rZXkoKTtcbiAgICAgIHRoaXMuYWxsb3dfc2ltcGxlX2tleSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXMudG9rZW5zLnB1c2godGhpcy5zY2FuX2FuY2hvcih0b2tlbnMuQW5jaG9yVG9rZW4pKTtcbiAgICB9O1xuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuZmV0Y2hfdGFnID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnNhdmVfcG9zc2libGVfc2ltcGxlX2tleSgpO1xuICAgICAgdGhpcy5hbGxvd19zaW1wbGVfa2V5ID0gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcy50b2tlbnMucHVzaCh0aGlzLnNjYW5fdGFnKCkpO1xuICAgIH07XG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5mZXRjaF9saXRlcmFsID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5mZXRjaF9ibG9ja19zY2FsYXIoJ3wnKTtcbiAgICB9O1xuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuZmV0Y2hfZm9sZGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5mZXRjaF9ibG9ja19zY2FsYXIoJz4nKTtcbiAgICB9O1xuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuZmV0Y2hfYmxvY2tfc2NhbGFyID0gZnVuY3Rpb24oc3R5bGUpIHtcbiAgICAgIHRoaXMuYWxsb3dfc2ltcGxlX2tleSA9IHRydWU7XG4gICAgICB0aGlzLnJlbW92ZV9wb3NzaWJsZV9zaW1wbGVfa2V5KCk7XG4gICAgICByZXR1cm4gdGhpcy50b2tlbnMucHVzaCh0aGlzLnNjYW5fYmxvY2tfc2NhbGFyKHN0eWxlKSk7XG4gICAgfTtcblxuICAgIFNjYW5uZXIucHJvdG90eXBlLmZldGNoX3NpbmdsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hfZmxvd19zY2FsYXIoJ1xcJycpO1xuICAgIH07XG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5mZXRjaF9kb3VibGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmZldGNoX2Zsb3dfc2NhbGFyKCdcIicpO1xuICAgIH07XG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5mZXRjaF9mbG93X3NjYWxhciA9IGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgICB0aGlzLnNhdmVfcG9zc2libGVfc2ltcGxlX2tleSgpO1xuICAgICAgdGhpcy5hbGxvd19zaW1wbGVfa2V5ID0gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcy50b2tlbnMucHVzaCh0aGlzLnNjYW5fZmxvd19zY2FsYXIoc3R5bGUpKTtcbiAgICB9O1xuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuZmV0Y2hfcGxhaW4gPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc2F2ZV9wb3NzaWJsZV9zaW1wbGVfa2V5KCk7XG4gICAgICB0aGlzLmFsbG93X3NpbXBsZV9rZXkgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzLnRva2Vucy5wdXNoKHRoaXMuc2Nhbl9wbGFpbigpKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBESVJFQ1RJVkU6IF4gJyUnXG4gICAgKi9cblxuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuY2hlY2tfZGlyZWN0aXZlID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5jb2x1bW4gPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qXG4gICAgRE9DVU1FTlQtU1RBUlQ6IF4gJy0tLScgKCcgJ3wnXFxuJylcbiAgICAqL1xuXG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5jaGVja19kb2N1bWVudF9zdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIF9yZWYxO1xuICAgICAgaWYgKHRoaXMuY29sdW1uID09PSAwICYmIHRoaXMucHJlZml4KDMpID09PSAnLS0tJyAmJiAoX3JlZjEgPSB0aGlzLnBlZWsoMyksIF9faW5kZXhPZi5jYWxsKENfTEIgKyBDX1dTICsgJ1xceDAwJywgX3JlZjEpID49IDApKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKlxuICAgIERPQ1VNRU5ULUVORDogXiAnLi4uJyAoJyAnfCdcXG4nKVxuICAgICovXG5cblxuICAgIFNjYW5uZXIucHJvdG90eXBlLmNoZWNrX2RvY3VtZW50X2VuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIF9yZWYxO1xuICAgICAgaWYgKHRoaXMuY29sdW1uID09PSAwICYmIHRoaXMucHJlZml4KDMpID09PSAnLi4uJyAmJiAoX3JlZjEgPSB0aGlzLnBlZWsoMyksIF9faW5kZXhPZi5jYWxsKENfTEIgKyBDX1dTICsgJ1xceDAwJywgX3JlZjEpID49IDApKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKlxuICAgIEJMT0NLLUVOVFJZOiAnLScgKCcgJ3wnXFxuJylcbiAgICAqL1xuXG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5jaGVja19ibG9ja19lbnRyeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIF9yZWYxO1xuICAgICAgcmV0dXJuIF9yZWYxID0gdGhpcy5wZWVrKDEpLCBfX2luZGV4T2YuY2FsbChDX0xCICsgQ19XUyArICdcXHgwMCcsIF9yZWYxKSA+PSAwO1xuICAgIH07XG5cbiAgICAvKlxuICAgIEtFWSAoZmxvdyBjb250ZXh0KTogICc/J1xuICAgIEtFWSAoYmxvY2sgY29udGV4dCk6ICc/JyAoJyAnfCdcXG4nKVxuICAgICovXG5cblxuICAgIFNjYW5uZXIucHJvdG90eXBlLmNoZWNrX2tleSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIF9yZWYxO1xuICAgICAgaWYgKHRoaXMuZmxvd19sZXZlbCAhPT0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVmMSA9IHRoaXMucGVlaygxKSwgX19pbmRleE9mLmNhbGwoQ19MQiArIENfV1MgKyAnXFx4MDAnLCBfcmVmMSkgPj0gMDtcbiAgICB9O1xuXG4gICAgLypcbiAgICBWQUxVRSAoZmxvdyBjb250ZXh0KTogICc6J1xuICAgIFZBTFVFIChibG9jayBjb250ZXh0KTogJzonICgnICd8J1xcbicpXG4gICAgKi9cblxuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuY2hlY2tfdmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfcmVmMTtcbiAgICAgIGlmICh0aGlzLmZsb3dfbGV2ZWwgIT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3JlZjEgPSB0aGlzLnBlZWsoMSksIF9faW5kZXhPZi5jYWxsKENfTEIgKyBDX1dTICsgJ1xceDAwJywgX3JlZjEpID49IDA7XG4gICAgfTtcblxuICAgIC8qXG4gICAgQSBwbGFpbiBzY2FsYXIgbWF5IHN0YXJ0IHdpdGggYW55IG5vbi1zcGFjZSBjaGFyYWN0ZXIgZXhjZXB0OlxuICAgICAgJy0nLCAnPycsICc6JywgJywnLCAnWycsICddJywgJ3snLCAnfScsXG4gICAgICAnIycsICcmJywgJyonLCAnIScsICd8JywgJz4nLCAnXFwnJywgJ1wiJyxcbiAgICAgICclJywgJ0AnLCAnYCcuXG4gICAgXG4gICAgSXQgbWF5IGFsc28gc3RhcnQgd2l0aFxuICAgICAgJy0nLCAnPycsICc6J1xuICAgIGlmIGl0IGlzIGZvbGxvd2VkIGJ5IGEgbm9uLXNwYWNlIGNoYXJhY3Rlci5cbiAgICBcbiAgICBOb3RlIHRoYXQgd2UgbGltaXQgdGhlIGxhc3QgcnVsZSB0byB0aGUgYmxvY2sgY29udGV4dCAoZXhjZXB0IHRoZSAnLSdcbiAgICBjaGFyYWN0ZXIpIGJlY2F1c2Ugd2Ugd2FudCB0aGUgZmxvdyBjb250ZXh0IHRvIGJlIHNwYWNlIGluZGVwZW5kZW50LlxuICAgICovXG5cblxuICAgIFNjYW5uZXIucHJvdG90eXBlLmNoZWNrX3BsYWluID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY2hhciwgX3JlZjE7XG4gICAgICBjaGFyID0gdGhpcy5wZWVrKCk7XG4gICAgICByZXR1cm4gX19pbmRleE9mLmNhbGwoQ19MQiArIENfV1MgKyAnXFx4MDAtPzosW117fSMmKiF8PlxcJ1wiJUBgJywgY2hhcikgPCAwIHx8ICgoX3JlZjEgPSB0aGlzLnBlZWsoMSksIF9faW5kZXhPZi5jYWxsKENfTEIgKyBDX1dTICsgJ1xceDAwJywgX3JlZjEpIDwgMCkgJiYgKGNoYXIgPT09ICctJyB8fCAodGhpcy5mbG93X2xldmVsID09PSAwICYmIF9faW5kZXhPZi5jYWxsKCc/OicsIGNoYXIpID49IDApKSk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgV2UgaWdub3JlIHNwYWNlcywgbGluZSBicmVha3MgYW5kIGNvbW1lbnRzLlxuICAgIElmIHdlIGZpbmQgYSBsaW5lIGJyZWFrIGluIHRoZSBibG9jayBjb250ZXh0LCB3ZSBzZXQgdGhlIGZsYWdcbiAgICBgYWxsb3dfc2ltcGxlX2tleWAgb24uXG4gICAgVGhlIGJ5dGUgb3JkZXIgbWFyayBpcyBzdHJpcHBlZCBpZiBpdCdzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gdGhlIHN0cmVhbS5cbiAgICBXZSBkbyBub3QgeWV0IHN1cHBvcnQgQk9NIGluc2lkZSB0aGUgc3RyZWFtIGFzIHRoZSBzcGVjaWZpY2F0aW9uIHJlcXVpcmVzLlxuICAgIEFueSBzdWNoIG1hcmsgd2lsbCBiZSBjb25zaWRlcmVkIGFzIGEgcGFydCBvZiB0aGUgZG9jdW1lbnQuXG4gICAgXG4gICAgVE9ETzogV2UgbmVlZCB0byBtYWtlIHRhYiBoYW5kbGluZyBydWxlcyBtb3JlIHNhbmUuICBBIGdvb2QgcnVsZSBpc1xuICAgICAgVGFicyBjYW5ub3QgcHJlY2VkZSB0b2tlbnMgQkxPQ0stU0VRVUVOQ0UtU1RBUlQsIEJMT0NLLU1BUFBJTkctU1RBUlQsXG4gICAgICBCTE9DSy1FTkQsIEtFWSAoYmxvY2sgY29udGV4dCksIFZBTFVFIChibG9jayBjb250ZXh0KSwgQkxPQ0stRU5UUllcbiAgICBTbyB0aGUgdGFiIGNoZWNraW5nIGNvZGUgaXNcbiAgICAgIEBhbGxvd19zaW1wbGVfa2V5ID0gb2ZmIGlmIDxUQUI+XG4gICAgV2UgYWxzbyBuZWVkIHRvIGFkZCB0aGUgY2hlY2sgZm9yIGBhbGxvd19zaW1wbGVfa2V5IGlzIG9uYCB0b1xuICAgIGB1bndpbmRfaW5kZW50YCBiZWZvcmUgaXNzdWluZyBCTE9DSy1FTkQuICBTY2FubmVycyBmb3IgYmxvY2ssIGZsb3cgYW5kXG4gICAgcGxhaW4gc2NhbGFycyBuZWVkIHRvIGJlIG1vZGlmaWVkLlxuICAgICovXG5cblxuICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5fdG9fbmV4dF90b2tlbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNvbW1lbnQsIGZvdW5kLCB0cmltbWVkQ29tbWVudCwgX3JlZjEsIF9yZXN1bHRzO1xuICAgICAgaWYgKHRoaXMuaW5kZXggPT09IDAgJiYgdGhpcy5wZWVrKCkgPT09ICdcXHVGRUZGJykge1xuICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgIH1cbiAgICAgIGZvdW5kID0gZmFsc2U7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgd2hpbGUgKCFmb3VuZCkge1xuICAgICAgICB3aGlsZSAodGhpcy5wZWVrKCkgPT09ICcgJykge1xuICAgICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbW1lbnQgPSAnJztcbiAgICAgICAgaWYgKHRoaXMucGVlaygpID09PSAnIycpIHtcbiAgICAgICAgICB3aGlsZSAoX3JlZjEgPSB0aGlzLnBlZWsoKSwgX19pbmRleE9mLmNhbGwoQ19MQiArICdcXHgwMCcsIF9yZWYxKSA8IDApIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5yYW1sSGVhZGVyRm91bmQpIHtcbiAgICAgICAgICAgICAgY29tbWVudCArPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMucmFtbEhlYWRlckZvdW5kKSB7XG4gICAgICAgICAgdHJpbW1lZENvbW1lbnQgPSBjb21tZW50LnRyaW0oKTtcbiAgICAgICAgICBpZiAodHJpbW1lZENvbW1lbnQgJiYgUkFNTF9WRVJTSU9OX1JFLnRlc3QodHJpbW1lZENvbW1lbnQpKSB7XG4gICAgICAgICAgICBpZiAodHJpbW1lZENvbW1lbnQgPT09IFJBTUxfVkVSU0lPTikge1xuICAgICAgICAgICAgICB0aGlzLnJhbWxIZWFkZXJGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5TY2FubmVyRXJyb3IoJ3ZlcnNpb24gdmFsaWRhdGlvbicsIG51bGwsIFwiVW5zdXBwb3J0ZWQgUkFNTCB2ZXJzaW9uOiAnXCIgKyBjb21tZW50ICsgXCInXCIsIHRoaXMuY3JlYXRlX21hcmsoMCwgMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5TY2FubmVyRXJyb3IoJ3ZlcnNpb24gdmFsaWRhdGlvbicsIG51bGwsIFwiVGhlIGZpcnN0IGxpbmUgbXVzdCBiZTogJ1wiICsgUkFNTF9WRVJTSU9OICsgXCInXCIsIHRoaXMuY3JlYXRlX21hcmsoMCwgMCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zY2FuX2xpbmVfYnJlYWsoKSkge1xuICAgICAgICAgIGlmICh0aGlzLmZsb3dfbGV2ZWwgPT09IDApIHtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2godGhpcy5hbGxvd19zaW1wbGVfa2V5ID0gdHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2godm9pZCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaChmb3VuZCA9IHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfTtcblxuICAgIC8qXG4gICAgU2VlIHRoZSBzcGVjaWZpY2F0aW9uIGZvciBkZXRhaWxzLlxuICAgICovXG5cblxuICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5fZGlyZWN0aXZlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZW5kX21hcmssIG5hbWUsIHN0YXJ0X21hcmssIHZhbHVlLCBfcmVmMTtcbiAgICAgIHN0YXJ0X21hcmsgPSB0aGlzLmdldF9tYXJrKCk7XG4gICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgIG5hbWUgPSB0aGlzLnNjYW5fZGlyZWN0aXZlX25hbWUoc3RhcnRfbWFyayk7XG4gICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICBpZiAobmFtZSA9PT0gJ1lBTUwnKSB7XG4gICAgICAgIHZhbHVlID0gdGhpcy5zY2FuX3lhbWxfZGlyZWN0aXZlX3ZhbHVlKHN0YXJ0X21hcmspO1xuICAgICAgICBlbmRfbWFyayA9IHRoaXMuZ2V0X21hcmsoKTtcbiAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ1RBRycpIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzLnNjYW5fdGFnX2RpcmVjdGl2ZV92YWx1ZShzdGFydF9tYXJrKTtcbiAgICAgICAgZW5kX21hcmsgPSB0aGlzLmdldF9tYXJrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmRfbWFyayA9IHRoaXMuZ2V0X21hcmsoKTtcbiAgICAgICAgd2hpbGUgKF9yZWYxID0gdGhpcy5wZWVrKCksIF9faW5kZXhPZi5jYWxsKENfTEIgKyAnXFx4MDAnLCBfcmVmMSkgPCAwKSB7XG4gICAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuc2Nhbl9kaXJlY3RpdmVfaWdub3JlZF9saW5lKHN0YXJ0X21hcmspO1xuICAgICAgcmV0dXJuIG5ldyB0b2tlbnMuRGlyZWN0aXZlVG9rZW4obmFtZSwgdmFsdWUsIHN0YXJ0X21hcmssIGVuZF9tYXJrKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBTZWUgdGhlIHNwZWNpZmljYXRpb24gZm9yIGRldGFpbHMuXG4gICAgKi9cblxuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuc2Nhbl9kaXJlY3RpdmVfbmFtZSA9IGZ1bmN0aW9uKHN0YXJ0X21hcmspIHtcbiAgICAgIHZhciBjaGFyLCBsZW5ndGgsIHZhbHVlO1xuICAgICAgbGVuZ3RoID0gMDtcbiAgICAgIGNoYXIgPSB0aGlzLnBlZWsobGVuZ3RoKTtcbiAgICAgIHdoaWxlICgoJzAnIDw9IGNoYXIgJiYgY2hhciA8PSAnOScpIHx8ICgnQScgPD0gY2hhciAmJiBjaGFyIDw9ICdaJykgfHwgKCdhJyA8PSBjaGFyICYmIGNoYXIgPD0gJ3onKSB8fCBfX2luZGV4T2YuY2FsbCgnLV8nLCBjaGFyKSA+PSAwKSB7XG4gICAgICAgIGxlbmd0aCsrO1xuICAgICAgICBjaGFyID0gdGhpcy5wZWVrKGxlbmd0aCk7XG4gICAgICB9XG4gICAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlNjYW5uZXJFcnJvcignd2hpbGUgc2Nhbm5pbmcgYSBkaXJlY3RpdmUnLCBzdGFydF9tYXJrLCBcImV4cGVjdGVkIGFscGhhbnVtZXJpYyBvciBudW1lcmljIGNoYXJhY3RlciBidXQgZm91bmQgXCIgKyBjaGFyLCB0aGlzLmdldF9tYXJrKCkpO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSB0aGlzLnByZWZpeChsZW5ndGgpO1xuICAgICAgdGhpcy5mb3J3YXJkKGxlbmd0aCk7XG4gICAgICBjaGFyID0gdGhpcy5wZWVrKCk7XG4gICAgICBpZiAoX19pbmRleE9mLmNhbGwoQ19MQiArICdcXHgwMCAnLCBjaGFyKSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuU2Nhbm5lckVycm9yKCd3aGlsZSBzY2FubmluZyBhIGRpcmVjdGl2ZScsIHN0YXJ0X21hcmssIFwiZXhwZWN0ZWQgYWxwaGFudW1lcmljIG9yIG51bWVyaWMgY2hhcmFjdGVyIGJ1dCBmb3VuZCBcIiArIGNoYXIsIHRoaXMuZ2V0X21hcmsoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcblxuICAgIC8qXG4gICAgU2VlIHRoZSBzcGVjaWZpY2F0aW9uIGZvciBkZXRhaWxzLlxuICAgICovXG5cblxuICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5feWFtbF9kaXJlY3RpdmVfdmFsdWUgPSBmdW5jdGlvbihzdGFydF9tYXJrKSB7XG4gICAgICB2YXIgbWFqb3IsIG1pbm9yLCBfcmVmMTtcbiAgICAgIHdoaWxlICh0aGlzLnBlZWsoKSA9PT0gJyAnKSB7XG4gICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgfVxuICAgICAgbWFqb3IgPSB0aGlzLnNjYW5feWFtbF9kaXJlY3RpdmVfbnVtYmVyKHN0YXJ0X21hcmspO1xuICAgICAgaWYgKHRoaXMucGVlaygpICE9PSAnLicpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuU2Nhbm5lckVycm9yKCd3aGlsZSBzY2FubmluZyBhIGRpcmVjdGl2ZScsIHN0YXJ0X21hcmssIFwiZXhwZWN0ZWQgYSBkaWdpdCBvciAnLicgYnV0IGZvdW5kIFwiICsgKHRoaXMucGVlaygpKSwgdGhpcy5nZXRfbWFyaygpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgbWlub3IgPSB0aGlzLnNjYW5feWFtbF9kaXJlY3RpdmVfbnVtYmVyKHN0YXJ0X21hcmspO1xuICAgICAgaWYgKF9yZWYxID0gdGhpcy5wZWVrKCksIF9faW5kZXhPZi5jYWxsKENfTEIgKyAnXFx4MDAgJywgX3JlZjEpIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5TY2FubmVyRXJyb3IoJ3doaWxlIHNjYW5uaW5nIGEgZGlyZWN0aXZlJywgc3RhcnRfbWFyaywgXCJleHBlY3RlZCBhIGRpZ2l0IG9yICcgJyBidXQgZm91bmQgXCIgKyAodGhpcy5wZWVrKCkpLCB0aGlzLmdldF9tYXJrKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFttYWpvciwgbWlub3JdO1xuICAgIH07XG5cbiAgICAvKlxuICAgIFNlZSB0aGUgc3BlY2lmaWNhdGlvbiBmb3IgZGV0YWlscy5cbiAgICAqL1xuXG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuX3lhbWxfZGlyZWN0aXZlX251bWJlciA9IGZ1bmN0aW9uKHN0YXJ0X21hcmspIHtcbiAgICAgIHZhciBjaGFyLCBsZW5ndGgsIHZhbHVlLCBfcmVmMTtcbiAgICAgIGNoYXIgPSB0aGlzLnBlZWsoKTtcbiAgICAgIGlmICghKCgnMCcgPD0gY2hhciAmJiBjaGFyIDw9ICc5JykpKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlNjYW5uZXJFcnJvcignd2hpbGUgc2Nhbm5pbmcgYSBkaXJlY3RpdmUnLCBzdGFydF9tYXJrLCBcImV4cGVjdGVkIGEgZGlnaXQgYnV0IGZvdW5kIFwiICsgY2hhciwgdGhpcy5nZXRfbWFyaygpKTtcbiAgICAgIH1cbiAgICAgIGxlbmd0aCA9IDA7XG4gICAgICB3aGlsZSAoKCcwJyA8PSAoX3JlZjEgPSB0aGlzLnBlZWsobGVuZ3RoKSkgJiYgX3JlZjEgPD0gJzknKSkge1xuICAgICAgICBsZW5ndGgrKztcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gcGFyc2VJbnQodGhpcy5wcmVmaXgobGVuZ3RoKSk7XG4gICAgICB0aGlzLmZvcndhcmQobGVuZ3RoKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBTZWUgdGhlIHNwZWNpZmljYXRpb24gZm9yIGRldGFpbHMuXG4gICAgKi9cblxuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuc2Nhbl90YWdfZGlyZWN0aXZlX3ZhbHVlID0gZnVuY3Rpb24oc3RhcnRfbWFyaykge1xuICAgICAgdmFyIGhhbmRsZSwgcHJlZml4O1xuICAgICAgd2hpbGUgKHRoaXMucGVlaygpID09PSAnICcpIHtcbiAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICB9XG4gICAgICBoYW5kbGUgPSB0aGlzLnNjYW5fdGFnX2RpcmVjdGl2ZV9oYW5kbGUoc3RhcnRfbWFyayk7XG4gICAgICB3aGlsZSAodGhpcy5wZWVrKCkgPT09ICcgJykge1xuICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgIH1cbiAgICAgIHByZWZpeCA9IHRoaXMuc2Nhbl90YWdfZGlyZWN0aXZlX3ByZWZpeChzdGFydF9tYXJrKTtcbiAgICAgIHJldHVybiBbaGFuZGxlLCBwcmVmaXhdO1xuICAgIH07XG5cbiAgICAvKlxuICAgIFNlZSB0aGUgc3BlY2lmaWNhdGlvbiBmb3IgZGV0YWlscy5cbiAgICAqL1xuXG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuX3RhZ19kaXJlY3RpdmVfaGFuZGxlID0gZnVuY3Rpb24oc3RhcnRfbWFyaykge1xuICAgICAgdmFyIGNoYXIsIHZhbHVlO1xuICAgICAgdmFsdWUgPSB0aGlzLnNjYW5fdGFnX2hhbmRsZSgnZGlyZWN0aXZlJywgc3RhcnRfbWFyayk7XG4gICAgICBjaGFyID0gdGhpcy5wZWVrKCk7XG4gICAgICBpZiAoY2hhciAhPT0gJyAnKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlNjYW5uZXJFcnJvcignd2hpbGUgc2Nhbm5pbmcgYSBkaXJlY3RpdmUnLCBzdGFydF9tYXJrLCBcImV4cGVjdGVkICcgJyBidXQgZm91bmQgXCIgKyBjaGFyLCB0aGlzLmdldF9tYXJrKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG5cbiAgICAvKlxuICAgIFNlZSB0aGUgc3BlY2lmaWNhdGlvbiBmb3IgZGV0YWlscy5cbiAgICAqL1xuXG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuX3RhZ19kaXJlY3RpdmVfcHJlZml4ID0gZnVuY3Rpb24oc3RhcnRfbWFyaykge1xuICAgICAgdmFyIGNoYXIsIHZhbHVlO1xuICAgICAgdmFsdWUgPSB0aGlzLnNjYW5fdGFnX3VyaSgnZGlyZWN0aXZlJywgc3RhcnRfbWFyayk7XG4gICAgICBjaGFyID0gdGhpcy5wZWVrKCk7XG4gICAgICBpZiAoX19pbmRleE9mLmNhbGwoQ19MQiArICdcXHgwMCAnLCBjaGFyKSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuU2Nhbm5lckVycm9yKCd3aGlsZSBzY2FubmluZyBhIGRpcmVjdGl2ZScsIHN0YXJ0X21hcmssIFwiZXhwZWN0ZWQgJyAnIGJ1dCBmb3VuZCBcIiArIGNoYXIsIHRoaXMuZ2V0X21hcmsoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcblxuICAgIC8qXG4gICAgU2VlIHRoZSBzcGVjaWZpY2F0aW9uIGZvciBkZXRhaWxzLlxuICAgICovXG5cblxuICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5fZGlyZWN0aXZlX2lnbm9yZWRfbGluZSA9IGZ1bmN0aW9uKHN0YXJ0X21hcmspIHtcbiAgICAgIHZhciBjaGFyLCBfcmVmMTtcbiAgICAgIHdoaWxlICh0aGlzLnBlZWsoKSA9PT0gJyAnKSB7XG4gICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucGVlaygpID09PSAnIycpIHtcbiAgICAgICAgd2hpbGUgKF9yZWYxID0gdGhpcy5wZWVrKCksIF9faW5kZXhPZi5jYWxsKENfTEIgKyAnXFx4MDAnLCBfcmVmMSkgPCAwKSB7XG4gICAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNoYXIgPSB0aGlzLnBlZWsoKTtcbiAgICAgIGlmIChfX2luZGV4T2YuY2FsbChDX0xCICsgJ1xceDAwJywgY2hhcikgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlNjYW5uZXJFcnJvcignd2hpbGUgc2Nhbm5pbmcgYSBkaXJlY3RpdmUnLCBzdGFydF9tYXJrLCBcImV4cGVjdGVkIGEgY29tbWVudCBvciBhIGxpbmUgYnJlYWsgYnV0IGZvdW5kIFwiICsgY2hhciwgdGhpcy5nZXRfbWFyaygpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnNjYW5fbGluZV9icmVhaygpO1xuICAgIH07XG5cbiAgICAvKlxuICAgIFRoZSBzcGVjaWZpY2F0aW9uIGRvZXMgbm90IHJlc3RyaWN0IGNoYXJhY3RlcnMgZm9yIGFuY2hvcnMgYW5kIGFsaWFzZXMuXG4gICAgVGhpcyBtYXkgbGVhZCB0byBwcm9ibGVtcywgZm9yIGluc3RhbmNlLCB0aGUgZG9jdW1lbnQ6XG4gICAgICBbICphbGlhcywgdmFsdWUgXVxuICAgIGNhbiBiZSBpbnRlcnB0ZXRlZCBpbiB0d28gd2F5cywgYXNcbiAgICAgIFsgXCJ2YWx1ZVwiIF1cbiAgICBhbmRcbiAgICAgIFsgKmFsaWFzICwgXCJ2YWx1ZVwiIF1cbiAgICBUaGVyZWZvcmUgd2UgcmVzdHJpY3QgYWxpYXNlcyB0byBudW1iZXJzIGFuZCBBU0NJSSBsZXR0ZXJzLlxuICAgICovXG5cblxuICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5fYW5jaG9yID0gZnVuY3Rpb24oVG9rZW5DbGFzcykge1xuICAgICAgdmFyIGNoYXIsIGluZGljYXRvciwgbGVuZ3RoLCBuYW1lLCBzdGFydF9tYXJrLCB2YWx1ZTtcbiAgICAgIHN0YXJ0X21hcmsgPSB0aGlzLmdldF9tYXJrKCk7XG4gICAgICBpbmRpY2F0b3IgPSB0aGlzLnBlZWsoKTtcbiAgICAgIGlmIChpbmRpY2F0b3IgPT09ICcqJykge1xuICAgICAgICBuYW1lID0gJ2FsaWFzJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5hbWUgPSAnYW5jaG9yJztcbiAgICAgIH1cbiAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgbGVuZ3RoID0gMDtcbiAgICAgIGNoYXIgPSB0aGlzLnBlZWsobGVuZ3RoKTtcbiAgICAgIHdoaWxlICgoJzAnIDw9IGNoYXIgJiYgY2hhciA8PSAnOScpIHx8ICgnQScgPD0gY2hhciAmJiBjaGFyIDw9ICdaJykgfHwgKCdhJyA8PSBjaGFyICYmIGNoYXIgPD0gJ3onKSB8fCBfX2luZGV4T2YuY2FsbCgnLV8nLCBjaGFyKSA+PSAwKSB7XG4gICAgICAgIGxlbmd0aCsrO1xuICAgICAgICBjaGFyID0gdGhpcy5wZWVrKGxlbmd0aCk7XG4gICAgICB9XG4gICAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlNjYW5uZXJFcnJvcihcIndoaWxlIHNjYW5uaW5nIGFuIFwiICsgbmFtZSwgc3RhcnRfbWFyaywgXCJleHBlY3RlZCBhbHBoYWJldGljIG9yIG51bWVyaWMgY2hhcmFjdGVyIGJ1dCBmb3VuZCAnXCIgKyBjaGFyICsgXCInXCIsIHRoaXMuZ2V0X21hcmsoKSk7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IHRoaXMucHJlZml4KGxlbmd0aCk7XG4gICAgICB0aGlzLmZvcndhcmQobGVuZ3RoKTtcbiAgICAgIGNoYXIgPSB0aGlzLnBlZWsoKTtcbiAgICAgIGlmIChfX2luZGV4T2YuY2FsbChDX0xCICsgQ19XUyArICdcXHgwMCcgKyAnPzosXX0lQGAnLCBjaGFyKSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuU2Nhbm5lckVycm9yKFwid2hpbGUgc2Nhbm5pbmcgYW4gXCIgKyBuYW1lLCBzdGFydF9tYXJrLCBcImV4cGVjdGVkIGFscGhhYmV0aWMgb3IgbnVtZXJpYyBjaGFyYWN0ZXIgYnV0IGZvdW5kICdcIiArIGNoYXIgKyBcIidcIiwgdGhpcy5nZXRfbWFyaygpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgVG9rZW5DbGFzcyh2YWx1ZSwgc3RhcnRfbWFyaywgdGhpcy5nZXRfbWFyaygpKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBTZWUgdGhlIHNwZWNpZmljYXRpb24gZm9yIGRldGFpbHMuXG4gICAgKi9cblxuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuc2Nhbl90YWcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjaGFyLCBoYW5kbGUsIGxlbmd0aCwgc3RhcnRfbWFyaywgc3VmZml4LCB1c2VfaGFuZGxlO1xuICAgICAgc3RhcnRfbWFyayA9IHRoaXMuZ2V0X21hcmsoKTtcbiAgICAgIGNoYXIgPSB0aGlzLnBlZWsoMSk7XG4gICAgICBpZiAoY2hhciA9PT0gJzwnKSB7XG4gICAgICAgIGhhbmRsZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZm9yd2FyZCgyKTtcbiAgICAgICAgc3VmZml4ID0gdGhpcy5zY2FuX3RhZ191cmkoJ3RhZycsIHN0YXJ0X21hcmspO1xuICAgICAgICBpZiAodGhpcy5wZWVrKCkgIT09ICc+Jykge1xuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlNjYW5uZXJFcnJvcignd2hpbGUgcGFyc2luZyBhIHRhZycsIHN0YXJ0X21hcmssIFwiZXhwZWN0ZWQgJz4nIGJ1dCBmb3VuZCBcIiArICh0aGlzLnBlZWsoKSksIHRoaXMuZ2V0X21hcmsoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICB9IGVsc2UgaWYgKF9faW5kZXhPZi5jYWxsKENfTEIgKyBDX1dTICsgJ1xceDAwJywgY2hhcikgPj0gMCkge1xuICAgICAgICBoYW5kbGUgPSBudWxsO1xuICAgICAgICBzdWZmaXggPSAnISc7XG4gICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVuZ3RoID0gMTtcbiAgICAgICAgdXNlX2hhbmRsZSA9IGZhbHNlO1xuICAgICAgICB3aGlsZSAoX19pbmRleE9mLmNhbGwoQ19MQiArICdcXHgwMCAnLCBjaGFyKSA8IDApIHtcbiAgICAgICAgICBpZiAoY2hhciA9PT0gJyEnKSB7XG4gICAgICAgICAgICB1c2VfaGFuZGxlID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZW5ndGgrKztcbiAgICAgICAgICBjaGFyID0gdGhpcy5wZWVrKGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVzZV9oYW5kbGUpIHtcbiAgICAgICAgICBoYW5kbGUgPSB0aGlzLnNjYW5fdGFnX2hhbmRsZSgndGFnJywgc3RhcnRfbWFyayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGFuZGxlID0gJyEnO1xuICAgICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgICB9XG4gICAgICAgIHN1ZmZpeCA9IHRoaXMuc2Nhbl90YWdfdXJpKCd0YWcnLCBzdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIGNoYXIgPSB0aGlzLnBlZWsoKTtcbiAgICAgIGlmIChfX2luZGV4T2YuY2FsbChDX0xCICsgJ1xceDAwICcsIGNoYXIpIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5TY2FubmVyRXJyb3IoJ3doaWxlIHNjYW5uaW5nIGEgdGFnJywgc3RhcnRfbWFyaywgXCJleHBlY3RlZCAnICcgYnV0IGZvdW5kIFwiICsgY2hhciwgdGhpcy5nZXRfbWFyaygpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgdG9rZW5zLlRhZ1Rva2VuKFtoYW5kbGUsIHN1ZmZpeF0sIHN0YXJ0X21hcmssIHRoaXMuZ2V0X21hcmsoKSk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgU2VlIHRoZSBzcGVjaWZpY2F0aW9uIGZvciBkZXRhaWxzLlxuICAgICovXG5cblxuICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5fYmxvY2tfc2NhbGFyID0gZnVuY3Rpb24oc3R5bGUpIHtcbiAgICAgIHZhciBicmVha3MsIGNob21waW5nLCBjaHVua3MsIGVuZF9tYXJrLCBmb2xkZWQsIGluY3JlbWVudCwgaW5kZW50LCBsZWFkaW5nX25vbl9zcGFjZSwgbGVuZ3RoLCBsaW5lX2JyZWFrLCBtYXhfaW5kZW50LCBtaW5faW5kZW50LCBzdGFydF9tYXJrLCBfcmVmMSwgX3JlZjIsIF9yZWYzLCBfcmVmNCwgX3JlZjUsIF9yZWY2LCBfcmVmNztcbiAgICAgIGZvbGRlZCA9IHN0eWxlID09PSAnPic7XG4gICAgICBjaHVua3MgPSBbXTtcbiAgICAgIHN0YXJ0X21hcmsgPSB0aGlzLmdldF9tYXJrKCk7XG4gICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgIF9yZWYxID0gdGhpcy5zY2FuX2Jsb2NrX3NjYWxhcl9pbmRpY2F0b3JzKHN0YXJ0X21hcmspLCBjaG9tcGluZyA9IF9yZWYxWzBdLCBpbmNyZW1lbnQgPSBfcmVmMVsxXTtcbiAgICAgIHRoaXMuc2Nhbl9ibG9ja19zY2FsYXJfaWdub3JlZF9saW5lKHN0YXJ0X21hcmspO1xuICAgICAgbWluX2luZGVudCA9IHRoaXMuaW5kZW50ICsgMTtcbiAgICAgIGlmIChtaW5faW5kZW50IDwgMSkge1xuICAgICAgICBtaW5faW5kZW50ID0gMTtcbiAgICAgIH1cbiAgICAgIGlmIChpbmNyZW1lbnQgPT0gbnVsbCkge1xuICAgICAgICBfcmVmMiA9IHRoaXMuc2Nhbl9ibG9ja19zY2FsYXJfaW5kZW50YXRpb24oKSwgYnJlYWtzID0gX3JlZjJbMF0sIG1heF9pbmRlbnQgPSBfcmVmMlsxXSwgZW5kX21hcmsgPSBfcmVmMlsyXTtcbiAgICAgICAgaW5kZW50ID0gTWF0aC5tYXgobWluX2luZGVudCwgbWF4X2luZGVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmRlbnQgPSBtaW5faW5kZW50ICsgaW5jcmVtZW50IC0gMTtcbiAgICAgICAgX3JlZjMgPSB0aGlzLnNjYW5fYmxvY2tfc2NhbGFyX2JyZWFrcyhpbmRlbnQpLCBicmVha3MgPSBfcmVmM1swXSwgZW5kX21hcmsgPSBfcmVmM1sxXTtcbiAgICAgIH1cbiAgICAgIGxpbmVfYnJlYWsgPSAnJztcbiAgICAgIHdoaWxlICh0aGlzLmNvbHVtbiA9PT0gaW5kZW50ICYmIHRoaXMucGVlaygpICE9PSAnXFx4MDAnKSB7XG4gICAgICAgIGNodW5rcyA9IGNodW5rcy5jb25jYXQoYnJlYWtzKTtcbiAgICAgICAgbGVhZGluZ19ub25fc3BhY2UgPSAoX3JlZjQgPSB0aGlzLnBlZWsoKSwgX19pbmRleE9mLmNhbGwoJyBcXHQnLCBfcmVmNCkgPCAwKTtcbiAgICAgICAgbGVuZ3RoID0gMDtcbiAgICAgICAgd2hpbGUgKF9yZWY1ID0gdGhpcy5wZWVrKGxlbmd0aCksIF9faW5kZXhPZi5jYWxsKENfTEIgKyAnXFx4MDAnLCBfcmVmNSkgPCAwKSB7XG4gICAgICAgICAgbGVuZ3RoKys7XG4gICAgICAgIH1cbiAgICAgICAgY2h1bmtzLnB1c2godGhpcy5wcmVmaXgobGVuZ3RoKSk7XG4gICAgICAgIHRoaXMuZm9yd2FyZChsZW5ndGgpO1xuICAgICAgICBsaW5lX2JyZWFrID0gdGhpcy5zY2FuX2xpbmVfYnJlYWsoKTtcbiAgICAgICAgX3JlZjYgPSB0aGlzLnNjYW5fYmxvY2tfc2NhbGFyX2JyZWFrcyhpbmRlbnQpLCBicmVha3MgPSBfcmVmNlswXSwgZW5kX21hcmsgPSBfcmVmNlsxXTtcbiAgICAgICAgaWYgKHRoaXMuY29sdW1uID09PSBpbmRlbnQgJiYgdGhpcy5wZWVrKCkgIT09ICdcXHgwMCcpIHtcbiAgICAgICAgICBpZiAoZm9sZGVkICYmIGxpbmVfYnJlYWsgPT09ICdcXG4nICYmIGxlYWRpbmdfbm9uX3NwYWNlICYmIChfcmVmNyA9IHRoaXMucGVlaygpLCBfX2luZGV4T2YuY2FsbCgnIFxcdCcsIF9yZWY3KSA8IDApKSB7XG4gICAgICAgICAgICBpZiAodXRpbC5pc19lbXB0eShicmVha3MpKSB7XG4gICAgICAgICAgICAgIGNodW5rcy5wdXNoKCcgJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNodW5rcy5wdXNoKGxpbmVfYnJlYWspO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNob21waW5nICE9PSBmYWxzZSkge1xuICAgICAgICBjaHVua3MucHVzaChsaW5lX2JyZWFrKTtcbiAgICAgIH1cbiAgICAgIGlmIChjaG9tcGluZyA9PT0gdHJ1ZSkge1xuICAgICAgICBjaHVua3MgPSBjaHVua3MuY29uY2F0KGJyZWFrcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IHRva2Vucy5TY2FsYXJUb2tlbihjaHVua3Muam9pbignJyksIGZhbHNlLCBzdGFydF9tYXJrLCBlbmRfbWFyaywgc3R5bGUpO1xuICAgIH07XG5cbiAgICAvKlxuICAgIFNlZSB0aGUgc3BlY2lmaWNhdGlvbiBmb3IgZGV0YWlscy5cbiAgICAqL1xuXG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuX2Jsb2NrX3NjYWxhcl9pbmRpY2F0b3JzID0gZnVuY3Rpb24oc3RhcnRfbWFyaykge1xuICAgICAgdmFyIGNoYXIsIGNob21waW5nLCBpbmNyZW1lbnQ7XG4gICAgICBjaG9tcGluZyA9IG51bGw7XG4gICAgICBpbmNyZW1lbnQgPSBudWxsO1xuICAgICAgY2hhciA9IHRoaXMucGVlaygpO1xuICAgICAgaWYgKF9faW5kZXhPZi5jYWxsKCcrLScsIGNoYXIpID49IDApIHtcbiAgICAgICAgY2hvbXBpbmcgPSBjaGFyID09PSAnKyc7XG4gICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgICBjaGFyID0gdGhpcy5wZWVrKCk7XG4gICAgICAgIGlmIChfX2luZGV4T2YuY2FsbChDX05VTUJFUlMsIGNoYXIpID49IDApIHtcbiAgICAgICAgICBpbmNyZW1lbnQgPSBwYXJzZUludChjaGFyKTtcbiAgICAgICAgICBpZiAoaW5jcmVtZW50ID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5TY2FubmVyRXJyb3IoJ3doaWxlIHNjYW5uaW5nIGEgYmxvY2sgc2NhbGFyJywgc3RhcnRfbWFyaywgJ2V4cGVjdGVkIGluZGVudGF0aW9uIGluZGljYXRvciBpbiB0aGUgcmFuZ2UgMS05IGJ1dCBmb3VuZCAwJywgdGhpcy5nZXRfbWFyaygpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoX19pbmRleE9mLmNhbGwoQ19OVU1CRVJTLCBjaGFyKSA+PSAwKSB7XG4gICAgICAgIGluY3JlbWVudCA9IHBhcnNlSW50KGNoYXIpO1xuICAgICAgICBpZiAoaW5jcmVtZW50ID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuU2Nhbm5lckVycm9yKCd3aGlsZSBzY2FubmluZyBhIGJsb2NrIHNjYWxhcicsIHN0YXJ0X21hcmssICdleHBlY3RlZCBpbmRlbnRhdGlvbiBpbmRpY2F0b3IgaW4gdGhlIHJhbmdlIDEtOSBidXQgZm91bmQgMCcsIHRoaXMuZ2V0X21hcmsoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgIGNoYXIgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgaWYgKF9faW5kZXhPZi5jYWxsKCcrLScsIGNoYXIpID49IDApIHtcbiAgICAgICAgICBjaG9tcGluZyA9IGNoYXIgPT09ICcrJztcbiAgICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hhciA9IHRoaXMucGVlaygpO1xuICAgICAgaWYgKF9faW5kZXhPZi5jYWxsKENfTEIgKyAnXFx4MDAgJywgY2hhcikgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlNjYW5uZXJFcnJvcignd2hpbGUgc2Nhbm5pbmcgYSBibG9jayBzY2FsYXInLCBzdGFydF9tYXJrLCBcImV4cGVjdGVkIGNob21waW5nIG9yIGluZGVudGF0aW9uIGluZGljYXRvcnMsIGJ1dCBmb3VuZCBcIiArIGNoYXIsIHRoaXMuZ2V0X21hcmsoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW2Nob21waW5nLCBpbmNyZW1lbnRdO1xuICAgIH07XG5cbiAgICAvKlxuICAgIFNlZSB0aGUgc3BlY2lmaWNhdGlvbiBmb3IgZGV0YWlscy5cbiAgICAqL1xuXG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuX2Jsb2NrX3NjYWxhcl9pZ25vcmVkX2xpbmUgPSBmdW5jdGlvbihzdGFydF9tYXJrKSB7XG4gICAgICB2YXIgY2hhciwgX3JlZjE7XG4gICAgICB3aGlsZSAodGhpcy5wZWVrKCkgPT09ICcgJykge1xuICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnBlZWsoKSA9PT0gJyMnKSB7XG4gICAgICAgIHdoaWxlIChfcmVmMSA9IHRoaXMucGVlaygpLCBfX2luZGV4T2YuY2FsbChDX0xCICsgJ1xceDAwJywgX3JlZjEpIDwgMCkge1xuICAgICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjaGFyID0gdGhpcy5wZWVrKCk7XG4gICAgICBpZiAoX19pbmRleE9mLmNhbGwoQ19MQiArICdcXHgwMCcsIGNoYXIpIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5TY2FubmVyRXJyb3IoJ3doaWxlIHNjYW5uaW5nIGEgYmxvY2sgc2NhbGFyJywgc3RhcnRfbWFyaywgXCJleHBlY3RlZCBhIGNvbW1lbnQgb3IgYSBsaW5lIGJyZWFrIGJ1dCBmb3VuZCBcIiArIGNoYXIsIHRoaXMuZ2V0X21hcmsoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5zY2FuX2xpbmVfYnJlYWsoKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBTZWUgdGhlIHNwZWNpZmljYXRpb24gZm9yIGRldGFpbHMuXG4gICAgKi9cblxuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuc2Nhbl9ibG9ja19zY2FsYXJfaW5kZW50YXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjaHVua3MsIGVuZF9tYXJrLCBtYXhfaW5kZW50LCBfcmVmMTtcbiAgICAgIGNodW5rcyA9IFtdO1xuICAgICAgbWF4X2luZGVudCA9IDA7XG4gICAgICBlbmRfbWFyayA9IHRoaXMuZ2V0X21hcmsoKTtcbiAgICAgIHdoaWxlIChfcmVmMSA9IHRoaXMucGVlaygpLCBfX2luZGV4T2YuY2FsbChDX0xCICsgJyAnLCBfcmVmMSkgPj0gMCkge1xuICAgICAgICBpZiAodGhpcy5wZWVrKCkgIT09ICcgJykge1xuICAgICAgICAgIGNodW5rcy5wdXNoKHRoaXMuc2Nhbl9saW5lX2JyZWFrKCkpO1xuICAgICAgICAgIGVuZF9tYXJrID0gdGhpcy5nZXRfbWFyaygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgICAgIGlmICh0aGlzLmNvbHVtbiA+IG1heF9pbmRlbnQpIHtcbiAgICAgICAgICAgIG1heF9pbmRlbnQgPSB0aGlzLmNvbHVtbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBbY2h1bmtzLCBtYXhfaW5kZW50LCBlbmRfbWFya107XG4gICAgfTtcblxuICAgIC8qXG4gICAgU2VlIHRoZSBzcGVjaWZpY2F0aW9uIGZvciBkZXRhaWxzLlxuICAgICovXG5cblxuICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5fYmxvY2tfc2NhbGFyX2JyZWFrcyA9IGZ1bmN0aW9uKGluZGVudCkge1xuICAgICAgdmFyIGNodW5rcywgZW5kX21hcmssIF9yZWYxO1xuICAgICAgY2h1bmtzID0gW107XG4gICAgICBlbmRfbWFyayA9IHRoaXMuZ2V0X21hcmsoKTtcbiAgICAgIHdoaWxlICh0aGlzLmNvbHVtbiA8IGluZGVudCAmJiB0aGlzLnBlZWsoKSA9PT0gJyAnKSB7XG4gICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgfVxuICAgICAgd2hpbGUgKF9yZWYxID0gdGhpcy5wZWVrKCksIF9faW5kZXhPZi5jYWxsKENfTEIsIF9yZWYxKSA+PSAwKSB7XG4gICAgICAgIGNodW5rcy5wdXNoKHRoaXMuc2Nhbl9saW5lX2JyZWFrKCkpO1xuICAgICAgICBlbmRfbWFyayA9IHRoaXMuZ2V0X21hcmsoKTtcbiAgICAgICAgd2hpbGUgKHRoaXMuY29sdW1uIDwgaW5kZW50ICYmIHRoaXMucGVlaygpID09PSAnICcpIHtcbiAgICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFtjaHVua3MsIGVuZF9tYXJrXTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBTZWUgdGhlIHNwZWNpZmljYXRpb24gZm9yIGRldGFpbHMuXG4gICAgTm90ZSB0aGF0IHdlIGxvb3NlIGluZGVudGF0aW9uIHJ1bGVzIGZvciBxdW90ZWQgc2NhbGFycy4gUXVvdGVkIHNjYWxhcnNcbiAgICBkb24ndCBuZWVkIHRvIGFkaGVyZSBpbmRlbnRhdGlvbiBiZWNhdXNlIFwiIGFuZCAnIGNsZWFybHkgbWFyayB0aGUgYmVnaW5uaW5nXG4gICAgYW5kIHRoZSBlbmQgb2YgdGhlbS4gVGhlcmVmb3JlIHdlIGFyZSBsZXNzIHJlc3RyaWN0aXZlIHRoYW4gdGhlXG4gICAgc3BlY2lmaWNhdGlvbiByZXF1aXJlcy4gV2Ugb25seSBuZWVkIHRvIGNoZWNrIHRoYXQgZG9jdW1lbnQgc2VwYXJhdG9ycyBhcmVcbiAgICBub3QgaW5jbHVkZWQgaW4gc2NhbGFycy5cbiAgICAqL1xuXG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuX2Zsb3dfc2NhbGFyID0gZnVuY3Rpb24oc3R5bGUpIHtcbiAgICAgIHZhciBjaHVua3MsIGRvdWJsZSwgcXVvdGUsIHN0YXJ0X21hcms7XG4gICAgICBkb3VibGUgPSBzdHlsZSA9PT0gJ1wiJztcbiAgICAgIGNodW5rcyA9IFtdO1xuICAgICAgc3RhcnRfbWFyayA9IHRoaXMuZ2V0X21hcmsoKTtcbiAgICAgIHF1b3RlID0gdGhpcy5wZWVrKCk7XG4gICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgIGNodW5rcyA9IGNodW5rcy5jb25jYXQodGhpcy5zY2FuX2Zsb3dfc2NhbGFyX25vbl9zcGFjZXMoZG91YmxlLCBzdGFydF9tYXJrKSk7XG4gICAgICB3aGlsZSAodGhpcy5wZWVrKCkgIT09IHF1b3RlKSB7XG4gICAgICAgIGNodW5rcyA9IGNodW5rcy5jb25jYXQodGhpcy5zY2FuX2Zsb3dfc2NhbGFyX3NwYWNlcyhkb3VibGUsIHN0YXJ0X21hcmspKTtcbiAgICAgICAgY2h1bmtzID0gY2h1bmtzLmNvbmNhdCh0aGlzLnNjYW5fZmxvd19zY2FsYXJfbm9uX3NwYWNlcyhkb3VibGUsIHN0YXJ0X21hcmspKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgcmV0dXJuIG5ldyB0b2tlbnMuU2NhbGFyVG9rZW4oY2h1bmtzLmpvaW4oJycpLCBmYWxzZSwgc3RhcnRfbWFyaywgdGhpcy5nZXRfbWFyaygpLCBzdHlsZSk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgU2VlIHRoZSBzcGVjaWZpY2F0aW9uIGZvciBkZXRhaWxzLlxuICAgICovXG5cblxuICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5fZmxvd19zY2FsYXJfbm9uX3NwYWNlcyA9IGZ1bmN0aW9uKGRvdWJsZSwgc3RhcnRfbWFyaykge1xuICAgICAgdmFyIGNoYXIsIGNodW5rcywgY29kZSwgaywgbGVuZ3RoLCBfaSwgX3JlZjEsIF9yZWYyO1xuICAgICAgY2h1bmtzID0gW107XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBsZW5ndGggPSAwO1xuICAgICAgICB3aGlsZSAoX3JlZjEgPSB0aGlzLnBlZWsobGVuZ3RoKSwgX19pbmRleE9mLmNhbGwoQ19MQiArIENfV1MgKyAnXFwnXCJcXFxcXFx4MDAnLCBfcmVmMSkgPCAwKSB7XG4gICAgICAgICAgbGVuZ3RoKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIGNodW5rcy5wdXNoKHRoaXMucHJlZml4KGxlbmd0aCkpO1xuICAgICAgICAgIHRoaXMuZm9yd2FyZChsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGNoYXIgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgaWYgKCFkb3VibGUgJiYgY2hhciA9PT0gJ1xcJycgJiYgdGhpcy5wZWVrKDEpID09PSAnXFwnJykge1xuICAgICAgICAgIGNodW5rcy5wdXNoKCdcXCcnKTtcbiAgICAgICAgICB0aGlzLmZvcndhcmQoMik7XG4gICAgICAgIH0gZWxzZSBpZiAoKGRvdWJsZSAmJiBjaGFyID09PSAnXFwnJykgfHwgKCFkb3VibGUgJiYgX19pbmRleE9mLmNhbGwoJ1wiXFxcXCcsIGNoYXIpID49IDApKSB7XG4gICAgICAgICAgY2h1bmtzLnB1c2goY2hhcik7XG4gICAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZG91YmxlICYmIGNoYXIgPT09ICdcXFxcJykge1xuICAgICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgICAgIGNoYXIgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgICBpZiAoY2hhciBpbiBFU0NBUEVfUkVQTEFDRU1FTlRTKSB7XG4gICAgICAgICAgICBjaHVua3MucHVzaChFU0NBUEVfUkVQTEFDRU1FTlRTW2NoYXJdKTtcbiAgICAgICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2hhciBpbiBFU0NBUEVfQ09ERVMpIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IEVTQ0FQRV9DT0RFU1tjaGFyXTtcbiAgICAgICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgICAgICAgZm9yIChrID0gX2kgPSAwOyAwIDw9IGxlbmd0aCA/IF9pIDwgbGVuZ3RoIDogX2kgPiBsZW5ndGg7IGsgPSAwIDw9IGxlbmd0aCA/ICsrX2kgOiAtLV9pKSB7XG4gICAgICAgICAgICAgIGlmIChfcmVmMiA9IHRoaXMucGVlayhrKSwgX19pbmRleE9mLmNhbGwoQ19OVU1CRVJTICsgJ0FCQ0RFRmFiY2RlZicsIF9yZWYyKSA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5TY2FubmVyRXJyb3IoJ3doaWxlIHNjYW5uaW5nIGEgZG91YmxlLXF1b3RlZCBzY2FsYXInLCBzdGFydF9tYXJrLCBcImV4cGVjdGVkIGVzY2FwZSBzZXF1ZW5jZSBvZiBcIiArIGxlbmd0aCArIFwiIGhleGFkZWNpbWFsIG51bWJlcnMsIGJ1dCBmb3VuZCBcIiArICh0aGlzLnBlZWsoaykpLCB0aGlzLmdldF9tYXJrKCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb2RlID0gcGFyc2VJbnQodGhpcy5wcmVmaXgobGVuZ3RoKSwgMTYpO1xuICAgICAgICAgICAgY2h1bmtzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSk7XG4gICAgICAgICAgICB0aGlzLmZvcndhcmQobGVuZ3RoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKF9faW5kZXhPZi5jYWxsKENfTEIsIGNoYXIpID49IDApIHtcbiAgICAgICAgICAgIHRoaXMuc2Nhbl9saW5lX2JyZWFrKCk7XG4gICAgICAgICAgICBjaHVua3MgPSBjaHVua3MuY29uY2F0KHRoaXMuc2Nhbl9mbG93X3NjYWxhcl9icmVha3MoZG91YmxlLCBzdGFydF9tYXJrKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlNjYW5uZXJFcnJvcignd2hpbGUgc2Nhbm5pbmcgYSBkb3VibGUtcXVvdGVkIHNjYWxhcicsIHN0YXJ0X21hcmssIFwiZm91bmQgdW5rbm93biBlc2NhcGUgY2hhcmFjdGVyIFwiICsgY2hhciwgdGhpcy5nZXRfbWFyaygpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGNodW5rcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvKlxuICAgIFNlZSB0aGUgc3BlY2lmaWNhdGlvbiBmb3IgZGV0YWlscy5cbiAgICAqL1xuXG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuX2Zsb3dfc2NhbGFyX3NwYWNlcyA9IGZ1bmN0aW9uKGRvdWJsZSwgc3RhcnRfbWFyaykge1xuICAgICAgdmFyIGJyZWFrcywgY2hhciwgY2h1bmtzLCBsZW5ndGgsIGxpbmVfYnJlYWssIHdoaXRlc3BhY2VzLCBfcmVmMTtcbiAgICAgIGNodW5rcyA9IFtdO1xuICAgICAgbGVuZ3RoID0gMDtcbiAgICAgIHdoaWxlIChfcmVmMSA9IHRoaXMucGVlayhsZW5ndGgpLCBfX2luZGV4T2YuY2FsbChDX1dTLCBfcmVmMSkgPj0gMCkge1xuICAgICAgICBsZW5ndGgrKztcbiAgICAgIH1cbiAgICAgIHdoaXRlc3BhY2VzID0gdGhpcy5wcmVmaXgobGVuZ3RoKTtcbiAgICAgIHRoaXMuZm9yd2FyZChsZW5ndGgpO1xuICAgICAgY2hhciA9IHRoaXMucGVlaygpO1xuICAgICAgaWYgKGNoYXIgPT09ICdcXHgwMCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuU2Nhbm5lckVycm9yKCd3aGlsZSBzY2FubmluZyBhIHF1b3RlZCBzY2FsYXInLCBzdGFydF9tYXJrLCAnZm91bmQgdW5leHBlY3RlZCBlbmQgb2Ygc3RyZWFtJywgdGhpcy5nZXRfbWFyaygpKTtcbiAgICAgIH1cbiAgICAgIGlmIChfX2luZGV4T2YuY2FsbChDX0xCLCBjaGFyKSA+PSAwKSB7XG4gICAgICAgIGxpbmVfYnJlYWsgPSB0aGlzLnNjYW5fbGluZV9icmVhaygpO1xuICAgICAgICBicmVha3MgPSB0aGlzLnNjYW5fZmxvd19zY2FsYXJfYnJlYWtzKGRvdWJsZSwgc3RhcnRfbWFyayk7XG4gICAgICAgIGlmIChsaW5lX2JyZWFrICE9PSAnXFxuJykge1xuICAgICAgICAgIGNodW5rcy5wdXNoKGxpbmVfYnJlYWspO1xuICAgICAgICB9IGVsc2UgaWYgKCFicmVha3MpIHtcbiAgICAgICAgICBjaHVua3MucHVzaCgnICcpO1xuICAgICAgICB9XG4gICAgICAgIGNodW5rcyA9IGNodW5rcy5jb25jYXQoYnJlYWtzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNodW5rcy5wdXNoKHdoaXRlc3BhY2VzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjaHVua3M7XG4gICAgfTtcblxuICAgIC8qXG4gICAgU2VlIHRoZSBzcGVjaWZpY2F0aW9uIGZvciBkZXRhaWxzLlxuICAgICovXG5cblxuICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5fZmxvd19zY2FsYXJfYnJlYWtzID0gZnVuY3Rpb24oZG91YmxlLCBzdGFydF9tYXJrKSB7XG4gICAgICB2YXIgY2h1bmtzLCBwcmVmaXgsIF9yZWYxLCBfcmVmMiwgX3JlZjM7XG4gICAgICBjaHVua3MgPSBbXTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHByZWZpeCA9IHRoaXMucHJlZml4KDMpO1xuICAgICAgICBpZiAocHJlZml4ID09PSAnLS0tJyB8fCBwcmVmaXggPT09ICcuLi4nICYmIChfcmVmMSA9IHRoaXMucGVlaygzKSwgX19pbmRleE9mLmNhbGwoQ19MQiArIENfV1MgKyAnXFx4MDAnLCBfcmVmMSkgPj0gMCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5TY2FubmVyRXJyb3IoJ3doaWxlIHNjYW5uaW5nIGEgcXVvdGVkIHNjYWxhcicsIHN0YXJ0X21hcmssICdmb3VuZCB1bmV4cGVjdGVkIGRvY3VtZW50IHNlcGFyYXRvcicsIHRoaXMuZ2V0X21hcmsoKSk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKF9yZWYyID0gdGhpcy5wZWVrKCksIF9faW5kZXhPZi5jYWxsKENfV1MsIF9yZWYyKSA+PSAwKSB7XG4gICAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9yZWYzID0gdGhpcy5wZWVrKCksIF9faW5kZXhPZi5jYWxsKENfTEIsIF9yZWYzKSA+PSAwKSB7XG4gICAgICAgICAgY2h1bmtzLnB1c2godGhpcy5zY2FuX2xpbmVfYnJlYWsoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGNodW5rcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvKlxuICAgIFNlZSB0aGUgc3BlY2lmaWNhdGlvbiBmb3IgZGV0YWlscy5cbiAgICBXZSBhZGQgYW4gYWRkaXRpb25hbCByZXN0cmljdGlvbiBmb3IgdGhlIGZsb3cgY29udGV4dDpcbiAgICAgIHBsYWluIHNjYWxhcnMgaW4gdGhlIGZsb3cgY29udGV4dCBjYW5ub3QgY29udGFpbiAnLCcsICc6JyBhbmQgJz8nLlxuICAgIFdlIGFsc28ga2VlcCB0cmFjayBvZiB0aGUgYGFsbG93X3NpbXBsZV9rZXlgIGZsYWcgaGVyZS5cbiAgICBJbmRlbnRhdGlvbiBydWxlcyBhcmUgbG9vc2VkIGZvciB0aGUgZmxvdyBjb250ZXh0LlxuICAgICovXG5cblxuICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5fcGxhaW4gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjaGFyLCBjaHVua3MsIGVuZF9tYXJrLCBpbmRlbnQsIGxlbmd0aCwgc3BhY2VzLCBzdGFydF9tYXJrLCBfcmVmMSwgX3JlZjI7XG4gICAgICBjaHVua3MgPSBbXTtcbiAgICAgIHN0YXJ0X21hcmsgPSBlbmRfbWFyayA9IHRoaXMuZ2V0X21hcmsoKTtcbiAgICAgIGluZGVudCA9IHRoaXMuaW5kZW50ICsgMTtcbiAgICAgIHNwYWNlcyA9IFtdO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgbGVuZ3RoID0gMDtcbiAgICAgICAgaWYgKHRoaXMucGVlaygpID09PSAnIycpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGNoYXIgPSB0aGlzLnBlZWsobGVuZ3RoKTtcbiAgICAgICAgICBpZiAoX19pbmRleE9mLmNhbGwoQ19MQiArIENfV1MgKyAnXFx4MDAnLCBjaGFyKSA+PSAwIHx8ICh0aGlzLmZsb3dfbGV2ZWwgPT09IDAgJiYgY2hhciA9PT0gJzonICYmIChfcmVmMSA9IHRoaXMucGVlayhsZW5ndGggKyAxKSwgX19pbmRleE9mLmNhbGwoQ19MQiArIENfV1MgKyAnXFx4MDAnLCBfcmVmMSkgPj0gMCkpIHx8ICh0aGlzLmZsb3dfbGV2ZWwgIT09IDAgJiYgX19pbmRleE9mLmNhbGwoJyw6P1tde30nLCBjaGFyKSA+PSAwKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxlbmd0aCsrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZsb3dfbGV2ZWwgIT09IDAgJiYgY2hhciA9PT0gJzonICYmIChfcmVmMiA9IHRoaXMucGVlayhsZW5ndGggKyAxKSwgX19pbmRleE9mLmNhbGwoQ19MQiArIENfV1MgKyAnXFx4MDAsW117fScsIF9yZWYyKSA8IDApKSB7XG4gICAgICAgICAgdGhpcy5mb3J3YXJkKGxlbmd0aCk7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuU2Nhbm5lckVycm9yKCd3aGlsZSBzY2FubmluZyBhIHBsYWluIHNjYWxhcicsIHN0YXJ0X21hcmssICdmb3VuZCB1bmV4cGVjdGVkIFxcJzpcXCcnLCB0aGlzLmdldF9tYXJrKCksICdQbGVhc2UgY2hlY2sgaHR0cDovL3B5eWFtbC5vcmcvd2lraS9ZQU1MQ29sb25JbkZsb3dDb250ZXh0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWxsb3dfc2ltcGxlX2tleSA9IGZhbHNlO1xuICAgICAgICBjaHVua3MgPSBjaHVua3MuY29uY2F0KHNwYWNlcyk7XG4gICAgICAgIGNodW5rcy5wdXNoKHRoaXMucHJlZml4KGxlbmd0aCkpO1xuICAgICAgICB0aGlzLmZvcndhcmQobGVuZ3RoKTtcbiAgICAgICAgZW5kX21hcmsgPSB0aGlzLmdldF9tYXJrKCk7XG4gICAgICAgIHNwYWNlcyA9IHRoaXMuc2Nhbl9wbGFpbl9zcGFjZXMoaW5kZW50LCBzdGFydF9tYXJrKTtcbiAgICAgICAgaWYgKChzcGFjZXMgPT0gbnVsbCkgfHwgc3BhY2VzLmxlbmd0aCA9PT0gMCB8fCB0aGlzLnBlZWsoKSA9PT0gJyMnIHx8ICh0aGlzLmZsb3dfbGV2ZWwgPT09IDAgJiYgdGhpcy5jb2x1bW4gPCBpbmRlbnQpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgdG9rZW5zLlNjYWxhclRva2VuKGNodW5rcy5qb2luKCcnKSwgdHJ1ZSwgc3RhcnRfbWFyaywgZW5kX21hcmspO1xuICAgIH07XG5cbiAgICAvKlxuICAgIFNlZSB0aGUgc3BlY2lmaWNhdGlvbiBmb3IgZGV0YWlscy5cbiAgICBUaGUgc3BlY2lmaWNhdGlvbiBpcyByZWFsbHkgY29uZnVzaW5nIGFib3V0IHRhYnMgaW4gcGxhaW4gc2NhbGFycy5cbiAgICBXZSBqdXN0IGZvcmJpZCB0aGVtIGNvbXBsZXRlbHkuIERvIG5vdCB1c2UgdGFicyBpbiBZQU1MIVxuICAgICovXG5cblxuICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5fcGxhaW5fc3BhY2VzID0gZnVuY3Rpb24oaW5kZW50LCBzdGFydF9tYXJrKSB7XG4gICAgICB2YXIgYnJlYWtzLCBjaGFyLCBjaHVua3MsIGxlbmd0aCwgbGluZV9icmVhaywgcHJlZml4LCB3aGl0ZXNwYWNlcywgX3JlZjEsIF9yZWYyO1xuICAgICAgY2h1bmtzID0gW107XG4gICAgICBsZW5ndGggPSAwO1xuICAgICAgd2hpbGUgKF9yZWYxID0gdGhpcy5wZWVrKGxlbmd0aCksIF9faW5kZXhPZi5jYWxsKCcgJywgX3JlZjEpID49IDApIHtcbiAgICAgICAgbGVuZ3RoKys7XG4gICAgICB9XG4gICAgICB3aGl0ZXNwYWNlcyA9IHRoaXMucHJlZml4KGxlbmd0aCk7XG4gICAgICB0aGlzLmZvcndhcmQobGVuZ3RoKTtcbiAgICAgIGNoYXIgPSB0aGlzLnBlZWsoKTtcbiAgICAgIGlmIChfX2luZGV4T2YuY2FsbChDX0xCLCBjaGFyKSA+PSAwKSB7XG4gICAgICAgIGxpbmVfYnJlYWsgPSB0aGlzLnNjYW5fbGluZV9icmVhaygpO1xuICAgICAgICB0aGlzLmFsbG93X3NpbXBsZV9rZXkgPSB0cnVlO1xuICAgICAgICBwcmVmaXggPSB0aGlzLnByZWZpeCgzKTtcbiAgICAgICAgaWYgKHByZWZpeCA9PT0gJy0tLScgfHwgcHJlZml4ID09PSAnLi4uJyAmJiB0aGlzLnBlZWsoX19pbmRleE9mLmNhbGwoQ19MQiArIENfV1MgKyAnXFx4MDAnLCAzKSA+PSAwKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBicmVha3MgPSBbXTtcbiAgICAgICAgd2hpbGUgKF9yZWYyID0gdGhpcy5wZWVrKCksIF9faW5kZXhPZi5jYWxsKENfTEIgKyAnICcsIF9yZWYyKSA+PSAwKSB7XG4gICAgICAgICAgaWYgKHRoaXMucGVlaygpID09PSAnICcpIHtcbiAgICAgICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVha3MucHVzaCh0aGlzLnNjYW5fbGluZV9icmVhaygpKTtcbiAgICAgICAgICAgIHByZWZpeCA9IHRoaXMucHJlZml4KDMpO1xuICAgICAgICAgICAgaWYgKHByZWZpeCA9PT0gJy0tLScgfHwgcHJlZml4ID09PSAnLi4uJyAmJiB0aGlzLnBlZWsoX19pbmRleE9mLmNhbGwoQ19MQiArIENfV1MgKyAnXFx4MDAnLCAzKSA+PSAwKSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5lX2JyZWFrICE9PSAnXFxuJykge1xuICAgICAgICAgIGNodW5rcy5wdXNoKGxpbmVfYnJlYWspO1xuICAgICAgICB9IGVsc2UgaWYgKGJyZWFrcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBjaHVua3MucHVzaCgnICcpO1xuICAgICAgICB9XG4gICAgICAgIGNodW5rcyA9IGNodW5rcy5jb25jYXQoYnJlYWtzKTtcbiAgICAgIH0gZWxzZSBpZiAod2hpdGVzcGFjZXMpIHtcbiAgICAgICAgY2h1bmtzLnB1c2god2hpdGVzcGFjZXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNodW5rcztcbiAgICB9O1xuXG4gICAgLypcbiAgICBTZWUgdGhlIHNwZWNpZmljYXRpb24gZm9yIGRldGFpbHMuXG4gICAgRm9yIHNvbWUgc3RyYW5nZSByZWFzb25zLCB0aGUgc3BlY2lmaWNhdGlvbiBkb2VzIG5vdCBhbGxvdyAnXycgaW4gdGFnXG4gICAgaGFuZGxlcy4gSSBoYXZlIGFsbG93ZWQgaXQgYW55d2F5LlxuICAgICovXG5cblxuICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5fdGFnX2hhbmRsZSA9IGZ1bmN0aW9uKG5hbWUsIHN0YXJ0X21hcmspIHtcbiAgICAgIHZhciBjaGFyLCBsZW5ndGgsIHZhbHVlO1xuICAgICAgY2hhciA9IHRoaXMucGVlaygpO1xuICAgICAgaWYgKGNoYXIgIT09ICchJykge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5TY2FubmVyRXJyb3IoXCJ3aGlsZSBzY2FubmluZyBhIFwiICsgbmFtZSwgc3RhcnRfbWFyaywgXCJleHBlY3RlZCAnIScgYnV0IGZvdW5kIFwiICsgY2hhciwgdGhpcy5nZXRfbWFyaygpKTtcbiAgICAgIH1cbiAgICAgIGxlbmd0aCA9IDE7XG4gICAgICBjaGFyID0gdGhpcy5wZWVrKGxlbmd0aCk7XG4gICAgICBpZiAoY2hhciAhPT0gJyAnKSB7XG4gICAgICAgIHdoaWxlICgoJzAnIDw9IGNoYXIgJiYgY2hhciA8PSAnOScpIHx8ICgnQScgPD0gY2hhciAmJiBjaGFyIDw9ICdaJykgfHwgKCdhJyA8PSBjaGFyICYmIGNoYXIgPD0gJ3onKSB8fCBfX2luZGV4T2YuY2FsbCgnLV8nLCBjaGFyKSA+PSAwKSB7XG4gICAgICAgICAgbGVuZ3RoKys7XG4gICAgICAgICAgY2hhciA9IHRoaXMucGVlayhsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyICE9PSAnIScpIHtcbiAgICAgICAgICB0aGlzLmZvcndhcmQobGVuZ3RoKTtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5TY2FubmVyRXJyb3IoXCJ3aGlsZSBzY2FubmluZyBhIFwiICsgbmFtZSwgc3RhcnRfbWFyaywgXCJleHBlY3RlZCAnIScgYnV0IGZvdW5kIFwiICsgY2hhciwgdGhpcy5nZXRfbWFyaygpKTtcbiAgICAgICAgfVxuICAgICAgICBsZW5ndGgrKztcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gdGhpcy5wcmVmaXgobGVuZ3RoKTtcbiAgICAgIHRoaXMuZm9yd2FyZChsZW5ndGgpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG5cbiAgICAvKlxuICAgIFNlZSB0aGUgc3BlY2lmaWNhdGlvbiBmb3IgZGV0YWlscy5cbiAgICBOb3RlOiB3ZSBkbyBub3QgY2hlY2sgaWYgVVJJIGlzIHdlbGwtZm9ybWVkLlxuICAgICovXG5cblxuICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5fdGFnX3VyaSA9IGZ1bmN0aW9uKG5hbWUsIHN0YXJ0X21hcmspIHtcbiAgICAgIHZhciBjaGFyLCBjaHVua3MsIGxlbmd0aDtcbiAgICAgIGNodW5rcyA9IFtdO1xuICAgICAgbGVuZ3RoID0gMDtcbiAgICAgIGNoYXIgPSB0aGlzLnBlZWsobGVuZ3RoKTtcbiAgICAgIHdoaWxlICgoJzAnIDw9IGNoYXIgJiYgY2hhciA8PSAnOScpIHx8ICgnQScgPD0gY2hhciAmJiBjaGFyIDw9ICdaJykgfHwgKCdhJyA8PSBjaGFyICYmIGNoYXIgPD0gJ3onKSB8fCBfX2luZGV4T2YuY2FsbCgnLTsvPzpAJj0rJCxfLiF+KlxcJygpW10lJywgY2hhcikgPj0gMCkge1xuICAgICAgICBpZiAoY2hhciA9PT0gJyUnKSB7XG4gICAgICAgICAgY2h1bmtzLnB1c2godGhpcy5wcmVmaXgobGVuZ3RoKSk7XG4gICAgICAgICAgdGhpcy5mb3J3YXJkKGxlbmd0aCk7XG4gICAgICAgICAgbGVuZ3RoID0gMDtcbiAgICAgICAgICBjaHVua3MucHVzaCh0aGlzLnNjYW5fdXJpX2VzY2FwZXMobmFtZSwgc3RhcnRfbWFyaykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxlbmd0aCsrO1xuICAgICAgICB9XG4gICAgICAgIGNoYXIgPSB0aGlzLnBlZWsobGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIGlmIChsZW5ndGggIT09IDApIHtcbiAgICAgICAgY2h1bmtzLnB1c2godGhpcy5wcmVmaXgobGVuZ3RoKSk7XG4gICAgICAgIHRoaXMuZm9yd2FyZChsZW5ndGgpO1xuICAgICAgICBsZW5ndGggPSAwO1xuICAgICAgfVxuICAgICAgaWYgKGNodW5rcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuU2Nhbm5lckVycm9yKFwid2hpbGUgcGFyc2luZyBhIFwiICsgbmFtZSwgc3RhcnRfbWFyaywgXCJleHBlY3RlZCBVUkkgYnV0IGZvdW5kIFwiICsgY2hhciwgdGhpcy5nZXRfbWFyaygpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjaHVua3Muam9pbignJyk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgU2VlIHRoZSBzcGVjaWZpY2F0aW9uIGZvciBkZXRhaWxzLlxuICAgICovXG5cblxuICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5fdXJpX2VzY2FwZXMgPSBmdW5jdGlvbihuYW1lLCBzdGFydF9tYXJrKSB7XG4gICAgICB2YXIgYnl0ZXMsIGssIG1hcmssIF9pO1xuICAgICAgYnl0ZXMgPSBbXTtcbiAgICAgIG1hcmsgPSB0aGlzLmdldF9tYXJrKCk7XG4gICAgICB3aGlsZSAodGhpcy5wZWVrKCkgPT09ICclJykge1xuICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgICAgZm9yIChrID0gX2kgPSAwOyBfaSA8PSAyOyBrID0gKytfaSkge1xuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlNjYW5uZXJFcnJvcihcIndoaWxlIHNjYW5uaW5nIGEgXCIgKyBuYW1lLCBzdGFydF9tYXJrLCBcImV4cGVjdGVkIFVSSSBlc2NhcGUgc2VxdWVuY2Ugb2YgMiBoZXhhZGVjaW1hbCBudW1iZXJzIGJ1dCBmb3VuZCAgICAgICAgICBcIiArICh0aGlzLnBlZWsoaykpLCB0aGlzLmdldF9tYXJrKCkpO1xuICAgICAgICB9XG4gICAgICAgIGJ5dGVzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludCh0aGlzLnByZWZpeCgyKSwgMTYpKSk7XG4gICAgICAgIHRoaXMuZm9yd2FyZCgyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBieXRlcy5qb2luKCcnKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBUcmFuc2Zvcm1zOlxuICAgICAgJ1xcclxcbicgICAgICA6ICAgJ1xcbidcbiAgICAgICdcXHInICAgICAgICA6ICAgJ1xcbidcbiAgICAgICdcXG4nICAgICAgICA6ICAgJ1xcbidcbiAgICAgICdcXHg4NScgICAgICA6ICAgJ1xcbidcbiAgICAgICdcXHUyMDI4JyAgICA6ICAgJ1xcdTIwMjgnXG4gICAgICAnXFx1MjAyOSAgICAgOiAgICdcXHUyMDI5J1xuICAgICAgZGVmYXVsdCAgICAgOiAgICcnXG4gICAgKi9cblxuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuc2Nhbl9saW5lX2JyZWFrID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY2hhcjtcbiAgICAgIGNoYXIgPSB0aGlzLnBlZWsoKTtcbiAgICAgIGlmIChfX2luZGV4T2YuY2FsbCgnXFxyXFxuXFx4ODUnLCBjaGFyKSA+PSAwKSB7XG4gICAgICAgIGlmICh0aGlzLnByZWZpeCgyKSA9PT0gJ1xcclxcbicpIHtcbiAgICAgICAgICB0aGlzLmZvcndhcmQoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdcXG4nO1xuICAgICAgfSBlbHNlIGlmIChfX2luZGV4T2YuY2FsbCgnXFx1MjAyOFxcdTIwMjknLCBjaGFyKSA+PSAwKSB7XG4gICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgICByZXR1cm4gY2hhcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnJztcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNjYW5uZXI7XG5cbiAgfSkoKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIihmdW5jdGlvbigpIHtcbiAgdmFyIE1hcmtlZFlBTUxFcnJvciwgbm9kZXMsIF9yZWYsXG4gICAgX19oYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksXG4gICAgX19leHRlbmRzID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChfX2hhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG4gICAgX19iaW5kID0gZnVuY3Rpb24oZm4sIG1lKXsgcmV0dXJuIGZ1bmN0aW9uKCl7IHJldHVybiBmbi5hcHBseShtZSwgYXJndW1lbnRzKTsgfTsgfTtcblxuICBNYXJrZWRZQU1MRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9ycycpLk1hcmtlZFlBTUxFcnJvcjtcblxuICBub2RlcyA9IHJlcXVpcmUoJy4vbm9kZXMnKTtcblxuICAvKlxuICBUaGUgU2NoZW1hcyB0aHJvd3MgdGhlc2UuXG4gICovXG5cblxuICB0aGlzLlNjaGVtYUVycm9yID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTY2hlbWFFcnJvciwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIFNjaGVtYUVycm9yKCkge1xuICAgICAgX3JlZiA9IFNjaGVtYUVycm9yLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIF9yZWY7XG4gICAgfVxuXG4gICAgcmV0dXJuIFNjaGVtYUVycm9yO1xuXG4gIH0pKE1hcmtlZFlBTUxFcnJvcik7XG5cbiAgLypcbiAgICBUaGUgU2NoZW1hcyBjbGFzcyBkZWFscyB3aXRoIGFwcGx5aW5nIHNjaGVtYXMgdG8gcmVzb3VyY2VzIGFjY29yZGluZyB0byB0aGUgc3BlY1xuICAqL1xuXG5cbiAgdGhpcy5TY2hlbWFzID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFNjaGVtYXMoKSB7XG4gICAgICB0aGlzLmdldF9zY2hlbWFzX3VzZWQgPSBfX2JpbmQodGhpcy5nZXRfc2NoZW1hc191c2VkLCB0aGlzKTtcbiAgICAgIHRoaXMuYXBwbHlfc2NoZW1hcyA9IF9fYmluZCh0aGlzLmFwcGx5X3NjaGVtYXMsIHRoaXMpO1xuICAgICAgdGhpcy5nZXRfYWxsX3NjaGVtYXMgPSBfX2JpbmQodGhpcy5nZXRfYWxsX3NjaGVtYXMsIHRoaXMpO1xuICAgICAgdGhpcy5oYXNfc2NoZW1hcyA9IF9fYmluZCh0aGlzLmhhc19zY2hlbWFzLCB0aGlzKTtcbiAgICAgIHRoaXMubG9hZF9zY2hlbWFzID0gX19iaW5kKHRoaXMubG9hZF9zY2hlbWFzLCB0aGlzKTtcbiAgICAgIHRoaXMuZGVjbGFyZWRTY2hlbWFzID0ge307XG4gICAgfVxuXG4gICAgU2NoZW1hcy5wcm90b3R5cGUubG9hZF9zY2hlbWFzID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIGFsbFNjaGVtYXMsXG4gICAgICAgIF90aGlzID0gdGhpcztcbiAgICAgIGlmICh0aGlzLmhhc19wcm9wZXJ0eShub2RlLCBcInNjaGVtYXNcIikpIHtcbiAgICAgICAgYWxsU2NoZW1hcyA9IHRoaXMucHJvcGVydHlfdmFsdWUobm9kZSwgJ3NjaGVtYXMnKTtcbiAgICAgICAgaWYgKGFsbFNjaGVtYXMgJiYgdHlwZW9mIGFsbFNjaGVtYXMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICByZXR1cm4gYWxsU2NoZW1hcy5mb3JFYWNoKGZ1bmN0aW9uKHNjaGVtYV9lbnRyeSkge1xuICAgICAgICAgICAgaWYgKHNjaGVtYV9lbnRyeSAmJiB0eXBlb2Ygc2NoZW1hX2VudHJ5ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBzY2hlbWFfZW50cnkudmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNjaGVtYV9lbnRyeS52YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHNjaGVtYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5kZWNsYXJlZFNjaGVtYXNbc2NoZW1hWzBdLnZhbHVlXSA9IHNjaGVtYTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgU2NoZW1hcy5wcm90b3R5cGUuaGFzX3NjaGVtYXMgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICBpZiAodGhpcy5kZWNsYXJlZFNjaGVtYXMubGVuZ3RoID09PSAwICYmIHRoaXMuaGFzX3Byb3BlcnR5KG5vZGUsIFwic2NoZW1hc1wiKSkge1xuICAgICAgICB0aGlzLmxvYWRfc2NoZW1hcyhub2RlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmRlY2xhcmVkU2NoZW1hcykubGVuZ3RoID4gMDtcbiAgICB9O1xuXG4gICAgU2NoZW1hcy5wcm90b3R5cGUuZ2V0X2FsbF9zY2hlbWFzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWNsYXJlZFNjaGVtYXM7XG4gICAgfTtcblxuICAgIFNjaGVtYXMucHJvdG90eXBlLmFwcGx5X3NjaGVtYXMgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgcmVzb3VyY2VzLCBzY2hlbWFzLFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG4gICAgICByZXNvdXJjZXMgPSB0aGlzLmNoaWxkX3Jlc291cmNlcyhub2RlKTtcbiAgICAgIHNjaGVtYXMgPSB0aGlzLmdldF9zY2hlbWFzX3VzZWQocmVzb3VyY2VzKTtcbiAgICAgIHJldHVybiBzY2hlbWFzLmZvckVhY2goZnVuY3Rpb24oc2NoZW1hKSB7XG4gICAgICAgIGlmIChzY2hlbWFbMV0udmFsdWUgaW4gX3RoaXMuZGVjbGFyZWRTY2hlbWFzKSB7XG4gICAgICAgICAgcmV0dXJuIHNjaGVtYVsxXS52YWx1ZSA9IF90aGlzLmRlY2xhcmVkU2NoZW1hc1tzY2hlbWFbMV0udmFsdWVdWzFdLnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgU2NoZW1hcy5wcm90b3R5cGUuZ2V0X3NjaGVtYXNfdXNlZCA9IGZ1bmN0aW9uKHJlc291cmNlcykge1xuICAgICAgdmFyIHNjaGVtYXMsXG4gICAgICAgIF90aGlzID0gdGhpcztcbiAgICAgIHNjaGVtYXMgPSBbXTtcbiAgICAgIHJlc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uKHJlc291cmNlKSB7XG4gICAgICAgIHZhciBwcm9wZXJ0aWVzO1xuICAgICAgICBwcm9wZXJ0aWVzID0gX3RoaXMuZ2V0X3Byb3BlcnRpZXMocmVzb3VyY2VbMV0sIFwic2NoZW1hXCIpO1xuICAgICAgICByZXR1cm4gc2NoZW1hcyA9IHNjaGVtYXMuY29uY2F0KHByb3BlcnRpZXMpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gc2NoZW1hcztcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNjaGVtYXM7XG5cbiAgfSkoKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIihmdW5jdGlvbigpIHtcbiAgdmFyIE1hcmtlZFlBTUxFcnJvciwgbm9kZXMsIF9yZWYsXG4gICAgX19oYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksXG4gICAgX19leHRlbmRzID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChfX2hhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG4gICAgX19iaW5kID0gZnVuY3Rpb24oZm4sIG1lKXsgcmV0dXJuIGZ1bmN0aW9uKCl7IHJldHVybiBmbi5hcHBseShtZSwgYXJndW1lbnRzKTsgfTsgfTtcblxuICBNYXJrZWRZQU1MRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9ycycpLk1hcmtlZFlBTUxFcnJvcjtcblxuICBub2RlcyA9IHJlcXVpcmUoJy4vbm9kZXMnKTtcblxuICAvKlxuICBUaGUgU2NoZW1hcyB0aHJvd3MgdGhlc2UuXG4gICovXG5cblxuICB0aGlzLlNlY3VyaXR5U2NoZW1lRXJyb3IgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNlY3VyaXR5U2NoZW1lRXJyb3IsIF9zdXBlcik7XG5cbiAgICAvKlxuICAgICAgVGhlIFNjaGVtYXMgY2xhc3MgZGVhbHMgd2l0aCBhcHBseWluZyBzY2hlbWFzIHRvIHJlc291cmNlcyBhY2NvcmRpbmcgdG8gdGhlIHNwZWNcbiAgICAqL1xuXG5cbiAgICBmdW5jdGlvbiBTZWN1cml0eVNjaGVtZUVycm9yKCkge1xuICAgICAgX3JlZiA9IFNlY3VyaXR5U2NoZW1lRXJyb3IuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gX3JlZjtcbiAgICB9XG5cbiAgICByZXR1cm4gU2VjdXJpdHlTY2hlbWVFcnJvcjtcblxuICB9KShNYXJrZWRZQU1MRXJyb3IpO1xuXG4gIHRoaXMuU2VjdXJpdHlTY2hlbWVzID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFNlY3VyaXR5U2NoZW1lcygpIHtcbiAgICAgIHRoaXMuZ2V0X3NlY3VyaXR5X3NjaGVtZSA9IF9fYmluZCh0aGlzLmdldF9zZWN1cml0eV9zY2hlbWUsIHRoaXMpO1xuICAgICAgdGhpcy5nZXRfYWxsX3NjaGVtZXMgPSBfX2JpbmQodGhpcy5nZXRfYWxsX3NjaGVtZXMsIHRoaXMpO1xuICAgICAgdGhpcy5sb2FkX3NlY3VyaXR5X3NjaGVtZXMgPSBfX2JpbmQodGhpcy5sb2FkX3NlY3VyaXR5X3NjaGVtZXMsIHRoaXMpO1xuICAgICAgdGhpcy5kZWNsYXJlZFNjaGVtZXMgPSB7fTtcbiAgICB9XG5cbiAgICBTZWN1cml0eVNjaGVtZXMucHJvdG90eXBlLmxvYWRfc2VjdXJpdHlfc2NoZW1lcyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBhbGxzY2hlbWVzLFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG4gICAgICBpZiAodGhpcy5oYXNfcHJvcGVydHkobm9kZSwgXCJzZWN1cml0eVNjaGVtZXNcIikpIHtcbiAgICAgICAgYWxsc2NoZW1lcyA9IHRoaXMucHJvcGVydHlfdmFsdWUobm9kZSwgJ3NlY3VyaXR5U2NoZW1lcycpO1xuICAgICAgICBpZiAoYWxsc2NoZW1lcyAmJiB0eXBlb2YgYWxsc2NoZW1lcyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIHJldHVybiBhbGxzY2hlbWVzLmZvckVhY2goZnVuY3Rpb24oc2NoZW1lX2VudHJ5KSB7XG4gICAgICAgICAgICBpZiAoc2NoZW1lX2VudHJ5LnRhZyA9PT0gJ3RhZzp5YW1sLm9yZywyMDAyOm1hcCcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNjaGVtZV9lbnRyeS52YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHNjaGVtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5kZWNsYXJlZFNjaGVtZXNbc2NoZW1lWzBdLnZhbHVlXSA9IHNjaGVtZVsxXS52YWx1ZTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgU2VjdXJpdHlTY2hlbWVzLnByb3RvdHlwZS5nZXRfYWxsX3NjaGVtZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlY2xhcmVkU2NoZW1lcztcbiAgICB9O1xuXG4gICAgU2VjdXJpdHlTY2hlbWVzLnByb3RvdHlwZS5nZXRfc2VjdXJpdHlfc2NoZW1lID0gZnVuY3Rpb24oc2NoZW1hTmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVjbGFyZWRTY2hlbWVzW3NjaGVtYU5hbWVdO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2VjdXJpdHlTY2hlbWVzO1xuXG4gIH0pKCk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIoZnVuY3Rpb24oKSB7XG4gIHZhciBfcmVmLCBfcmVmMSwgX3JlZjEwLCBfcmVmMTEsIF9yZWYxMiwgX3JlZjEzLCBfcmVmMiwgX3JlZjMsIF9yZWY0LCBfcmVmNSwgX3JlZjYsIF9yZWY3LCBfcmVmOCwgX3JlZjksXG4gICAgX19oYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksXG4gICAgX19leHRlbmRzID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChfX2hhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH07XG5cbiAgdGhpcy5Ub2tlbiA9IChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBUb2tlbihzdGFydF9tYXJrLCBlbmRfbWFyaykge1xuICAgICAgdGhpcy5zdGFydF9tYXJrID0gc3RhcnRfbWFyaztcbiAgICAgIHRoaXMuZW5kX21hcmsgPSBlbmRfbWFyaztcbiAgICB9XG5cbiAgICByZXR1cm4gVG9rZW47XG5cbiAgfSkoKTtcblxuICB0aGlzLkRpcmVjdGl2ZVRva2VuID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEaXJlY3RpdmVUb2tlbiwgX3N1cGVyKTtcblxuICAgIERpcmVjdGl2ZVRva2VuLnByb3RvdHlwZS5pZCA9ICc8ZGlyZWN0aXZlPic7XG5cbiAgICBmdW5jdGlvbiBEaXJlY3RpdmVUb2tlbihuYW1lLCB2YWx1ZSwgc3RhcnRfbWFyaywgZW5kX21hcmspIHtcbiAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICB0aGlzLnN0YXJ0X21hcmsgPSBzdGFydF9tYXJrO1xuICAgICAgdGhpcy5lbmRfbWFyayA9IGVuZF9tYXJrO1xuICAgIH1cblxuICAgIHJldHVybiBEaXJlY3RpdmVUb2tlbjtcblxuICB9KSh0aGlzLlRva2VuKTtcblxuICB0aGlzLkRvY3VtZW50U3RhcnRUb2tlbiA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRG9jdW1lbnRTdGFydFRva2VuLCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gRG9jdW1lbnRTdGFydFRva2VuKCkge1xuICAgICAgX3JlZiA9IERvY3VtZW50U3RhcnRUb2tlbi5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfcmVmO1xuICAgIH1cblxuICAgIERvY3VtZW50U3RhcnRUb2tlbi5wcm90b3R5cGUuaWQgPSAnPGRvY3VtZW50IHN0YXJ0Pic7XG5cbiAgICByZXR1cm4gRG9jdW1lbnRTdGFydFRva2VuO1xuXG4gIH0pKHRoaXMuVG9rZW4pO1xuXG4gIHRoaXMuRG9jdW1lbnRFbmRUb2tlbiA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRG9jdW1lbnRFbmRUb2tlbiwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIERvY3VtZW50RW5kVG9rZW4oKSB7XG4gICAgICBfcmVmMSA9IERvY3VtZW50RW5kVG9rZW4uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gX3JlZjE7XG4gICAgfVxuXG4gICAgRG9jdW1lbnRFbmRUb2tlbi5wcm90b3R5cGUuaWQgPSAnPGRvY3VtZW50IGVuZD4nO1xuXG4gICAgcmV0dXJuIERvY3VtZW50RW5kVG9rZW47XG5cbiAgfSkodGhpcy5Ub2tlbik7XG5cbiAgdGhpcy5TdHJlYW1TdGFydFRva2VuID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdHJlYW1TdGFydFRva2VuLCBfc3VwZXIpO1xuXG4gICAgU3RyZWFtU3RhcnRUb2tlbi5wcm90b3R5cGUuaWQgPSAnPHN0cmVhbSBzdGFydD4nO1xuXG4gICAgZnVuY3Rpb24gU3RyZWFtU3RhcnRUb2tlbihzdGFydF9tYXJrLCBlbmRfbWFyaywgZW5jb2RpbmcpIHtcbiAgICAgIHRoaXMuc3RhcnRfbWFyayA9IHN0YXJ0X21hcms7XG4gICAgICB0aGlzLmVuZF9tYXJrID0gZW5kX21hcms7XG4gICAgICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gICAgfVxuXG4gICAgcmV0dXJuIFN0cmVhbVN0YXJ0VG9rZW47XG5cbiAgfSkodGhpcy5Ub2tlbik7XG5cbiAgdGhpcy5TdHJlYW1FbmRUb2tlbiA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3RyZWFtRW5kVG9rZW4sIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBTdHJlYW1FbmRUb2tlbigpIHtcbiAgICAgIF9yZWYyID0gU3RyZWFtRW5kVG9rZW4uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gX3JlZjI7XG4gICAgfVxuXG4gICAgU3RyZWFtRW5kVG9rZW4ucHJvdG90eXBlLmlkID0gJzxzdHJlYW0gZW5kPic7XG5cbiAgICByZXR1cm4gU3RyZWFtRW5kVG9rZW47XG5cbiAgfSkodGhpcy5Ub2tlbik7XG5cbiAgdGhpcy5CbG9ja1NlcXVlbmNlU3RhcnRUb2tlbiA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQmxvY2tTZXF1ZW5jZVN0YXJ0VG9rZW4sIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBCbG9ja1NlcXVlbmNlU3RhcnRUb2tlbigpIHtcbiAgICAgIF9yZWYzID0gQmxvY2tTZXF1ZW5jZVN0YXJ0VG9rZW4uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gX3JlZjM7XG4gICAgfVxuXG4gICAgQmxvY2tTZXF1ZW5jZVN0YXJ0VG9rZW4ucHJvdG90eXBlLmlkID0gJzxibG9jayBzZXF1ZW5jZSBzdGFydD4nO1xuXG4gICAgcmV0dXJuIEJsb2NrU2VxdWVuY2VTdGFydFRva2VuO1xuXG4gIH0pKHRoaXMuVG9rZW4pO1xuXG4gIHRoaXMuQmxvY2tNYXBwaW5nU3RhcnRUb2tlbiA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQmxvY2tNYXBwaW5nU3RhcnRUb2tlbiwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIEJsb2NrTWFwcGluZ1N0YXJ0VG9rZW4oKSB7XG4gICAgICBfcmVmNCA9IEJsb2NrTWFwcGluZ1N0YXJ0VG9rZW4uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gX3JlZjQ7XG4gICAgfVxuXG4gICAgQmxvY2tNYXBwaW5nU3RhcnRUb2tlbi5wcm90b3R5cGUuaWQgPSAnPGJsb2NrIG1hcHBpbmcgZW5kPic7XG5cbiAgICByZXR1cm4gQmxvY2tNYXBwaW5nU3RhcnRUb2tlbjtcblxuICB9KSh0aGlzLlRva2VuKTtcblxuICB0aGlzLkJsb2NrRW5kVG9rZW4gPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJsb2NrRW5kVG9rZW4sIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBCbG9ja0VuZFRva2VuKCkge1xuICAgICAgX3JlZjUgPSBCbG9ja0VuZFRva2VuLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIF9yZWY1O1xuICAgIH1cblxuICAgIEJsb2NrRW5kVG9rZW4ucHJvdG90eXBlLmlkID0gJzxibG9jayBlbmQ+JztcblxuICAgIHJldHVybiBCbG9ja0VuZFRva2VuO1xuXG4gIH0pKHRoaXMuVG9rZW4pO1xuXG4gIHRoaXMuRmxvd1NlcXVlbmNlU3RhcnRUb2tlbiA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRmxvd1NlcXVlbmNlU3RhcnRUb2tlbiwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIEZsb3dTZXF1ZW5jZVN0YXJ0VG9rZW4oKSB7XG4gICAgICBfcmVmNiA9IEZsb3dTZXF1ZW5jZVN0YXJ0VG9rZW4uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gX3JlZjY7XG4gICAgfVxuXG4gICAgRmxvd1NlcXVlbmNlU3RhcnRUb2tlbi5wcm90b3R5cGUuaWQgPSAnWyc7XG5cbiAgICByZXR1cm4gRmxvd1NlcXVlbmNlU3RhcnRUb2tlbjtcblxuICB9KSh0aGlzLlRva2VuKTtcblxuICB0aGlzLkZsb3dNYXBwaW5nU3RhcnRUb2tlbiA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRmxvd01hcHBpbmdTdGFydFRva2VuLCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gRmxvd01hcHBpbmdTdGFydFRva2VuKCkge1xuICAgICAgX3JlZjcgPSBGbG93TWFwcGluZ1N0YXJ0VG9rZW4uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gX3JlZjc7XG4gICAgfVxuXG4gICAgRmxvd01hcHBpbmdTdGFydFRva2VuLnByb3RvdHlwZS5pZCA9ICd7JztcblxuICAgIHJldHVybiBGbG93TWFwcGluZ1N0YXJ0VG9rZW47XG5cbiAgfSkodGhpcy5Ub2tlbik7XG5cbiAgdGhpcy5GbG93U2VxdWVuY2VFbmRUb2tlbiA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRmxvd1NlcXVlbmNlRW5kVG9rZW4sIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBGbG93U2VxdWVuY2VFbmRUb2tlbigpIHtcbiAgICAgIF9yZWY4ID0gRmxvd1NlcXVlbmNlRW5kVG9rZW4uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gX3JlZjg7XG4gICAgfVxuXG4gICAgRmxvd1NlcXVlbmNlRW5kVG9rZW4ucHJvdG90eXBlLmlkID0gJ10nO1xuXG4gICAgcmV0dXJuIEZsb3dTZXF1ZW5jZUVuZFRva2VuO1xuXG4gIH0pKHRoaXMuVG9rZW4pO1xuXG4gIHRoaXMuRmxvd01hcHBpbmdFbmRUb2tlbiA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRmxvd01hcHBpbmdFbmRUb2tlbiwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIEZsb3dNYXBwaW5nRW5kVG9rZW4oKSB7XG4gICAgICBfcmVmOSA9IEZsb3dNYXBwaW5nRW5kVG9rZW4uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gX3JlZjk7XG4gICAgfVxuXG4gICAgRmxvd01hcHBpbmdFbmRUb2tlbi5wcm90b3R5cGUuaWQgPSAnfSc7XG5cbiAgICByZXR1cm4gRmxvd01hcHBpbmdFbmRUb2tlbjtcblxuICB9KSh0aGlzLlRva2VuKTtcblxuICB0aGlzLktleVRva2VuID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhLZXlUb2tlbiwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIEtleVRva2VuKCkge1xuICAgICAgX3JlZjEwID0gS2V5VG9rZW4uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gX3JlZjEwO1xuICAgIH1cblxuICAgIEtleVRva2VuLnByb3RvdHlwZS5pZCA9ICc/JztcblxuICAgIHJldHVybiBLZXlUb2tlbjtcblxuICB9KSh0aGlzLlRva2VuKTtcblxuICB0aGlzLlZhbHVlVG9rZW4gPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFZhbHVlVG9rZW4sIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBWYWx1ZVRva2VuKCkge1xuICAgICAgX3JlZjExID0gVmFsdWVUb2tlbi5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfcmVmMTE7XG4gICAgfVxuXG4gICAgVmFsdWVUb2tlbi5wcm90b3R5cGUuaWQgPSAnOic7XG5cbiAgICByZXR1cm4gVmFsdWVUb2tlbjtcblxuICB9KSh0aGlzLlRva2VuKTtcblxuICB0aGlzLkJsb2NrRW50cnlUb2tlbiA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQmxvY2tFbnRyeVRva2VuLCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gQmxvY2tFbnRyeVRva2VuKCkge1xuICAgICAgX3JlZjEyID0gQmxvY2tFbnRyeVRva2VuLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIF9yZWYxMjtcbiAgICB9XG5cbiAgICBCbG9ja0VudHJ5VG9rZW4ucHJvdG90eXBlLmlkID0gJy0nO1xuXG4gICAgcmV0dXJuIEJsb2NrRW50cnlUb2tlbjtcblxuICB9KSh0aGlzLlRva2VuKTtcblxuICB0aGlzLkZsb3dFbnRyeVRva2VuID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGbG93RW50cnlUb2tlbiwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIEZsb3dFbnRyeVRva2VuKCkge1xuICAgICAgX3JlZjEzID0gRmxvd0VudHJ5VG9rZW4uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gX3JlZjEzO1xuICAgIH1cblxuICAgIEZsb3dFbnRyeVRva2VuLnByb3RvdHlwZS5pZCA9ICcsJztcblxuICAgIHJldHVybiBGbG93RW50cnlUb2tlbjtcblxuICB9KSh0aGlzLlRva2VuKTtcblxuICB0aGlzLkFsaWFzVG9rZW4gPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFsaWFzVG9rZW4sIF9zdXBlcik7XG5cbiAgICBBbGlhc1Rva2VuLnByb3RvdHlwZS5pZCA9ICc8YWxpYXM+JztcblxuICAgIGZ1bmN0aW9uIEFsaWFzVG9rZW4odmFsdWUsIHN0YXJ0X21hcmssIGVuZF9tYXJrKSB7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICB0aGlzLnN0YXJ0X21hcmsgPSBzdGFydF9tYXJrO1xuICAgICAgdGhpcy5lbmRfbWFyayA9IGVuZF9tYXJrO1xuICAgIH1cblxuICAgIHJldHVybiBBbGlhc1Rva2VuO1xuXG4gIH0pKHRoaXMuVG9rZW4pO1xuXG4gIHRoaXMuQW5jaG9yVG9rZW4gPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFuY2hvclRva2VuLCBfc3VwZXIpO1xuXG4gICAgQW5jaG9yVG9rZW4ucHJvdG90eXBlLmlkID0gJzxhbmNob3I+JztcblxuICAgIGZ1bmN0aW9uIEFuY2hvclRva2VuKHZhbHVlLCBzdGFydF9tYXJrLCBlbmRfbWFyaykge1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgdGhpcy5zdGFydF9tYXJrID0gc3RhcnRfbWFyaztcbiAgICAgIHRoaXMuZW5kX21hcmsgPSBlbmRfbWFyaztcbiAgICB9XG5cbiAgICByZXR1cm4gQW5jaG9yVG9rZW47XG5cbiAgfSkodGhpcy5Ub2tlbik7XG5cbiAgdGhpcy5UYWdUb2tlbiA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGFnVG9rZW4sIF9zdXBlcik7XG5cbiAgICBUYWdUb2tlbi5wcm90b3R5cGUuaWQgPSAnPHRhZz4nO1xuXG4gICAgZnVuY3Rpb24gVGFnVG9rZW4odmFsdWUsIHN0YXJ0X21hcmssIGVuZF9tYXJrKSB7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICB0aGlzLnN0YXJ0X21hcmsgPSBzdGFydF9tYXJrO1xuICAgICAgdGhpcy5lbmRfbWFyayA9IGVuZF9tYXJrO1xuICAgIH1cblxuICAgIHJldHVybiBUYWdUb2tlbjtcblxuICB9KSh0aGlzLlRva2VuKTtcblxuICB0aGlzLlNjYWxhclRva2VuID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTY2FsYXJUb2tlbiwgX3N1cGVyKTtcblxuICAgIFNjYWxhclRva2VuLnByb3RvdHlwZS5pZCA9ICc8c2NhbGFyPic7XG5cbiAgICBmdW5jdGlvbiBTY2FsYXJUb2tlbih2YWx1ZSwgcGxhaW4sIHN0YXJ0X21hcmssIGVuZF9tYXJrLCBzdHlsZSkge1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgdGhpcy5wbGFpbiA9IHBsYWluO1xuICAgICAgdGhpcy5zdGFydF9tYXJrID0gc3RhcnRfbWFyaztcbiAgICAgIHRoaXMuZW5kX21hcmsgPSBlbmRfbWFyaztcbiAgICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gU2NhbGFyVG9rZW47XG5cbiAgfSkodGhpcy5Ub2tlbik7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIoZnVuY3Rpb24oKSB7XG4gIHZhciBNYXJrZWRZQU1MRXJyb3IsIGluZmxlY3Rpb24sIG5vZGVzLCB1dGlsLCBfcmVmLCBfcmVmMSxcbiAgICBfX2hhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSxcbiAgICBfX2V4dGVuZHMgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKF9faGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfTtcblxuICBNYXJrZWRZQU1MRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9ycycpLk1hcmtlZFlBTUxFcnJvcjtcblxuICBub2RlcyA9IHJlcXVpcmUoJy4vbm9kZXMnKTtcblxuICBpbmZsZWN0aW9uID0gcmVxdWlyZSgnaW5mbGVjdGlvbicpO1xuXG4gIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuICAvKlxuICBUaGUgVHJhaXRzIHRocm93cyB0aGVzZS5cbiAgKi9cblxuXG4gIHRoaXMuVHJhaXRFcnJvciA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVHJhaXRFcnJvciwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIFRyYWl0RXJyb3IoKSB7XG4gICAgICBfcmVmID0gVHJhaXRFcnJvci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfcmVmO1xuICAgIH1cblxuICAgIHJldHVybiBUcmFpdEVycm9yO1xuXG4gIH0pKE1hcmtlZFlBTUxFcnJvcik7XG5cbiAgLypcbiAgKi9cblxuXG4gIHRoaXMuUGFyYW1ldGVyRXJyb3IgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBhcmFtZXRlckVycm9yLCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gUGFyYW1ldGVyRXJyb3IoKSB7XG4gICAgICBfcmVmMSA9IFBhcmFtZXRlckVycm9yLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIF9yZWYxO1xuICAgIH1cblxuICAgIHJldHVybiBQYXJhbWV0ZXJFcnJvcjtcblxuICB9KShNYXJrZWRZQU1MRXJyb3IpO1xuXG4gIC8qXG4gIFRoZSBUcmFpdHMgY2xhc3MgZGVhbHMgd2l0aCBhcHBseWluZyB0cmFpdHMgdG8gcmVzb3VyY2VzIGFjY29yZGluZyB0byB0aGUgc3BlY1xuICAqL1xuXG5cbiAgdGhpcy5UcmFpdHMgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gVHJhaXRzKCkge1xuICAgICAgdGhpcy5kZWNsYXJlZFRyYWl0cyA9IHt9O1xuICAgIH1cblxuICAgIFRyYWl0cy5wcm90b3R5cGUubG9hZF90cmFpdHMgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgYWxsVHJhaXRzLFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG4gICAgICBpZiAodGhpcy5oYXNfcHJvcGVydHkobm9kZSwgJ3RyYWl0cycpKSB7XG4gICAgICAgIGFsbFRyYWl0cyA9IHRoaXMucHJvcGVydHlfdmFsdWUobm9kZSwgJ3RyYWl0cycpO1xuICAgICAgICBpZiAoYWxsVHJhaXRzICYmIHR5cGVvZiBhbGxUcmFpdHMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICByZXR1cm4gYWxsVHJhaXRzLmZvckVhY2goZnVuY3Rpb24odHJhaXRfaXRlbSkge1xuICAgICAgICAgICAgaWYgKHRyYWl0X2l0ZW0gJiYgdHlwZW9mIHRyYWl0X2l0ZW0gPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHRyYWl0X2l0ZW0udmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRyYWl0X2l0ZW0udmFsdWUuZm9yRWFjaChmdW5jdGlvbih0cmFpdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5kZWNsYXJlZFRyYWl0c1t0cmFpdFswXS52YWx1ZV0gPSB0cmFpdDtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVHJhaXRzLnByb3RvdHlwZS5oYXNfdHJhaXRzID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgaWYgKHRoaXMuZGVjbGFyZWRUcmFpdHMubGVuZ3RoID09PSAwICYmIHRoaXMuaGFzX3Byb3BlcnR5KG5vZGUsICd0cmFpdHMnKSkge1xuICAgICAgICB0aGlzLmxvYWRfdHJhaXRzKG5vZGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuZGVjbGFyZWRUcmFpdHMpLmxlbmd0aCA+IDA7XG4gICAgfTtcblxuICAgIFRyYWl0cy5wcm90b3R5cGUuZ2V0X3RyYWl0ID0gZnVuY3Rpb24odHJhaXROYW1lKSB7XG4gICAgICBpZiAodHJhaXROYW1lIGluIHRoaXMuZGVjbGFyZWRUcmFpdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjbGFyZWRUcmFpdHNbdHJhaXROYW1lXVsxXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBUcmFpdHMucHJvdG90eXBlLmFwcGx5X3RyYWl0cyA9IGZ1bmN0aW9uKG5vZGUsIHJlc291cmNlVXJpLCByZW1vdmVRcykge1xuICAgICAgdmFyIHJlc291cmNlcyxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuICAgICAgaWYgKHJlc291cmNlVXJpID09IG51bGwpIHtcbiAgICAgICAgcmVzb3VyY2VVcmkgPSBcIlwiO1xuICAgICAgfVxuICAgICAgaWYgKHJlbW92ZVFzID09IG51bGwpIHtcbiAgICAgICAgcmVtb3ZlUXMgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKCF1dGlsLmlzTWFwcGluZyhub2RlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5oYXNfdHJhaXRzKG5vZGUpKSB7XG4gICAgICAgIHJlc291cmNlcyA9IHRoaXMuY2hpbGRfcmVzb3VyY2VzKG5vZGUpO1xuICAgICAgICByZXR1cm4gcmVzb3VyY2VzLmZvckVhY2goZnVuY3Rpb24ocmVzb3VyY2UpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuYXBwbHlfdHJhaXRzX3RvX3Jlc291cmNlKHJlc291cmNlVXJpICsgcmVzb3VyY2VbMF0udmFsdWUsIHJlc291cmNlWzFdLCByZW1vdmVRcyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBUcmFpdHMucHJvdG90eXBlLmFwcGx5X3RyYWl0c190b19yZXNvdXJjZSA9IGZ1bmN0aW9uKHJlc291cmNlVXJpLCByZXNvdXJjZSwgcmVtb3ZlUXMpIHtcbiAgICAgIHZhciBtZXRob2RzLCB1c2VzLFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG4gICAgICBpZiAoIXV0aWwuaXNNYXBwaW5nKHJlc291cmNlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBtZXRob2RzID0gdGhpcy5jaGlsZF9tZXRob2RzKHJlc291cmNlKTtcbiAgICAgIGlmICh0aGlzLmhhc19wcm9wZXJ0eShyZXNvdXJjZSwgJ2lzJykpIHtcbiAgICAgICAgdXNlcyA9IHRoaXMucHJvcGVydHlfdmFsdWUocmVzb3VyY2UsICdpcycpO1xuICAgICAgICB1c2VzLmZvckVhY2goZnVuY3Rpb24odXNlKSB7XG4gICAgICAgICAgcmV0dXJuIG1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5hcHBseV90cmFpdChyZXNvdXJjZVVyaSwgbWV0aG9kLCB1c2UpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIG1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgaWYgKF90aGlzLmhhc19wcm9wZXJ0eShtZXRob2RbMV0sICdpcycpKSB7XG4gICAgICAgICAgdXNlcyA9IF90aGlzLnByb3BlcnR5X3ZhbHVlKG1ldGhvZFsxXSwgJ2lzJyk7XG4gICAgICAgICAgcmV0dXJuIHVzZXMuZm9yRWFjaChmdW5jdGlvbih1c2UpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5hcHBseV90cmFpdChyZXNvdXJjZVVyaSwgbWV0aG9kLCB1c2UpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChyZW1vdmVRcykge1xuICAgICAgICByZXNvdXJjZS5yZW1vdmVfcXVlc3Rpb25fbWFya19wcm9wZXJ0aWVzKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5hcHBseV90cmFpdHMocmVzb3VyY2UsIHJlc291cmNlVXJpLCByZW1vdmVRcyk7XG4gICAgfTtcblxuICAgIFRyYWl0cy5wcm90b3R5cGUuYXBwbHlfdHJhaXQgPSBmdW5jdGlvbihyZXNvdXJjZVVyaSwgbWV0aG9kLCB1c2VLZXkpIHtcbiAgICAgIHZhciBwbGFpblBhcmFtZXRlcnMsIHRlbXAsIHRyYWl0LCB0cmFpdE5hbWU7XG4gICAgICB0cmFpdE5hbWUgPSB0aGlzLmtleV9vcl92YWx1ZSh1c2VLZXkpO1xuICAgICAgaWYgKCEodHJhaXROYW1lICE9IG51bGwgPyB0cmFpdE5hbWUudHJpbSgpIDogdm9pZCAwKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5UcmFpdEVycm9yKCd3aGlsZSBhcHBseWluZyB0cmFpdCcsIG51bGwsICd0cmFpdCBuYW1lIG11c3QgYmUgcHJvdmlkZWQnLCB1c2VLZXkuc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICBpZiAoISh0cmFpdCA9IHRoaXMuZ2V0X3RyYWl0KHRyYWl0TmFtZSkpKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlRyYWl0RXJyb3IoJ3doaWxlIGFwcGx5aW5nIHRyYWl0JywgbnVsbCwgXCJ0aGVyZSBpcyBubyB0cmFpdCBuYW1lZCBcIiArIHRyYWl0TmFtZSwgdXNlS2V5LnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgcGxhaW5QYXJhbWV0ZXJzID0gdGhpcy5nZXRfcGFyYW1ldGVyc19mcm9tX2lzX2tleShyZXNvdXJjZVVyaSwgbWV0aG9kWzBdLnZhbHVlLCB1c2VLZXkpO1xuICAgICAgdGVtcCA9IHRyYWl0LmNsb25lRm9yVHJhaXQoKTtcbiAgICAgIHRoaXMuYXBwbHlfcGFyYW1ldGVycyh0ZW1wLCBwbGFpblBhcmFtZXRlcnMsIHVzZUtleSk7XG4gICAgICB0aGlzLmFwcGx5X2RlZmF1bHRfbWVkaWFfdHlwZV90b19tZXRob2QodGVtcCk7XG4gICAgICB0ZW1wLmNvbWJpbmUobWV0aG9kWzFdKTtcbiAgICAgIHJldHVybiBtZXRob2RbMV0gPSB0ZW1wO1xuICAgIH07XG5cbiAgICBUcmFpdHMucHJvdG90eXBlLmFwcGx5X3BhcmFtZXRlcnMgPSBmdW5jdGlvbihyZXNvdXJjZSwgcGFyYW1ldGVycywgdXNlS2V5KSB7XG4gICAgICB2YXIgcGFyYW1ldGVyTmFtZSwgdXNlZFBhcmFtZXRlcnMsIF9yZXN1bHRzO1xuICAgICAgdGhpcy5fYXBwbHlfcGFyYW1ldGVycyhyZXNvdXJjZSwgcGFyYW1ldGVycywgdXNlS2V5LCB1c2VkUGFyYW1ldGVycyA9IHtcbiAgICAgICAgcmVzb3VyY2VQYXRoOiB0cnVlLFxuICAgICAgICByZXNvdXJjZVBhdGhOYW1lOiB0cnVlLFxuICAgICAgICBtZXRob2ROYW1lOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKHBhcmFtZXRlck5hbWUgaW4gcGFyYW1ldGVycykge1xuICAgICAgICBpZiAoIXVzZWRQYXJhbWV0ZXJzW3BhcmFtZXRlck5hbWVdKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuUGFyYW1ldGVyRXJyb3IoJ3doaWxlIGFwcGx5aW5nIHBhcmFtZXRlcnMnLCBudWxsLCBcInVudXNlZCBwYXJhbWV0ZXI6IFwiICsgcGFyYW1ldGVyTmFtZSwgdXNlS2V5LnN0YXJ0X21hcmspO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2godm9pZCAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH07XG5cbiAgICBUcmFpdHMucHJvdG90eXBlLl9hcHBseV9wYXJhbWV0ZXJzID0gZnVuY3Rpb24ocmVzb3VyY2UsIHBhcmFtZXRlcnMsIHVzZUtleSwgdXNlZFBhcmFtZXRlcnMpIHtcbiAgICAgIHZhciBwYXJhbWV0ZXJVc2UsXG4gICAgICAgIF90aGlzID0gdGhpcztcbiAgICAgIGlmICghcmVzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHV0aWwuaXNTdHJpbmcocmVzb3VyY2UpKSB7XG4gICAgICAgIGlmIChwYXJhbWV0ZXJVc2UgPSByZXNvdXJjZS52YWx1ZS5tYXRjaCgvPDxcXHMqKFteXFx8XFxzPl0rKVxccyooXFx8LiopP1xccyo+Pi9nKSkge1xuICAgICAgICAgIHBhcmFtZXRlclVzZS5mb3JFYWNoKGZ1bmN0aW9uKHBhcmFtZXRlcikge1xuICAgICAgICAgICAgdmFyIG1ldGhvZCwgcGFyYW1ldGVyTmFtZSwgdmFsdWUsIF9yZWYyLCBfcmVmMztcbiAgICAgICAgICAgIHBhcmFtZXRlck5hbWUgPSBwYXJhbWV0ZXIgIT0gbnVsbCA/IChfcmVmMiA9IHBhcmFtZXRlci50cmltKCkpICE9IG51bGwgPyBfcmVmMi5yZXBsYWNlKC9bPD5dKy9nLCAnJykudHJpbSgpIDogdm9pZCAwIDogdm9pZCAwO1xuICAgICAgICAgICAgX3JlZjMgPSBwYXJhbWV0ZXJOYW1lLnNwbGl0KC9cXHMqXFx8XFxzKi8pLCBwYXJhbWV0ZXJOYW1lID0gX3JlZjNbMF0sIG1ldGhvZCA9IF9yZWYzWzFdO1xuICAgICAgICAgICAgaWYgKCEocGFyYW1ldGVyTmFtZSBpbiBwYXJhbWV0ZXJzKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5QYXJhbWV0ZXJFcnJvcignd2hpbGUgYXBwbHlpbmcgcGFyYW1ldGVycycsIG51bGwsIFwidmFsdWUgd2FzIG5vdCBwcm92aWRlZCBmb3IgcGFyYW1ldGVyOiBcIiArIHBhcmFtZXRlck5hbWUsIHVzZUtleS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlID0gcGFyYW1ldGVyc1twYXJhbWV0ZXJOYW1lXTtcbiAgICAgICAgICAgIHVzZWRQYXJhbWV0ZXJzW3BhcmFtZXRlck5hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChtZXRob2QpIHtcbiAgICAgICAgICAgICAgaWYgKG1ldGhvZC5tYXRjaCgvIVxccypzaW5ndWxhcml6ZS8pKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBpbmZsZWN0aW9uLnNpbmd1bGFyaXplKHZhbHVlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChtZXRob2QubWF0Y2goLyFcXHMqcGx1cmFsaXplLykpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGluZmxlY3Rpb24ucGx1cmFsaXplKHZhbHVlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5QYXJhbWV0ZXJFcnJvcignd2hpbGUgdmFsaWRhdGluZyBwYXJhbWV0ZXInLCBudWxsLCAndW5rbm93biBmdW5jdGlvbiBhcHBsaWVkIHRvIHBhcmFtZXRlcicsIHJlc291cmNlLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzb3VyY2UudmFsdWUgPSByZXNvdXJjZS52YWx1ZS5yZXBsYWNlKHBhcmFtZXRlciwgdmFsdWUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh1dGlsLmlzU2VxdWVuY2UocmVzb3VyY2UpKSB7XG4gICAgICAgIHJlc291cmNlLnZhbHVlLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5fYXBwbHlfcGFyYW1ldGVycyhub2RlLCBwYXJhbWV0ZXJzLCB1c2VLZXksIHVzZWRQYXJhbWV0ZXJzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh1dGlsLmlzTWFwcGluZyhyZXNvdXJjZSkpIHtcbiAgICAgICAgcmVzb3VyY2UudmFsdWUuZm9yRWFjaChmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgICAgICAgIF90aGlzLl9hcHBseV9wYXJhbWV0ZXJzKHByb3BlcnR5WzBdLCBwYXJhbWV0ZXJzLCB1c2VLZXksIHVzZWRQYXJhbWV0ZXJzKTtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuX2FwcGx5X3BhcmFtZXRlcnMocHJvcGVydHlbMV0sIHBhcmFtZXRlcnMsIHVzZUtleSwgdXNlZFBhcmFtZXRlcnMpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVHJhaXRzLnByb3RvdHlwZS5nZXRfcGFyYW1ldGVyc19mcm9tX2lzX2tleSA9IGZ1bmN0aW9uKHJlc291cmNlVXJpLCBtZXRob2ROYW1lLCB0eXBlS2V5KSB7XG4gICAgICB2YXIgcGFyYW1ldGVyLCBwYXJhbWV0ZXJzLCByZXNlcnZlZCwgcmVzdWx0LCBfaSwgX2xlbiwgX3JlZjI7XG4gICAgICByZXN1bHQgPSB7fTtcbiAgICAgIHJlc2VydmVkID0ge1xuICAgICAgICBtZXRob2ROYW1lOiBtZXRob2ROYW1lLFxuICAgICAgICByZXNvdXJjZVBhdGg6IHJlc291cmNlVXJpLnJlcGxhY2UoL1xcL1xcLyovZywgJy8nKSxcbiAgICAgICAgcmVzb3VyY2VQYXRoTmFtZTogdGhpcy5leHRyYWN0UmVzb3VyY2VQYXRoTmFtZShyZXNvdXJjZVVyaSlcbiAgICAgIH07XG4gICAgICBpZiAodXRpbC5pc01hcHBpbmcodHlwZUtleSkpIHtcbiAgICAgICAgcGFyYW1ldGVycyA9IHRoaXMudmFsdWVfb3JfdW5kZWZpbmVkKHR5cGVLZXkpO1xuICAgICAgICBpZiAodXRpbC5pc01hcHBpbmcocGFyYW1ldGVyc1swXVsxXSkpIHtcbiAgICAgICAgICBfcmVmMiA9IHBhcmFtZXRlcnNbMF1bMV0udmFsdWU7XG4gICAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgICAgcGFyYW1ldGVyID0gX3JlZjJbX2ldO1xuICAgICAgICAgICAgaWYgKHBhcmFtZXRlclswXS52YWx1ZSBpbiByZXNlcnZlZCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5UcmFpdEVycm9yKCd3aGlsZSBhcHBseWluZyBwYXJhbWV0ZXJzJywgbnVsbCwgXCJpbnZhbGlkIHBhcmFtZXRlciBuYW1lOiBcIiArIHBhcmFtZXRlclswXS52YWx1ZSArIFwiIGlzIHJlc2VydmVkXCIsIHBhcmFtZXRlclswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFtwYXJhbWV0ZXJbMF0udmFsdWVdID0gcGFyYW1ldGVyWzFdLnZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHV0aWwuZXh0ZW5kKHJlc3VsdCwgcmVzZXJ2ZWQpO1xuICAgIH07XG5cbiAgICBUcmFpdHMucHJvdG90eXBlLmV4dHJhY3RSZXNvdXJjZVBhdGhOYW1lID0gZnVuY3Rpb24ocmVzb3VyY2VVcmkpIHtcbiAgICAgIHZhciBwYXRoU2VnbWVudHMsIHNlZ21lbnQ7XG4gICAgICBwYXRoU2VnbWVudHMgPSByZXNvdXJjZVVyaS5zcGxpdCgvXFwvLyk7XG4gICAgICB3aGlsZSAoc2VnbWVudCA9IHBhdGhTZWdtZW50cy5wb3AoKSkge1xuICAgICAgICBpZiAoISh0eXBlb2Ygc2VnbWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWdtZW50ICE9PSBudWxsID8gc2VnbWVudC5tYXRjaCgvW3t9XS8pIDogdm9pZCAwKSkge1xuICAgICAgICAgIHJldHVybiBzZWdtZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFRyYWl0cztcblxuICB9KSgpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiKGZ1bmN0aW9uKCkge1xuICB2YXIgbm9kZXMsIHVyaXRlbXBsYXRlLCB1dGlsLFxuICAgIF9fYmluZCA9IGZ1bmN0aW9uKGZuLCBtZSl7IHJldHVybiBmdW5jdGlvbigpeyByZXR1cm4gZm4uYXBwbHkobWUsIGFyZ3VtZW50cyk7IH07IH07XG5cbiAgdXJpdGVtcGxhdGUgPSByZXF1aXJlKCd1cml0ZW1wbGF0ZScpO1xuXG4gIG5vZGVzID0gcmVxdWlyZSgnLi9ub2RlcycpO1xuXG4gIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuICAvKlxuICAgICBBcHBsaWVzIHRyYW5zZm9ybWF0aW9ucyB0byB0aGUgUkFNTFxuICAqL1xuXG5cbiAgdGhpcy5UcmFuc2Zvcm1hdGlvbnMgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gVHJhbnNmb3JtYXRpb25zKHNldHRpbmdzKSB7XG4gICAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgICB0aGlzLmlzQ29udGVudFR5cGVTdHJpbmcgPSBfX2JpbmQodGhpcy5pc0NvbnRlbnRUeXBlU3RyaW5nLCB0aGlzKTtcbiAgICAgIHRoaXMuYWRkX2tleV92YWx1ZV90b19ub2RlID0gX19iaW5kKHRoaXMuYWRkX2tleV92YWx1ZV90b19ub2RlLCB0aGlzKTtcbiAgICAgIHRoaXMuYXBwbHlfZGVmYXVsdF9tZWRpYV90eXBlX3RvX3Jlc291cmNlID0gX19iaW5kKHRoaXMuYXBwbHlfZGVmYXVsdF9tZWRpYV90eXBlX3RvX3Jlc291cmNlLCB0aGlzKTtcbiAgICAgIHRoaXMuZ2V0X21lZGlhX3R5cGUgPSBfX2JpbmQodGhpcy5nZXRfbWVkaWFfdHlwZSwgdGhpcyk7XG4gICAgICB0aGlzLmxvYWRfZGVmYXVsdF9tZWRpYV90eXBlID0gX19iaW5kKHRoaXMubG9hZF9kZWZhdWx0X21lZGlhX3R5cGUsIHRoaXMpO1xuICAgICAgdGhpcy5hcHBseUFzdFRyYW5zZm9ybWF0aW9ucyA9IF9fYmluZCh0aGlzLmFwcGx5QXN0VHJhbnNmb3JtYXRpb25zLCB0aGlzKTtcbiAgICAgIHRoaXMuYXBwbHlUcmFuc2Zvcm1hdGlvbnMgPSBfX2JpbmQodGhpcy5hcHBseVRyYW5zZm9ybWF0aW9ucywgdGhpcyk7XG4gICAgICB0aGlzLmRlY2xhcmVkU2NoZW1hcyA9IHt9O1xuICAgIH1cblxuICAgIFRyYW5zZm9ybWF0aW9ucy5wcm90b3R5cGUuYXBwbHlUcmFuc2Zvcm1hdGlvbnMgPSBmdW5jdGlvbihyb290T2JqZWN0KSB7XG4gICAgICB2YXIgcmVzb3VyY2VzO1xuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudHJhbnNmb3JtKSB7XG4gICAgICAgIHRoaXMuYXBwbHlUcmFuc2Zvcm1hdGlvbnNUb1Jvb3Qocm9vdE9iamVjdCk7XG4gICAgICAgIHJlc291cmNlcyA9IHJvb3RPYmplY3QucmVzb3VyY2VzO1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBseVRyYW5zZm9ybWF0aW9uc1RvUmVzb3VyY2VzKHJvb3RPYmplY3QsIHJlc291cmNlcyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFRyYW5zZm9ybWF0aW9ucy5wcm90b3R5cGUuYXBwbHlBc3RUcmFuc2Zvcm1hdGlvbnMgPSBmdW5jdGlvbihkb2N1bWVudCkge1xuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudHJhbnNmb3JtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybV9kb2N1bWVudChkb2N1bWVudCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFRyYW5zZm9ybWF0aW9ucy5wcm90b3R5cGUubG9hZF9kZWZhdWx0X21lZGlhX3R5cGUgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICBpZiAoIXV0aWwuaXNNYXBwaW5nKG5vZGUgfHwgKG5vZGUgIT0gbnVsbCA/IG5vZGUudmFsdWUgOiB2b2lkIDApKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5tZWRpYVR5cGUgPSB0aGlzLnByb3BlcnR5X3ZhbHVlKG5vZGUsICdtZWRpYVR5cGUnKTtcbiAgICB9O1xuXG4gICAgVHJhbnNmb3JtYXRpb25zLnByb3RvdHlwZS5nZXRfbWVkaWFfdHlwZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWVkaWFUeXBlO1xuICAgIH07XG5cbiAgICBUcmFuc2Zvcm1hdGlvbnMucHJvdG90eXBlLmFwcGx5VHJhbnNmb3JtYXRpb25zVG9Sb290ID0gZnVuY3Rpb24ocm9vdE9iamVjdCkge1xuICAgICAgdmFyIGV4cHJlc3Npb25zLCB0ZW1wbGF0ZTtcbiAgICAgIGlmIChyb290T2JqZWN0LmJhc2VVcmkpIHtcbiAgICAgICAgdGVtcGxhdGUgPSB1cml0ZW1wbGF0ZS5wYXJzZShyb290T2JqZWN0LmJhc2VVcmkpO1xuICAgICAgICBleHByZXNzaW9ucyA9IHRlbXBsYXRlLmV4cHJlc3Npb25zLmZpbHRlcihmdW5jdGlvbihleHByKSB7XG4gICAgICAgICAgcmV0dXJuICd0ZW1wbGF0ZVRleHQnIGluIGV4cHI7XG4gICAgICAgIH0pLm1hcChmdW5jdGlvbihleHByZXNzaW9uKSB7XG4gICAgICAgICAgcmV0dXJuIGV4cHJlc3Npb24udGVtcGxhdGVUZXh0O1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb25zLmxlbmd0aCkge1xuICAgICAgICAgIGlmICghcm9vdE9iamVjdC5iYXNlVXJpUGFyYW1ldGVycykge1xuICAgICAgICAgICAgcm9vdE9iamVjdC5iYXNlVXJpUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbnMuZm9yRWFjaChmdW5jdGlvbihwYXJhbWV0ZXJOYW1lKSB7XG4gICAgICAgICAgaWYgKCEocGFyYW1ldGVyTmFtZSBpbiByb290T2JqZWN0LmJhc2VVcmlQYXJhbWV0ZXJzKSkge1xuICAgICAgICAgICAgcm9vdE9iamVjdC5iYXNlVXJpUGFyYW1ldGVyc1twYXJhbWV0ZXJOYW1lXSA9IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICAgICAgICAgIGRpc3BsYXlOYW1lOiBwYXJhbWV0ZXJOYW1lXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHBhcmFtZXRlck5hbWUgPT09IFwidmVyc2lvblwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiByb290T2JqZWN0LmJhc2VVcmlQYXJhbWV0ZXJzW3BhcmFtZXRlck5hbWVdW1wiZW51bVwiXSA9IFtyb290T2JqZWN0LnZlcnNpb25dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFRyYW5zZm9ybWF0aW9ucy5wcm90b3R5cGUuYXBwbHlUcmFuc2Zvcm1hdGlvbnNUb1Jlc291cmNlcyA9IGZ1bmN0aW9uKHJvb3RPYmplY3QsIHJlc291cmNlcykge1xuICAgICAgdmFyIGV4cHJlc3Npb25zLCBpbmhlcml0ZWRTZWNTY2hlbWUsIG1ldGhvZCwgcGFyYW1ldGVyTmFtZSwgcGF0aFBhcnRzLCByZXNvdXJjZSwgdGVtcGxhdGUsIF9pLCBfaiwgX2ssIF9sZW4sIF9sZW4xLCBfbGVuMiwgX3JlZiwgX3JlZjEsIF9yZXN1bHRzO1xuICAgICAgaWYgKHJlc291cmNlcyAhPSBudWxsID8gcmVzb3VyY2VzLmxlbmd0aCA6IHZvaWQgMCkge1xuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IHJlc291cmNlcy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIHJlc291cmNlID0gcmVzb3VyY2VzW19pXTtcbiAgICAgICAgICBpbmhlcml0ZWRTZWNTY2hlbWUgPSByZXNvdXJjZS5zZWN1cmVkQnkgPyByZXNvdXJjZS5zZWN1cmVkQnkgOiByb290T2JqZWN0ICE9IG51bGwgPyByb290T2JqZWN0LnNlY3VyZWRCeSA6IHZvaWQgMDtcbiAgICAgICAgICBpZiAoKF9yZWYgPSByZXNvdXJjZS5tZXRob2RzKSAhPSBudWxsID8gX3JlZi5sZW5ndGggOiB2b2lkIDApIHtcbiAgICAgICAgICAgIF9yZWYxID0gcmVzb3VyY2UubWV0aG9kcztcbiAgICAgICAgICAgIGZvciAoX2ogPSAwLCBfbGVuMSA9IF9yZWYxLmxlbmd0aDsgX2ogPCBfbGVuMTsgX2orKykge1xuICAgICAgICAgICAgICBtZXRob2QgPSBfcmVmMVtfal07XG4gICAgICAgICAgICAgIGlmICghKFwic2VjdXJlZEJ5XCIgaW4gbWV0aG9kKSkge1xuICAgICAgICAgICAgICAgIGlmIChpbmhlcml0ZWRTZWNTY2hlbWUpIHtcbiAgICAgICAgICAgICAgICAgIG1ldGhvZC5zZWN1cmVkQnkgPSBpbmhlcml0ZWRTZWNTY2hlbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhdGhQYXJ0cyA9IHJlc291cmNlLnJlbGF0aXZlVXJpLnNwbGl0KCdcXC8nKTtcbiAgICAgICAgICB3aGlsZSAoIXBhdGhQYXJ0c1swXSAmJiBwYXRoUGFydHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBwYXRoUGFydHMuc2hpZnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb3VyY2UucmVsYXRpdmVVcmlQYXRoU2VnbWVudHMgPSBwYXRoUGFydHM7XG4gICAgICAgICAgdGVtcGxhdGUgPSB1cml0ZW1wbGF0ZS5wYXJzZShyZXNvdXJjZS5yZWxhdGl2ZVVyaSk7XG4gICAgICAgICAgZXhwcmVzc2lvbnMgPSB0ZW1wbGF0ZS5leHByZXNzaW9ucy5maWx0ZXIoZnVuY3Rpb24oZXhwcikge1xuICAgICAgICAgICAgcmV0dXJuICd0ZW1wbGF0ZVRleHQnIGluIGV4cHI7XG4gICAgICAgICAgfSkubWFwKGZ1bmN0aW9uKGV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIHJldHVybiBleHByZXNzaW9uLnRlbXBsYXRlVGV4dDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoZXhwcmVzc2lvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIXJlc291cmNlLnVyaVBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgICAgcmVzb3VyY2UudXJpUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKF9rID0gMCwgX2xlbjIgPSBleHByZXNzaW9ucy5sZW5ndGg7IF9rIDwgX2xlbjI7IF9rKyspIHtcbiAgICAgICAgICAgIHBhcmFtZXRlck5hbWUgPSBleHByZXNzaW9uc1tfa107XG4gICAgICAgICAgICBpZiAoIShwYXJhbWV0ZXJOYW1lIGluIHJlc291cmNlLnVyaVBhcmFtZXRlcnMpKSB7XG4gICAgICAgICAgICAgIHJlc291cmNlLnVyaVBhcmFtZXRlcnNbcGFyYW1ldGVyTmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkaXNwbGF5TmFtZTogcGFyYW1ldGVyTmFtZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKHRoaXMuYXBwbHlUcmFuc2Zvcm1hdGlvbnNUb1Jlc291cmNlcyhyb290T2JqZWN0LCByZXNvdXJjZS5yZXNvdXJjZXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qXG4gICAgTWVkaWEgVHlwZSBwaXZvdCB3aGVuIHVzaW5nIGRlZmF1bHQgbWVkaWFUeXBlIHByb3BlcnR5XG4gICAgKi9cblxuXG4gICAgVHJhbnNmb3JtYXRpb25zLnByb3RvdHlwZS5hcHBseV9kZWZhdWx0X21lZGlhX3R5cGVfdG9fcmVzb3VyY2UgPSBmdW5jdGlvbihyZXNvdXJjZSkge1xuICAgICAgdmFyIGNoaWxkUmVzb3VyY2UsIG1ldGhvZCwgX2ksIF9qLCBfbGVuLCBfbGVuMSwgX3JlZiwgX3JlZjEsIF9yZXN1bHRzO1xuICAgICAgaWYgKCF0aGlzLm1lZGlhVHlwZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXV0aWwuaXNNYXBwaW5nKHJlc291cmNlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBfcmVmID0gdGhpcy5jaGlsZF9yZXNvdXJjZXMocmVzb3VyY2UpO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGNoaWxkUmVzb3VyY2UgPSBfcmVmW19pXTtcbiAgICAgICAgdGhpcy5hcHBseV9kZWZhdWx0X21lZGlhX3R5cGVfdG9fcmVzb3VyY2UoY2hpbGRSZXNvdXJjZVsxXSk7XG4gICAgICB9XG4gICAgICBfcmVmMSA9IHRoaXMuY2hpbGRfbWV0aG9kcyhyZXNvdXJjZSk7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChfaiA9IDAsIF9sZW4xID0gX3JlZjEubGVuZ3RoOyBfaiA8IF9sZW4xOyBfaisrKSB7XG4gICAgICAgIG1ldGhvZCA9IF9yZWYxW19qXTtcbiAgICAgICAgX3Jlc3VsdHMucHVzaCh0aGlzLmFwcGx5X2RlZmF1bHRfbWVkaWFfdHlwZV90b19tZXRob2QobWV0aG9kWzFdKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfTtcblxuICAgIFRyYW5zZm9ybWF0aW9ucy5wcm90b3R5cGUuYXBwbHlfZGVmYXVsdF9tZWRpYV90eXBlX3RvX21ldGhvZCA9IGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgdmFyIHJlc3BvbnNlcyxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuICAgICAgaWYgKCF0aGlzLm1lZGlhVHlwZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXV0aWwuaXNNYXBwaW5nKG1ldGhvZCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaGFzX3Byb3BlcnR5KG1ldGhvZCwgJ2JvZHknKSkge1xuICAgICAgICB0aGlzLmFwcGx5X2RlZmF1bHRfbWVkaWFfdHlwZV90b19ib2R5KHRoaXMuZ2V0X3Byb3BlcnR5KG1ldGhvZCwgJ2JvZHknKSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5oYXNfcHJvcGVydHkobWV0aG9kLCAncmVzcG9uc2VzJykpIHtcbiAgICAgICAgcmVzcG9uc2VzID0gdGhpcy5nZXRfcHJvcGVydHkobWV0aG9kLCAncmVzcG9uc2VzJyk7XG4gICAgICAgIGlmICghKHJlc3BvbnNlcyAmJiByZXNwb25zZXMudmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZXMudmFsdWUuZm9yRWFjaChmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgIGlmIChfdGhpcy5oYXNfcHJvcGVydHkocmVzcG9uc2VbMV0sICdib2R5JykpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5hcHBseV9kZWZhdWx0X21lZGlhX3R5cGVfdG9fYm9keShfdGhpcy5nZXRfcHJvcGVydHkocmVzcG9uc2VbMV0sICdib2R5JykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFRyYW5zZm9ybWF0aW9ucy5wcm90b3R5cGUuYXBwbHlfZGVmYXVsdF9tZWRpYV90eXBlX3RvX2JvZHkgPSBmdW5jdGlvbihib2R5KSB7XG4gICAgICB2YXIga2V5LCByZXNwb25zZVR5cGUsIHJlc3BvbnNlVHlwZUtleSwgX3JlZiwgX3JlZjEsIF9yZWYyO1xuICAgICAgaWYgKCF1dGlsLmlzTWFwcGluZyhib2R5KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoYm9keSAhPSBudWxsID8gKF9yZWYgPSBib2R5LnZhbHVlKSAhPSBudWxsID8gKF9yZWYxID0gX3JlZlswXSkgIT0gbnVsbCA/IChfcmVmMiA9IF9yZWYxWzBdKSAhPSBudWxsID8gX3JlZjIudmFsdWUgOiB2b2lkIDAgOiB2b2lkIDAgOiB2b2lkIDAgOiB2b2lkIDApIHtcbiAgICAgICAga2V5ID0gYm9keS52YWx1ZVswXVswXS52YWx1ZTtcbiAgICAgICAgaWYgKCFrZXkubWF0Y2goL1xcLy8pKSB7XG4gICAgICAgICAgcmVzcG9uc2VUeXBlID0gbmV3IG5vZGVzLk1hcHBpbmdOb2RlKCd0YWc6eWFtbC5vcmcsMjAwMjptYXAnLCBbXSwgYm9keS5zdGFydF9tYXJrLCBib2R5LmVuZF9tYXJrKTtcbiAgICAgICAgICByZXNwb25zZVR5cGVLZXkgPSBuZXcgbm9kZXMuU2NhbGFyTm9kZSgndGFnOnlhbWwub3JnLDIwMDI6c3RyJywgdGhpcy5tZWRpYVR5cGUsIGJvZHkuc3RhcnRfbWFyaywgYm9keS5lbmRfbWFyayk7XG4gICAgICAgICAgcmVzcG9uc2VUeXBlLnZhbHVlLnB1c2goW3Jlc3BvbnNlVHlwZUtleSwgYm9keS5jbG9uZSgpXSk7XG4gICAgICAgICAgcmV0dXJuIGJvZHkudmFsdWUgPSByZXNwb25zZVR5cGUudmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVHJhbnNmb3JtYXRpb25zLnByb3RvdHlwZS5ub29wID0gZnVuY3Rpb24oKSB7fTtcblxuICAgIFRyYW5zZm9ybWF0aW9ucy5wcm90b3R5cGUudHJhbnNmb3JtX3R5cGVzID0gZnVuY3Rpb24odHlwZVByb3BlcnR5KSB7XG4gICAgICB2YXIgdHlwZXMsXG4gICAgICAgIF90aGlzID0gdGhpcztcbiAgICAgIHR5cGVzID0gdHlwZVByb3BlcnR5LnZhbHVlO1xuICAgICAgcmV0dXJuIHR5cGVzLmZvckVhY2goZnVuY3Rpb24odHlwZV9lbnRyeSkge1xuICAgICAgICByZXR1cm4gdHlwZV9lbnRyeS52YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMudHJhbnNmb3JtX3Jlc291cmNlKHR5cGUsIHRydWUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBUcmFuc2Zvcm1hdGlvbnMucHJvdG90eXBlLnRyYW5zZm9ybV90cmFpdHMgPSBmdW5jdGlvbih0cmFpdFByb3BlcnR5KSB7XG4gICAgICB2YXIgdHJhaXRzLFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG4gICAgICB0cmFpdHMgPSB0cmFpdFByb3BlcnR5LnZhbHVlO1xuICAgICAgcmV0dXJuIHRyYWl0cy5mb3JFYWNoKGZ1bmN0aW9uKHRyYWl0X2VudHJ5KSB7XG4gICAgICAgIHJldHVybiB0cmFpdF9lbnRyeS52YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHRyYWl0KSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLnRyYW5zZm9ybV9tZXRob2QodHJhaXRbMV0sIHRydWUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBUcmFuc2Zvcm1hdGlvbnMucHJvdG90eXBlLnRyYW5zZm9ybV9uYW1lZF9wYXJhbXMgPSBmdW5jdGlvbihwcm9wZXJ0eSwgYWxsb3dQYXJhbWV0ZXJLZXlzLCByZXF1aXJlZEJ5RGVmYXVsdCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIGlmIChyZXF1aXJlZEJ5RGVmYXVsdCA9PSBudWxsKSB7XG4gICAgICAgIHJlcXVpcmVkQnlEZWZhdWx0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh1dGlsLmlzTnVsbChwcm9wZXJ0eVsxXSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb3BlcnR5WzFdLnZhbHVlLmZvckVhY2goZnVuY3Rpb24ocGFyYW0pIHtcbiAgICAgICAgaWYgKHV0aWwuaXNOdWxsKHBhcmFtWzFdKSkge1xuICAgICAgICAgIHBhcmFtWzFdID0gbmV3IG5vZGVzLk1hcHBpbmdOb2RlKCd0YWc6eWFtbC5vcmcsMjAwMjptYXAnLCBbXSwgcGFyYW1bMV0uc3RhcnRfbWFyaywgcGFyYW1bMV0uZW5kX21hcmspO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcy50cmFuc2Zvcm1fY29tbW9uX3BhcmFtZXRlcl9wcm9wZXJ0aWVzKHBhcmFtWzBdLnZhbHVlLCBwYXJhbVsxXSwgYWxsb3dQYXJhbWV0ZXJLZXlzLCByZXF1aXJlZEJ5RGVmYXVsdCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgVHJhbnNmb3JtYXRpb25zLnByb3RvdHlwZS50cmFuc2Zvcm1fY29tbW9uX3BhcmFtZXRlcl9wcm9wZXJ0aWVzID0gZnVuY3Rpb24ocGFyYW1ldGVyTmFtZSwgbm9kZSwgYWxsb3dQYXJhbWV0ZXJLZXlzLCByZXF1aXJlZEJ5RGVmYXVsdCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIGlmICh1dGlsLmlzU2VxdWVuY2Uobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUudmFsdWUuZm9yRWFjaChmdW5jdGlvbihwYXJhbWV0ZXIpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMudHJhbnNmb3JtX25hbWVkX3BhcmFtZXRlcihwYXJhbWV0ZXJOYW1lLCBwYXJhbWV0ZXIsIGFsbG93UGFyYW1ldGVyS2V5cywgcmVxdWlyZWRCeURlZmF1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybV9uYW1lZF9wYXJhbWV0ZXIocGFyYW1ldGVyTmFtZSwgbm9kZSwgYWxsb3dQYXJhbWV0ZXJLZXlzLCByZXF1aXJlZEJ5RGVmYXVsdCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFRyYW5zZm9ybWF0aW9ucy5wcm90b3R5cGUudHJhbnNmb3JtX25hbWVkX3BhcmFtZXRlciA9IGZ1bmN0aW9uKHBhcmFtZXRlck5hbWUsIG5vZGUsIGFsbG93UGFyYW1ldGVyS2V5cywgcmVxdWlyZWRCeURlZmF1bHQpIHtcbiAgICAgIHZhciBoYXNEaXNwbGF5TmFtZSwgaGFzUmVxdWlyZWQsIGhhc1R5cGUsXG4gICAgICAgIF90aGlzID0gdGhpcztcbiAgICAgIGhhc0Rpc3BsYXlOYW1lID0gZmFsc2U7XG4gICAgICBoYXNSZXF1aXJlZCA9IGZhbHNlO1xuICAgICAgaGFzVHlwZSA9IGZhbHNlO1xuICAgICAgbm9kZS52YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkTm9kZSkge1xuICAgICAgICB2YXIgY2Fub25pY2FsUHJvcGVydHlOYW1lO1xuICAgICAgICBpZiAoYWxsb3dQYXJhbWV0ZXJLZXlzICYmIF90aGlzLmlzUGFyYW1ldGVyS2V5KGNoaWxkTm9kZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2Fub25pY2FsUHJvcGVydHlOYW1lID0gX3RoaXMuY2Fub25pY2FsaXplUHJvcGVydHlOYW1lKGNoaWxkTm9kZVswXS52YWx1ZSwgYWxsb3dQYXJhbWV0ZXJLZXlzKTtcbiAgICAgICAgc3dpdGNoIChjYW5vbmljYWxQcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgICBjYXNlIFwicGF0dGVyblwiOlxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLm5vb3AoKTtcbiAgICAgICAgICBjYXNlIFwiZGVmYXVsdFwiOlxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLm5vb3AoKTtcbiAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLm5vb3AoKTtcbiAgICAgICAgICBjYXNlIFwiZGVzY3JpcHRpb25cIjpcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5ub29wKCk7XG4gICAgICAgICAgY2FzZSBcImV4YW1wbGVcIjpcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5ub29wKCk7XG4gICAgICAgICAgY2FzZSBcIm1pbkxlbmd0aFwiOlxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLm5vb3AoKTtcbiAgICAgICAgICBjYXNlIFwibWF4TGVuZ3RoXCI6XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMubm9vcCgpO1xuICAgICAgICAgIGNhc2UgXCJtaW5pbXVtXCI6XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMubm9vcCgpO1xuICAgICAgICAgIGNhc2UgXCJtYXhpbXVtXCI6XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMubm9vcCgpO1xuICAgICAgICAgIGNhc2UgXCJyZXBlYXRcIjpcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5ub29wKCk7XG4gICAgICAgICAgY2FzZSBcImRpc3BsYXlOYW1lXCI6XG4gICAgICAgICAgICByZXR1cm4gaGFzRGlzcGxheU5hbWUgPSB0cnVlO1xuICAgICAgICAgIGNhc2UgXCJ0eXBlXCI6XG4gICAgICAgICAgICByZXR1cm4gaGFzVHlwZSA9IHRydWU7XG4gICAgICAgICAgY2FzZSBcInJlcXVpcmVkXCI6XG4gICAgICAgICAgICByZXR1cm4gaGFzUmVxdWlyZWQgPSB0cnVlO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMubm9vcCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmICghaGFzRGlzcGxheU5hbWUpIHtcbiAgICAgICAgdGhpcy5hZGRfa2V5X3ZhbHVlX3RvX25vZGUobm9kZSwgJ2Rpc3BsYXlOYW1lJywgJ3RhZzp5YW1sLm9yZywyMDAyOnN0cicsIHRoaXMuY2Fub25pY2FsaXplUHJvcGVydHlOYW1lKHBhcmFtZXRlck5hbWUsIGFsbG93UGFyYW1ldGVyS2V5cykpO1xuICAgICAgfVxuICAgICAgaWYgKCFoYXNSZXF1aXJlZCkge1xuICAgICAgICBpZiAocmVxdWlyZWRCeURlZmF1bHQpIHtcbiAgICAgICAgICB0aGlzLmFkZF9rZXlfdmFsdWVfdG9fbm9kZShub2RlLCAncmVxdWlyZWQnLCAndGFnOnlhbWwub3JnLDIwMDI6Ym9vbCcsICd0cnVlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghaGFzVHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRfa2V5X3ZhbHVlX3RvX25vZGUobm9kZSwgJ3R5cGUnLCAndGFnOnlhbWwub3JnLDIwMDI6c3RyJywgJ3N0cmluZycpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBUcmFuc2Zvcm1hdGlvbnMucHJvdG90eXBlLmFkZF9rZXlfdmFsdWVfdG9fbm9kZSA9IGZ1bmN0aW9uKG5vZGUsIGtleU5hbWUsIHZhbHVlVGFnLCB2YWx1ZSkge1xuICAgICAgdmFyIHByb3BlcnR5TmFtZSwgcHJvcGVydHlWYWx1ZTtcbiAgICAgIHByb3BlcnR5TmFtZSA9IG5ldyBub2Rlcy5TY2FsYXJOb2RlKCd0YWc6eWFtbC5vcmcsMjAwMjpzdHInLCBrZXlOYW1lLCBub2RlLnN0YXJ0X21hcmssIG5vZGUuZW5kX21hcmspO1xuICAgICAgcHJvcGVydHlWYWx1ZSA9IG5ldyBub2Rlcy5TY2FsYXJOb2RlKHZhbHVlVGFnLCB2YWx1ZSwgbm9kZS5zdGFydF9tYXJrLCBub2RlLmVuZF9tYXJrKTtcbiAgICAgIHJldHVybiBub2RlLnZhbHVlLnB1c2goW3Byb3BlcnR5TmFtZSwgcHJvcGVydHlWYWx1ZV0pO1xuICAgIH07XG5cbiAgICBUcmFuc2Zvcm1hdGlvbnMucHJvdG90eXBlLnRyYW5zZm9ybV9kb2N1bWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICBpZiAobm9kZSAhPSBudWxsID8gbm9kZS52YWx1ZSA6IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gbm9kZS52YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgICAgICAgdmFyIF9yZWY7XG4gICAgICAgICAgc3dpdGNoIChwcm9wZXJ0eVswXS52YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSBcInRpdGxlXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy5ub29wKCk7XG4gICAgICAgICAgICBjYXNlIFwic2VjdXJpdHlTY2hlbWVzXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy5ub29wKCk7XG4gICAgICAgICAgICBjYXNlIFwic2NoZW1hc1wiOlxuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMubm9vcCgpO1xuICAgICAgICAgICAgY2FzZSBcInZlcnNpb25cIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLm5vb3AoKTtcbiAgICAgICAgICAgIGNhc2UgXCJkb2N1bWVudGF0aW9uXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy5ub29wKCk7XG4gICAgICAgICAgICBjYXNlIFwibWVkaWFUeXBlXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy5ub29wKCk7XG4gICAgICAgICAgICBjYXNlIFwic2VjdXJlZEJ5XCI6XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy5ub29wKCk7XG4gICAgICAgICAgICBjYXNlIFwiYmFzZVVyaVwiOlxuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMubm9vcCgpO1xuICAgICAgICAgICAgY2FzZSBcInRyYWl0c1wiOlxuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMudHJhbnNmb3JtX3RyYWl0cyhwcm9wZXJ0eVsxXSk7XG4gICAgICAgICAgICBjYXNlIFwiYmFzZVVyaVBhcmFtZXRlcnNcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnRyYW5zZm9ybV9uYW1lZF9wYXJhbXMocHJvcGVydHksIGZhbHNlKTtcbiAgICAgICAgICAgIGNhc2UgXCJyZXNvdXJjZVR5cGVzXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy50cmFuc2Zvcm1fdHlwZXMocHJvcGVydHlbMV0pO1xuICAgICAgICAgICAgY2FzZSBcInJlc291cmNlc1wiOlxuICAgICAgICAgICAgICByZXR1cm4gKF9yZWYgPSBwcm9wZXJ0eVsxXSkgIT0gbnVsbCA/IF9yZWYudmFsdWUuZm9yRWFjaChmdW5jdGlvbihyZXNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy50cmFuc2Zvcm1fcmVzb3VyY2UocmVzb3VyY2UpO1xuICAgICAgICAgICAgICB9KSA6IHZvaWQgMDtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy5ub29wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVHJhbnNmb3JtYXRpb25zLnByb3RvdHlwZS50cmFuc2Zvcm1fcmVzb3VyY2UgPSBmdW5jdGlvbihyZXNvdXJjZSwgYWxsb3dQYXJhbWV0ZXJLZXlzKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgaWYgKGFsbG93UGFyYW1ldGVyS2V5cyA9PSBudWxsKSB7XG4gICAgICAgIGFsbG93UGFyYW1ldGVyS2V5cyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHJlc291cmNlLnZhbHVlKSB7XG4gICAgICAgIHJldHVybiByZXNvdXJjZS52YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgICAgICAgdmFyIGNhbm9uaWNhbEtleSwgaXNLbm93bkNvbW1vblByb3BlcnR5LCBfcmVmLCBfcmVmMTtcbiAgICAgICAgICBpc0tub3duQ29tbW9uUHJvcGVydHkgPSBfdGhpcy50cmFuc2Zvcm1fY29tbW9uX3Byb3BlcnRpZXMocHJvcGVydHksIGFsbG93UGFyYW1ldGVyS2V5cyk7XG4gICAgICAgICAgaWYgKCFpc0tub3duQ29tbW9uUHJvcGVydHkpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5pc0h0dHBNZXRob2QocHJvcGVydHlbMF0udmFsdWUsIGFsbG93UGFyYW1ldGVyS2V5cykpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnRyYW5zZm9ybV9tZXRob2QocHJvcGVydHlbMV0sIGFsbG93UGFyYW1ldGVyS2V5cyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjYW5vbmljYWxLZXkgPSBfdGhpcy5jYW5vbmljYWxpemVQcm9wZXJ0eU5hbWUocHJvcGVydHlbMF0udmFsdWUsIGFsbG93UGFyYW1ldGVyS2V5cyk7XG4gICAgICAgICAgICAgIHN3aXRjaCAoY2Fub25pY2FsS2V5KSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInR5cGVcIjpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5ub29wKCk7XG4gICAgICAgICAgICAgICAgY2FzZSBcInVzYWdlXCI6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMubm9vcCgpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzZWN1cmVkQnlcIjpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5ub29wKCk7XG4gICAgICAgICAgICAgICAgY2FzZSBcInVyaVBhcmFtZXRlcnNcIjpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy50cmFuc2Zvcm1fbmFtZWRfcGFyYW1zKHByb3BlcnR5LCBhbGxvd1BhcmFtZXRlcktleXMpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJiYXNlVXJpUGFyYW1ldGVyc1wiOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnRyYW5zZm9ybV9uYW1lZF9wYXJhbXMocHJvcGVydHksIGFsbG93UGFyYW1ldGVyS2V5cyk7XG4gICAgICAgICAgICAgICAgY2FzZSBcInJlc291cmNlc1wiOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIChfcmVmID0gcHJvcGVydHlbMV0pICE9IG51bGwgPyBfcmVmLnZhbHVlLmZvckVhY2goZnVuY3Rpb24ocmVzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnRyYW5zZm9ybV9yZXNvdXJjZShyZXNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICB9KSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBjYXNlIFwibWV0aG9kc1wiOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIChfcmVmMSA9IHByb3BlcnR5WzFdKSAhPSBudWxsID8gX3JlZjEudmFsdWUuZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnRyYW5zZm9ybV9tZXRob2QobWV0aG9kLCBhbGxvd1BhcmFtZXRlcktleXMpO1xuICAgICAgICAgICAgICAgICAgfSkgOiB2b2lkIDA7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5ub29wKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBUcmFuc2Zvcm1hdGlvbnMucHJvdG90eXBlLnRyYW5zZm9ybV9tZXRob2QgPSBmdW5jdGlvbihtZXRob2QsIGFsbG93UGFyYW1ldGVyS2V5cykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIGlmICh1dGlsLmlzTnVsbChtZXRob2QpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXRob2QudmFsdWUuZm9yRWFjaChmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgICAgICB2YXIgY2Fub25pY2FsS2V5O1xuICAgICAgICBpZiAoX3RoaXMudHJhbnNmb3JtX2NvbW1vbl9wcm9wZXJ0aWVzKHByb3BlcnR5LCBhbGxvd1BhcmFtZXRlcktleXMpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhbm9uaWNhbEtleSA9IF90aGlzLmNhbm9uaWNhbGl6ZVByb3BlcnR5TmFtZShwcm9wZXJ0eVswXS52YWx1ZSwgYWxsb3dQYXJhbWV0ZXJLZXlzKTtcbiAgICAgICAgc3dpdGNoIChjYW5vbmljYWxLZXkpIHtcbiAgICAgICAgICBjYXNlIFwic2VjdXJlZEJ5XCI6XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMubm9vcCgpO1xuICAgICAgICAgIGNhc2UgXCJ1c2FnZVwiOlxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLm5vb3AoKTtcbiAgICAgICAgICBjYXNlIFwiaGVhZGVyc1wiOlxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnRyYW5zZm9ybV9uYW1lZF9wYXJhbXMocHJvcGVydHksIGFsbG93UGFyYW1ldGVyS2V5cywgZmFsc2UpO1xuICAgICAgICAgIGNhc2UgXCJxdWVyeVBhcmFtZXRlcnNcIjpcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy50cmFuc2Zvcm1fbmFtZWRfcGFyYW1zKHByb3BlcnR5LCBhbGxvd1BhcmFtZXRlcktleXMsIGZhbHNlKTtcbiAgICAgICAgICBjYXNlIFwiYmFzZVVyaVBhcmFtZXRlcnNcIjpcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy50cmFuc2Zvcm1fbmFtZWRfcGFyYW1zKHByb3BlcnR5LCBhbGxvd1BhcmFtZXRlcktleXMpO1xuICAgICAgICAgIGNhc2UgXCJib2R5XCI6XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMudHJhbnNmb3JtX2JvZHkocHJvcGVydHksIGFsbG93UGFyYW1ldGVyS2V5cyk7XG4gICAgICAgICAgY2FzZSBcInJlc3BvbnNlc1wiOlxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnRyYW5zZm9ybV9yZXNwb25zZXMocHJvcGVydHksIGFsbG93UGFyYW1ldGVyS2V5cyk7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5ub29wKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBUcmFuc2Zvcm1hdGlvbnMucHJvdG90eXBlLnRyYW5zZm9ybV9yZXNwb25zZXMgPSBmdW5jdGlvbihyZXNwb25zZXMsIGFsbG93UGFyYW1ldGVyS2V5cykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIGlmICh1dGlsLmlzTnVsbChyZXNwb25zZXNbMV0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNwb25zZXNbMV0udmFsdWUuZm9yRWFjaChmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gX3RoaXMudHJhbnNmb3JtX3Jlc3BvbnNlKHJlc3BvbnNlLCBhbGxvd1BhcmFtZXRlcktleXMpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIFRyYW5zZm9ybWF0aW9ucy5wcm90b3R5cGUudHJhbnNmb3JtX3Jlc3BvbnNlID0gZnVuY3Rpb24ocmVzcG9uc2UsIGFsbG93UGFyYW1ldGVyS2V5cykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIGlmICh1dGlsLmlzTWFwcGluZyhyZXNwb25zZVsxXSkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlWzFdLnZhbHVlLmZvckVhY2goZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICAgICAgICB2YXIgY2Fub25pY2FsS2V5O1xuICAgICAgICAgIGNhbm9uaWNhbEtleSA9IF90aGlzLmNhbm9uaWNhbGl6ZVByb3BlcnR5TmFtZShwcm9wZXJ0eVswXS52YWx1ZSwgYWxsb3dQYXJhbWV0ZXJLZXlzKTtcbiAgICAgICAgICBzd2l0Y2ggKGNhbm9uaWNhbEtleSkge1xuICAgICAgICAgICAgY2FzZSBcImRlc2NyaXB0aW9uXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy5ub29wKCk7XG4gICAgICAgICAgICBjYXNlIFwiYm9keVwiOlxuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMudHJhbnNmb3JtX2JvZHkocHJvcGVydHksIGFsbG93UGFyYW1ldGVyS2V5cyk7XG4gICAgICAgICAgICBjYXNlIFwiaGVhZGVyc1wiOlxuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMudHJhbnNmb3JtX25hbWVkX3BhcmFtcyhwcm9wZXJ0eSwgYWxsb3dQYXJhbWV0ZXJLZXlzLCBmYWxzZSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMubm9vcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFRyYW5zZm9ybWF0aW9ucy5wcm90b3R5cGUuaXNDb250ZW50VHlwZVN0cmluZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCA/IHZhbHVlLm1hdGNoKC9eW15cXC9dK1xcL1teXFwvXSskLykgOiB2b2lkIDA7XG4gICAgfTtcblxuICAgIFRyYW5zZm9ybWF0aW9ucy5wcm90b3R5cGUudHJhbnNmb3JtX2JvZHkgPSBmdW5jdGlvbihwcm9wZXJ0eSwgYWxsb3dQYXJhbWV0ZXJLZXlzKSB7XG4gICAgICB2YXIgX3JlZixcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuICAgICAgaWYgKHV0aWwuaXNOdWxsKHByb3BlcnR5WzFdKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gKF9yZWYgPSBwcm9wZXJ0eVsxXS52YWx1ZSkgIT0gbnVsbCA/IF9yZWYuZm9yRWFjaChmdW5jdGlvbihib2R5UHJvcGVydHkpIHtcbiAgICAgICAgdmFyIGNhbm9uaWNhbFByb3BlcnR5O1xuICAgICAgICBpZiAoX3RoaXMuaXNQYXJhbWV0ZXJLZXkoYm9keVByb3BlcnR5KSkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5ub29wKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoX3RoaXMuaXNDb250ZW50VHlwZVN0cmluZyhib2R5UHJvcGVydHlbMF0udmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLnRyYW5zZm9ybV9ib2R5KGJvZHlQcm9wZXJ0eSwgYWxsb3dQYXJhbWV0ZXJLZXlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYW5vbmljYWxQcm9wZXJ0eSA9IF90aGlzLmNhbm9uaWNhbGl6ZVByb3BlcnR5TmFtZShib2R5UHJvcGVydHlbMF0udmFsdWUsIGFsbG93UGFyYW1ldGVyS2V5cyk7XG4gICAgICAgICAgc3dpdGNoIChjYW5vbmljYWxQcm9wZXJ0eSkge1xuICAgICAgICAgICAgY2FzZSBcImV4YW1wbGVcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLm5vb3AoKTtcbiAgICAgICAgICAgIGNhc2UgXCJzY2hlbWFcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLm5vb3AoKTtcbiAgICAgICAgICAgIGNhc2UgXCJmb3JtUGFyYW1ldGVyc1wiOlxuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMudHJhbnNmb3JtX25hbWVkX3BhcmFtcyhib2R5UHJvcGVydHksIGFsbG93UGFyYW1ldGVyS2V5cywgZmFsc2UpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLm5vb3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pIDogdm9pZCAwO1xuICAgIH07XG5cbiAgICBUcmFuc2Zvcm1hdGlvbnMucHJvdG90eXBlLnRyYW5zZm9ybV9jb21tb25fcHJvcGVydGllcyA9IGZ1bmN0aW9uKHByb3BlcnR5LCBhbGxvd1BhcmFtZXRlcktleXMpIHtcbiAgICAgIHZhciBjYW5vbmljYWxQcm9wZXJ0eTtcbiAgICAgIGlmICh0aGlzLmlzUGFyYW1ldGVyS2V5KHByb3BlcnR5KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbm9uaWNhbFByb3BlcnR5ID0gdGhpcy5jYW5vbmljYWxpemVQcm9wZXJ0eU5hbWUocHJvcGVydHlbMF0udmFsdWUsIGFsbG93UGFyYW1ldGVyS2V5cyk7XG4gICAgICAgIHN3aXRjaCAoY2Fub25pY2FsUHJvcGVydHkpIHtcbiAgICAgICAgICBjYXNlIFwiZGlzcGxheU5hbWVcIjpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIGNhc2UgXCJkZXNjcmlwdGlvblwiOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgY2FzZSBcImlzXCI6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhpcy5ub29wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFRyYW5zZm9ybWF0aW9ucztcblxuICB9KSgpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiKGZ1bmN0aW9uKCkge1xuICB2YXIgX19zbGljZSA9IFtdLnNsaWNlLFxuICAgIF9faGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gIHRoaXMuZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRlc3RpbmF0aW9uLCBrLCBzb3VyY2UsIHNvdXJjZXMsIHYsIF9pLCBfbGVuO1xuICAgIGRlc3RpbmF0aW9uID0gYXJndW1lbnRzWzBdLCBzb3VyY2VzID0gMiA8PSBhcmd1bWVudHMubGVuZ3RoID8gX19zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkgOiBbXTtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IHNvdXJjZXMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgIHNvdXJjZSA9IHNvdXJjZXNbX2ldO1xuICAgICAgZm9yIChrIGluIHNvdXJjZSkge1xuICAgICAgICB2ID0gc291cmNlW2tdO1xuICAgICAgICBkZXN0aW5hdGlvbltrXSA9IHY7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZXN0aW5hdGlvbjtcbiAgfTtcblxuICB0aGlzLmlzX2VtcHR5ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGtleTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopIHx8IHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gb2JqLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoIV9faGFzUHJvcC5jYWxsKG9iaiwga2V5KSkgY29udGludWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIHRoaXMuaXNOb29wID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHJldHVybiBub2RlO1xuICB9O1xuXG4gIHRoaXMuaXNNYXBwaW5nID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHJldHVybiAobm9kZSAhPSBudWxsID8gbm9kZS50YWcgOiB2b2lkIDApID09PSBcInRhZzp5YW1sLm9yZywyMDAyOm1hcFwiO1xuICB9O1xuXG4gIHRoaXMuaXNOdWxsID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHJldHVybiAobm9kZSAhPSBudWxsID8gbm9kZS50YWcgOiB2b2lkIDApID09PSBcInRhZzp5YW1sLm9yZywyMDAyOm51bGxcIjtcbiAgfTtcblxuICB0aGlzLmlzU2VxdWVuY2UgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgcmV0dXJuIChub2RlICE9IG51bGwgPyBub2RlLnRhZyA6IHZvaWQgMCkgPT09IFwidGFnOnlhbWwub3JnLDIwMDI6c2VxXCI7XG4gIH07XG5cbiAgdGhpcy5pc1N0cmluZyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICByZXR1cm4gKG5vZGUgIT0gbnVsbCA/IG5vZGUudGFnIDogdm9pZCAwKSA9PT0gXCJ0YWc6eWFtbC5vcmcsMjAwMjpzdHJcIjtcbiAgfTtcblxuICB0aGlzLmlzSW50ZWdlciA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICByZXR1cm4gKG5vZGUgIT0gbnVsbCA/IG5vZGUudGFnIDogdm9pZCAwKSA9PT0gXCJ0YWc6eWFtbC5vcmcsMjAwMjppbnRcIjtcbiAgfTtcblxuICB0aGlzLmlzTnVsbGFibGVNYXBwaW5nID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHJldHVybiB0aGlzLmlzTWFwcGluZyhub2RlKSB8fCB0aGlzLmlzTnVsbChub2RlKTtcbiAgfTtcblxuICB0aGlzLmlzTnVsbGFibGVTdHJpbmcgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNTdHJpbmcobm9kZSkgfHwgdGhpcy5pc051bGwobm9kZSk7XG4gIH07XG5cbiAgdGhpcy5pc051bGxhYmxlU2VxdWVuY2UgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNTZXF1ZW5jZShub2RlKSB8fCB0aGlzLmlzTnVsbChub2RlKTtcbiAgfTtcblxuICB0aGlzLmlzTnVtYmVyID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHJldHVybiAobm9kZSAhPSBudWxsID8gbm9kZS50YWcgOiB2b2lkIDApID09PSAndGFnOnlhbWwub3JnLDIwMDI6aW50JyB8fCAobm9kZSAhPSBudWxsID8gbm9kZS50YWcgOiB2b2lkIDApID09PSAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnO1xuICB9O1xuXG4gIHRoaXMuaXNTY2FsYXIgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgcmV0dXJuIChub2RlICE9IG51bGwgPyBub2RlLnRhZyA6IHZvaWQgMCkgPT09ICd0YWc6eWFtbC5vcmcsMjAwMjpudWxsJyB8fCAobm9kZSAhPSBudWxsID8gbm9kZS50YWcgOiB2b2lkIDApID09PSAndGFnOnlhbWwub3JnLDIwMDI6Ym9vbCcgfHwgKG5vZGUgIT0gbnVsbCA/IG5vZGUudGFnIDogdm9pZCAwKSA9PT0gJ3RhZzp5YW1sLm9yZywyMDAyOmludCcgfHwgKG5vZGUgIT0gbnVsbCA/IG5vZGUudGFnIDogdm9pZCAwKSA9PT0gJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0JyB8fCAobm9kZSAhPSBudWxsID8gbm9kZS50YWcgOiB2b2lkIDApID09PSAndGFnOnlhbWwub3JnLDIwMDI6YmluYXJ5JyB8fCAobm9kZSAhPSBudWxsID8gbm9kZS50YWcgOiB2b2lkIDApID09PSAndGFnOnlhbWwub3JnLDIwMDI6dGltZXN0YW1wJyB8fCAobm9kZSAhPSBudWxsID8gbm9kZS50YWcgOiB2b2lkIDApID09PSAndGFnOnlhbWwub3JnLDIwMDI6c3RyJztcbiAgfTtcblxuICB0aGlzLmlzQ29sbGVjdGlvbiA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICByZXR1cm4gKG5vZGUgIT0gbnVsbCA/IG5vZGUudGFnIDogdm9pZCAwKSA9PT0gJ3RhZzp5YW1sLm9yZywyMDAyOm9tYXAnIHx8IChub2RlICE9IG51bGwgPyBub2RlLnRhZyA6IHZvaWQgMCkgPT09ICd0YWc6eWFtbC5vcmcsMjAwMjpwYWlycycgfHwgKG5vZGUgIT0gbnVsbCA/IG5vZGUudGFnIDogdm9pZCAwKSA9PT0gJ3RhZzp5YW1sLm9yZywyMDAyOnNldCcgfHwgKG5vZGUgIT0gbnVsbCA/IG5vZGUudGFnIDogdm9pZCAwKSA9PT0gJ3RhZzp5YW1sLm9yZywyMDAyOnNlcScgfHwgKG5vZGUgIT0gbnVsbCA/IG5vZGUudGFnIDogdm9pZCAwKSA9PT0gJ3RhZzp5YW1sLm9yZywyMDAyOm1hcCc7XG4gIH07XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIoZnVuY3Rpb24oKSB7XG4gIHZhciBNYXJrZWRZQU1MRXJyb3IsIGpzb25saW50LCBub2RlcywgdHJhaXRzLCB1cml0ZW1wbGF0ZSwgdXJsLCB1dGlsLCBfcmVmLFxuICAgIF9faGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LFxuICAgIF9fZXh0ZW5kcyA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoX19oYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuICAgIF9fYmluZCA9IGZ1bmN0aW9uKGZuLCBtZSl7IHJldHVybiBmdW5jdGlvbigpeyByZXR1cm4gZm4uYXBwbHkobWUsIGFyZ3VtZW50cyk7IH07IH0sXG4gICAgX19pbmRleE9mID0gW10uaW5kZXhPZiB8fCBmdW5jdGlvbihpdGVtKSB7IGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHsgaWYgKGkgaW4gdGhpcyAmJiB0aGlzW2ldID09PSBpdGVtKSByZXR1cm4gaTsgfSByZXR1cm4gLTE7IH07XG5cbiAgdXJsID0gcmVxdWlyZSgndXJsJyk7XG5cbiAgdXJpdGVtcGxhdGUgPSByZXF1aXJlKCd1cml0ZW1wbGF0ZScpO1xuXG4gIE1hcmtlZFlBTUxFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3JzJykuTWFya2VkWUFNTEVycm9yO1xuXG4gIG5vZGVzID0gcmVxdWlyZSgnLi9ub2RlcycpO1xuXG4gIHRyYWl0cyA9IHJlcXVpcmUoJy4vdHJhaXRzJyk7XG5cbiAgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4gIGpzb25saW50ID0gcmVxdWlyZSgnanNvbi1saW50Jyk7XG5cbiAgLypcbiAgVGhlIFZhbGlkYXRvciB0aHJvd3MgdGhlc2UuXG4gICovXG5cblxuICB0aGlzLlZhbGlkYXRpb25FcnJvciA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVmFsaWRhdGlvbkVycm9yLCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gVmFsaWRhdGlvbkVycm9yKCkge1xuICAgICAgX3JlZiA9IFZhbGlkYXRpb25FcnJvci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfcmVmO1xuICAgIH1cblxuICAgIHJldHVybiBWYWxpZGF0aW9uRXJyb3I7XG5cbiAgfSkoTWFya2VkWUFNTEVycm9yKTtcblxuICAvKlxuICBBIGNvbGxlY3Rpb24gb2YgbXVsdGlwbGUgdmFsaWRhdGlvbiBlcnJvcnNcbiAgKi9cblxuXG4gIHRoaXMuVmFsaWRhdGlvbkVycm9ycyA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVmFsaWRhdGlvbkVycm9ycywgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIFZhbGlkYXRpb25FcnJvcnModmFsaWRhdGlvbl9lcnJvcnMpIHtcbiAgICAgIHRoaXMudmFsaWRhdGlvbl9lcnJvcnMgPSB2YWxpZGF0aW9uX2Vycm9ycztcbiAgICB9XG5cbiAgICBWYWxpZGF0aW9uRXJyb3JzLnByb3RvdHlwZS5nZXRfdmFsaWRhdGlvbl9lcnJvcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRpb25fZXJyb3JzO1xuICAgIH07XG5cbiAgICByZXR1cm4gVmFsaWRhdGlvbkVycm9ycztcblxuICB9KShNYXJrZWRZQU1MRXJyb3IpO1xuXG4gIC8qXG4gIFRoZSBWYWxpZGF0b3IgY2xhc3MgZGVhbHMgd2l0aCB2YWxpZGF0aW5nIGEgWUFNTCBmaWxlIGFjY29yZGluZyB0byB0aGUgc3BlY1xuICAqL1xuXG5cbiAgdGhpcy5WYWxpZGF0b3IgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gVmFsaWRhdG9yKCkge1xuICAgICAgdGhpcy5nZXRfcHJvcGVydGllcyA9IF9fYmluZCh0aGlzLmdldF9wcm9wZXJ0aWVzLCB0aGlzKTtcbiAgICAgIHRoaXMuZ2V0X2xpc3RfdmFsdWVzID0gX19iaW5kKHRoaXMuZ2V0X2xpc3RfdmFsdWVzLCB0aGlzKTtcbiAgICAgIHRoaXMudmFsaWRhdGlvbnMgPSBbdGhpcy52YWxpZGF0ZV9yb290LCB0aGlzLnZhbGlkYXRlX3Jvb3RfcHJvcGVydGllcywgdGhpcy52YWxpZGF0ZV9iYXNlX3VyaV9wYXJhbWV0ZXJzLCB0aGlzLnZhbGlkX2Fic29sdXRlX3VyaXNdO1xuICAgIH1cblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRhdGVfZG9jdW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgdmFsaWRhdGlvbiwgX2ksIF9sZW4sIF9yZWYxO1xuICAgICAgX3JlZjEgPSB0aGlzLnZhbGlkYXRpb25zO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICB2YWxpZGF0aW9uID0gX3JlZjFbX2ldO1xuICAgICAgICB2YWxpZGF0aW9uLmNhbGwodGhpcywgbm9kZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZV9zZWN1cml0eV9zY2hlbWVzID0gZnVuY3Rpb24oc2NoZW1lc1Byb3BlcnR5KSB7XG4gICAgICB2YXIgc2NoZW1lLCBzY2hlbWVfZW50cnksIF9pLCBfbGVuLCBfcmVmMSwgX3Jlc3VsdHM7XG4gICAgICBpZiAoIXV0aWwuaXNTZXF1ZW5jZShzY2hlbWVzUHJvcGVydHkpKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBzZWN1cml0eVNjaGVtZXMnLCBudWxsLCAnaW52YWxpZCBzZWN1cml0eSBzY2hlbWVzIHByb3BlcnR5LCBpdCBtdXN0IGJlIGFuIGFycmF5Jywgc2NoZW1lc1Byb3BlcnR5LnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgX3JlZjEgPSBzY2hlbWVzUHJvcGVydHkudmFsdWU7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBzY2hlbWVfZW50cnkgPSBfcmVmMVtfaV07XG4gICAgICAgIGlmICghdXRpbC5pc01hcHBpbmcoc2NoZW1lX2VudHJ5KSkge1xuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBzZWN1cml0eVNjaGVtZXMnLCBudWxsLCAnaW52YWxpZCBzZWN1cml0eSBzY2hlbWUgcHJvcGVydHksIGl0IG11c3QgYmUgYSBtYXAnLCBzY2hlbWVfZW50cnkuc3RhcnRfbWFyayk7XG4gICAgICAgIH1cbiAgICAgICAgX3Jlc3VsdHMucHVzaCgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIF9qLCBfbGVuMSwgX3JlZjIsIF9yZXN1bHRzMTtcbiAgICAgICAgICBfcmVmMiA9IHNjaGVtZV9lbnRyeS52YWx1ZTtcbiAgICAgICAgICBfcmVzdWx0czEgPSBbXTtcbiAgICAgICAgICBmb3IgKF9qID0gMCwgX2xlbjEgPSBfcmVmMi5sZW5ndGg7IF9qIDwgX2xlbjE7IF9qKyspIHtcbiAgICAgICAgICAgIHNjaGVtZSA9IF9yZWYyW19qXTtcbiAgICAgICAgICAgIGlmICghdXRpbC5pc01hcHBpbmcoc2NoZW1lWzFdKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgc2VjdXJpdHlTY2hlbWVzJywgbnVsbCwgJ2ludmFsaWQgc2VjdXJpdHkgc2NoZW1lIHByb3BlcnR5LCBpdCBtdXN0IGJlIGEgbWFwJywgc2NoZW1lWzBdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3Jlc3VsdHMxLnB1c2godGhpcy52YWxpZGF0ZV9zZWN1cml0eV9zY2hlbWUoc2NoZW1lWzFdKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBfcmVzdWx0czE7XG4gICAgICAgIH0pLmNhbGwodGhpcykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLnRyYWNrUmVwZWF0ZWRQcm9wZXJ0aWVzID0gZnVuY3Rpb24ocHJvcGVydGllcywga2V5LCBwcm9wZXJ0eSwgc2VjdGlvbiwgZXJyb3JNZXNzYWdlKSB7XG4gICAgICBpZiAoc2VjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIHNlY3Rpb24gPSBcIlJBTUxcIjtcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvck1lc3NhZ2UgPT0gbnVsbCkge1xuICAgICAgICBlcnJvck1lc3NhZ2UgPSBcImEgcHJvcGVydHkgd2l0aCB0aGUgc2FtZSBuYW1lIGFscmVhZHkgZXhpc3RzXCI7XG4gICAgICB9XG4gICAgICBpZiAoa2V5IGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKFwid2hpbGUgdmFsaWRhdGluZyBcIiArIHNlY3Rpb24sIG51bGwsIFwiXCIgKyBlcnJvck1lc3NhZ2UgKyBcIjogJ1wiICsga2V5ICsgXCInXCIsIHByb3BlcnR5LnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb3BlcnRpZXNba2V5XSA9IHByb3BlcnR5O1xuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlX3NlY3VyaXR5X3NjaGVtZSA9IGZ1bmN0aW9uKHNjaGVtZSkge1xuICAgICAgdmFyIHByb3BlcnR5LCBzY2hlbWVQcm9wZXJ0aWVzLCBzZXR0aW5ncywgdHlwZSwgX2ksIF9sZW4sIF9yZWYxO1xuICAgICAgdHlwZSA9IG51bGw7XG4gICAgICBzZXR0aW5ncyA9IG51bGw7XG4gICAgICBzY2hlbWVQcm9wZXJ0aWVzID0ge307XG4gICAgICBfcmVmMSA9IHNjaGVtZS52YWx1ZTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjEubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgcHJvcGVydHkgPSBfcmVmMVtfaV07XG4gICAgICAgIHRoaXMudHJhY2tSZXBlYXRlZFByb3BlcnRpZXMoc2NoZW1lUHJvcGVydGllcywgcHJvcGVydHlbMF0udmFsdWUsIHByb3BlcnR5WzBdLCAnd2hpbGUgdmFsaWRhdGluZyBzZWN1cml0eSBzY2hlbWUnLCBcInByb3BlcnR5IGFscmVhZHkgdXNlZCBpbiBzZWN1cml0eSBzY2hlbWVcIik7XG4gICAgICAgIHN3aXRjaCAocHJvcGVydHlbMF0udmFsdWUpIHtcbiAgICAgICAgICBjYXNlIFwiZGVzY3JpcHRpb25cIjpcbiAgICAgICAgICAgIGlmICghdXRpbC5pc1NjYWxhcihwcm9wZXJ0eVsxXSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHNlY3VyaXR5IHNjaGVtZScsIG51bGwsICdzY2hlbWVzIGRlc2NyaXB0aW9uIG11c3QgYmUgYSBzdHJpbmcnLCBwcm9wZXJ0eVsxXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJ0eXBlXCI6XG4gICAgICAgICAgICB0eXBlID0gcHJvcGVydHlbMV0udmFsdWU7XG4gICAgICAgICAgICBpZiAoISh1dGlsLmlzU3RyaW5nKHByb3BlcnR5WzFdKSAmJiB0eXBlLm1hdGNoKC9eKE9BdXRoIDEuMHxPQXV0aCAyLjB8QmFzaWMgQXV0aGVudGljYXRpb258RGlnZXN0IEF1dGhlbnRpY2F0aW9ufHgtLispJC8pKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgc2VjdXJpdHkgc2NoZW1lJywgbnVsbCwgJ3NjaGVtZXMgdHlwZSBtdXN0IGJlIGFueSBvZjogXCJPQXV0aCAxLjBcIiwgXCJPQXV0aCAyLjBcIiwgXCJCYXNpYyBBdXRoZW50aWNhdGlvblwiLCBcIkRpZ2VzdCBBdXRoZW50aWNhdGlvblwiLCBcIngtXFx7LitcXH1cIicsIHByb3BlcnR5WzFdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImRlc2NyaWJlZEJ5XCI6XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlX21ldGhvZChwcm9wZXJ0eSwgdHJ1ZSwgXCJzZWN1cml0eSBzY2hlbWVcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwic2V0dGluZ3NcIjpcbiAgICAgICAgICAgIHNldHRpbmdzID0gcHJvcGVydHk7XG4gICAgICAgICAgICBpZiAoIXV0aWwuaXNOdWxsYWJsZU1hcHBpbmcocHJvcGVydHlbMV0pKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBzZWN1cml0eSBzY2hlbWUnLCBudWxsLCAnc2NoZW1lcyBzZXR0aW5ncyBtdXN0IGJlIGEgbWFwJywgcHJvcGVydHlbMV0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHNlY3VyaXR5IHNjaGVtZScsIG51bGwsIFwicHJvcGVydHk6ICdcIiArIHByb3BlcnR5WzBdLnZhbHVlICsgXCInIGlzIGludmFsaWQgaW4gYSBzZWN1cml0eSBzY2hlbWVcIiwgcHJvcGVydHlbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghdHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgc2VjdXJpdHkgc2NoZW1lJywgbnVsbCwgJ3NjaGVtZXMgdHlwZSBtdXN0IGJlIGFueSBvZjogXCJPQXV0aCAxLjBcIiwgXCJPQXV0aCAyLjBcIiwgXCJCYXNpYyBBdXRoZW50aWNhdGlvblwiLCBcIkRpZ2VzdCBBdXRoZW50aWNhdGlvblwiLCBcIngtXFx7LitcXH1cIicsIHNjaGVtZS5zdGFydF9tYXJrKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJPQXV0aCAyLjBcIikge1xuICAgICAgICBpZiAoIXNldHRpbmdzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHNlY3VyaXR5IHNjaGVtZScsIG51bGwsICdmb3IgT0F1dGggMi4wIHNldHRpbmdzIG11c3QgYmUgYSBtYXAnLCBzY2hlbWUuc3RhcnRfbWFyayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVfb2F1dGgyX3NldHRpbmdzKHNldHRpbmdzKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJPQXV0aCAxLjBcIikge1xuICAgICAgICBpZiAoIXNldHRpbmdzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHNlY3VyaXR5IHNjaGVtZScsIG51bGwsICdmb3IgT0F1dGggMS4wIHNldHRpbmdzIG11c3QgYmUgYSBtYXAnLCBzY2hlbWUuc3RhcnRfbWFyayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVfb2F1dGgxX3NldHRpbmdzKHNldHRpbmdzKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZV9vYXV0aDJfc2V0dGluZ3MgPSBmdW5jdGlvbihzZXR0aW5ncykge1xuICAgICAgdmFyIHByb3BlcnR5LCBwcm9wZXJ0eU5hbWUsIHNldHRpbmdQcm9wZXJ0aWVzLCBfaSwgX2osIF9sZW4sIF9sZW4xLCBfcmVmMSwgX3JlZjIsIF9yZXN1bHRzO1xuICAgICAgc2V0dGluZ1Byb3BlcnRpZXMgPSB7fTtcbiAgICAgIF9yZWYxID0gc2V0dGluZ3NbMV0udmFsdWU7XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYxLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIHByb3BlcnR5ID0gX3JlZjFbX2ldO1xuICAgICAgICB0aGlzLnRyYWNrUmVwZWF0ZWRQcm9wZXJ0aWVzKHNldHRpbmdQcm9wZXJ0aWVzLCBwcm9wZXJ0eVswXS52YWx1ZSwgcHJvcGVydHlbMF0sICd3aGlsZSB2YWxpZGF0aW5nIHNlY3VyaXR5IHNjaGVtZScsIFwic2V0dGluZyB3aXRoIHRoZSBzYW1lIG5hbWUgYWxyZWFkeSBleGlzdHNcIik7XG4gICAgICAgIHN3aXRjaCAocHJvcGVydHlbMF0udmFsdWUpIHtcbiAgICAgICAgICBjYXNlIFwiYXV0aG9yaXphdGlvblVyaVwiOlxuICAgICAgICAgICAgaWYgKCF1dGlsLmlzU3RyaW5nKHByb3BlcnR5WzFdKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgc2VjdXJpdHkgc2NoZW1lJywgbnVsbCwgJ2F1dGhvcml6YXRpb25VcmkgbXVzdCBiZSBhIFVSTCcsIHByb3BlcnR5WzBdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImFjY2Vzc1Rva2VuVXJpXCI6XG4gICAgICAgICAgICBpZiAoIXV0aWwuaXNTdHJpbmcocHJvcGVydHlbMV0pKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBzZWN1cml0eSBzY2hlbWUnLCBudWxsLCAnYWNjZXNzVG9rZW5VcmkgbXVzdCBiZSBhIFVSTCcsIHByb3BlcnR5WzBdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBfcmVmMiA9IFsnYWNjZXNzVG9rZW5VcmknLCAnYXV0aG9yaXphdGlvblVyaSddO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoX2ogPSAwLCBfbGVuMSA9IF9yZWYyLmxlbmd0aDsgX2ogPCBfbGVuMTsgX2orKykge1xuICAgICAgICBwcm9wZXJ0eU5hbWUgPSBfcmVmMltfal07XG4gICAgICAgIGlmICghKHByb3BlcnR5TmFtZSBpbiBzZXR0aW5nUHJvcGVydGllcykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgc2VjdXJpdHkgc2NoZW1lJywgbnVsbCwgXCJPQXV0aCAyLjAgc2V0dGluZ3MgbXVzdCBoYXZlIFwiICsgcHJvcGVydHlOYW1lICsgXCIgcHJvcGVydHlcIiwgc2V0dGluZ3NbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaCh2b2lkIDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRhdGVfb2F1dGgxX3NldHRpbmdzID0gZnVuY3Rpb24oc2V0dGluZ3MpIHtcbiAgICAgIHZhciBwcm9wZXJ0eSwgcHJvcGVydHlOYW1lLCBzZXR0aW5nUHJvcGVydGllcywgX2ksIF9qLCBfbGVuLCBfbGVuMSwgX3JlZjEsIF9yZWYyLCBfcmVzdWx0cztcbiAgICAgIHNldHRpbmdQcm9wZXJ0aWVzID0ge307XG4gICAgICBfcmVmMSA9IHNldHRpbmdzWzFdLnZhbHVlO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBwcm9wZXJ0eSA9IF9yZWYxW19pXTtcbiAgICAgICAgdGhpcy50cmFja1JlcGVhdGVkUHJvcGVydGllcyhzZXR0aW5nUHJvcGVydGllcywgcHJvcGVydHlbMF0udmFsdWUsIHByb3BlcnR5WzBdLCAnd2hpbGUgdmFsaWRhdGluZyBzZWN1cml0eSBzY2hlbWUnLCBcInNldHRpbmcgd2l0aCB0aGUgc2FtZSBuYW1lIGFscmVhZHkgZXhpc3RzXCIpO1xuICAgICAgICBzd2l0Y2ggKHByb3BlcnR5WzBdLnZhbHVlKSB7XG4gICAgICAgICAgY2FzZSBcInJlcXVlc3RUb2tlblVyaVwiOlxuICAgICAgICAgICAgaWYgKCF1dGlsLmlzU3RyaW5nKHByb3BlcnR5WzFdKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgc2VjdXJpdHkgc2NoZW1lJywgbnVsbCwgJ3JlcXVlc3RUb2tlblVyaSBtdXN0IGJlIGEgVVJMJywgcHJvcGVydHlbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiYXV0aG9yaXphdGlvblVyaVwiOlxuICAgICAgICAgICAgaWYgKCF1dGlsLmlzU3RyaW5nKHByb3BlcnR5WzFdKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgc2VjdXJpdHkgc2NoZW1lJywgbnVsbCwgJ2F1dGhvcml6YXRpb25VcmkgbXVzdCBiZSBhIFVSTCcsIHByb3BlcnR5WzBdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInRva2VuQ3JlZGVudGlhbHNVcmlcIjpcbiAgICAgICAgICAgIGlmICghdXRpbC5pc1N0cmluZyhwcm9wZXJ0eVsxXSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHNlY3VyaXR5IHNjaGVtZScsIG51bGwsICd0b2tlbkNyZWRlbnRpYWxzVXJpIG11c3QgYmUgYSBVUkwnLCBwcm9wZXJ0eVswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgX3JlZjIgPSBbJ3JlcXVlc3RUb2tlblVyaScsICdhdXRob3JpemF0aW9uVXJpJywgJ3Rva2VuQ3JlZGVudGlhbHNVcmknXTtcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKF9qID0gMCwgX2xlbjEgPSBfcmVmMi5sZW5ndGg7IF9qIDwgX2xlbjE7IF9qKyspIHtcbiAgICAgICAgcHJvcGVydHlOYW1lID0gX3JlZjJbX2pdO1xuICAgICAgICBpZiAoIShwcm9wZXJ0eU5hbWUgaW4gc2V0dGluZ1Byb3BlcnRpZXMpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHNlY3VyaXR5IHNjaGVtZScsIG51bGwsIFwiT0F1dGggMS4wIHNldHRpbmdzIG11c3QgaGF2ZSBcIiArIHByb3BlcnR5TmFtZSArIFwiIHByb3BlcnR5XCIsIHNldHRpbmdzWzBdLnN0YXJ0X21hcmspO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2godm9pZCAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlX3Jvb3Rfc2NoZW1hcyA9IGZ1bmN0aW9uKHNjaGVtYXMpIHtcbiAgICAgIHZhciBzY2hlbWEsIHNjaGVtYUxpc3QsIHNjaGVtYU5hbWUsIF9yZXN1bHRzO1xuICAgICAgaWYgKCF1dGlsLmlzU2VxdWVuY2Uoc2NoZW1hcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHNjaGVtYXMnLCBudWxsLCAnc2NoZW1hcyBwcm9wZXJ0eSBtdXN0IGJlIGFuIGFycmF5Jywgc2NoZW1hcy5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIHNjaGVtYUxpc3QgPSB0aGlzLmdldF9hbGxfc2NoZW1hcygpO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoc2NoZW1hTmFtZSBpbiBzY2hlbWFMaXN0KSB7XG4gICAgICAgIHNjaGVtYSA9IHNjaGVtYUxpc3Rbc2NoZW1hTmFtZV07XG4gICAgICAgIGlmICghKHNjaGVtYVsxXS50YWcgJiYgdXRpbC5pc1N0cmluZyhzY2hlbWFbMV0pKSkge1xuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBzY2hlbWFzJywgbnVsbCwgJ3NjaGVtYSAnICsgc2NoZW1hTmFtZSArICcgbXVzdCBiZSBhIHN0cmluZycsIHNjaGVtYVswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgfVxuICAgICAgICBfcmVzdWx0cy5wdXNoKHRoaXMudmFsaWRhdGVTY2hlbWEoc2NoZW1hWzFdKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRhdGVfcm9vdCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIGlmICghKG5vZGUgfHwgdXRpbC5pc051bGwobm9kZSkpKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyByb290JywgbnVsbCwgJ2VtcHR5IGRvY3VtZW50Jywgbm9kZSAhPSBudWxsID8gbm9kZS5zdGFydF9tYXJrIDogdm9pZCAwKTtcbiAgICAgIH1cbiAgICAgIGlmICghdXRpbC5pc01hcHBpbmcobm9kZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHJvb3QnLCBudWxsLCAnZG9jdW1lbnQgbXVzdCBiZSBhIG1hcCcsIG5vZGUuc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRhdGVfYmFzZV91cmlfcGFyYW1ldGVycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLmJhc2VVcmlQYXJhbWV0ZXJzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5iYXNlVXJpKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyB1cmkgcGFyYW1ldGVycycsIG51bGwsICd1cmkgcGFyYW1ldGVycyBkZWZpbmVkIHdoZW4gdGhlcmUgaXMgbm8gYmFzZVVyaScsIHRoaXMuYmFzZVVyaVBhcmFtZXRlcnMuc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICBpZiAoIXV0aWwuaXNOdWxsYWJsZU1hcHBpbmcodGhpcy5iYXNlVXJpUGFyYW1ldGVycykpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHVyaSBwYXJhbWV0ZXJzJywgbnVsbCwgJ2Jhc2UgdXJpIHBhcmFtZXRlcnMgbXVzdCBiZSBhIG1hcCcsIHRoaXMuYmFzZVVyaVBhcmFtZXRlcnMuc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZV91cmlfcGFyYW1ldGVycyh0aGlzLmJhc2VVcmksIHRoaXMuYmFzZVVyaVBhcmFtZXRlcnMsIGZhbHNlLCBmYWxzZSwgW1widmVyc2lvblwiXSk7XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRhdGVfdXJpX3BhcmFtZXRlcnMgPSBmdW5jdGlvbih1cmksIHVyaVByb3BlcnR5LCBhbGxvd1BhcmFtZXRlcktleXMsIHNraXBQYXJhbWV0ZXJVc2VDaGVjaywgcmVzZXJ2ZWROYW1lcykge1xuICAgICAgdmFyIGVyciwgZXhwcmVzc2lvbnMsIHBhcmFtZXRlck5hbWUsIHRlbXBsYXRlLCB1cmlQYXJhbWV0ZXIsIHVyaVBhcmFtZXRlcnMsIF9pLCBfbGVuLCBfcmVmMSwgX3JlZjIsIF9yZXN1bHRzO1xuICAgICAgaWYgKHJlc2VydmVkTmFtZXMgPT0gbnVsbCkge1xuICAgICAgICByZXNlcnZlZE5hbWVzID0gW107XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICB0ZW1wbGF0ZSA9IHVyaXRlbXBsYXRlLnBhcnNlKHVyaSk7XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgZXJyID0gX2Vycm9yO1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgdXJpIHBhcmFtZXRlcnMnLCBudWxsLCBlcnIgIT0gbnVsbCA/IChfcmVmMSA9IGVyci5vcHRpb25zKSAhPSBudWxsID8gX3JlZjEubWVzc2FnZSA6IHZvaWQgMCA6IHZvaWQgMCwgdXJpUHJvcGVydHkuc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICBleHByZXNzaW9ucyA9IHRlbXBsYXRlLmV4cHJlc3Npb25zLmZpbHRlcihmdW5jdGlvbihleHByKSB7XG4gICAgICAgIHJldHVybiBcInRlbXBsYXRlVGV4dFwiIGluIGV4cHI7XG4gICAgICB9KS5tYXAoZnVuY3Rpb24oZXhwcmVzc2lvbikge1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbi50ZW1wbGF0ZVRleHQ7XG4gICAgICB9KTtcbiAgICAgIHVyaVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgIGlmICh0eXBlb2YgdXJpUHJvcGVydHkudmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgX3JlZjIgPSB1cmlQcm9wZXJ0eS52YWx1ZTtcbiAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIHVyaVBhcmFtZXRlciA9IF9yZWYyW19pXTtcbiAgICAgICAgICBwYXJhbWV0ZXJOYW1lID0gdGhpcy5jYW5vbmljYWxpemVQcm9wZXJ0eU5hbWUodXJpUGFyYW1ldGVyWzBdLnZhbHVlLCBhbGxvd1BhcmFtZXRlcktleXMpO1xuICAgICAgICAgIHRoaXMudHJhY2tSZXBlYXRlZFByb3BlcnRpZXModXJpUGFyYW1ldGVycywgcGFyYW1ldGVyTmFtZSwgdXJpUHJvcGVydHksICd3aGlsZSB2YWxpZGF0aW5nIFVSSSBwYXJhbWV0ZXJzJywgXCJVUkkgcGFyYW1ldGVyIHdpdGggdGhlIHNhbWUgbmFtZSBhbHJlYWR5IGV4aXN0c1wiKTtcbiAgICAgICAgICBpZiAoX19pbmRleE9mLmNhbGwocmVzZXJ2ZWROYW1lcywgcGFyYW1ldGVyTmFtZSkgPj0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIGJhc2VVcmknLCBudWxsLCB1cmlQYXJhbWV0ZXJbMF0udmFsdWUgKyAnIHBhcmFtZXRlciBub3QgYWxsb3dlZCBoZXJlJywgdXJpUGFyYW1ldGVyWzBdLnN0YXJ0X21hcmspO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoISh1dGlsLmlzTnVsbGFibGVNYXBwaW5nKHVyaVBhcmFtZXRlclsxXSwgYWxsb3dQYXJhbWV0ZXJLZXlzKSB8fCB1dGlsLmlzTnVsbGFibGVTZXF1ZW5jZSh1cmlQYXJhbWV0ZXJbMV0sIGFsbG93UGFyYW1ldGVyS2V5cykpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgYmFzZVVyaScsIG51bGwsICdVUkkgcGFyYW1ldGVyIG11c3QgYmUgYSBtYXAnLCB1cmlQYXJhbWV0ZXJbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdXRpbC5pc051bGwodXJpUGFyYW1ldGVyWzFdKSkge1xuICAgICAgICAgICAgdGhpcy52YWxpZF9jb21tb25fcGFyYW1ldGVyX3Byb3BlcnRpZXModXJpUGFyYW1ldGVyWzFdLCBhbGxvd1BhcmFtZXRlcktleXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIShza2lwUGFyYW1ldGVyVXNlQ2hlY2sgfHwgdGhpcy5pc1BhcmFtZXRlcktleSh1cmlQYXJhbWV0ZXIpIHx8IF9faW5kZXhPZi5jYWxsKGV4cHJlc3Npb25zLCBwYXJhbWV0ZXJOYW1lKSA+PSAwKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIGJhc2VVcmknLCBudWxsLCB1cmlQYXJhbWV0ZXJbMF0udmFsdWUgKyAnIHVyaSBwYXJhbWV0ZXIgdW51c2VkJywgdXJpUGFyYW1ldGVyWzBdLnN0YXJ0X21hcmspO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfcmVzdWx0cy5wdXNoKHZvaWQgMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZV90eXBlcyA9IGZ1bmN0aW9uKHR5cGVQcm9wZXJ0eSkge1xuICAgICAgdmFyIHR5cGUsIHR5cGVfZW50cnksIHR5cGVzLCBfaSwgX2xlbiwgX3Jlc3VsdHM7XG4gICAgICB0eXBlcyA9IHR5cGVQcm9wZXJ0eS52YWx1ZTtcbiAgICAgIGlmICghdXRpbC5pc1NlcXVlbmNlKHR5cGVQcm9wZXJ0eSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHJlc291cmNlIHR5cGVzJywgbnVsbCwgJ2ludmFsaWQgcmVzb3VyY2VUeXBlcyBkZWZpbml0aW9uLCBpdCBtdXN0IGJlIGFuIGFycmF5JywgdHlwZVByb3BlcnR5LnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gdHlwZXMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgdHlwZV9lbnRyeSA9IHR5cGVzW19pXTtcbiAgICAgICAgaWYgKCF1dGlsLmlzTWFwcGluZyh0eXBlX2VudHJ5KSkge1xuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyByZXNvdXJjZSB0eXBlcycsIG51bGwsICdpbnZhbGlkIHJlc291cmNlVHlwZSBkZWZpbml0aW9uLCBpdCBtdXN0IGJlIGEgbWFwJywgdHlwZV9lbnRyeS5zdGFydF9tYXJrKTtcbiAgICAgICAgfVxuICAgICAgICBfcmVzdWx0cy5wdXNoKChmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgX2osIF9sZW4xLCBfcmVmMSwgX3Jlc3VsdHMxO1xuICAgICAgICAgIF9yZWYxID0gdHlwZV9lbnRyeS52YWx1ZTtcbiAgICAgICAgICBfcmVzdWx0czEgPSBbXTtcbiAgICAgICAgICBmb3IgKF9qID0gMCwgX2xlbjEgPSBfcmVmMS5sZW5ndGg7IF9qIDwgX2xlbjE7IF9qKyspIHtcbiAgICAgICAgICAgIHR5cGUgPSBfcmVmMVtfal07XG4gICAgICAgICAgICBpZiAodGhpcy5pc1BhcmFtZXRlcktleSh0eXBlKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcmVzb3VyY2UgdHlwZXMnLCBudWxsLCAncGFyYW1ldGVyIGtleSBjYW5ub3QgYmUgdXNlZCBhcyBhIHJlc291cmNlIHR5cGUgbmFtZScsIHR5cGVbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXV0aWwuaXNNYXBwaW5nKHR5cGVbMV0pKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyByZXNvdXJjZSB0eXBlcycsIG51bGwsICdpbnZhbGlkIHJlc291cmNlVHlwZSBkZWZpbml0aW9uLCBpdCBtdXN0IGJlIGEgbWFwJywgdHlwZVsxXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9yZXN1bHRzMS5wdXNoKHRoaXMudmFsaWRhdGVfcmVzb3VyY2UodHlwZSwgdHJ1ZSwgJ3Jlc291cmNlIHR5cGUnKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBfcmVzdWx0czE7XG4gICAgICAgIH0pLmNhbGwodGhpcykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlX3RyYWl0cyA9IGZ1bmN0aW9uKHRyYWl0UHJvcGVydHkpIHtcbiAgICAgIHZhciB0cmFpdCwgdHJhaXRfZW50cnksIF9pLCBfbGVuLCBfcmVzdWx0cztcbiAgICAgIHRyYWl0cyA9IHRyYWl0UHJvcGVydHkudmFsdWU7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkodHJhaXRzKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgdHJhaXRzJywgbnVsbCwgJ2ludmFsaWQgdHJhaXRzIGRlZmluaXRpb24sIGl0IG11c3QgYmUgYW4gYXJyYXknLCB0cmFpdFByb3BlcnR5LnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gdHJhaXRzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIHRyYWl0X2VudHJ5ID0gdHJhaXRzW19pXTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRyYWl0X2VudHJ5LnZhbHVlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyB0cmFpdHMnLCBudWxsLCAnaW52YWxpZCB0cmFpdHMgZGVmaW5pdGlvbiwgaXQgbXVzdCBiZSBhbiBhcnJheScsIHRyYWl0UHJvcGVydHkuc3RhcnRfbWFyayk7XG4gICAgICAgIH1cbiAgICAgICAgX3Jlc3VsdHMucHVzaCgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIF9qLCBfbGVuMSwgX3JlZjEsIF9yZXN1bHRzMTtcbiAgICAgICAgICBfcmVmMSA9IHRyYWl0X2VudHJ5LnZhbHVlO1xuICAgICAgICAgIF9yZXN1bHRzMSA9IFtdO1xuICAgICAgICAgIGZvciAoX2ogPSAwLCBfbGVuMSA9IF9yZWYxLmxlbmd0aDsgX2ogPCBfbGVuMTsgX2orKykge1xuICAgICAgICAgICAgdHJhaXQgPSBfcmVmMVtfal07XG4gICAgICAgICAgICBpZiAodGhpcy5pc1BhcmFtZXRlcktleSh0cmFpdCkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHRyYWl0cycsIG51bGwsICdwYXJhbWV0ZXIga2V5IGNhbm5vdCBiZSB1c2VkIGFzIGEgdHJhaXQgbmFtZScsIHRyYWl0WzBdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF1dGlsLmlzTWFwcGluZyh0cmFpdFsxXSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHRyYWl0cycsIG51bGwsICdpbnZhbGlkIHRyYWl0IGRlZmluaXRpb24sIGl0IG11c3QgYmUgYSBtYXAnLCB0cmFpdFsxXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9yZXN1bHRzMS5wdXNoKHRoaXMudmFsaWRfdHJhaXRzX3Byb3BlcnRpZXModHJhaXQpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF9yZXN1bHRzMTtcbiAgICAgICAgfSkuY2FsbCh0aGlzKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRfdHJhaXRzX3Byb3BlcnRpZXMgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgaW52YWxpZDtcbiAgICAgIGlmICghbm9kZVsxXS52YWx1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXV0aWwuaXNNYXBwaW5nKG5vZGVbMV0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGludmFsaWQgPSBub2RlWzFdLnZhbHVlLmZpbHRlcihmdW5jdGlvbihjaGlsZE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkTm9kZVswXS52YWx1ZSA9PT0gXCJpc1wiIHx8IGNoaWxkTm9kZVswXS52YWx1ZSA9PT0gXCJ0eXBlXCI7XG4gICAgICB9KTtcbiAgICAgIGlmIChpbnZhbGlkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHRyYWl0IHByb3BlcnRpZXMnLCBudWxsLCBcInByb3BlcnR5OiAnXCIgKyBpbnZhbGlkWzBdWzBdLnZhbHVlICsgXCInIGlzIGludmFsaWQgaW4gYSB0cmFpdFwiLCBpbnZhbGlkWzBdWzBdLnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVfbWV0aG9kKG5vZGUsIHRydWUsICd0cmFpdCcpO1xuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLmNhbm9uaWNhbGl6ZVByb3BlcnR5TmFtZSA9IGZ1bmN0aW9uKHByb3BlcnR5TmFtZSwgbXVzdFJlbW92ZVF1ZXN0aW9uTWFyaykge1xuICAgICAgaWYgKG11c3RSZW1vdmVRdWVzdGlvbk1hcmsgJiYgcHJvcGVydHlOYW1lLnNsaWNlKC0xKSA9PT0gJz8nKSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0eU5hbWUuc2xpY2UoMCwgLTEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb3BlcnR5TmFtZTtcbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZF9jb21tb25fcGFyYW1ldGVyX3Byb3BlcnRpZXMgPSBmdW5jdGlvbihub2RlLCBhbGxvd1BhcmFtZXRlcktleXMpIHtcbiAgICAgIHZhciBwYXJhbWV0ZXIsIF9pLCBfbGVuLCBfcmVmMSwgX3Jlc3VsdHM7XG4gICAgICBpZiAoIW5vZGUudmFsdWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHV0aWwuaXNTZXF1ZW5jZShub2RlKSkge1xuICAgICAgICBpZiAobm9kZS52YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcGFyYW1ldGVyIHByb3BlcnRpZXMnLCBudWxsLCAnbmFtZWQgcGFyYW1ldGVyIG5lZWRzIGF0IGxlYXN0IG9uZSB0eXBlJywgbm9kZS5zdGFydF9tYXJrKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShub2RlLnZhbHVlLmxlbmd0aCA+IDEpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHBhcmFtZXRlciBwcm9wZXJ0aWVzJywgbnVsbCwgJ3NpbmdsZSB0eXBlIGZvciB2YXJpYWJseSB0eXBlZCBwYXJhbWV0ZXInLCBub2RlLnN0YXJ0X21hcmspO1xuICAgICAgICB9XG4gICAgICAgIF9yZWYxID0gbm9kZS52YWx1ZTtcbiAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIHBhcmFtZXRlciA9IF9yZWYxW19pXTtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKHRoaXMudmFsaWRhdGVfbmFtZWRfcGFyYW1ldGVyKHBhcmFtZXRlciwgYWxsb3dQYXJhbWV0ZXJLZXlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVfbmFtZWRfcGFyYW1ldGVyKG5vZGUsIGFsbG93UGFyYW1ldGVyS2V5cyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRhdGVfbmFtZWRfcGFyYW1ldGVyID0gZnVuY3Rpb24obm9kZSwgYWxsb3dQYXJhbWV0ZXJLZXlzKSB7XG4gICAgICB2YXIgYm9vbGVhblZhbHVlcywgY2Fub25pY2FsUHJvcGVydHlOYW1lLCBjaGlsZE5vZGUsIGVudW1WYWx1ZXMsIHBhcmFtZXRlclByb3BlcnRpZXMsIHBhcmFtZXRlclR5cGUsIHByb3BlcnR5TmFtZSwgcHJvcGVydHlWYWx1ZSwgdW51c2FibGVQcm9wZXJ0eSwgdmFsaWQsIHZhbGlkVHlwZXMsIF9pLCBfaiwgX2ssIF9sZW4sIF9sZW4xLCBfbGVuMiwgX3JlZjEsIF9yZWYyLCBfcmVmMywgX3Jlc3VsdHM7XG4gICAgICBwYXJhbWV0ZXJQcm9wZXJ0aWVzID0ge307XG4gICAgICBwYXJhbWV0ZXJUeXBlID0gXCJzdHJpbmdcIjtcbiAgICAgIF9yZWYxID0gbm9kZS52YWx1ZTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjEubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgY2hpbGROb2RlID0gX3JlZjFbX2ldO1xuICAgICAgICBwcm9wZXJ0eU5hbWUgPSBjaGlsZE5vZGVbMF0udmFsdWU7XG4gICAgICAgIHByb3BlcnR5VmFsdWUgPSBjaGlsZE5vZGVbMV0udmFsdWU7XG4gICAgICAgIHRoaXMudHJhY2tSZXBlYXRlZFByb3BlcnRpZXMocGFyYW1ldGVyUHJvcGVydGllcywgdGhpcy5jYW5vbmljYWxpemVQcm9wZXJ0eU5hbWUoY2hpbGROb2RlWzBdLnZhbHVlLCB0cnVlKSwgY2hpbGROb2RlWzBdLCAnd2hpbGUgdmFsaWRhdGluZyBwYXJhbWV0ZXIgcHJvcGVydGllcycsIFwicGFyYW1ldGVyIHByb3BlcnR5IGFscmVhZHkgdXNlZFwiKTtcbiAgICAgICAgYm9vbGVhblZhbHVlcyA9IFtcInRydWVcIiwgXCJmYWxzZVwiXTtcbiAgICAgICAgaWYgKGFsbG93UGFyYW1ldGVyS2V5cykge1xuICAgICAgICAgIGlmICh0aGlzLmlzUGFyYW1ldGVyS2V5KGNoaWxkTm9kZSkgfHwgdGhpcy5pc1BhcmFtZXRlclZhbHVlKGNoaWxkTm9kZSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYW5vbmljYWxQcm9wZXJ0eU5hbWUgPSB0aGlzLmNhbm9uaWNhbGl6ZVByb3BlcnR5TmFtZShwcm9wZXJ0eU5hbWUsIGFsbG93UGFyYW1ldGVyS2V5cyk7XG4gICAgICAgIHZhbGlkID0gdHJ1ZTtcbiAgICAgICAgc3dpdGNoIChwcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgICBjYXNlIFwiZGlzcGxheU5hbWVcIjpcbiAgICAgICAgICAgIGlmICghdXRpbC5pc1NjYWxhcihjaGlsZE5vZGVbMV0pKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBwYXJhbWV0ZXIgcHJvcGVydGllcycsIG51bGwsICd0aGUgdmFsdWUgb2YgZGlzcGxheU5hbWUgbXVzdCBiZSBhIHNjYWxhcicsIGNoaWxkTm9kZVsxXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJwYXR0ZXJuXCI6XG4gICAgICAgICAgICBpZiAoIXV0aWwuaXNTY2FsYXIoY2hpbGROb2RlWzFdKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcGFyYW1ldGVyIHByb3BlcnRpZXMnLCBudWxsLCAndGhlIHZhbHVlIG9mIHBhdHRlcm4gbXVzdCBiZSBhIHNjYWxhcicsIGNoaWxkTm9kZVsxXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJkZWZhdWx0XCI6XG4gICAgICAgICAgICBpZiAoIXV0aWwuaXNTY2FsYXIoY2hpbGROb2RlWzFdKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcGFyYW1ldGVyIHByb3BlcnRpZXMnLCBudWxsLCAndGhlIHZhbHVlIG9mIGRlZmF1bHQgbXVzdCBiZSBhIHNjYWxhcicsIGNoaWxkTm9kZVsxXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJkZXNjcmlwdGlvblwiOlxuICAgICAgICAgICAgaWYgKCF1dGlsLmlzU2NhbGFyKGNoaWxkTm9kZVsxXSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHBhcmFtZXRlciBwcm9wZXJ0aWVzJywgbnVsbCwgJ3RoZSB2YWx1ZSBvZiBkZXNjcmlwdGlvbiBtdXN0IGJlIGEgc2NhbGFyJywgY2hpbGROb2RlWzFdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImV4YW1wbGVcIjpcbiAgICAgICAgICAgIGlmICghdXRpbC5pc1NjYWxhcihjaGlsZE5vZGVbMV0pKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBwYXJhbWV0ZXIgcHJvcGVydGllcycsIG51bGwsICd0aGUgdmFsdWUgb2YgZXhhbXBsZSBtdXN0IGJlIGEgc2NhbGFyJywgY2hpbGROb2RlWzFdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIm1pbkxlbmd0aFwiOlxuICAgICAgICAgICAgaWYgKGlzTmFOKHByb3BlcnR5VmFsdWUpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBwYXJhbWV0ZXIgcHJvcGVydGllcycsIG51bGwsICd0aGUgdmFsdWUgb2YgbWluTGVuZ3RoIG11c3QgYmUgYSBudW1iZXInLCBjaGlsZE5vZGVbMV0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwibWF4TGVuZ3RoXCI6XG4gICAgICAgICAgICBpZiAoaXNOYU4ocHJvcGVydHlWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHBhcmFtZXRlciBwcm9wZXJ0aWVzJywgbnVsbCwgJ3RoZSB2YWx1ZSBvZiBtYXhMZW5ndGggbXVzdCBiZSBhIG51bWJlcicsIGNoaWxkTm9kZVsxXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJtaW5pbXVtXCI6XG4gICAgICAgICAgICBpZiAoaXNOYU4ocHJvcGVydHlWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHBhcmFtZXRlciBwcm9wZXJ0aWVzJywgbnVsbCwgJ3RoZSB2YWx1ZSBvZiBtaW5pbXVtIG11c3QgYmUgYSBudW1iZXInLCBjaGlsZE5vZGVbMV0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwibWF4aW11bVwiOlxuICAgICAgICAgICAgaWYgKGlzTmFOKHByb3BlcnR5VmFsdWUpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBwYXJhbWV0ZXIgcHJvcGVydGllcycsIG51bGwsICd0aGUgdmFsdWUgb2YgbWF4aW11bSBtdXN0IGJlIGEgbnVtYmVyJywgY2hpbGROb2RlWzFdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInR5cGVcIjpcbiAgICAgICAgICAgIHBhcmFtZXRlclR5cGUgPSBwcm9wZXJ0eVZhbHVlO1xuICAgICAgICAgICAgdmFsaWRUeXBlcyA9IFsnc3RyaW5nJywgJ251bWJlcicsICdpbnRlZ2VyJywgJ2RhdGUnLCAnYm9vbGVhbicsICdmaWxlJ107XG4gICAgICAgICAgICBpZiAoX19pbmRleE9mLmNhbGwodmFsaWRUeXBlcywgcHJvcGVydHlWYWx1ZSkgPCAwKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBwYXJhbWV0ZXIgcHJvcGVydGllcycsIG51bGwsICd0eXBlIGNhbiBiZSBlaXRoZXIgb2Y6IHN0cmluZywgbnVtYmVyLCBpbnRlZ2VyLCBmaWxlLCBkYXRlIG9yIGJvb2xlYW4gJywgY2hpbGROb2RlWzFdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInJlcXVpcmVkXCI6XG4gICAgICAgICAgICBpZiAoX19pbmRleE9mLmNhbGwoYm9vbGVhblZhbHVlcywgcHJvcGVydHlWYWx1ZSkgPCAwKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBwYXJhbWV0ZXIgcHJvcGVydGllcycsIG51bGwsICdyZXF1aXJlZCBjYW4gYmUgYW55IGVpdGhlciB0cnVlIG9yIGZhbHNlJywgY2hpbGROb2RlWzFdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInJlcGVhdFwiOlxuICAgICAgICAgICAgaWYgKF9faW5kZXhPZi5jYWxsKGJvb2xlYW5WYWx1ZXMsIHByb3BlcnR5VmFsdWUpIDwgMCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcGFyYW1ldGVyIHByb3BlcnRpZXMnLCBudWxsLCAncmVwZWF0IGNhbiBiZSBhbnkgZWl0aGVyIHRydWUgb3IgZmFsc2UnLCBjaGlsZE5vZGVbMV0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGNhbm9uaWNhbFByb3BlcnR5TmFtZSkge1xuICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICBpZiAoIXV0aWwuaXNOdWxsYWJsZVNlcXVlbmNlKGNoaWxkTm9kZVsxXSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHBhcmFtZXRlciBwcm9wZXJ0aWVzJywgbnVsbCwgJ3RoZSB2YWx1ZSBvZiBlbnVtIG11c3QgYmUgYW4gYXJyYXknLCBjaGlsZE5vZGVbMV0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNoaWxkTm9kZVsxXS52YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHBhcmFtZXRlciBwcm9wZXJ0aWVzJywgbnVsbCwgJ2VudW0gaXMgZW1wdHknLCBjaGlsZE5vZGVbMV0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbnVtVmFsdWVzID0gdGhpcy5nZXRfbGlzdF92YWx1ZXMoY2hpbGROb2RlWzFdLnZhbHVlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc0R1cGxpY2F0ZXMoZW51bVZhbHVlcykpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHBhcmFtZXRlciBwcm9wZXJ0aWVzJywgbnVsbCwgJ2VudW0gY29udGFpbnMgZHVwbGljYXRlZCB2YWx1ZXMnLCBjaGlsZE5vZGVbMV0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcGFyYW1ldGVyIHByb3BlcnRpZXMnLCBudWxsLCBcInVua25vd24gcHJvcGVydHkgXCIgKyBwcm9wZXJ0eU5hbWUsIGNoaWxkTm9kZVswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBhcmFtZXRlclR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgX3JlZjIgPSBbJ2VudW0nLCAncGF0dGVybicsICdtaW5MZW5ndGgnLCAnbWF4TGVuZ3RoJ107XG4gICAgICAgIGZvciAoX2ogPSAwLCBfbGVuMSA9IF9yZWYyLmxlbmd0aDsgX2ogPCBfbGVuMTsgX2orKykge1xuICAgICAgICAgIHVudXNhYmxlUHJvcGVydHkgPSBfcmVmMltfal07XG4gICAgICAgICAgaWYgKHVudXNhYmxlUHJvcGVydHkgaW4gcGFyYW1ldGVyUHJvcGVydGllcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHBhcmFtZXRlciBwcm9wZXJ0aWVzJywgbnVsbCwgXCJwcm9wZXJ0eSBcIiArIHVudXNhYmxlUHJvcGVydHkgKyBcIiBjYW4gb25seSBiZSB1c2VkIGlmIHR5cGUgaXMgJ3N0cmluZydcIiwgcGFyYW1ldGVyUHJvcGVydGllc1t1bnVzYWJsZVByb3BlcnR5XS5zdGFydF9tYXJrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghKHBhcmFtZXRlclR5cGUgPT09IFwibnVtYmVyXCIgfHwgcGFyYW1ldGVyVHlwZSA9PT0gXCJpbnRlZ2VyXCIpKSB7XG4gICAgICAgIF9yZWYzID0gWydtaW5pbXVtJywgJ21heGltdW0nXTtcbiAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChfayA9IDAsIF9sZW4yID0gX3JlZjMubGVuZ3RoOyBfayA8IF9sZW4yOyBfaysrKSB7XG4gICAgICAgICAgdW51c2FibGVQcm9wZXJ0eSA9IF9yZWYzW19rXTtcbiAgICAgICAgICBpZiAodW51c2FibGVQcm9wZXJ0eSBpbiBwYXJhbWV0ZXJQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcGFyYW1ldGVyIHByb3BlcnRpZXMnLCBudWxsLCBcInByb3BlcnR5IFwiICsgdW51c2FibGVQcm9wZXJ0eSArIFwiIGNhbiBvbmx5IGJlIHVzZWQgaWYgdHlwZSBpcyAnbnVtYmVyJyBvciAnaW50ZWdlcidcIiwgcGFyYW1ldGVyUHJvcGVydGllc1t1bnVzYWJsZVByb3BlcnR5XS5zdGFydF9tYXJrKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaCh2b2lkIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUuZ2V0X2xpc3RfdmFsdWVzID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHJldHVybiBub2RlLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtLnZhbHVlO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRhdGVfcm9vdF9wcm9wZXJ0aWVzID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIGNoZWNrVmVyc2lvbiwgcHJvcGVydHksIHJvb3RQcm9wZXJ0aWVzLCBfaSwgX2xlbiwgX3JlZjE7XG4gICAgICBjaGVja1ZlcnNpb24gPSBmYWxzZTtcbiAgICAgIHJvb3RQcm9wZXJ0aWVzID0ge307XG4gICAgICBpZiAobm9kZSAhPSBudWxsID8gbm9kZS52YWx1ZSA6IHZvaWQgMCkge1xuICAgICAgICBfcmVmMSA9IG5vZGUudmFsdWU7XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjEubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICBwcm9wZXJ0eSA9IF9yZWYxW19pXTtcbiAgICAgICAgICBpZiAocHJvcGVydHlbMF0udmFsdWUubWF0Y2goL15cXC8vKSkge1xuICAgICAgICAgICAgdGhpcy50cmFja1JlcGVhdGVkUHJvcGVydGllcyhyb290UHJvcGVydGllcywgdGhpcy5jYW5vbmljYWxpemVQcm9wZXJ0eU5hbWUocHJvcGVydHlbMF0udmFsdWUsIHRydWUpLCBwcm9wZXJ0eVswXSwgJ3doaWxlIHZhbGlkYXRpbmcgcm9vdCBwcm9wZXJ0aWVzJywgXCJyZXNvdXJjZSBhbHJlYWR5IGRlY2xhcmVkXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNrUmVwZWF0ZWRQcm9wZXJ0aWVzKHJvb3RQcm9wZXJ0aWVzLCBwcm9wZXJ0eVswXS52YWx1ZSwgcHJvcGVydHlbMF0sICd3aGlsZSB2YWxpZGF0aW5nIHJvb3QgcHJvcGVydGllcycsICdyb290IHByb3BlcnR5IGFscmVhZHkgdXNlZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzd2l0Y2ggKHByb3BlcnR5WzBdLnZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlICd0aXRsZSc6XG4gICAgICAgICAgICAgIGlmICghdXRpbC5pc1NjYWxhcihwcm9wZXJ0eVsxXSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcm9vdCBwcm9wZXJ0aWVzJywgbnVsbCwgJ3RpdGxlIG11c3QgYmUgYSBzdHJpbmcnLCBwcm9wZXJ0eVswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Jhc2VVcmknOlxuICAgICAgICAgICAgICBpZiAoIXV0aWwuaXNTY2FsYXIocHJvcGVydHlbMV0pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHJvb3QgcHJvcGVydGllcycsIG51bGwsICdiYXNlVXJpIG11c3QgYmUgYSBzdHJpbmcnLCBwcm9wZXJ0eVswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLmJhc2VVcmkgPSBwcm9wZXJ0eVsxXS52YWx1ZTtcbiAgICAgICAgICAgICAgY2hlY2tWZXJzaW9uID0gdGhpcy52YWxpZGF0ZV9iYXNlX3VyaShwcm9wZXJ0eVsxXSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc2VjdXJpdHlTY2hlbWVzJzpcbiAgICAgICAgICAgICAgdGhpcy52YWxpZGF0ZV9zZWN1cml0eV9zY2hlbWVzKHByb3BlcnR5WzFdKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzY2hlbWFzJzpcbiAgICAgICAgICAgICAgdGhpcy52YWxpZGF0ZV9yb290X3NjaGVtYXMocHJvcGVydHlbMV0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3ZlcnNpb24nOlxuICAgICAgICAgICAgICBpZiAoIXV0aWwuaXNTY2FsYXIocHJvcGVydHlbMV0pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHJvb3QgcHJvcGVydGllcycsIG51bGwsICd2ZXJzaW9uIG11c3QgYmUgYSBzdHJpbmcnLCBwcm9wZXJ0eVswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIXV0aWwuaXNOdWxsKHByb3BlcnR5WzFdKSkge1xuICAgICAgICAgICAgICAgIHByb3BlcnR5WzFdLnRhZyA9ICd0YWc6eWFtbC5vcmcsMjAwMjpzdHInO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndHJhaXRzJzpcbiAgICAgICAgICAgICAgdGhpcy52YWxpZGF0ZV90cmFpdHMocHJvcGVydHlbMV0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2RvY3VtZW50YXRpb24nOlxuICAgICAgICAgICAgICBpZiAoIXV0aWwuaXNTZXF1ZW5jZShwcm9wZXJ0eVsxXSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcm9vdCBwcm9wZXJ0aWVzJywgbnVsbCwgJ2RvY3VtZW50YXRpb24gbXVzdCBiZSBhbiBhcnJheScsIHByb3BlcnR5WzBdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMudmFsaWRhdGVfZG9jdW1lbnRhdGlvbihwcm9wZXJ0eVsxXSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWVkaWFUeXBlJzpcbiAgICAgICAgICAgICAgaWYgKCF1dGlsLmlzU3RyaW5nKHByb3BlcnR5WzFdKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyByb290IHByb3BlcnRpZXMnLCBudWxsLCAnbWVkaWFUeXBlIG11c3QgYmUgYSBzY2FsYXInLCBwcm9wZXJ0eVswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Jhc2VVcmlQYXJhbWV0ZXJzJzpcbiAgICAgICAgICAgICAgdGhpcy5iYXNlVXJpUGFyYW1ldGVycyA9IHByb3BlcnR5WzFdO1xuICAgICAgICAgICAgICB1dGlsLmlzTm9vcChwcm9wZXJ0eVsxXSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncmVzb3VyY2VUeXBlcyc6XG4gICAgICAgICAgICAgIHRoaXMudmFsaWRhdGVfdHlwZXMocHJvcGVydHlbMV0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlY3VyZWRCeSc6XG4gICAgICAgICAgICAgIHRoaXMudmFsaWRhdGVfc2VjdXJlZF9ieShwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncHJvdG9jb2xzJzpcbiAgICAgICAgICAgICAgdGhpcy52YWxpZGF0ZV9wcm90b2NvbHNfcHJvcGVydHkocHJvcGVydHkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGlmIChwcm9wZXJ0eVswXS52YWx1ZS5tYXRjaCgvXlxcLy8pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWxpZGF0ZV9yZXNvdXJjZShwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHJvb3QgcHJvcGVydGllcycsIG51bGwsIFwidW5rbm93biBwcm9wZXJ0eSBcIiArIHByb3BlcnR5WzBdLnZhbHVlLCBwcm9wZXJ0eVswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCEoJ3RpdGxlJyBpbiByb290UHJvcGVydGllcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHJvb3QgcHJvcGVydGllcycsIG51bGwsICdtaXNzaW5nIHRpdGxlJywgbm9kZS5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGVja1ZlcnNpb24gJiYgISgndmVyc2lvbicgaW4gcm9vdFByb3BlcnRpZXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyB2ZXJzaW9uJywgbnVsbCwgJ21pc3NpbmcgdmVyc2lvbicsIG5vZGUuc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRhdGVfZG9jdW1lbnRhdGlvbiA9IGZ1bmN0aW9uKGRvY3VtZW50YXRpb25fcHJvcGVydHkpIHtcbiAgICAgIHZhciBkb2NTZWN0aW9uLCBfaSwgX2xlbiwgX3JlZjEsIF9yZXN1bHRzO1xuICAgICAgaWYgKCFkb2N1bWVudGF0aW9uX3Byb3BlcnR5LnZhbHVlLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgZG9jdW1lbnRhdGlvbiBzZWN0aW9uJywgbnVsbCwgJ3RoZXJlIG11c3QgYmUgYXQgbGVhc3Qgb25lIGRvY3VtZW50IGluIHRoZSBkb2N1bWVudGF0aW9uIHNlY3Rpb24nLCBkb2N1bWVudGF0aW9uX3Byb3BlcnR5LnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgX3JlZjEgPSBkb2N1bWVudGF0aW9uX3Byb3BlcnR5LnZhbHVlO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjEubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgZG9jU2VjdGlvbiA9IF9yZWYxW19pXTtcbiAgICAgICAgX3Jlc3VsdHMucHVzaCh0aGlzLnZhbGlkYXRlX2RvY19zZWN0aW9uKGRvY1NlY3Rpb24pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZV9kb2Nfc2VjdGlvbiA9IGZ1bmN0aW9uKGRvY1NlY3Rpb24pIHtcbiAgICAgIHZhciBkb2NQcm9wZXJ0aWVzLCBwcm9wZXJ0eSwgX2ksIF9sZW4sIF9yZWYxO1xuICAgICAgaWYgKCF1dGlsLmlzTWFwcGluZyhkb2NTZWN0aW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgZG9jdW1lbnRhdGlvbiBzZWN0aW9uJywgbnVsbCwgJ2VhY2ggZG9jdW1lbnRhdGlvbiBzZWN0aW9uIG11c3QgYmUgYSBtYXAnLCBkb2NTZWN0aW9uLnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgZG9jUHJvcGVydGllcyA9IHt9O1xuICAgICAgX3JlZjEgPSBkb2NTZWN0aW9uLnZhbHVlO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBwcm9wZXJ0eSA9IF9yZWYxW19pXTtcbiAgICAgICAgdGhpcy50cmFja1JlcGVhdGVkUHJvcGVydGllcyhkb2NQcm9wZXJ0aWVzLCBwcm9wZXJ0eVswXS52YWx1ZSwgcHJvcGVydHlbMF0sICd3aGlsZSB2YWxpZGF0aW5nIGRvY3VtZW50YXRpb24gc2VjdGlvbicsIFwicHJvcGVydHkgYWxyZWFkeSB1c2VkXCIpO1xuICAgICAgICBzd2l0Y2ggKHByb3BlcnR5WzBdLnZhbHVlKSB7XG4gICAgICAgICAgY2FzZSBcInRpdGxlXCI6XG4gICAgICAgICAgICBpZiAoISh1dGlsLmlzU2NhbGFyKHByb3BlcnR5WzFdKSAmJiAhdXRpbC5pc051bGwocHJvcGVydHlbMV0pKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgZG9jdW1lbnRhdGlvbiBzZWN0aW9uJywgbnVsbCwgJ3RpdGxlIG11c3QgYmUgYSBzdHJpbmcnLCBwcm9wZXJ0eVswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJjb250ZW50XCI6XG4gICAgICAgICAgICBpZiAoISh1dGlsLmlzU2NhbGFyKHByb3BlcnR5WzFdKSAmJiAhdXRpbC5pc051bGwocHJvcGVydHlbMV0pKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgZG9jdW1lbnRhdGlvbiBzZWN0aW9uJywgbnVsbCwgJ2NvbnRlbnQgbXVzdCBiZSBhIHN0cmluZycsIHByb3BlcnR5WzBdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyByb290IHByb3BlcnRpZXMnLCBudWxsLCAndW5rbm93biBwcm9wZXJ0eSAnICsgcHJvcGVydHlbMF0udmFsdWUsIHByb3BlcnR5WzBdLnN0YXJ0X21hcmspO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIShcImNvbnRlbnRcIiBpbiBkb2NQcm9wZXJ0aWVzKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgZG9jdW1lbnRhdGlvbiBzZWN0aW9uJywgbnVsbCwgJ2EgZG9jdW1lbnRhdGlvbiBlbnRyeSBtdXN0IGhhdmUgY29udGVudCBwcm9wZXJ0eScsIGRvY1NlY3Rpb24uc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICBpZiAoIShcInRpdGxlXCIgaW4gZG9jUHJvcGVydGllcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIGRvY3VtZW50YXRpb24gc2VjdGlvbicsIG51bGwsICdhIGRvY3VtZW50YXRpb24gZW50cnkgbXVzdCBoYXZlIHRpdGxlIHByb3BlcnR5JywgZG9jU2VjdGlvbi5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS5jaGlsZF9yZXNvdXJjZXMgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICBpZiAobm9kZSAmJiB1dGlsLmlzTWFwcGluZyhub2RlKSkge1xuICAgICAgICByZXR1cm4gbm9kZS52YWx1ZS5maWx0ZXIoZnVuY3Rpb24oY2hpbGROb2RlKSB7XG4gICAgICAgICAgcmV0dXJuIGNoaWxkTm9kZVswXS52YWx1ZS5tYXRjaCgvXlxcLy8pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbXTtcbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZV9yZXNvdXJjZSA9IGZ1bmN0aW9uKHJlc291cmNlLCBhbGxvd1BhcmFtZXRlcktleXMsIGNvbnRleHQpIHtcbiAgICAgIHZhciBjYW5vbmljYWxLZXksIGVyciwga2V5LCBwcm9wZXJ0eSwgcmVzb3VyY2VQcm9wZXJ0aWVzLCB0ZW1wbGF0ZSwgdmFsaWQsIF9pLCBfbGVuLCBfcmVmMSwgX3JlZjIsIF9yZXN1bHRzO1xuICAgICAgaWYgKGFsbG93UGFyYW1ldGVyS2V5cyA9PSBudWxsKSB7XG4gICAgICAgIGFsbG93UGFyYW1ldGVyS2V5cyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGNvbnRleHQgPT0gbnVsbCkge1xuICAgICAgICBjb250ZXh0ID0gXCJyZXNvdXJjZVwiO1xuICAgICAgfVxuICAgICAgaWYgKCEocmVzb3VyY2VbMV0gJiYgdXRpbC5pc051bGxhYmxlTWFwcGluZyhyZXNvdXJjZVsxXSkpKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyByZXNvdXJjZXMnLCBudWxsLCAncmVzb3VyY2UgaXMgbm90IGEgbWFwJywgcmVzb3VyY2VbMV0uc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICBpZiAocmVzb3VyY2VbMF0udmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0ZW1wbGF0ZSA9IHVyaXRlbXBsYXRlLnBhcnNlKHJlc291cmNlWzBdLnZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgZXJyID0gX2Vycm9yO1xuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyByZXNvdXJjZScsIG51bGwsIFwiUmVzb3VyY2UgbmFtZSBpcyBpbnZhbGlkOiBcIiArIChlcnIgIT0gbnVsbCA/IChfcmVmMSA9IGVyci5vcHRpb25zKSAhPSBudWxsID8gX3JlZjEubWVzc2FnZSA6IHZvaWQgMCA6IHZvaWQgMCksIHJlc291cmNlWzBdLnN0YXJ0X21hcmspO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodXRpbC5pc051bGwocmVzb3VyY2VbMV0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChyZXNvdXJjZVsxXS52YWx1ZSkge1xuICAgICAgICByZXNvdXJjZVByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgX3JlZjIgPSByZXNvdXJjZVsxXS52YWx1ZTtcbiAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIHByb3BlcnR5ID0gX3JlZjJbX2ldO1xuICAgICAgICAgIGlmIChwcm9wZXJ0eVswXS52YWx1ZS5tYXRjaCgvXlxcLy8pKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNrUmVwZWF0ZWRQcm9wZXJ0aWVzKHJlc291cmNlUHJvcGVydGllcywgdGhpcy5jYW5vbmljYWxpemVQcm9wZXJ0eU5hbWUocHJvcGVydHlbMF0udmFsdWUsIHRydWUpLCBwcm9wZXJ0eVswXSwgJ3doaWxlIHZhbGlkYXRpbmcgcmVzb3VyY2UnLCBcInJlc291cmNlIGFscmVhZHkgZGVjbGFyZWRcIik7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzSHR0cE1ldGhvZChwcm9wZXJ0eVswXS52YWx1ZSwgYWxsb3dQYXJhbWV0ZXJLZXlzKSkge1xuICAgICAgICAgICAgdGhpcy50cmFja1JlcGVhdGVkUHJvcGVydGllcyhyZXNvdXJjZVByb3BlcnRpZXMsIHRoaXMuY2Fub25pY2FsaXplUHJvcGVydHlOYW1lKHByb3BlcnR5WzBdLnZhbHVlLCB0cnVlKSwgcHJvcGVydHlbMF0sICd3aGlsZSB2YWxpZGF0aW5nIHJlc291cmNlJywgXCJtZXRob2QgYWxyZWFkeSBkZWNsYXJlZFwiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50cmFja1JlcGVhdGVkUHJvcGVydGllcyhyZXNvdXJjZVByb3BlcnRpZXMsIHRoaXMuY2Fub25pY2FsaXplUHJvcGVydHlOYW1lKHByb3BlcnR5WzBdLnZhbHVlLCB0cnVlKSwgcHJvcGVydHlbMF0sICd3aGlsZSB2YWxpZGF0aW5nIHJlc291cmNlJywgXCJwcm9wZXJ0eSBhbHJlYWR5IHVzZWRcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdGhpcy52YWxpZGF0ZV9jb21tb25fcHJvcGVydGllcyhwcm9wZXJ0eSwgYWxsb3dQYXJhbWV0ZXJLZXlzKSkge1xuICAgICAgICAgICAgaWYgKHByb3BlcnR5WzBdLnZhbHVlLm1hdGNoKC9eXFwvLykpIHtcbiAgICAgICAgICAgICAgaWYgKGFsbG93UGFyYW1ldGVyS2V5cykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyB0cmFpdCBwcm9wZXJ0aWVzJywgbnVsbCwgJ3Jlc291cmNlIHR5cGUgY2Fubm90IGRlZmluZSBjaGlsZCByZXNvdXJjZXMnLCBwcm9wZXJ0eVswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBfcmVzdWx0cy5wdXNoKHRoaXMudmFsaWRhdGVfcmVzb3VyY2UocHJvcGVydHksIGFsbG93UGFyYW1ldGVyS2V5cykpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzSHR0cE1ldGhvZChwcm9wZXJ0eVswXS52YWx1ZSwgYWxsb3dQYXJhbWV0ZXJLZXlzKSkge1xuICAgICAgICAgICAgICBfcmVzdWx0cy5wdXNoKHRoaXMudmFsaWRhdGVfbWV0aG9kKHByb3BlcnR5LCBhbGxvd1BhcmFtZXRlcktleXMsICdtZXRob2QnKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBrZXkgPSBwcm9wZXJ0eVswXS52YWx1ZTtcbiAgICAgICAgICAgICAgY2Fub25pY2FsS2V5ID0gdGhpcy5jYW5vbmljYWxpemVQcm9wZXJ0eU5hbWUoa2V5LCBhbGxvd1BhcmFtZXRlcktleXMpO1xuICAgICAgICAgICAgICB2YWxpZCA9IHRydWU7XG4gICAgICAgICAgICAgIHN3aXRjaCAoY2Fub25pY2FsS2V5KSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInVyaVBhcmFtZXRlcnNcIjpcbiAgICAgICAgICAgICAgICAgIGlmICghdXRpbC5pc051bGxhYmxlTWFwcGluZyhwcm9wZXJ0eVsxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHVyaSBwYXJhbWV0ZXJzJywgbnVsbCwgJ3VyaSBwYXJhbWV0ZXJzIG11c3QgYmUgYSBtYXAnLCBwcm9wZXJ0eVswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHRoaXMudmFsaWRhdGVfdXJpX3BhcmFtZXRlcnMocmVzb3VyY2VbMF0udmFsdWUsIHByb3BlcnR5WzFdLCBhbGxvd1BhcmFtZXRlcktleXMsIGFsbG93UGFyYW1ldGVyS2V5cyk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiYmFzZVVyaVBhcmFtZXRlcnNcIjpcbiAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5iYXNlVXJpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyB1cmkgcGFyYW1ldGVycycsIG51bGwsICdiYXNlIHVyaSBwYXJhbWV0ZXJzIGRlZmluZWQgd2hlbiB0aGVyZSBpcyBubyBiYXNlVXJpJywgcHJvcGVydHlbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoIXV0aWwuaXNOdWxsYWJsZU1hcHBpbmcocHJvcGVydHlbMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyB1cmkgcGFyYW1ldGVycycsIG51bGwsICdiYXNlIHVyaSBwYXJhbWV0ZXJzIG11c3QgYmUgYSBtYXAnLCBwcm9wZXJ0eVswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHRoaXMudmFsaWRhdGVfdXJpX3BhcmFtZXRlcnModGhpcy5iYXNlVXJpLCBwcm9wZXJ0eVsxXSwgYWxsb3dQYXJhbWV0ZXJLZXlzKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICB2YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInR5cGVcIjpcbiAgICAgICAgICAgICAgICAgIF9yZXN1bHRzLnB1c2godGhpcy52YWxpZGF0ZV90eXBlX3Byb3BlcnR5KHByb3BlcnR5LCBhbGxvd1BhcmFtZXRlcktleXMpKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ1c2FnZVwiOlxuICAgICAgICAgICAgICAgICAgaWYgKCFhbGxvd1BhcmFtZXRlcktleXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHJlc291cmNlcycsIG51bGwsIFwicHJvcGVydHk6ICdcIiArIHByb3BlcnR5WzBdLnZhbHVlICsgXCInIGlzIGludmFsaWQgaW4gYSByZXNvdXJjZVwiLCBwcm9wZXJ0eVswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF9yZXN1bHRzLnB1c2godm9pZCAwKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzZWN1cmVkQnlcIjpcbiAgICAgICAgICAgICAgICAgIF9yZXN1bHRzLnB1c2godGhpcy52YWxpZGF0ZV9zZWN1cmVkX2J5KHByb3BlcnR5KSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcmVzb3VyY2VzJywgbnVsbCwgXCJwcm9wZXJ0eTogJ1wiICsgcHJvcGVydHlbMF0udmFsdWUgKyAoXCInIGlzIGludmFsaWQgaW4gYSBcIiArIGNvbnRleHQpLCBwcm9wZXJ0eVswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF9yZXN1bHRzLnB1c2godm9pZCAwKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfcmVzdWx0cy5wdXNoKHZvaWQgMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZV9zZWN1cmVkX2J5ID0gZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICAgIHZhciBzZWNTY2hlbWUsIHNlY1NjaGVtZXMsIHNlY3VyaXR5U2NoZW1lTmFtZSwgX2ksIF9sZW4sIF9yZWYxLCBfcmVzdWx0cztcbiAgICAgIGlmICghdXRpbC5pc1NlcXVlbmNlKHByb3BlcnR5WzFdKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgc2VjdXJpdHlTY2hlbWUnLCBudWxsLCBcInByb3BlcnR5ICdzZWN1cmVkQnknIG11c3QgYmUgYW4gYXJyYXlcIiwgcHJvcGVydHlbMF0uc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICBzZWNTY2hlbWVzID0gdGhpcy5nZXRfbGlzdF92YWx1ZXMocHJvcGVydHlbMV0udmFsdWUpO1xuICAgICAgaWYgKHRoaXMuaGFzRHVwbGljYXRlcyhzZWNTY2hlbWVzKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgc2VjdXJpdHlTY2hlbWUgY29uc3VtcHRpb24nLCBudWxsLCAnc2VjdXJpdHlTY2hlbWVzIGNhbiBvbmx5IGJlIHJlZmVyZW5jZWQgb25jZSBpbiBhIHNlY3VyZWRCeSBwcm9wZXJ0eScsIHByb3BlcnR5WzBdLnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgX3JlZjEgPSBwcm9wZXJ0eVsxXS52YWx1ZTtcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYxLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIHNlY1NjaGVtZSA9IF9yZWYxW19pXTtcbiAgICAgICAgaWYgKHV0aWwuaXNTZXF1ZW5jZShzZWNTY2hlbWUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHNlY3VyaXR5U2NoZW1lIGNvbnN1bXB0aW9uJywgbnVsbCwgJ3NlY3VyaXR5U2NoZW1lIHJlZmVyZW5jZSBjYW5ub3QgYmUgYW4gYXJyYXknLCBzZWNTY2hlbWUuc3RhcnRfbWFyayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF1dGlsLmlzTnVsbChzZWNTY2hlbWUpKSB7XG4gICAgICAgICAgc2VjdXJpdHlTY2hlbWVOYW1lID0gdGhpcy5rZXlfb3JfdmFsdWUoc2VjU2NoZW1lKTtcbiAgICAgICAgICBpZiAoIXRoaXMuZ2V0X3NlY3VyaXR5X3NjaGVtZShzZWN1cml0eVNjaGVtZU5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgc2VjdXJpdHlTY2hlbWUgY29uc3VtcHRpb24nLCBudWxsLCAndGhlcmUgaXMgbm8gc2VjdXJpdHlTY2hlbWUgbmFtZWQgJyArIHNlY3VyaXR5U2NoZW1lTmFtZSwgc2VjU2NoZW1lLnN0YXJ0X21hcmspO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfcmVzdWx0cy5wdXNoKHZvaWQgMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2godm9pZCAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlX3Byb3RvY29sc19wcm9wZXJ0eSA9IGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgICB2YXIgcHJvdG9jb2wsIF9pLCBfbGVuLCBfcmVmMSwgX3JlZjIsIF9yZXN1bHRzO1xuICAgICAgaWYgKCF1dGlsLmlzU2VxdWVuY2UocHJvcGVydHlbMV0pKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBwcm90b2NvbHMnLCBudWxsLCAncHJvcGVydHkgbXVzdCBiZSBhbiBhcnJheScsIHByb3BlcnR5WzBdLnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgX3JlZjEgPSBwcm9wZXJ0eVsxXS52YWx1ZTtcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYxLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIHByb3RvY29sID0gX3JlZjFbX2ldO1xuICAgICAgICBpZiAoIXV0aWwuaXNTdHJpbmcocHJvdG9jb2wpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHByb3RvY29scycsIG51bGwsICd2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nJywgcHJvdG9jb2wuc3RhcnRfbWFyayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChfcmVmMiA9IHByb3RvY29sLnZhbHVlKSAhPT0gJ0hUVFAnICYmIF9yZWYyICE9PSAnSFRUUFMnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHByb3RvY29scycsIG51bGwsICdvbmx5IEhUVFAgYW5kIEhUVFBTIHZhbHVlcyBhcmUgYWxsb3dlZCcsIHByb3RvY29sLnN0YXJ0X21hcmspO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2godm9pZCAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlX3R5cGVfcHJvcGVydHkgPSBmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgICAgdmFyIHBhcmFtZXRlciwgdHlwZU5hbWUsIF9pLCBfbGVuLCBfcmVmMSwgX3Jlc3VsdHM7XG4gICAgICBpZiAoISh1dGlsLmlzTWFwcGluZyhwcm9wZXJ0eVsxXSkgfHwgdXRpbC5pc1N0cmluZyhwcm9wZXJ0eVsxXSkpKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyByZXNvdXJjZSB0eXBlcycsIG51bGwsIFwicHJvcGVydHkgJ3R5cGUnIG11c3QgYmUgYSBzdHJpbmcgb3IgYSBtYXBcIiwgcHJvcGVydHlbMF0uc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICBpZiAodXRpbC5pc01hcHBpbmcocHJvcGVydHlbMV0pKSB7XG4gICAgICAgIGlmIChwcm9wZXJ0eVsxXS52YWx1ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHJlc291cmNlIHR5cGVzJywgbnVsbCwgJ2EgcmVzb3VyY2Ugb3IgcmVzb3VyY2VUeXBlIGNhbiBpbmhlcml0IGZyb20gYSBzaW5nbGUgcmVzb3VyY2VUeXBlJywgcHJvcGVydHlbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHR5cGVOYW1lID0gdGhpcy5rZXlfb3JfdmFsdWUocHJvcGVydHlbMV0pO1xuICAgICAgaWYgKCEodHlwZU5hbWUgIT0gbnVsbCA/IHR5cGVOYW1lLnRyaW0oKSA6IHZvaWQgMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHJlc291cmNlIHR5cGUgY29uc3VtcHRpb24nLCBudWxsLCAncmVzb3VyY2UgdHlwZSBuYW1lIG11c3QgYmUgcHJvdmlkZWQnLCBwcm9wZXJ0eVsxXS5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIGlmICghKHRoaXMuaXNQYXJhbWV0ZXJLZXlWYWx1ZSh0eXBlTmFtZSkgfHwgdGhpcy5nZXRfdHlwZSh0eXBlTmFtZSkpKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyByZXNvdXJjZSB0eXBlIGNvbnN1bXB0aW9uJywgbnVsbCwgXCJ0aGVyZSBpcyBubyByZXNvdXJjZSB0eXBlIG5hbWVkIFwiICsgdHlwZU5hbWUsIHByb3BlcnR5WzFdLnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgaWYgKHV0aWwuaXNNYXBwaW5nKHByb3BlcnR5WzFdKSkge1xuICAgICAgICBfcmVmMSA9IHByb3BlcnR5WzFdLnZhbHVlO1xuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYxLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgcGFyYW1ldGVyID0gX3JlZjFbX2ldO1xuICAgICAgICAgIGlmICghKHV0aWwuaXNOdWxsKHBhcmFtZXRlclsxXSkgfHwgdXRpbC5pc01hcHBpbmcocGFyYW1ldGVyWzFdKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyByZXNvdXJjZSBjb25zdW1wdGlvbicsIG51bGwsICdyZXNvdXJjZSB0eXBlIHBhcmFtZXRlcnMgbXVzdCBiZSBpbiBhIG1hcCcsIHBhcmFtZXRlclsxXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaCh2b2lkIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRhdGVfbWV0aG9kID0gZnVuY3Rpb24obWV0aG9kLCBhbGxvd1BhcmFtZXRlcktleXMsIGNvbnRleHQpIHtcbiAgICAgIHZhciBjYW5vbmljYWxLZXksIGtleSwgbWV0aG9kUHJvcGVydGllcywgcHJvcGVydHksIHZhbGlkLCBfaSwgX2xlbiwgX3JlZjEsIF9yZXN1bHRzO1xuICAgICAgaWYgKGNvbnRleHQgPT0gbnVsbCkge1xuICAgICAgICBjb250ZXh0ID0gJ21ldGhvZCc7XG4gICAgICB9XG4gICAgICBpZiAodXRpbC5pc051bGwobWV0aG9kWzFdKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXV0aWwuaXNNYXBwaW5nKG1ldGhvZFsxXSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIG1ldGhvZHMnLCBudWxsLCBcIm1ldGhvZCBtdXN0IGJlIGEgbWFwXCIsIG1ldGhvZFswXS5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIG1ldGhvZFByb3BlcnRpZXMgPSB7fTtcbiAgICAgIF9yZWYxID0gbWV0aG9kWzFdLnZhbHVlO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjEubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgcHJvcGVydHkgPSBfcmVmMVtfaV07XG4gICAgICAgIHRoaXMudHJhY2tSZXBlYXRlZFByb3BlcnRpZXMobWV0aG9kUHJvcGVydGllcywgdGhpcy5jYW5vbmljYWxpemVQcm9wZXJ0eU5hbWUocHJvcGVydHlbMF0udmFsdWUsIHRydWUpLCBwcm9wZXJ0eVswXSwgJ3doaWxlIHZhbGlkYXRpbmcgbWV0aG9kJywgXCJwcm9wZXJ0eSBhbHJlYWR5IHVzZWRcIik7XG4gICAgICAgIGlmICh0aGlzLnZhbGlkYXRlX2NvbW1vbl9wcm9wZXJ0aWVzKHByb3BlcnR5LCBhbGxvd1BhcmFtZXRlcktleXMsIGNvbnRleHQpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAga2V5ID0gcHJvcGVydHlbMF0udmFsdWU7XG4gICAgICAgIGNhbm9uaWNhbEtleSA9IHRoaXMuY2Fub25pY2FsaXplUHJvcGVydHlOYW1lKGtleSwgYWxsb3dQYXJhbWV0ZXJLZXlzKTtcbiAgICAgICAgdmFsaWQgPSB0cnVlO1xuICAgICAgICBzd2l0Y2ggKGNhbm9uaWNhbEtleSkge1xuICAgICAgICAgIGNhc2UgJ2hlYWRlcnMnOlxuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZV9oZWFkZXJzKHByb3BlcnR5LCBhbGxvd1BhcmFtZXRlcktleXMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAncXVlcnlQYXJhbWV0ZXJzJzpcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVfcXVlcnlfcGFyYW1zKHByb3BlcnR5LCBhbGxvd1BhcmFtZXRlcktleXMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnYm9keSc6XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlX2JvZHkocHJvcGVydHksIGFsbG93UGFyYW1ldGVyS2V5cywgbnVsbCwgZmFsc2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAncmVzcG9uc2VzJzpcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVfcmVzcG9uc2VzKHByb3BlcnR5LCBhbGxvd1BhcmFtZXRlcktleXMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnYmFzZVVyaVBhcmFtZXRlcnMnOlxuICAgICAgICAgICAgaWYgKCF0aGlzLmJhc2VVcmkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHVyaSBwYXJhbWV0ZXJzJywgbnVsbCwgJ2Jhc2UgdXJpIHBhcmFtZXRlcnMgZGVmaW5lZCB3aGVuIHRoZXJlIGlzIG5vIGJhc2VVcmknLCBwcm9wZXJ0eVswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdXRpbC5pc051bGxhYmxlTWFwcGluZyhwcm9wZXJ0eVsxXSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHVyaSBwYXJhbWV0ZXJzJywgbnVsbCwgJ2Jhc2UgdXJpIHBhcmFtZXRlcnMgbXVzdCBiZSBhIG1hcCcsIHByb3BlcnR5WzBdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZV91cmlfcGFyYW1ldGVycyh0aGlzLmJhc2VVcmksIHByb3BlcnR5WzFdLCBhbGxvd1BhcmFtZXRlcktleXMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAncHJvdG9jb2xzJzpcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVfcHJvdG9jb2xzX3Byb3BlcnR5KHByb3BlcnR5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB2YWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgY2FzZSAnc2VjdXJlZEJ5JzpcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2godGhpcy52YWxpZGF0ZV9zZWN1cmVkX2J5KHByb3BlcnR5KSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd1c2FnZSc6XG4gICAgICAgICAgICBpZiAoIShhbGxvd1BhcmFtZXRlcktleXMgJiYgY29udGV4dCA9PT0gJ3RyYWl0JykpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHJlc291cmNlcycsIG51bGwsIFwicHJvcGVydHk6ICd1c2FnZScgaXMgaW52YWxpZCBpbiBhIFwiICsgY29udGV4dCwgcHJvcGVydHlbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBfcmVzdWx0cy5wdXNoKHZvaWQgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcmVzb3VyY2VzJywgbnVsbCwgXCJwcm9wZXJ0eTogJ1wiICsgcHJvcGVydHlbMF0udmFsdWUgKyBcIicgaXMgaW52YWxpZCBpbiBhIFwiICsgY29udGV4dCwgcHJvcGVydHlbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBfcmVzdWx0cy5wdXNoKHZvaWQgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZV9yZXNwb25zZXMgPSBmdW5jdGlvbihyZXNwb25zZXMsIGFsbG93UGFyYW1ldGVyS2V5cykge1xuICAgICAgdmFyIHJlc3BvbnNlLCByZXNwb25zZVZhbHVlcywgX2ksIF9sZW4sIF9yZWYxLCBfcmVzdWx0cztcbiAgICAgIGlmICh1dGlsLmlzTnVsbChyZXNwb25zZXNbMV0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghdXRpbC5pc01hcHBpbmcocmVzcG9uc2VzWzFdKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcmVzcG9uc2VzJywgbnVsbCwgXCJwcm9wZXJ0eTogJ3Jlc3BvbnNlcycgbXVzdCBiZSBhIG1hcFwiLCByZXNwb25zZXNbMF0uc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICByZXNwb25zZVZhbHVlcyA9IHt9O1xuICAgICAgX3JlZjEgPSByZXNwb25zZXNbMV0udmFsdWU7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICByZXNwb25zZSA9IF9yZWYxW19pXTtcbiAgICAgICAgaWYgKCF1dGlsLmlzTnVsbGFibGVNYXBwaW5nKHJlc3BvbnNlWzFdKSkge1xuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyByZXNwb25zZXMnLCBudWxsLCAnZWFjaCByZXNwb25zZSBtdXN0IGJlIGEgbWFwJywgcmVzcG9uc2VbMV0uc3RhcnRfbWFyayk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFja1JlcGVhdGVkUHJvcGVydGllcyhyZXNwb25zZVZhbHVlcywgdGhpcy5jYW5vbmljYWxpemVQcm9wZXJ0eU5hbWUocmVzcG9uc2VbMF0udmFsdWUsIHRydWUpLCByZXNwb25zZVswXSwgJ3doaWxlIHZhbGlkYXRpbmcgcmVzcG9uc2VzJywgXCJyZXNwb25zZSBjb2RlIGFscmVhZHkgdXNlZFwiKTtcbiAgICAgICAgX3Jlc3VsdHMucHVzaCh0aGlzLnZhbGlkYXRlX3Jlc3BvbnNlKHJlc3BvbnNlLCBhbGxvd1BhcmFtZXRlcktleXMpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZV9xdWVyeV9wYXJhbXMgPSBmdW5jdGlvbihwcm9wZXJ0eSwgYWxsb3dQYXJhbWV0ZXJLZXlzKSB7XG4gICAgICB2YXIgcGFyYW0sIHF1ZXJ5UGFyYW1ldGVycywgX2ksIF9sZW4sIF9yZWYxLCBfcmVzdWx0cztcbiAgICAgIGlmICh1dGlsLmlzTnVsbChwcm9wZXJ0eVsxXSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCF1dGlsLmlzTWFwcGluZyhwcm9wZXJ0eVsxXSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHF1ZXJ5IHBhcmFtZXRlcnMnLCBudWxsLCBcInByb3BlcnR5OiAncXVlcnlQYXJhbWV0ZXJzJyBtdXN0IGJlIGEgbWFwXCIsIHByb3BlcnR5WzBdLnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICBfcmVmMSA9IHByb3BlcnR5WzFdLnZhbHVlO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjEubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgcGFyYW0gPSBfcmVmMVtfaV07XG4gICAgICAgIGlmICghKHV0aWwuaXNOdWxsYWJsZU1hcHBpbmcocGFyYW1bMV0pIHx8IHV0aWwuaXNOdWxsYWJsZVNlcXVlbmNlKHBhcmFtWzFdKSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcXVlcnkgcGFyYW1ldGVycycsIG51bGwsIFwiZWFjaCBxdWVyeSBwYXJhbWV0ZXIgbXVzdCBiZSBhIG1hcFwiLCBwYXJhbVsxXS5zdGFydF9tYXJrKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYWNrUmVwZWF0ZWRQcm9wZXJ0aWVzKHF1ZXJ5UGFyYW1ldGVycywgdGhpcy5jYW5vbmljYWxpemVQcm9wZXJ0eU5hbWUocGFyYW1bMF0udmFsdWUsIHRydWUpLCBwYXJhbVswXSwgJ3doaWxlIHZhbGlkYXRpbmcgcXVlcnkgcGFyYW1ldGVyJywgXCJwYXJhbWV0ZXIgbmFtZSBhbHJlYWR5IHVzZWRcIik7XG4gICAgICAgIF9yZXN1bHRzLnB1c2godGhpcy52YWxpZF9jb21tb25fcGFyYW1ldGVyX3Byb3BlcnRpZXMocGFyYW1bMV0sIGFsbG93UGFyYW1ldGVyS2V5cykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlX2Zvcm1fcGFyYW1zID0gZnVuY3Rpb24ocHJvcGVydHksIGFsbG93UGFyYW1ldGVyS2V5cykge1xuICAgICAgdmFyIGZvcm1QYXJhbWV0ZXJzLCBwYXJhbSwgX2ksIF9sZW4sIF9yZWYxLCBfcmVzdWx0cztcbiAgICAgIGlmICh1dGlsLmlzTnVsbChwcm9wZXJ0eVsxXSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCF1dGlsLmlzTWFwcGluZyhwcm9wZXJ0eVsxXSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHF1ZXJ5IHBhcmFtZXRlcnMnLCBudWxsLCBcInByb3BlcnR5OiAnZm9ybVBhcmFtZXRlcnMnIG11c3QgYmUgYSBtYXBcIiwgcHJvcGVydHlbMF0uc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICBmb3JtUGFyYW1ldGVycyA9IHt9O1xuICAgICAgX3JlZjEgPSBwcm9wZXJ0eVsxXS52YWx1ZTtcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYxLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIHBhcmFtID0gX3JlZjFbX2ldO1xuICAgICAgICBpZiAoISh1dGlsLmlzTnVsbGFibGVNYXBwaW5nKHBhcmFtWzFdKSB8fCB1dGlsLmlzTnVsbGFibGVTZXF1ZW5jZShwYXJhbVsxXSkpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHF1ZXJ5IHBhcmFtZXRlcnMnLCBudWxsLCAnZWFjaCBmb3JtIHBhcmFtZXRlciBtdXN0IGJlIGEgbWFwJywgcGFyYW1bMV0uc3RhcnRfbWFyayk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFja1JlcGVhdGVkUHJvcGVydGllcyhmb3JtUGFyYW1ldGVycywgdGhpcy5jYW5vbmljYWxpemVQcm9wZXJ0eU5hbWUocGFyYW1bMF0udmFsdWUsIHRydWUpLCBwYXJhbVswXSwgJ3doaWxlIHZhbGlkYXRpbmcgZm9ybSBwYXJhbWV0ZXInLCBcInBhcmFtZXRlciBuYW1lIGFscmVhZHkgdXNlZFwiKTtcbiAgICAgICAgX3Jlc3VsdHMucHVzaCh0aGlzLnZhbGlkX2NvbW1vbl9wYXJhbWV0ZXJfcHJvcGVydGllcyhwYXJhbVsxXSwgYWxsb3dQYXJhbWV0ZXJLZXlzKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRhdGVfaGVhZGVycyA9IGZ1bmN0aW9uKHByb3BlcnR5LCBhbGxvd1BhcmFtZXRlcktleXMpIHtcbiAgICAgIHZhciBoZWFkZXJOYW1lcywgcGFyYW0sIF9pLCBfbGVuLCBfcmVmMSwgX3Jlc3VsdHM7XG4gICAgICBpZiAodXRpbC5pc051bGwocHJvcGVydHlbMV0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghdXRpbC5pc01hcHBpbmcocHJvcGVydHlbMV0pKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBoZWFkZXJzJywgbnVsbCwgXCJwcm9wZXJ0eTogJ2hlYWRlcnMnIG11c3QgYmUgYSBtYXBcIiwgcHJvcGVydHlbMF0uc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICBoZWFkZXJOYW1lcyA9IHt9O1xuICAgICAgX3JlZjEgPSBwcm9wZXJ0eVsxXS52YWx1ZTtcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYxLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIHBhcmFtID0gX3JlZjFbX2ldO1xuICAgICAgICBpZiAoISh1dGlsLmlzTnVsbGFibGVNYXBwaW5nKHBhcmFtWzFdKSB8fCB1dGlsLmlzTnVsbGFibGVTZXF1ZW5jZShwYXJhbVsxXSkpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHF1ZXJ5IHBhcmFtZXRlcnMnLCBudWxsLCBcImVhY2ggaGVhZGVyIG11c3QgYmUgYSBtYXBcIiwgcGFyYW1bMV0uc3RhcnRfbWFyayk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFja1JlcGVhdGVkUHJvcGVydGllcyhoZWFkZXJOYW1lcywgdGhpcy5jYW5vbmljYWxpemVQcm9wZXJ0eU5hbWUocGFyYW1bMF0udmFsdWUsIHRydWUpLCBwYXJhbVswXSwgJ3doaWxlIHZhbGlkYXRpbmcgaGVhZGVycycsIFwiaGVhZGVyIG5hbWUgYWxyZWFkeSB1c2VkXCIpO1xuICAgICAgICBfcmVzdWx0cy5wdXNoKHRoaXMudmFsaWRfY29tbW9uX3BhcmFtZXRlcl9wcm9wZXJ0aWVzKHBhcmFtWzFdLCBhbGxvd1BhcmFtZXRlcktleXMpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZV9yZXNwb25zZSA9IGZ1bmN0aW9uKHJlc3BvbnNlLCBhbGxvd1BhcmFtZXRlcktleXMpIHtcbiAgICAgIHZhciBjYW5vbmljYWxLZXksIHByb3BlcnR5LCByZXNwb25zZUNvZGUsIHJlc3BvbnNlUHJvcGVydGllcywgdmFsaWQsIF9pLCBfaiwgX2xlbiwgX2xlbjEsIF9yZWYxLCBfcmVmMiwgX3Jlc3VsdHM7XG4gICAgICBpZiAodXRpbC5pc1NlcXVlbmNlKHJlc3BvbnNlWzBdKSkge1xuICAgICAgICBpZiAoIXJlc3BvbnNlWzBdLnZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyByZXNwb25zZXMnLCBudWxsLCAndGhlcmUgbXVzdCBiZSBhdCBsZWFzdCBvbmUgcmVzcG9uc2UgY29kZScsIHJlc3BvbnNlWzBdLnN0YXJ0X21hcmspO1xuICAgICAgICB9XG4gICAgICAgIF9yZWYxID0gcmVzcG9uc2VbMF0udmFsdWU7XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjEubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICByZXNwb25zZUNvZGUgPSBfcmVmMVtfaV07XG4gICAgICAgICAgaWYgKCEodGhpcy5pc1BhcmFtZXRlcktleShyZXNwb25zZUNvZGUpIHx8IHV0aWwuaXNJbnRlZ2VyKHJlc3BvbnNlQ29kZSkgfHwgIWlzTmFOKHRoaXMuY2Fub25pY2FsaXplUHJvcGVydHlOYW1lKHJlc3BvbnNlQ29kZSwgYWxsb3dQYXJhbWV0ZXJLZXlzKSkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcmVzcG9uc2VzJywgbnVsbCwgXCJlYWNoIHJlc3BvbnNlIGtleSBtdXN0IGJlIGFuIGludGVnZXJcIiwgcmVzcG9uc2VDb2RlLnN0YXJ0X21hcmspO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghKHRoaXMuaXNQYXJhbWV0ZXJLZXkocmVzcG9uc2UpIHx8IHV0aWwuaXNJbnRlZ2VyKHJlc3BvbnNlWzBdKSB8fCAhaXNOYU4odGhpcy5jYW5vbmljYWxpemVQcm9wZXJ0eU5hbWUocmVzcG9uc2VbMF0udmFsdWUsIGFsbG93UGFyYW1ldGVyS2V5cykpKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcmVzcG9uc2VzJywgbnVsbCwgXCJlYWNoIHJlc3BvbnNlIGtleSBtdXN0IGJlIGFuIGludGVnZXJcIiwgcmVzcG9uc2VbMF0uc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICBpZiAoIXV0aWwuaXNOdWxsYWJsZU1hcHBpbmcocmVzcG9uc2VbMV0pKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyByZXNwb25zZXMnLCBudWxsLCBcImVhY2ggcmVzcG9uc2UgcHJvcGVydHkgbXVzdCBiZSBhIG1hcFwiLCByZXNwb25zZVswXS5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIGlmICh1dGlsLmlzTWFwcGluZyhyZXNwb25zZVsxXSkpIHtcbiAgICAgICAgcmVzcG9uc2VQcm9wZXJ0aWVzID0ge307XG4gICAgICAgIF9yZWYyID0gcmVzcG9uc2VbMV0udmFsdWU7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoX2ogPSAwLCBfbGVuMSA9IF9yZWYyLmxlbmd0aDsgX2ogPCBfbGVuMTsgX2orKykge1xuICAgICAgICAgIHByb3BlcnR5ID0gX3JlZjJbX2pdO1xuICAgICAgICAgIGNhbm9uaWNhbEtleSA9IHRoaXMuY2Fub25pY2FsaXplUHJvcGVydHlOYW1lKHByb3BlcnR5WzBdLnZhbHVlLCBhbGxvd1BhcmFtZXRlcktleXMpO1xuICAgICAgICAgIHRoaXMudHJhY2tSZXBlYXRlZFByb3BlcnRpZXMocmVzcG9uc2VQcm9wZXJ0aWVzLCBjYW5vbmljYWxLZXksIHByb3BlcnR5WzBdLCAnd2hpbGUgdmFsaWRhdGluZyByZXNwb25zZXMnLCBcInByb3BlcnR5IGFscmVhZHkgdXNlZFwiKTtcbiAgICAgICAgICB2YWxpZCA9IHRydWU7XG4gICAgICAgICAgaWYgKCF0aGlzLmlzUGFyYW1ldGVyS2V5KHByb3BlcnR5KSkge1xuICAgICAgICAgICAgc3dpdGNoIChwcm9wZXJ0eVswXS52YWx1ZSkge1xuICAgICAgICAgICAgICBjYXNlIFwiZGVzY3JpcHRpb25cIjpcbiAgICAgICAgICAgICAgICBpZiAoIXV0aWwuaXNTY2FsYXIocHJvcGVydHlbMV0pKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcmVzcG9uc2VzJywgbnVsbCwgJ3Byb3BlcnR5IGRlc2NyaXB0aW9uIG11c3QgYmUgYSBzdHJpbmcnLCByZXNwb25zZVswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAoY2Fub25pY2FsS2V5KSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJib2R5XCI6XG4gICAgICAgICAgICAgICAgX3Jlc3VsdHMucHVzaCh0aGlzLnZhbGlkYXRlX2JvZHkocHJvcGVydHksIGFsbG93UGFyYW1ldGVyS2V5cywgbnVsbCwgdHJ1ZSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiaGVhZGVyc1wiOlxuICAgICAgICAgICAgICAgIGlmICghdXRpbC5pc051bGxhYmxlTWFwcGluZyhwcm9wZXJ0eVsxXSkpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyByZXNvdXJjZXMnLCBudWxsLCBcInByb3BlcnR5ICdoZWFkZXJzJyBtdXN0IGJlIGEgbWFwXCIsIHByb3BlcnR5WzBdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfcmVzdWx0cy5wdXNoKHRoaXMudmFsaWRhdGVfaGVhZGVycyhwcm9wZXJ0eSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyByZXNwb25zZScsIG51bGwsIFwicHJvcGVydHk6ICdcIiArIHByb3BlcnR5WzBdLnZhbHVlICsgXCInIGlzIGludmFsaWQgaW4gYSByZXNwb25zZVwiLCBwcm9wZXJ0eVswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgX3Jlc3VsdHMucHVzaCh2b2lkIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaCh2b2lkIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUuaXNIdHRwTWV0aG9kID0gZnVuY3Rpb24odmFsdWUsIGFsbG93UGFyYW1ldGVyS2V5cykge1xuICAgICAgdmFyIF9yZWYxO1xuICAgICAgaWYgKGFsbG93UGFyYW1ldGVyS2V5cyA9PSBudWxsKSB7XG4gICAgICAgIGFsbG93UGFyYW1ldGVyS2V5cyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHZhbHVlID0gdGhpcy5jYW5vbmljYWxpemVQcm9wZXJ0eU5hbWUodmFsdWUsIGFsbG93UGFyYW1ldGVyS2V5cyk7XG4gICAgICAgIHJldHVybiAoX3JlZjEgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpKSA9PT0gJ29wdGlvbnMnIHx8IF9yZWYxID09PSAnZ2V0JyB8fCBfcmVmMSA9PT0gJ2hlYWQnIHx8IF9yZWYxID09PSAncG9zdCcgfHwgX3JlZjEgPT09ICdwdXQnIHx8IF9yZWYxID09PSAnZGVsZXRlJyB8fCBfcmVmMSA9PT0gJ3RyYWNlJyB8fCBfcmVmMSA9PT0gJ2Nvbm5lY3QnIHx8IF9yZWYxID09PSAncGF0Y2gnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLmlzUGFyYW1ldGVyVmFsdWUgPSBmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNQYXJhbWV0ZXJLZXkocHJvcGVydHksIGZhbHNlKTtcbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS5pc1BhcmFtZXRlcktleSA9IGZ1bmN0aW9uKHByb3BlcnR5LCBjaGVja0tleSkge1xuICAgICAgdmFyIG9mZnNldDtcbiAgICAgIGlmIChjaGVja0tleSA9PSBudWxsKSB7XG4gICAgICAgIGNoZWNrS2V5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIG9mZnNldCA9IGNoZWNrS2V5ID8gMCA6IDE7XG4gICAgICBpZiAoIShjaGVja0tleSB8fCB1dGlsLmlzU2NhbGFyKHByb3BlcnR5WzFdKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaXNQYXJhbWV0ZXJLZXlWYWx1ZShwcm9wZXJ0eVtvZmZzZXRdLnZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAocHJvcGVydHlbb2Zmc2V0XS52YWx1ZS5tYXRjaCgvPDxcXHMqKFteXFx8XFxzPl0rKVxccypcXHwuKlxccyo+Pi9nKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcGFyYW1ldGVyJywgbnVsbCwgXCJ1bmtub3duIGZ1bmN0aW9uIGFwcGxpZWQgdG8gcHJvcGVydHkgbmFtZVwiLCBwcm9wZXJ0eVswXS5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS5pc1BhcmFtZXRlcktleVZhbHVlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZS5tYXRjaCgvPDxcXHMqKFteXFx8XFxzPl0rKVxccyo+Pi9nKSB8fCB2YWx1ZS5tYXRjaCgvPDxcXHMqKFteXFx8XFxzPl0rKVxccyooXFx8XFxzKlxcIVxccyooc2luZ3VsYXJpemV8cGx1cmFsaXplKSk/XFxzKj4+L2cpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlX2JvZHkgPSBmdW5jdGlvbihwcm9wZXJ0eSwgYWxsb3dQYXJhbWV0ZXJLZXlzLCBib2R5TW9kZSwgaXNSZXNwb25zZUJvZHkpIHtcbiAgICAgIHZhciBib2R5UHJvcGVydGllcywgYm9keVByb3BlcnR5LCBjYW5vbmljYWxQcm9wZXJ0eSwgaW1wbGljaXRNb2RlLCBrZXksIHN0YXJ0X21hcmssIHZhbGlkLCBfaSwgX2xlbiwgX3JlZjE7XG4gICAgICBpZiAoYm9keU1vZGUgPT0gbnVsbCkge1xuICAgICAgICBib2R5TW9kZSA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAodXRpbC5pc051bGwocHJvcGVydHlbMV0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghdXRpbC5pc01hcHBpbmcocHJvcGVydHlbMV0pKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBib2R5JywgbnVsbCwgXCJwcm9wZXJ0eTogYm9keSBzcGVjaWZpY2F0aW9uIG11c3QgYmUgYSBtYXBcIiwgcHJvcGVydHlbMF0uc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICBpbXBsaWNpdE1vZGUgPSBbXCJpbXBsaWNpdFwiLCBcImZvcmNlZEltcGxpY2l0XCJdO1xuICAgICAgYm9keVByb3BlcnRpZXMgPSB7fTtcbiAgICAgIF9yZWYxID0gcHJvcGVydHlbMV0udmFsdWU7XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYxLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGJvZHlQcm9wZXJ0eSA9IF9yZWYxW19pXTtcbiAgICAgICAgdGhpcy50cmFja1JlcGVhdGVkUHJvcGVydGllcyhib2R5UHJvcGVydGllcywgdGhpcy5jYW5vbmljYWxpemVQcm9wZXJ0eU5hbWUoYm9keVByb3BlcnR5WzBdLnZhbHVlLCB0cnVlKSwgYm9keVByb3BlcnR5WzBdLCAnd2hpbGUgdmFsaWRhdGluZyBib2R5JywgXCJwcm9wZXJ0eSBhbHJlYWR5IHVzZWRcIik7XG4gICAgICAgIGlmICh0aGlzLmlzUGFyYW1ldGVyS2V5KGJvZHlQcm9wZXJ0eSkpIHtcbiAgICAgICAgICBpZiAoIWFsbG93UGFyYW1ldGVyS2V5cykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIGJvZHknLCBudWxsLCBcInByb3BlcnR5ICdcIiArIGJvZHlQcm9wZXJ0eVswXS52YWx1ZSArIFwiJyBpcyBpbnZhbGlkIGluIGEgcmVzb3VyY2VcIiwgYm9keVByb3BlcnR5WzBdLnN0YXJ0X21hcmspO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChib2R5UHJvcGVydHlbMF0udmFsdWUubWF0Y2goL15bXlxcL10rXFwvW15cXC9dKyQvKSkge1xuICAgICAgICAgIGlmIChib2R5TW9kZSAmJiBib2R5TW9kZSAhPT0gXCJleHBsaWNpdFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgYm9keScsIG51bGwsIFwibm90IGNvbXBhdGlibGUgd2l0aCBpbXBsaWNpdCBkZWZhdWx0IE1lZGlhIFR5cGVcIiwgYm9keVByb3BlcnR5WzBdLnN0YXJ0X21hcmspO1xuICAgICAgICAgIH1cbiAgICAgICAgICBib2R5TW9kZSA9IFwiZXhwbGljaXRcIjtcbiAgICAgICAgICB0aGlzLnZhbGlkYXRlX2JvZHkoYm9keVByb3BlcnR5LCBhbGxvd1BhcmFtZXRlcktleXMsIFwiZm9yY2VkSW1wbGljaXRcIiwgaXNSZXNwb25zZUJvZHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGtleSA9IGJvZHlQcm9wZXJ0eVswXS52YWx1ZTtcbiAgICAgICAgICBjYW5vbmljYWxQcm9wZXJ0eSA9IHRoaXMuY2Fub25pY2FsaXplUHJvcGVydHlOYW1lKGtleSwgYWxsb3dQYXJhbWV0ZXJLZXlzKTtcbiAgICAgICAgICB2YWxpZCA9IHRydWU7XG4gICAgICAgICAgc3dpdGNoIChjYW5vbmljYWxQcm9wZXJ0eSkge1xuICAgICAgICAgICAgY2FzZSBcImZvcm1QYXJhbWV0ZXJzXCI6XG4gICAgICAgICAgICAgIGlmIChib2R5TW9kZSAmJiBfX2luZGV4T2YuY2FsbChpbXBsaWNpdE1vZGUsIGJvZHlNb2RlKSA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgYm9keScsIG51bGwsIFwibm90IGNvbXBhdGlibGUgd2l0aCBleHBsaWNpdCBNZWRpYSBUeXBlXCIsIGJvZHlQcm9wZXJ0eVswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoYm9keU1vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGJvZHlNb2RlID0gXCJpbXBsaWNpdFwiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMudmFsaWRhdGVfZm9ybV9wYXJhbXMoYm9keVByb3BlcnR5LCBhbGxvd1BhcmFtZXRlcktleXMpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICBjYXNlIFwiZXhhbXBsZVwiOlxuICAgICAgICAgICAgICBpZiAoYm9keU1vZGUgJiYgX19pbmRleE9mLmNhbGwoaW1wbGljaXRNb2RlLCBib2R5TW9kZSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIGJvZHknLCBudWxsLCBcIm5vdCBjb21wYXRpYmxlIHdpdGggZXhwbGljaXQgTWVkaWEgVHlwZVwiLCBib2R5UHJvcGVydHlbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGJvZHlNb2RlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBib2R5TW9kZSA9IFwiaW1wbGljaXRcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIXV0aWwuaXNTY2FsYXIoYm9keVByb3BlcnR5WzFdKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBib2R5JywgbnVsbCwgXCJleGFtcGxlIG11c3QgYmUgYSBzdHJpbmdcIiwgYm9keVByb3BlcnR5WzBdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInNjaGVtYVwiOlxuICAgICAgICAgICAgICBpZiAoYm9keU1vZGUgJiYgX19pbmRleE9mLmNhbGwoaW1wbGljaXRNb2RlLCBib2R5TW9kZSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIGJvZHknLCBudWxsLCBcIm5vdCBjb21wYXRpYmxlIHdpdGggZXhwbGljaXQgTWVkaWEgVHlwZVwiLCBib2R5UHJvcGVydHlbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGJvZHlNb2RlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBib2R5TW9kZSA9IFwiaW1wbGljaXRcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIXV0aWwuaXNTY2FsYXIoYm9keVByb3BlcnR5WzFdKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBib2R5JywgbnVsbCwgXCJzY2hlbWEgbXVzdCBiZSBhIHN0cmluZ1wiLCBib2R5UHJvcGVydHlbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy52YWxpZGF0ZVNjaGVtYShib2R5UHJvcGVydHlbMV0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgYm9keScsIG51bGwsIFwicHJvcGVydHk6ICdcIiArIGJvZHlQcm9wZXJ0eVswXS52YWx1ZSArIFwiJyBpcyBpbnZhbGlkIGluIGEgYm9keVwiLCBib2R5UHJvcGVydHlbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChcImZvcm1QYXJhbWV0ZXJzXCIgaW4gYm9keVByb3BlcnRpZXMpIHtcbiAgICAgICAgc3RhcnRfbWFyayA9IGJvZHlQcm9wZXJ0aWVzLmZvcm1QYXJhbWV0ZXJzLnN0YXJ0X21hcms7XG4gICAgICAgIGlmIChpc1Jlc3BvbnNlQm9keSkge1xuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBib2R5JywgbnVsbCwgXCJmb3JtUGFyYW1ldGVycyBjYW5ub3QgYmUgdXNlZCB0byBkZXNjcmliZSByZXNwb25zZSBib2RpZXNcIiwgc3RhcnRfbWFyayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwic2NoZW1hXCIgaW4gYm9keVByb3BlcnRpZXMgfHwgXCJleGFtcGxlXCIgaW4gYm9keVByb3BlcnRpZXMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgYm9keScsIG51bGwsIFwiZm9ybVBhcmFtZXRlcnMgY2Fubm90IGJlIHVzZWQgdG9nZXRoZXIgd2l0aCB0aGUgZXhhbXBsZSBvciBzY2hlbWEgcHJvcGVydGllc1wiLCBzdGFydF9tYXJrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGJvZHlNb2RlID09PSBcImltcGxpY2l0XCIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdldF9tZWRpYV90eXBlKCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgYm9keScsIG51bGwsIFwiYm9keSB0cmllcyB0byB1c2UgZGVmYXVsdCBNZWRpYSBUeXBlLCBidXQgbWVkaWFUeXBlIGlzIG51bGxcIiwgcHJvcGVydHlbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZVNjaGVtYSA9IGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgICB2YXIgZXJyb3IsIGxpbnQsIG1hcmssIHNjaGVtYTtcbiAgICAgIGlmICh0aGlzLmlzWG1sU2NoZW1hKHByb3BlcnR5LnZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmlzSnNvblNjaGVtYShwcm9wZXJ0eS52YWx1ZSkpIHtcbiAgICAgICAgbGludCA9IGpzb25saW50KHByb3BlcnR5LnZhbHVlKTtcbiAgICAgICAgaWYgKGxpbnQuZXJyb3IpIHtcbiAgICAgICAgICBtYXJrID0gdGhpcy5jcmVhdGVfbWFyayhwcm9wZXJ0eS5zdGFydF9tYXJrLmxpbmUgKyBsaW50LmxpbmUsIDApO1xuICAgICAgICAgIGlmIChwcm9wZXJ0eS5lbmRfbWFyay5saW5lID09PSBtYXJrLmxpbmUgJiYgcHJvcGVydHkuZW5kX21hcmsuY29sdW1uID09PSAwKSB7XG4gICAgICAgICAgICBtYXJrLmxpbmUtLTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIGJvZHknLCBudWxsLCBcInNjaGVtYSBpcyBub3QgdmFsaWQgSlNPTiBlcnJvcjogJ1wiICsgbGludC5lcnJvciArIFwiJ1wiLCBtYXJrKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBzY2hlbWEgPSBKU09OLnBhcnNlKHByb3BlcnR5LnZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgZXJyb3IgPSBfZXJyb3I7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIGJvZHknLCBudWxsLCBcInNjaGVtYSBpcyBub3QgdmFsaWQgSlNPTiBlcnJvcjogJ1wiICsgZXJyb3IgKyBcIidcIiwgcHJvcGVydHkuc3RhcnRfbWFyayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS5pc0pzb25TY2hlbWEgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIHJldHVybiBzdHJpbmcgIT0gbnVsbCA/IHN0cmluZy5tYXRjaCgvXlxccypcXHsvKSA6IHZvaWQgMDtcbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS5pc1htbFNjaGVtYSA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgcmV0dXJuIHN0cmluZyAhPSBudWxsID8gc3RyaW5nLm1hdGNoKC9eXFxzKig8XFw/eG1sW14+XSs+KT9bXFxzXFxuXSo8eHM6c2NoZW1hLykgOiB2b2lkIDA7XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRhdGVfY29tbW9uX3Byb3BlcnRpZXMgPSBmdW5jdGlvbihwcm9wZXJ0eSwgYWxsb3dQYXJhbWV0ZXJLZXlzLCBjb250ZXh0KSB7XG4gICAgICB2YXIgdXNlLCBfaSwgX2xlbiwgX3JlZjE7XG4gICAgICBpZiAodGhpcy5pc1BhcmFtZXRlcktleShwcm9wZXJ0eSkpIHtcbiAgICAgICAgaWYgKCFhbGxvd1BhcmFtZXRlcktleXMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcmVzb3VyY2VzJywgbnVsbCwgXCJwcm9wZXJ0eSAnXCIgKyBwcm9wZXJ0eVswXS52YWx1ZSArIFwiJyBpcyBpbnZhbGlkIGluIGEgcmVzb3VyY2VcIiwgcHJvcGVydHlbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2ggKHByb3BlcnR5WzBdLnZhbHVlKSB7XG4gICAgICAgICAgY2FzZSBcImRpc3BsYXlOYW1lXCI6XG4gICAgICAgICAgICBpZiAoY29udGV4dCA9PT0gJ21ldGhvZCcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF1dGlsLmlzU2NhbGFyKHByb3BlcnR5WzFdKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcmVzb3VyY2VzJywgbnVsbCwgXCJwcm9wZXJ0eSAnZGlzcGxheU5hbWUnIG11c3QgYmUgYSBzdHJpbmdcIiwgcHJvcGVydHlbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICBjYXNlIFwiZGVzY3JpcHRpb25cIjpcbiAgICAgICAgICAgIGlmICghdXRpbC5pc1NjYWxhcihwcm9wZXJ0eVsxXSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHJlc291cmNlcycsIG51bGwsIFwicHJvcGVydHkgJ2Rlc2NyaXB0aW9uJyBtdXN0IGJlIGEgc3RyaW5nXCIsIHByb3BlcnR5WzBdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgY2FzZSBcImlzXCI6XG4gICAgICAgICAgICBpZiAoIXV0aWwuaXNTZXF1ZW5jZShwcm9wZXJ0eVsxXSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHJlc291cmNlcycsIG51bGwsIFwicHJvcGVydHkgJ2lzJyBtdXN0IGJlIGFuIGFycmF5XCIsIHByb3BlcnR5WzBdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3JlZjEgPSBwcm9wZXJ0eVsxXS52YWx1ZTtcbiAgICAgICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjEubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICAgICAgdXNlID0gX3JlZjFbX2ldO1xuICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRlX3RyYWl0X3VzZSh1c2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZV90cmFpdF91c2UgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgcGFyYW1ldGVyLCB0cmFpdE5hbWUsIHRyYWl0VmFsdWUsIF9pLCBfbGVuLCBfcmVmMSwgX3Jlc3VsdHM7XG4gICAgICBpZiAoISh1dGlsLmlzU2NhbGFyKG5vZGUpIHx8IHV0aWwuaXNNYXBwaW5nKG5vZGUpKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgdHJhaXQgY29uc3VtcHRpb24nLCBudWxsLCAndHJhaXQgbXVzdCBiZSBhIHN0cmluZyBvciBhIG1hcCcsIG5vZGUuc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICB0cmFpdE5hbWUgPSB0aGlzLmtleV9vcl92YWx1ZShub2RlKTtcbiAgICAgIGlmICghKHRyYWl0TmFtZSAhPSBudWxsID8gdHJhaXROYW1lLnRyaW0oKSA6IHZvaWQgMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHRyYWl0IGNvbnN1bXB0aW9uJywgbnVsbCwgJ3RyYWl0IG5hbWUgbXVzdCBiZSBwcm92aWRlZCcsIG5vZGUuc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICBpZiAoISh0aGlzLmlzUGFyYW1ldGVyS2V5VmFsdWUodHJhaXROYW1lKSB8fCB0aGlzLmdldF90cmFpdCh0cmFpdE5hbWUpKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgdHJhaXQgY29uc3VtcHRpb24nLCBudWxsLCBcInRoZXJlIGlzIG5vIHRyYWl0IG5hbWVkIFwiICsgdHJhaXROYW1lLCBub2RlLnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgaWYgKHV0aWwuaXNTY2FsYXIobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdHJhaXRWYWx1ZSA9IG5vZGUudmFsdWVbMF1bMV07XG4gICAgICBpZiAoISh1dGlsLmlzTnVsbCh0cmFpdFZhbHVlKSB8fCB1dGlsLmlzTWFwcGluZyh0cmFpdFZhbHVlKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHRyYWl0IGNvbnN1bXB0aW9uJywgbnVsbCwgJ3RyYWl0IG11c3QgYmUgYSBtYXAnLCB0cmFpdFZhbHVlLnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgaWYgKHV0aWwuaXNOdWxsKHRyYWl0VmFsdWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIF9yZWYxID0gdHJhaXRWYWx1ZS52YWx1ZTtcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYxLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIHBhcmFtZXRlciA9IF9yZWYxW19pXTtcbiAgICAgICAgaWYgKCF1dGlsLmlzU2NhbGFyKHBhcmFtZXRlclsxXSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgdHJhaXQgY29uc3VtcHRpb24nLCBudWxsLCAncGFyYW1ldGVyIHZhbHVlIG11c3QgYmUgYSBzY2FsYXInLCBwYXJhbWV0ZXJbMV0uc3RhcnRfbWFyayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaCh2b2lkIDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUuY2hpbGRfbWV0aG9kcyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICBpZiAoIShub2RlICYmIHV0aWwuaXNNYXBwaW5nKG5vZGUpKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZS52YWx1ZS5maWx0ZXIoZnVuY3Rpb24oY2hpbGROb2RlKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5pc0h0dHBNZXRob2QoY2hpbGROb2RlWzBdLnZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLmhhc19wcm9wZXJ0eSA9IGZ1bmN0aW9uKG5vZGUsIHByb3BlcnR5KSB7XG4gICAgICBpZiAobm9kZSAmJiB1dGlsLmlzTWFwcGluZyhub2RlKSkge1xuICAgICAgICByZXR1cm4gbm9kZS52YWx1ZS5zb21lKGZ1bmN0aW9uKGNoaWxkTm9kZSkge1xuICAgICAgICAgIHJldHVybiBjaGlsZE5vZGVbMF0udmFsdWUgJiYgdHlwZW9mIGNoaWxkTm9kZVswXS52YWx1ZSAhPT0gXCJvYmplY3RcIiAmJiBjaGlsZE5vZGVbMF0udmFsdWUgPT09IHByb3BlcnR5O1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS5wcm9wZXJ0eV92YWx1ZSA9IGZ1bmN0aW9uKG5vZGUsIHByb3BlcnR5KSB7XG4gICAgICB2YXIgZmlsdGVyZWROb2RlcztcbiAgICAgIGZpbHRlcmVkTm9kZXMgPSBub2RlLnZhbHVlLmZpbHRlcihmdW5jdGlvbihjaGlsZE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBjaGlsZE5vZGVbMF0udmFsdWUgIT09IFwib2JqZWN0XCIgJiYgY2hpbGROb2RlWzBdLnZhbHVlID09PSBwcm9wZXJ0eTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGZpbHRlcmVkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXJlZE5vZGVzWzBdWzFdLnZhbHVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLmdldF9wcm9wZXJ0eSA9IGZ1bmN0aW9uKG5vZGUsIHByb3BlcnR5KSB7XG4gICAgICB2YXIgZmlsdGVyZWROb2RlcyxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuICAgICAgaWYgKG5vZGUgJiYgdXRpbC5pc01hcHBpbmcobm9kZSkpIHtcbiAgICAgICAgZmlsdGVyZWROb2RlcyA9IG5vZGUudmFsdWUuZmlsdGVyKGZ1bmN0aW9uKGNoaWxkTm9kZSkge1xuICAgICAgICAgIHJldHVybiB1dGlsLmlzU3RyaW5nKGNoaWxkTm9kZVswXSkgJiYgY2hpbGROb2RlWzBdLnZhbHVlID09PSBwcm9wZXJ0eTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChmaWx0ZXJlZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBpZiAoZmlsdGVyZWROb2Rlc1swXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyZWROb2Rlc1swXVsxXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBbXTtcbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS5nZXRfcHJvcGVydGllcyA9IGZ1bmN0aW9uKG5vZGUsIHByb3BlcnR5KSB7XG4gICAgICB2YXIgcHJvcCwgcHJvcGVydGllcywgX2ksIF9sZW4sIF9yZWYxO1xuICAgICAgcHJvcGVydGllcyA9IFtdO1xuICAgICAgaWYgKG5vZGUgJiYgdXRpbC5pc01hcHBpbmcobm9kZSkpIHtcbiAgICAgICAgX3JlZjEgPSBub2RlLnZhbHVlO1xuICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYxLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgcHJvcCA9IF9yZWYxW19pXTtcbiAgICAgICAgICBpZiAodXRpbC5pc1N0cmluZyhwcm9wWzBdKSAmJiBwcm9wWzBdLnZhbHVlID09PSBwcm9wZXJ0eSkge1xuICAgICAgICAgICAgcHJvcGVydGllcy5wdXNoKHByb3ApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzID0gcHJvcGVydGllcy5jb25jYXQodGhpcy5nZXRfcHJvcGVydGllcyhwcm9wWzFdLCBwcm9wZXJ0eSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRfYWJzb2x1dGVfdXJpcyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciByZXBlYXRlZFVyaSwgdXJpcztcbiAgICAgIHVyaXMgPSB0aGlzLmdldF9hYnNvbHV0ZV91cmlzKG5vZGUpO1xuICAgICAgaWYgKHJlcGVhdGVkVXJpID0gdGhpcy5oYXNEdXBsaWNhdGVzVXJpcyh1cmlzKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgdHJhaXQgY29uc3VtcHRpb24nLCBudWxsLCBcInR3byByZXNvdXJjZXMgc2hhcmUgc2FtZSBVUkkgXCIgKyByZXBlYXRlZFVyaS51cmksIHJlcGVhdGVkVXJpLm1hcmspO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLmdldF9hYnNvbHV0ZV91cmlzID0gZnVuY3Rpb24obm9kZSwgcGFyZW50UGF0aCkge1xuICAgICAgdmFyIGNoaWxkUmVzb3VyY2UsIGNoaWxkX3Jlc291cmNlcywgcmVzcG9uc2UsIHVyaSwgX2ksIF9sZW47XG4gICAgICByZXNwb25zZSA9IFtdO1xuICAgICAgaWYgKCF1dGlsLmlzTnVsbGFibGVNYXBwaW5nKG5vZGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyByZXNvdXJjZXMnLCBudWxsLCAncmVzb3VyY2UgaXMgbm90IGEgbWFwJywgbm9kZS5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkX3Jlc291cmNlcyA9IHRoaXMuY2hpbGRfcmVzb3VyY2VzKG5vZGUpO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBjaGlsZF9yZXNvdXJjZXMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgY2hpbGRSZXNvdXJjZSA9IGNoaWxkX3Jlc291cmNlc1tfaV07XG4gICAgICAgIGlmIChwYXJlbnRQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICB1cmkgPSBwYXJlbnRQYXRoICsgY2hpbGRSZXNvdXJjZVswXS52YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1cmkgPSBjaGlsZFJlc291cmNlWzBdLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3BvbnNlLnB1c2goe1xuICAgICAgICAgIHVyaTogdXJpLFxuICAgICAgICAgIG1hcms6IGNoaWxkUmVzb3VyY2VbMF0uc3RhcnRfbWFya1xuICAgICAgICB9KTtcbiAgICAgICAgcmVzcG9uc2UgPSByZXNwb25zZS5jb25jYXQodGhpcy5nZXRfYWJzb2x1dGVfdXJpcyhjaGlsZFJlc291cmNlWzFdLCB1cmkpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS5rZXlfb3JfdmFsdWUgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgcG9zc2libGVLZXlOYW1lLCBfcmVmMSwgX3JlZjIsIF9yZWYzO1xuICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBub2Rlcy5TY2FsYXJOb2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlLnZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBub2Rlcy5NYXBwaW5nTm9kZSkge1xuICAgICAgICBwb3NzaWJsZUtleU5hbWUgPSBub2RlICE9IG51bGwgPyAoX3JlZjEgPSBub2RlLnZhbHVlKSAhPSBudWxsID8gKF9yZWYyID0gX3JlZjFbMF0pICE9IG51bGwgPyAoX3JlZjMgPSBfcmVmMlswXSkgIT0gbnVsbCA/IF9yZWYzLnZhbHVlIDogdm9pZCAwIDogdm9pZCAwIDogdm9pZCAwIDogdm9pZCAwO1xuICAgICAgICBpZiAocG9zc2libGVLZXlOYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHBvc3NpYmxlS2V5TmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUudmFsdWVfb3JfdW5kZWZpbmVkID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBub2Rlcy5NYXBwaW5nTm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRhdGVfYmFzZV91cmkgPSBmdW5jdGlvbihiYXNlVXJpTm9kZSkge1xuICAgICAgdmFyIGJhc2VVcmksIGVyciwgZXhwcmVzc2lvbnMsIHByb3RvY29sLCB0ZW1wbGF0ZSwgX3JlZjEsIF9yZWYyO1xuICAgICAgYmFzZVVyaSA9IChfcmVmMSA9IGJhc2VVcmlOb2RlLnZhbHVlKSAhPSBudWxsID8gX3JlZjEudHJpbSgpIDogdm9pZCAwO1xuICAgICAgaWYgKCFiYXNlVXJpKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBiYXNlVXJpJywgbnVsbCwgJ2Jhc2VVcmkgbXVzdCBoYXZlIGEgdmFsdWUnLCBiYXNlVXJpTm9kZS5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIHByb3RvY29sID0gKCh1cmwucGFyc2UoYmFzZVVyaSkpLnByb3RvY29sIHx8ICdodHRwOicpLnNsaWNlKDAsIC0xKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgaWYgKHByb3RvY29sICE9PSAnSFRUUCcgJiYgcHJvdG9jb2wgIT09ICdIVFRQUycpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIGJhc2VVcmknLCBudWxsLCAnYmFzZVVyaSBwcm90b2NvbCBtdXN0IGJlIGVpdGhlciBIVFRQIG9yIEhUVFBTJywgYmFzZVVyaU5vZGUuc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICB0ZW1wbGF0ZSA9IHVyaXRlbXBsYXRlLnBhcnNlKGJhc2VVcmkpO1xuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgIGVyciA9IF9lcnJvcjtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIGJhc2VVcmknLCBudWxsLCBlcnIgIT0gbnVsbCA/IChfcmVmMiA9IGVyci5vcHRpb25zKSAhPSBudWxsID8gX3JlZjIubWVzc2FnZSA6IHZvaWQgMCA6IHZvaWQgMCwgYmFzZVVyaU5vZGUuc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICBleHByZXNzaW9ucyA9IHRlbXBsYXRlLmV4cHJlc3Npb25zLmZpbHRlcihmdW5jdGlvbihleHByKSB7XG4gICAgICAgIHJldHVybiAndGVtcGxhdGVUZXh0JyBpbiBleHByO1xuICAgICAgfSkubWFwKGZ1bmN0aW9uKGV4cHJlc3Npb24pIHtcbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb24udGVtcGxhdGVUZXh0O1xuICAgICAgfSk7XG4gICAgICBpZiAoX19pbmRleE9mLmNhbGwoZXhwcmVzc2lvbnMsICd2ZXJzaW9uJykgPj0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS5nZXRfdmFsaWRhdGlvbl9lcnJvcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRpb25fZXJyb3JzO1xuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLmlzX3ZhbGlkID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWxpZGF0aW9uX2Vycm9ycy5sZW5ndGggPT09IDA7XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUuaGFzRHVwbGljYXRlc1VyaXMgPSBmdW5jdGlvbihhcnJheSkge1xuICAgICAgdmFyIGl0ZW0sIG91dHB1dCwgX2ksIF9sZW47XG4gICAgICBvdXRwdXQgPSB7fTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gYXJyYXkubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgaXRlbSA9IGFycmF5W19pXTtcbiAgICAgICAgaWYgKGl0ZW0udXJpIGluIG91dHB1dCkge1xuICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dFtpdGVtLnVyaV0gPSBpdGVtO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLmhhc0R1cGxpY2F0ZXMgPSBmdW5jdGlvbihhcnJheSkge1xuICAgICAgdmFyIGl0ZW0sIG91dHB1dCwgX2ksIF9sZW47XG4gICAgICBvdXRwdXQgPSB7fTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gYXJyYXkubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgaXRlbSA9IGFycmF5W19pXTtcbiAgICAgICAgaWYgKGl0ZW0gaW4gb3V0cHV0KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0W2l0ZW1dID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFZhbGlkYXRvcjtcblxuICB9KSgpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9saWIvX3N0cmVhbV9kdXBsZXguanNcIilcbiIsIi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgfXJldHVybiBrZXlzO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleDtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBwcm9jZXNzTmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcblxudXRpbC5pbmhlcml0cyhEdXBsZXgsIFJlYWRhYmxlKTtcblxudmFyIGtleXMgPSBvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7XG5mb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgdmFyIG1ldGhvZCA9IGtleXNbdl07XG4gIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKSBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbn1cblxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSkgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xufVxuXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcbiAgLy8gdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuYWxsb3dIYWxmT3BlbiB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKSByZXR1cm47XG5cbiAgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cbiAgcHJvY2Vzc05leHRUaWNrKG9uRW5kTlQsIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBvbkVuZE5UKHNlbGYpIHtcbiAgc2VsZi5lbmQoKTtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaCh4cywgZikge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGYoeHNbaV0sIGkpO1xuICB9XG59IiwiLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgcHJvY2Vzc05leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbnZhciBFRWxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiAoZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbTtcbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgU3RyZWFtID0gcmVxdWlyZSgnc3QnICsgJ3JlYW0nKTtcbiAgfSBjYXRjaCAoXykge30gZmluYWxseSB7XG4gICAgaWYgKCFTdHJlYW0pIFN0cmVhbSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbiAgfVxufSkoKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBidWZmZXJTaGltID0gcmVxdWlyZSgnYnVmZmVyLXNoaW1zJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGRlYnVnVXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBkZWJ1ZyA9IHZvaWQgMDtcbmlmIChkZWJ1Z1V0aWwgJiYgZGVidWdVdGlsLmRlYnVnbG9nKSB7XG4gIGRlYnVnID0gZGVidWdVdGlsLmRlYnVnbG9nKCdzdHJlYW0nKTtcbn0gZWxzZSB7XG4gIGRlYnVnID0gZnVuY3Rpb24gKCkge307XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFN0cmluZ0RlY29kZXI7XG5cbnV0aWwuaW5oZXJpdHMoUmVhZGFibGUsIFN0cmVhbSk7XG5cbnZhciBoYXNQcmVwZW5kTGlzdGVuZXIgPSB0eXBlb2YgRUUucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJztcblxuZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbikge1xuICBpZiAoaGFzUHJlcGVuZExpc3RlbmVyKSByZXR1cm4gZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnQsIGZuKTtcblxuICAvLyBUaGlzIGlzIGEgYnJ1dGFsbHkgdWdseSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyXG4gIC8vIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnkgdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuIFRoaXMgaXMgaGVyZVxuICAvLyBvbmx5IGJlY2F1c2UgdGhpcyBjb2RlIG5lZWRzIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9uc1xuICAvLyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGUgdGhlIHByZXBlbmRMaXN0ZW5lcigpIG1ldGhvZC4gVGhlIGdvYWxcbiAgLy8gaXMgdG8gZXZlbnR1YWxseSByZW1vdmUgdGhpcyBoYWNrLlxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkgZW1pdHRlci5vbihldmVudCwgZm4pO2Vsc2UgaWYgKGlzQXJyYXkoZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkpIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0udW5zaGlmdChmbik7ZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXTtcbn1cblxudmFyIER1cGxleDtcbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG9cbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod20gfHwgaHdtID09PSAwID8gaHdtIDogZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IH4gfnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICB0aGlzLmJ1ZmZlciA9IFtdO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuICB0aGlzLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIHdoZW4gcGlwaW5nLCB3ZSBvbmx5IGNhcmUgYWJvdXQgJ3JlYWRhYmxlJyBldmVudHMgdGhhdCBoYXBwZW5cbiAgLy8gYWZ0ZXIgcmVhZCgpaW5nIGFsbCB0aGUgYnl0ZXMgYW5kIG5vdCBnZXR0aW5nIGFueSBwdXNoYmFjay5cbiAgdGhpcy5yYW5PdXQgPSBmYWxzZTtcblxuICAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuICB0aGlzLmF3YWl0RHJhaW4gPSAwO1xuXG4gIC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuXG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cblxudmFyIER1cGxleDtcbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKSByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3lcbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fcmVhZCA9IG9wdGlvbnMucmVhZDtcblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuXG4vLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCxcbi8vIHNpbWlsYXIgdG8gaG93IFdyaXRhYmxlLndyaXRlKCkgcmV0dXJucyB0cnVlIGlmIHlvdSBzaG91bGRcbi8vIHdyaXRlKCkgc29tZSBtb3JlLlxuUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICBjaHVuayA9IGJ1ZmZlclNoaW0uZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBmYWxzZSk7XG59O1xuXG4vLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCAnJywgdHJ1ZSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPT09IGZhbHNlO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQpIHtcbiAgdmFyIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XG4gIGlmIChlcikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfSBlbHNlIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgIGlmIChzdGF0ZS5lbmRlZCAmJiAhYWRkVG9Gcm9udCkge1xuICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ3N0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GJyk7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZEVtaXR0ZWQgJiYgYWRkVG9Gcm9udCkge1xuICAgICAgdmFyIF9lID0gbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpO1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgX2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc2tpcEFkZDtcbiAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFhZGRUb0Zyb250ICYmICFlbmNvZGluZykge1xuICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuICAgICAgICBza2lwQWRkID0gIXN0YXRlLm9iamVjdE1vZGUgJiYgY2h1bmsubGVuZ3RoID09PSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWFkZFRvRnJvbnQpIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcblxuICAgICAgLy8gRG9uJ3QgYWRkIHRvIHRoZSBidWZmZXIgaWYgd2UndmUgZGVjb2RlZCB0byBhbiBlbXB0eSBzdHJpbmcgY2h1bmsgYW5kXG4gICAgICAvLyB3ZSdyZSBub3QgaW4gb2JqZWN0IG1vZGVcbiAgICAgIGlmICghc2tpcEFkZCkge1xuICAgICAgICAvLyBpZiB3ZSB3YW50IHRoZSBkYXRhIG5vdywganVzdCBlbWl0IGl0LlxuICAgICAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMpIHtcbiAgICAgICAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgICAgICAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxuICAgICAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICAgICAgICBpZiAoYWRkVG9Gcm9udCkgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO2Vsc2Ugc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuXG4gICAgICAgICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSkgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gbmVlZE1vcmVEYXRhKHN0YXRlKTtcbn1cblxuLy8gaWYgaXQncyBwYXN0IHRoZSBoaWdoIHdhdGVyIG1hcmssIHdlIGNhbiBwdXNoIGluIHNvbWUgbW9yZS5cbi8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lXG4vLyBtb3JlIGJ5dGVzLiAgVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCxcbi8vIHN1Y2ggYXMgdGhlIHJlcGwuICBBbHNvLCBpZiB0aGUgcHVzaCgpIHRyaWdnZXJlZCBhXG4vLyByZWFkYWJsZSBldmVudCwgYW5kIHRoZSB1c2VyIGNhbGxlZCByZWFkKGxhcmdlTnVtYmVyKSBzdWNoIHRoYXRcbi8vIG5lZWRSZWFkYWJsZSB3YXMgc2V0LCB0aGVuIHdlIG91Z2h0IHRvIHB1c2ggbW9yZSwgc28gdGhhdCBhbm90aGVyXG4vLyAncmVhZGFibGUnIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkLlxuZnVuY3Rpb24gbmVlZE1vcmVEYXRhKHN0YXRlKSB7XG4gIHJldHVybiAhc3RhdGUuZW5kZWQgJiYgKHN0YXRlLm5lZWRSZWFkYWJsZSB8fCBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCk7XG59XG5cbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24gKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gZW5jO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIERvbid0IHJhaXNlIHRoZSBod20gPiA4TUJcbnZhciBNQVhfSFdNID0gMHg4MDAwMDA7XG5mdW5jdGlvbiBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyXG4gICAgbi0tO1xuICAgIG4gfD0gbiA+Pj4gMTtcbiAgICBuIHw9IG4gPj4+IDI7XG4gICAgbiB8PSBuID4+PiA0O1xuICAgIG4gfD0gbiA+Pj4gODtcbiAgICBuIHw9IG4gPj4+IDE2O1xuICAgIG4rKztcbiAgfVxuICByZXR1cm4gbjtcbn1cblxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSByZXR1cm4gMDtcblxuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0dXJuIG4gPT09IDAgPyAwIDogMTtcblxuICBpZiAobiA9PT0gbnVsbCB8fCBpc05hTihuKSkge1xuICAgIC8vIG9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmJ1ZmZlci5sZW5ndGgpIHJldHVybiBzdGF0ZS5idWZmZXJbMF0ubGVuZ3RoO2Vsc2UgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChuIDw9IDApIHJldHVybiAwO1xuXG4gIC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSB0YXJnZXQgYnVmZmVyIGxldmVsLFxuICAvLyB0aGVuIHJhaXNlIHRoZSB3YXRlciBtYXJrLiAgQnVtcCB1cCB0byB0aGUgbmV4dCBoaWdoZXN0XG4gIC8vIHBvd2VyIG9mIDIsIHRvIHByZXZlbnQgaW5jcmVhc2luZyBpdCBleGNlc3NpdmVseSBpbiB0aW55XG4gIC8vIGFtb3VudHMuXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaykgc3RhdGUuaGlnaFdhdGVyTWFyayA9IGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pO1xuXG4gIC8vIGRvbid0IGhhdmUgdGhhdCBtdWNoLiAgcmV0dXJuIG51bGwsIHVubGVzcyB3ZSd2ZSBlbmRlZC5cbiAgaWYgKG4gPiBzdGF0ZS5sZW5ndGgpIHtcbiAgICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG47XG59XG5cbi8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIGRlYnVnKCdyZWFkJywgbik7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBuT3JpZyA9IG47XG5cbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuID4gMCkgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5uZWVkUmVhZGFibGUgJiYgKHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtlbHNlIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpO1xuXG4gIC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZTtcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xuICB9XG5cbiAgLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xuICAgIGRvUmVhZCA9IGZhbHNlO1xuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcbiAgfVxuXG4gIGlmIChkb1JlYWQpIHtcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlO1xuICAgIC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7XG4gIH1cblxuICAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG4gIGlmIChkb1JlYWQgJiYgIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG5cbiAgdmFyIHJldDtcbiAgaWYgKG4gPiAwKSByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7ZWxzZSByZXQgPSBudWxsO1xuXG4gIGlmIChyZXQgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIG4gPSAwO1xuICB9XG5cbiAgc3RhdGUubGVuZ3RoIC09IG47XG5cbiAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxuICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcblxuICBpZiAocmV0ICE9PSBudWxsKSB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlciA9IG51bGw7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICByZXR1cm4gZXI7XG59XG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUuZW5kZWQpIHJldHVybjtcbiAgaWYgKHN0YXRlLmRlY29kZXIpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbn1cblxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBpZiAoc3RhdGUuc3luYykgcHJvY2Vzc05leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7ZWxzZSBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgZGVidWcoJ2VtaXQgcmVhZGFibGUnKTtcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gIGZsb3coc3RyZWFtKTtcbn1cblxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwcm9jZXNzTmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxuICAgICAgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO2Vsc2UgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XG5cbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcblxuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogY2xlYW51cDtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHByb2Nlc3NOZXh0VGljayhlbmRGbik7ZWxzZSBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuXG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUpIHtcbiAgICBkZWJ1Zygnb251bnBpcGUnKTtcbiAgICBpZiAocmVhZGFibGUgPT09IHNyYykge1xuICAgICAgY2xlYW51cCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcblxuICAgIGNsZWFuZWRVcCA9IHRydWU7XG5cbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpIG9uZHJhaW4oKTtcbiAgfVxuXG4gIHNyYy5vbignZGF0YScsIG9uZGF0YSk7XG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGRlYnVnKCdvbmRhdGEnKTtcbiAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgaWYgKGZhbHNlID09PSByZXQpIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIHVucGlwZWQgZHVyaW5nIGBkZXN0LndyaXRlKClgLCBpdCBpcyBwb3NzaWJsZVxuICAgICAgLy8gdG8gZ2V0IHN0dWNrIGluIGEgcGVybWFuZW50bHkgcGF1c2VkIHN0YXRlIGlmIHRoYXQgd3JpdGVcbiAgICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuXG4gICAgICAvLyA9PiBDaGVjayB3aGV0aGVyIGBkZXN0YCBpcyBzdGlsbCBhIHBpcGluZyBkZXN0aW5hdGlvbi5cbiAgICAgIGlmICgoc3RhdGUucGlwZXNDb3VudCA9PT0gMSAmJiBzdGF0ZS5waXBlcyA9PT0gZGVzdCB8fCBzdGF0ZS5waXBlc0NvdW50ID4gMSAmJiBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KSAhPT0gLTEpICYmICFjbGVhbmVkVXApIHtcbiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgICAgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgIH1cbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRWxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApIGRlc3QuZW1pdCgnZXJyb3InLCBlcik7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIHVzZXJsYW5kIG9uZXMuXG4gIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9XG5cbiAgLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcblxuICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBpZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKSByZXR1cm4gdGhpcztcblxuICAvLyBqdXN0IG9uZSBkZXN0aW5hdGlvbi4gIG1vc3QgY29tbW9uIGNhc2UuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7XG4gICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuXG4gICAgaWYgKGRlc3QgJiYgZGVzdCAhPT0gc3RhdGUucGlwZXMpIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKCFkZXN0KSBkZXN0ID0gc3RhdGUucGlwZXM7XG5cbiAgICAvLyBnb3QgYSBtYXRjaC5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KSBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc2xvdyBjYXNlLiBtdWx0aXBsZSBwaXBlIGRlc3RpbmF0aW9ucy5cblxuICBpZiAoIWRlc3QpIHtcbiAgICAvLyByZW1vdmUgYWxsLlxuICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50O1xuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGVuOyBfaSsrKSB7XG4gICAgICBkZXN0c1tfaV0uZW1pdCgndW5waXBlJywgdGhpcyk7XG4gICAgfXJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGkgPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGkgPT09IC0xKSByZXR1cm4gdGhpcztcblxuICBzdGF0ZS5waXBlcy5zcGxpY2UoaSwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG5cbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICAvLyBJZiBsaXN0ZW5pbmcgdG8gZGF0YSwgYW5kIGl0IGhhcyBub3QgZXhwbGljaXRseSBiZWVuIHBhdXNlZCxcbiAgLy8gdGhlbiBjYWxsIHJlc3VtZSB0byBzdGFydCB0aGUgZmxvdyBvZiBkYXRhIG9uIHRoZSBuZXh0IHRpY2suXG4gIGlmIChldiA9PT0gJ2RhdGEnICYmIGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHtcbiAgICB0aGlzLnJlc3VtZSgpO1xuICB9XG5cbiAgaWYgKGV2ID09PSAncmVhZGFibGUnICYmICF0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICghc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICBwcm9jZXNzTmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcywgc3RhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG5mdW5jdGlvbiBuUmVhZGluZ05leHRUaWNrKHNlbGYpIHtcbiAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICBzZWxmLnJlYWQoMCk7XG59XG5cbi8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdyZXN1bWUnKTtcbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHByb2Nlc3NOZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfVxuXG4gIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XG4gIGZsb3coc3RyZWFtKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpIHN0cmVhbS5yZWFkKDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xuICBpZiAoZmFsc2UgIT09IHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwYXVzZScpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcpIHtcbiAgICBkbyB7XG4gICAgICB2YXIgY2h1bmsgPSBzdHJlYW0ucmVhZCgpO1xuICAgIH0gd2hpbGUgKG51bGwgIT09IGNodW5rICYmIHN0YXRlLmZsb3dpbmcpO1xuICB9XG59XG5cbi8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSBzZWxmLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIHNlbGYucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZGF0YScpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuXG4gICAgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlXG4gICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpKSByZXR1cm47ZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSkgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IHNlbGYucHVzaChjaHVuayk7XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHRoaXNbaV0gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KGkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cbiAgdmFyIGV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcbiAgZm9yRWFjaChldmVudHMsIGZ1bmN0aW9uIChldikge1xuICAgIHN0cmVhbS5vbihldiwgc2VsZi5lbWl0LmJpbmQoc2VsZiwgZXYpKTtcbiAgfSk7XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgc2VsZi5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHNlbGY7XG59O1xuXG4vLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcblxuLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIHZhciBsaXN0ID0gc3RhdGUuYnVmZmVyO1xuICB2YXIgbGVuZ3RoID0gc3RhdGUubGVuZ3RoO1xuICB2YXIgc3RyaW5nTW9kZSA9ICEhc3RhdGUuZGVjb2RlcjtcbiAgdmFyIG9iamVjdE1vZGUgPSAhIXN0YXRlLm9iamVjdE1vZGU7XG4gIHZhciByZXQ7XG5cbiAgLy8gbm90aGluZyBpbiB0aGUgbGlzdCwgZGVmaW5pdGVseSBlbXB0eS5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcblxuICBpZiAobGVuZ3RoID09PSAwKSByZXQgPSBudWxsO2Vsc2UgaWYgKG9iamVjdE1vZGUpIHJldCA9IGxpc3Quc2hpZnQoKTtlbHNlIGlmICghbiB8fCBuID49IGxlbmd0aCkge1xuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgYXJyYXkuXG4gICAgaWYgKHN0cmluZ01vZGUpIHJldCA9IGxpc3Quam9pbignJyk7ZWxzZSBpZiAobGlzdC5sZW5ndGggPT09IDEpIHJldCA9IGxpc3RbMF07ZWxzZSByZXQgPSBCdWZmZXIuY29uY2F0KGxpc3QsIGxlbmd0aCk7XG4gICAgbGlzdC5sZW5ndGggPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQganVzdCBzb21lIG9mIGl0LlxuICAgIGlmIChuIDwgbGlzdFswXS5sZW5ndGgpIHtcbiAgICAgIC8vIGp1c3QgdGFrZSBhIHBhcnQgb2YgdGhlIGZpcnN0IGxpc3QgaXRlbS5cbiAgICAgIC8vIHNsaWNlIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzLlxuICAgICAgdmFyIGJ1ZiA9IGxpc3RbMF07XG4gICAgICByZXQgPSBidWYuc2xpY2UoMCwgbik7XG4gICAgICBsaXN0WzBdID0gYnVmLnNsaWNlKG4pO1xuICAgIH0gZWxzZSBpZiAobiA9PT0gbGlzdFswXS5sZW5ndGgpIHtcbiAgICAgIC8vIGZpcnN0IGxpc3QgaXMgYSBwZXJmZWN0IG1hdGNoXG4gICAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbXBsZXggY2FzZS5cbiAgICAgIC8vIHdlIGhhdmUgZW5vdWdoIHRvIGNvdmVyIGl0LCBidXQgaXQgc3BhbnMgcGFzdCB0aGUgZmlyc3QgYnVmZmVyLlxuICAgICAgaWYgKHN0cmluZ01vZGUpIHJldCA9ICcnO2Vsc2UgcmV0ID0gYnVmZmVyU2hpbS5hbGxvY1Vuc2FmZShuKTtcblxuICAgICAgdmFyIGMgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGwgJiYgYyA8IG47IGkrKykge1xuICAgICAgICB2YXIgX2J1ZiA9IGxpc3RbMF07XG4gICAgICAgIHZhciBjcHkgPSBNYXRoLm1pbihuIC0gYywgX2J1Zi5sZW5ndGgpO1xuXG4gICAgICAgIGlmIChzdHJpbmdNb2RlKSByZXQgKz0gX2J1Zi5zbGljZSgwLCBjcHkpO2Vsc2UgX2J1Zi5jb3B5KHJldCwgYywgMCwgY3B5KTtcblxuICAgICAgICBpZiAoY3B5IDwgX2J1Zi5sZW5ndGgpIGxpc3RbMF0gPSBfYnVmLnNsaWNlKGNweSk7ZWxzZSBsaXN0LnNoaWZ0KCk7XG5cbiAgICAgICAgYyArPSBjcHk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBJZiB3ZSBnZXQgaGVyZSBiZWZvcmUgY29uc3VtaW5nIGFsbCB0aGUgYnl0ZXMsIHRoZW4gdGhhdCBpcyBhXG4gIC8vIGJ1ZyBpbiBub2RlLiAgU2hvdWxkIG5ldmVyIGhhcHBlbi5cbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApIHRocm93IG5ldyBFcnJvcignXCJlbmRSZWFkYWJsZSgpXCIgY2FsbGVkIG9uIG5vbi1lbXB0eSBzdHJlYW0nKTtcblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gICAgcHJvY2Vzc05leHRUaWNrKGVuZFJlYWRhYmxlTlQsIHN0YXRlLCBzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkge1xuICAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoKHhzLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZih4c1tpXSwgaSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufSIsIi8vIGEgdHJhbnNmb3JtIHN0cmVhbSBpcyBhIHJlYWRhYmxlL3dyaXRhYmxlIHN0cmVhbSB3aGVyZSB5b3UgZG9cbi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgXCJmaWx0ZXJcIixcbi8vIGJ1dCB0aGF0J3Mgbm90IGEgZ3JlYXQgbmFtZSBmb3IgaXQsIHNpbmNlIHRoYXQgaW1wbGllcyBhIHRoaW5nIHdoZXJlXG4vLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkXG4vLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pXG4vL1xuLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYVxuLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsXG4vLyBhIHpsaWIgc3RyZWFtIG1pZ2h0IHRha2UgbXVsdGlwbGUgcGxhaW4tdGV4dCB3cml0ZXMoKSwgYW5kIHRoZW5cbi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS5cbi8vXG4vLyBIZXJlJ3MgaG93IHRoaXMgd29ya3M6XG4vL1xuLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXG4vLyBzdHJlYW0gY2xhc3Nlcy4gIFdoZW4geW91IHdyaXRlKGNodW5rKSwgdGhhdCBjYWxscyBfd3JpdGUoY2h1bmssY2IpXG4vLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzXG4vLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsXG4vLyB0aGVyZSdzIGVub3VnaCBwZW5kaW5nIHJlYWRhYmxlIGRhdGEgYnVmZmVyZWQgdXAuXG4vL1xuLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW5cbi8vIF9yZWFkKG4pIGlzIGNhbGxlZCwgaXQgdHJhbnNmb3JtcyB0aGUgcXVldWVkIHVwIGRhdGEsIGNhbGxpbmcgdGhlXG4vLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGVcbi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0XG4vLyBvdXRwdXR0ZWQgYml0IGNhbGxzIHRoZSByZWFkY2IsIGFuZCBzdWJzZXF1ZW50IGNodW5rcyBqdXN0IGdvIGludG9cbi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS5cbi8vXG4vLyBUaGlzIHdheSwgYmFjay1wcmVzc3VyZSBpcyBhY3R1YWxseSBkZXRlcm1pbmVkIGJ5IHRoZSByZWFkaW5nIHNpZGUsXG4vLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLFxuLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZ1xuLy8gaGVyZS4gIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgc3RyZWFtIHdoZXJlIGV2ZXJ5IGJ5dGUgb2YgaW5wdXQgaXNcbi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnlcbi8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW5cbi8vIDFrYiBvZiBkYXRhIGJlaW5nIG91dHB1dC4gIEluIHRoaXMgY2FzZSwgeW91IGNvdWxkIHdyaXRlIGEgdmVyeSBzbWFsbFxuLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJblxuLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsXG4vLyB0aGUgc3lzdGVtIHRvIHN0b3AgZG9pbmcgdGhlIHRyYW5zZm9ybS4gIEEgc2luZ2xlIDRNQiB3cml0ZSBjb3VsZFxuLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS5cbi8vXG4vLyBIb3dldmVyLCBldmVuIGluIHN1Y2ggYSBwYXRob2xvZ2ljYWwgY2FzZSwgb25seSBhIHNpbmdsZSB3cml0dGVuIGNodW5rXG4vLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsXG4vLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxudmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFRyYW5zZm9ybSwgRHVwbGV4KTtcblxuZnVuY3Rpb24gVHJhbnNmb3JtU3RhdGUoc3RyZWFtKSB7XG4gIHRoaXMuYWZ0ZXJUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoZXIsIGRhdGEpIHtcbiAgICByZXR1cm4gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSk7XG4gIH07XG5cbiAgdGhpcy5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHRoaXMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG4gIHRoaXMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRoaXMud3JpdGVlbmNvZGluZyA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG5cbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcblxuICBpZiAoIWNiKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdubyB3cml0ZWNiIGluIFRyYW5zZm9ybSBjbGFzcycpKTtcblxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG5cbiAgaWYgKGRhdGEgIT09IG51bGwgJiYgZGF0YSAhPT0gdW5kZWZpbmVkKSBzdHJlYW0ucHVzaChkYXRhKTtcblxuICBjYihlcik7XG5cbiAgdmFyIHJzID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBycy5yZWFkaW5nID0gZmFsc2U7XG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgIHN0cmVhbS5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSkgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG5cbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSBuZXcgVHJhbnNmb3JtU3RhdGUodGhpcyk7XG5cbiAgLy8gd2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICB2YXIgc3RyZWFtID0gdGhpcztcblxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2ggPSBvcHRpb25zLmZsdXNoO1xuICB9XG5cbiAgdGhpcy5vbmNlKCdwcmVmaW5pc2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLl9mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2goZnVuY3Rpb24gKGVyKSB7XG4gICAgICBkb25lKHN0cmVhbSwgZXIpO1xuICAgIH0pO2Vsc2UgZG9uZShzdHJlYW0pO1xuICB9KTtcbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xufTtcblxuLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuLy9cbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbi8vXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHwgcnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07XG5cbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiB0cy53cml0ZWNiICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIpIHtcbiAgaWYgKGVyKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG4gIHZhciB3cyA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAod3MubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiB3cy5sZW5ndGggIT0gMCcpO1xuXG4gIGlmICh0cy50cmFuc2Zvcm1pbmcpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHN0aWxsIHRyYW5zZm9ybWluZycpO1xuXG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcbn0iLCIvLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBXcml0YWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBwcm9jZXNzTmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgYXN5bmNXcml0ZSA9ICFwcm9jZXNzLmJyb3dzZXIgJiYgWyd2MC4xMCcsICd2MC45LiddLmluZGV4T2YocHJvY2Vzcy52ZXJzaW9uLnNsaWNlKDAsIDUpKSA+IC0xID8gc2V0SW1tZWRpYXRlIDogcHJvY2Vzc05leHRUaWNrO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaW50ZXJuYWxVdGlsID0ge1xuICBkZXByZWNhdGU6IHJlcXVpcmUoJ3V0aWwtZGVwcmVjYXRlJylcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW07XG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIFN0cmVhbSA9IHJlcXVpcmUoJ3N0JyArICdyZWFtJyk7XG4gIH0gY2F0Y2ggKF8pIHt9IGZpbmFsbHkge1xuICAgIGlmICghU3RyZWFtKSBTdHJlYW0gPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG4gIH1cbn0pKCk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbi8qPHJlcGxhY2VtZW50PiovXG52YXIgYnVmZmVyU2hpbSA9IHJlcXVpcmUoJ2J1ZmZlci1zaGltcycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoV3JpdGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIG5vcCgpIHt9XG5cbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbn1cblxudmFyIER1cGxleDtcbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXG4gIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIHdyaXRlKCkgc3RhcnRzIHJldHVybmluZyBmYWxzZVxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIHRoYXQgd2UgYWx3YXlzIHJldHVybiBmYWxzZSBpZlxuICAvLyB0aGUgZW50aXJlIGJ1ZmZlciBpcyBub3QgZmx1c2hlZCBpbW1lZGlhdGVseSBvbiB3cml0ZSgpXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bSB8fCBod20gPT09IDAgPyBod20gOiBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gfiB+dGhpcy5oaWdoV2F0ZXJNYXJrO1xuXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2U7XG4gIC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7XG4gIC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICAvLyB3aGVuICdmaW5pc2gnIGlzIGVtaXR0ZWRcbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cbiAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcbiAgLy8gc29ja2V0IG9yIGZpbGUuXG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTtcblxuICAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsXG4gIHRoaXMuY29ya2VkID0gMDtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXG4gIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXG4gIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uIChlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG5cbiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuICB0aGlzLndyaXRlbGVuID0gMDtcblxuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIHRoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cbiAgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcbiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkXG4gIHRoaXMucGVuZGluZ2NiID0gMDtcblxuICAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXG4gIC8vIFRoaXMgaXMgcmVsZXZhbnQgZm9yIHN5bmNocm9ub3VzIFRyYW5zZm9ybSBzdHJlYW1zXG4gIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuXG4gIC8vIGNvdW50IGJ1ZmZlcmVkIHJlcXVlc3RzXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuXG4gIC8vIGFsbG9jYXRlIHRoZSBmaXJzdCBDb3JrZWRSZXF1ZXN0LCB0aGVyZSBpcyBhbHdheXNcbiAgLy8gb25lIGFsbG9jYXRlZCBhbmQgZnJlZSB0byB1c2UsIGFuZCB3ZSBtYWludGFpbiBhdCBtb3N0IHR3b1xuICB0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHRoaXMpO1xufVxuXG5Xcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiB3cml0YWJsZVN0YXRlR2V0QnVmZmVyKCkge1xuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xuICB2YXIgb3V0ID0gW107XG4gIHdoaWxlIChjdXJyZW50KSB7XG4gICAgb3V0LnB1c2goY3VycmVudCk7XG4gICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUsICdidWZmZXInLCB7XG4gICAgICBnZXQ6IGludGVybmFsVXRpbC5kZXByZWNhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTtcbiAgICAgIH0sICdfd3JpdGFibGVTdGF0ZS5idWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIF93cml0YWJsZVN0YXRlLmdldEJ1ZmZlciAnICsgJ2luc3RlYWQuJylcbiAgICB9KTtcbiAgfSBjYXRjaCAoXykge31cbn0pKCk7XG5cbnZhciBEdXBsZXg7XG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0aG91Z2ggdGhleSdyZSBub3RcbiAgLy8gaW5zdGFuY2VvZiBXcml0YWJsZSwgdGhleSdyZSBpbnN0YW5jZW9mIFJlYWRhYmxlLlxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgV3JpdGFibGUpICYmICEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeS5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGUgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRlID0gb3B0aW9ucy53cml0ZTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZXYgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRldiA9IG9wdGlvbnMud3JpdGV2O1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdDYW5ub3QgcGlwZSwgbm90IHJlYWRhYmxlJykpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJyk7XG4gIC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgcHJvY2Vzc05leHRUaWNrKGNiLCBlcik7XG59XG5cbi8vIElmIHdlIGdldCBzb21ldGhpbmcgdGhhdCBpcyBub3QgYSBidWZmZXIsIHN0cmluZywgbnVsbCwgb3IgdW5kZWZpbmVkLFxuLy8gYW5kIHdlJ3JlIG5vdCBpbiBvYmplY3RNb2RlLCB0aGVuIHRoYXQncyBhbiBlcnJvci5cbi8vIE90aGVyd2lzZSBzdHJlYW0gY2h1bmtzIGFyZSBhbGwgY29uc2lkZXJlZCB0byBiZSBvZiBsZW5ndGg9MSwgYW5kIHRoZVxuLy8gd2F0ZXJtYXJrcyBkZXRlcm1pbmUgaG93IG1hbnkgb2JqZWN0cyB0byBrZWVwIGluIHRoZSBidWZmZXIsIHJhdGhlciB0aGFuXG4vLyBob3cgbWFueSBieXRlcyBvciBjaGFyYWN0ZXJzLlxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIHZhbGlkID0gdHJ1ZTtcbiAgdmFyIGVyID0gZmFsc2U7XG4gIC8vIEFsd2F5cyB0aHJvdyBlcnJvciBpZiBhIG51bGwgaXMgd3JpdHRlblxuICAvLyBpZiB3ZSBhcmUgbm90IGluIG9iamVjdCBtb2RlIHRoZW4gdGhyb3dcbiAgLy8gaWYgaXQgaXMgbm90IGEgYnVmZmVyLCBzdHJpbmcsIG9yIHVuZGVmaW5lZC5cbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbScpO1xuICB9IGVsc2UgaWYgKCFCdWZmZXIuaXNCdWZmZXIoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIGlmIChlcikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICBwcm9jZXNzTmV4dFRpY2soY2IsIGVyKTtcbiAgICB2YWxpZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWxpZDtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSBlbmNvZGluZyA9ICdidWZmZXInO2Vsc2UgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7XG5cbiAgaWYgKHN0YXRlLmVuZGVkKSB3cml0ZUFmdGVyRW5kKHRoaXMsIGNiKTtlbHNlIGlmICh2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgc3RhdGUuY29ya2VkKys7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQtLTtcblxuICAgIGlmICghc3RhdGUud3JpdGluZyAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTtcbiAgfVxufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnNldERlZmF1bHRFbmNvZGluZyA9IGZ1bmN0aW9uIHNldERlZmF1bHRFbmNvZGluZyhlbmNvZGluZykge1xuICAvLyBub2RlOjpQYXJzZUVuY29kaW5nKCkgcmVxdWlyZXMgbG93ZXIgY2FzZS5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCEoWydoZXgnLCAndXRmOCcsICd1dGYtOCcsICdhc2NpaScsICdiaW5hcnknLCAnYmFzZTY0JywgJ3VjczInLCAndWNzLTInLCAndXRmMTZsZScsICd1dGYtMTZsZScsICdyYXcnXS5pbmRleE9mKChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpKSA+IC0xKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZWZhdWx0RW5jb2RpbmcgPSBlbmNvZGluZztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKSB7XG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgY2h1bmsgPSBidWZmZXJTaGltLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuICByZXR1cm4gY2h1bms7XG59XG5cbi8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcblxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG5cbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuICBpZiAoIXJldCkgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpIHtcbiAgICB2YXIgbGFzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG5ldyBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgICBpZiAobGFzdCkge1xuICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgKz0gMTtcbiAgfSBlbHNlIHtcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIGlmICh3cml0ZXYpIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtlbHNlIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XG4gIC0tc3RhdGUucGVuZGluZ2NiO1xuICBpZiAoc3luYykgcHJvY2Vzc05leHRUaWNrKGNiLCBlcik7ZWxzZSBjYihlcik7XG5cbiAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG5cbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcblxuICBpZiAoZXIpIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO2Vsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSB7XG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgLyo8cmVwbGFjZW1lbnQ+Ki9cbiAgICAgIGFzeW5jV3JpdGUoYWZ0ZXJXcml0ZSwgc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgIC8qPC9yZXBsYWNlbWVudD4qL1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKSBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIHN0YXRlLnBlbmRpbmdjYi0tO1xuICBjYigpO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59XG5cbi8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7XG5cbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHtcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgdmFyIGwgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudDtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpO1xuICAgIHZhciBob2xkZXIgPSBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7XG4gICAgaG9sZGVyLmVudHJ5ID0gZW50cnk7XG5cbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgYnVmZmVyW2NvdW50XSA9IGVudHJ5O1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG5cbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHRydWUsIHN0YXRlLmxlbmd0aCwgYnVmZmVyLCAnJywgaG9sZGVyLmZpbmlzaCk7XG5cbiAgICAvLyBkb1dyaXRlIGlzIGFsbW9zdCBhbHdheXMgYXN5bmMsIGRlZmVyIHRoZXNlIHRvIHNhdmUgYSBiaXQgb2YgdGltZVxuICAgIC8vIGFzIHRoZSBob3QgcGF0aCBlbmRzIHdpdGggZG9Xcml0ZVxuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICAgIGlmIChob2xkZXIubmV4dCkge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gaG9sZGVyLm5leHQ7XG4gICAgICBob2xkZXIubmV4dCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHN0YXRlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gU2xvdyBjYXNlLCB3cml0ZSBjaHVua3Mgb25lLWJ5LW9uZVxuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XG4gICAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XG4gICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cbiAgICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbnRyeSA9PT0gbnVsbCkgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIH1cblxuICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IGVudHJ5O1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGV2ID0gbnVsbDtcblxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gY2h1bms7XG4gICAgY2h1bmsgPSBudWxsO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChjaHVuayAhPT0gbnVsbCAmJiBjaHVuayAhPT0gdW5kZWZpbmVkKSB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7XG5cbiAgLy8gLmVuZCgpIGZ1bGx5IHVuY29ya3NcbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZCA9IDE7XG4gICAgdGhpcy51bmNvcmsoKTtcbiAgfVxuXG4gIC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cbiAgaWYgKCFzdGF0ZS5lbmRpbmcgJiYgIXN0YXRlLmZpbmlzaGVkKSBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpO1xufTtcblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUuZW5kaW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPT09IG51bGwgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS53cml0aW5nO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnByZWZpbmlzaGVkKSB7XG4gICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG4gIGlmIChuZWVkKSB7XG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKSBwcm9jZXNzTmV4dFRpY2soY2IpO2Vsc2Ugc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlO1xufVxuXG4vLyBJdCBzZWVtcyBhIGxpbmtlZCBsaXN0IGJ1dCBpdCBpcyBub3Rcbi8vIHRoZXJlIHdpbGwgYmUgb25seSAyIG9mIHRoZXNlIGZvciBlYWNoIHN0cmVhbVxuZnVuY3Rpb24gQ29ya2VkUmVxdWVzdChzdGF0ZSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHRoaXMubmV4dCA9IG51bGw7XG4gIHRoaXMuZW50cnkgPSBudWxsO1xuXG4gIHRoaXMuZmluaXNoID0gZnVuY3Rpb24gKGVycikge1xuICAgIHZhciBlbnRyeSA9IF90aGlzLmVudHJ5O1xuICAgIF90aGlzLmVudHJ5ID0gbnVsbDtcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgICBjYihlcnIpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgIH1cbiAgICBpZiAoc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlKSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUubmV4dCA9IF90aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBfdGhpcztcbiAgICB9XG4gIH07XG59IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qc1wiKVxuIiwidmFyIFN0cmVhbSA9IChmdW5jdGlvbiAoKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcmVxdWlyZSgnc3QnICsgJ3JlYW0nKTsgLy8gaGFjayB0byBmaXggYSBjaXJjdWxhciBkZXBlbmRlbmN5IGlzc3VlIHdoZW4gdXNlZCB3aXRoIGJyb3dzZXJpZnlcbiAgfSBjYXRjaChfKXt9XG59KCkpO1xuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcycpO1xuZXhwb3J0cy5TdHJlYW0gPSBTdHJlYW0gfHwgZXhwb3J0cztcbmV4cG9ydHMuUmVhZGFibGUgPSBleHBvcnRzO1xuZXhwb3J0cy5Xcml0YWJsZSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbmV4cG9ydHMuRHVwbGV4ID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbmV4cG9ydHMuVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMnKTtcbmV4cG9ydHMuUGFzc1Rocm91Z2ggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzJyk7XG5cbmlmICghcHJvY2Vzcy5icm93c2VyICYmIHByb2Nlc3MuZW52LlJFQURBQkxFX1NUUkVBTSA9PT0gJ2Rpc2FibGUnICYmIFN0cmVhbSkge1xuICBtb2R1bGUuZXhwb3J0cyA9IFN0cmVhbTtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzXCIpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzXCIpXG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW07XG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmluaGVyaXRzKFN0cmVhbSwgRUUpO1xuU3RyZWFtLlJlYWRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzJyk7XG5TdHJlYW0uV3JpdGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanMnKTtcblN0cmVhbS5EdXBsZXggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzJyk7XG5TdHJlYW0uVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcycpO1xuU3RyZWFtLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzJyk7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuNC54XG5TdHJlYW0uU3RyZWFtID0gU3RyZWFtO1xuXG5cblxuLy8gb2xkLXN0eWxlIHN0cmVhbXMuICBOb3RlIHRoYXQgdGhlIHBpcGUgbWV0aG9kICh0aGUgb25seSByZWxldmFudFxuLy8gcGFydCBvZiB0aGlzIGNsYXNzKSBpcyBvdmVycmlkZGVuIGluIHRoZSBSZWFkYWJsZSBjbGFzcy5cblxuZnVuY3Rpb24gU3RyZWFtKCkge1xuICBFRS5jYWxsKHRoaXMpO1xufVxuXG5TdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBvcHRpb25zKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGlmIChkZXN0LndyaXRhYmxlKSB7XG4gICAgICBpZiAoZmFsc2UgPT09IGRlc3Qud3JpdGUoY2h1bmspICYmIHNvdXJjZS5wYXVzZSkge1xuICAgICAgICBzb3VyY2UucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2RhdGEnLCBvbmRhdGEpO1xuXG4gIGZ1bmN0aW9uIG9uZHJhaW4oKSB7XG4gICAgaWYgKHNvdXJjZS5yZWFkYWJsZSAmJiBzb3VyY2UucmVzdW1lKSB7XG4gICAgICBzb3VyY2UucmVzdW1lKCk7XG4gICAgfVxuICB9XG5cbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICAvLyBJZiB0aGUgJ2VuZCcgb3B0aW9uIGlzIG5vdCBzdXBwbGllZCwgZGVzdC5lbmQoKSB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gIC8vIHNvdXJjZSBnZXRzIHRoZSAnZW5kJyBvciAnY2xvc2UnIGV2ZW50cy4gIE9ubHkgZGVzdC5lbmQoKSBvbmNlLlxuICBpZiAoIWRlc3QuX2lzU3RkaW8gJiYgKCFvcHRpb25zIHx8IG9wdGlvbnMuZW5kICE9PSBmYWxzZSkpIHtcbiAgICBzb3VyY2Uub24oJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2Uub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH1cblxuICB2YXIgZGlkT25FbmQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBpZiAodHlwZW9mIGRlc3QuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgZGVzdC5kZXN0cm95KCk7XG4gIH1cblxuICAvLyBkb24ndCBsZWF2ZSBkYW5nbGluZyBwaXBlcyB3aGVuIHRoZXJlIGFyZSBlcnJvcnMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBjbGVhbnVwKCk7XG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQodGhpcywgJ2Vycm9yJykgPT09IDApIHtcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgc3RyZWFtIGVycm9yIGluIHBpcGUuXG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIHJlbW92ZSBhbGwgdGhlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG4gIH1cblxuICBzb3VyY2Uub24oJ2VuZCcsIGNsZWFudXApO1xuICBzb3VyY2Uub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzb3VyY2UpO1xuXG4gIC8vIEFsbG93IGZvciB1bml4LWxpa2UgdXNhZ2U6IEEucGlwZShCKS5waXBlKEMpXG4gIHJldHVybiBkZXN0O1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG52YXIgaXNCdWZmZXJFbmNvZGluZyA9IEJ1ZmZlci5pc0VuY29kaW5nXG4gIHx8IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gICAgICAgc3dpdGNoIChlbmNvZGluZyAmJiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICBjYXNlICdoZXgnOiBjYXNlICd1dGY4JzogY2FzZSAndXRmLTgnOiBjYXNlICdhc2NpaSc6IGNhc2UgJ2JpbmFyeSc6IGNhc2UgJ2Jhc2U2NCc6IGNhc2UgJ3VjczInOiBjYXNlICd1Y3MtMic6IGNhc2UgJ3V0ZjE2bGUnOiBjYXNlICd1dGYtMTZsZSc6IGNhc2UgJ3Jhdyc6IHJldHVybiB0cnVlO1xuICAgICAgICAgZGVmYXVsdDogcmV0dXJuIGZhbHNlO1xuICAgICAgIH1cbiAgICAgfVxuXG5cbmZ1bmN0aW9uIGFzc2VydEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIGlmIChlbmNvZGluZyAmJiAhaXNCdWZmZXJFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIH1cbn1cblxuLy8gU3RyaW5nRGVjb2RlciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVmZmljaWVudGx5IHNwbGl0dGluZyBhIHNlcmllcyBvZlxuLy8gYnVmZmVycyBpbnRvIGEgc2VyaWVzIG9mIEpTIHN0cmluZ3Mgd2l0aG91dCBicmVha2luZyBhcGFydCBtdWx0aS1ieXRlXG4vLyBjaGFyYWN0ZXJzLiBDRVNVLTggaXMgaGFuZGxlZCBhcyBwYXJ0IG9mIHRoZSBVVEYtOCBlbmNvZGluZy5cbi8vXG4vLyBAVE9ETyBIYW5kbGluZyBhbGwgZW5jb2RpbmdzIGluc2lkZSBhIHNpbmdsZSBvYmplY3QgbWFrZXMgaXQgdmVyeSBkaWZmaWN1bHRcbi8vIHRvIHJlYXNvbiBhYm91dCB0aGlzIGNvZGUsIHNvIGl0IHNob3VsZCBiZSBzcGxpdCB1cCBpbiB0aGUgZnV0dXJlLlxuLy8gQFRPRE8gVGhlcmUgc2hvdWxkIGJlIGEgdXRmOC1zdHJpY3QgZW5jb2RpbmcgdGhhdCByZWplY3RzIGludmFsaWQgVVRGLTggY29kZVxuLy8gcG9pbnRzIGFzIHVzZWQgYnkgQ0VTVS04LlxudmFyIFN0cmluZ0RlY29kZXIgPSBleHBvcnRzLlN0cmluZ0RlY29kZXIgPSBmdW5jdGlvbihlbmNvZGluZykge1xuICB0aGlzLmVuY29kaW5nID0gKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bLV9dLywgJycpO1xuICBhc3NlcnRFbmNvZGluZyhlbmNvZGluZyk7XG4gIHN3aXRjaCAodGhpcy5lbmNvZGluZykge1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgLy8gQ0VTVS04IHJlcHJlc2VudHMgZWFjaCBvZiBTdXJyb2dhdGUgUGFpciBieSAzLWJ5dGVzXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICAvLyBVVEYtMTYgcmVwcmVzZW50cyBlYWNoIG9mIFN1cnJvZ2F0ZSBQYWlyIGJ5IDItYnl0ZXNcbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDI7XG4gICAgICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyID0gdXRmMTZEZXRlY3RJbmNvbXBsZXRlQ2hhcjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAvLyBCYXNlLTY0IHN0b3JlcyAzIGJ5dGVzIGluIDQgY2hhcnMsIGFuZCBwYWRzIHRoZSByZW1haW5kZXIuXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAzO1xuICAgICAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IGJhc2U2NERldGVjdEluY29tcGxldGVDaGFyO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMud3JpdGUgPSBwYXNzVGhyb3VnaFdyaXRlO1xuICAgICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRW5vdWdoIHNwYWNlIHRvIHN0b3JlIGFsbCBieXRlcyBvZiBhIHNpbmdsZSBjaGFyYWN0ZXIuIFVURi04IG5lZWRzIDRcbiAgLy8gYnl0ZXMsIGJ1dCBDRVNVLTggbWF5IHJlcXVpcmUgdXAgdG8gNiAoMyBieXRlcyBwZXIgc3Vycm9nYXRlKS5cbiAgdGhpcy5jaGFyQnVmZmVyID0gbmV3IEJ1ZmZlcig2KTtcbiAgLy8gTnVtYmVyIG9mIGJ5dGVzIHJlY2VpdmVkIGZvciB0aGUgY3VycmVudCBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgY2hhcmFjdGVyLlxuICB0aGlzLmNoYXJSZWNlaXZlZCA9IDA7XG4gIC8vIE51bWJlciBvZiBieXRlcyBleHBlY3RlZCBmb3IgdGhlIGN1cnJlbnQgaW5jb21wbGV0ZSBtdWx0aS1ieXRlIGNoYXJhY3Rlci5cbiAgdGhpcy5jaGFyTGVuZ3RoID0gMDtcbn07XG5cblxuLy8gd3JpdGUgZGVjb2RlcyB0aGUgZ2l2ZW4gYnVmZmVyIGFuZCByZXR1cm5zIGl0IGFzIEpTIHN0cmluZyB0aGF0IGlzXG4vLyBndWFyYW50ZWVkIHRvIG5vdCBjb250YWluIGFueSBwYXJ0aWFsIG11bHRpLWJ5dGUgY2hhcmFjdGVycy4gQW55IHBhcnRpYWxcbi8vIGNoYXJhY3RlciBmb3VuZCBhdCB0aGUgZW5kIG9mIHRoZSBidWZmZXIgaXMgYnVmZmVyZWQgdXAsIGFuZCB3aWxsIGJlXG4vLyByZXR1cm5lZCB3aGVuIGNhbGxpbmcgd3JpdGUgYWdhaW4gd2l0aCB0aGUgcmVtYWluaW5nIGJ5dGVzLlxuLy9cbi8vIE5vdGU6IENvbnZlcnRpbmcgYSBCdWZmZXIgY29udGFpbmluZyBhbiBvcnBoYW4gc3Vycm9nYXRlIHRvIGEgU3RyaW5nXG4vLyBjdXJyZW50bHkgd29ya3MsIGJ1dCBjb252ZXJ0aW5nIGEgU3RyaW5nIHRvIGEgQnVmZmVyICh2aWEgYG5ldyBCdWZmZXJgLCBvclxuLy8gQnVmZmVyI3dyaXRlKSB3aWxsIHJlcGxhY2UgaW5jb21wbGV0ZSBzdXJyb2dhdGVzIHdpdGggdGhlIHVuaWNvZGVcbi8vIHJlcGxhY2VtZW50IGNoYXJhY3Rlci4gU2VlIGh0dHBzOi8vY29kZXJldmlldy5jaHJvbWl1bS5vcmcvMTIxMTczMDA5LyAuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB2YXIgY2hhclN0ciA9ICcnO1xuICAvLyBpZiBvdXIgbGFzdCB3cml0ZSBlbmRlZCB3aXRoIGFuIGluY29tcGxldGUgbXVsdGlieXRlIGNoYXJhY3RlclxuICB3aGlsZSAodGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgLy8gZGV0ZXJtaW5lIGhvdyBtYW55IHJlbWFpbmluZyBieXRlcyB0aGlzIGJ1ZmZlciBoYXMgdG8gb2ZmZXIgZm9yIHRoaXMgY2hhclxuICAgIHZhciBhdmFpbGFibGUgPSAoYnVmZmVyLmxlbmd0aCA+PSB0aGlzLmNoYXJMZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCkgP1xuICAgICAgICB0aGlzLmNoYXJMZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCA6XG4gICAgICAgIGJ1ZmZlci5sZW5ndGg7XG5cbiAgICAvLyBhZGQgdGhlIG5ldyBieXRlcyB0byB0aGUgY2hhciBidWZmZXJcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIHRoaXMuY2hhclJlY2VpdmVkLCAwLCBhdmFpbGFibGUpO1xuICAgIHRoaXMuY2hhclJlY2VpdmVkICs9IGF2YWlsYWJsZTtcblxuICAgIGlmICh0aGlzLmNoYXJSZWNlaXZlZCA8IHRoaXMuY2hhckxlbmd0aCkge1xuICAgICAgLy8gc3RpbGwgbm90IGVub3VnaCBjaGFycyBpbiB0aGlzIGJ1ZmZlcj8gd2FpdCBmb3IgbW9yZSAuLi5cbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgYnl0ZXMgYmVsb25naW5nIHRvIHRoZSBjdXJyZW50IGNoYXJhY3RlciBmcm9tIHRoZSBidWZmZXJcbiAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UoYXZhaWxhYmxlLCBidWZmZXIubGVuZ3RoKTtcblxuICAgIC8vIGdldCB0aGUgY2hhcmFjdGVyIHRoYXQgd2FzIHNwbGl0XG4gICAgY2hhclN0ciA9IHRoaXMuY2hhckJ1ZmZlci5zbGljZSgwLCB0aGlzLmNoYXJMZW5ndGgpLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xuXG4gICAgLy8gQ0VTVS04OiBsZWFkIHN1cnJvZ2F0ZSAoRDgwMC1EQkZGKSBpcyBhbHNvIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlclxuICAgIHZhciBjaGFyQ29kZSA9IGNoYXJTdHIuY2hhckNvZGVBdChjaGFyU3RyLmxlbmd0aCAtIDEpO1xuICAgIGlmIChjaGFyQ29kZSA+PSAweEQ4MDAgJiYgY2hhckNvZGUgPD0gMHhEQkZGKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggKz0gdGhpcy5zdXJyb2dhdGVTaXplO1xuICAgICAgY2hhclN0ciA9ICcnO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHRoaXMuY2hhclJlY2VpdmVkID0gdGhpcy5jaGFyTGVuZ3RoID0gMDtcblxuICAgIC8vIGlmIHRoZXJlIGFyZSBubyBtb3JlIGJ5dGVzIGluIHRoaXMgYnVmZmVyLCBqdXN0IGVtaXQgb3VyIGNoYXJcbiAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGNoYXJTdHI7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIGFuZCBzZXQgY2hhckxlbmd0aCAvIGNoYXJSZWNlaXZlZFxuICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcik7XG5cbiAgdmFyIGVuZCA9IGJ1ZmZlci5sZW5ndGg7XG4gIGlmICh0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAvLyBidWZmZXIgdGhlIGluY29tcGxldGUgY2hhcmFjdGVyIGJ5dGVzIHdlIGdvdFxuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgMCwgYnVmZmVyLmxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkLCBlbmQpO1xuICAgIGVuZCAtPSB0aGlzLmNoYXJSZWNlaXZlZDtcbiAgfVxuXG4gIGNoYXJTdHIgKz0gYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIGVuZCk7XG5cbiAgdmFyIGVuZCA9IGNoYXJTdHIubGVuZ3RoIC0gMTtcbiAgdmFyIGNoYXJDb2RlID0gY2hhclN0ci5jaGFyQ29kZUF0KGVuZCk7XG4gIC8vIENFU1UtODogbGVhZCBzdXJyb2dhdGUgKEQ4MDAtREJGRikgaXMgYWxzbyB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXJcbiAgaWYgKGNoYXJDb2RlID49IDB4RDgwMCAmJiBjaGFyQ29kZSA8PSAweERCRkYpIHtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuc3Vycm9nYXRlU2l6ZTtcbiAgICB0aGlzLmNoYXJMZW5ndGggKz0gc2l6ZTtcbiAgICB0aGlzLmNoYXJSZWNlaXZlZCArPSBzaXplO1xuICAgIHRoaXMuY2hhckJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgc2l6ZSwgMCwgc2l6ZSk7XG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCAwLCAwLCBzaXplKTtcbiAgICByZXR1cm4gY2hhclN0ci5zdWJzdHJpbmcoMCwgZW5kKTtcbiAgfVxuXG4gIC8vIG9yIGp1c3QgZW1pdCB0aGUgY2hhclN0clxuICByZXR1cm4gY2hhclN0cjtcbn07XG5cbi8vIGRldGVjdEluY29tcGxldGVDaGFyIGRldGVybWluZXMgaWYgdGhlcmUgaXMgYW4gaW5jb21wbGV0ZSBVVEYtOCBjaGFyYWN0ZXIgYXRcbi8vIHRoZSBlbmQgb2YgdGhlIGdpdmVuIGJ1ZmZlci4gSWYgc28sIGl0IHNldHMgdGhpcy5jaGFyTGVuZ3RoIHRvIHRoZSBieXRlXG4vLyBsZW5ndGggdGhhdCBjaGFyYWN0ZXIsIGFuZCBzZXRzIHRoaXMuY2hhclJlY2VpdmVkIHRvIHRoZSBudW1iZXIgb2YgYnl0ZXNcbi8vIHRoYXQgYXJlIGF2YWlsYWJsZSBmb3IgdGhpcyBjaGFyYWN0ZXIuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAvLyBkZXRlcm1pbmUgaG93IG1hbnkgYnl0ZXMgd2UgaGF2ZSB0byBjaGVjayBhdCB0aGUgZW5kIG9mIHRoaXMgYnVmZmVyXG4gIHZhciBpID0gKGJ1ZmZlci5sZW5ndGggPj0gMykgPyAzIDogYnVmZmVyLmxlbmd0aDtcblxuICAvLyBGaWd1cmUgb3V0IGlmIG9uZSBvZiB0aGUgbGFzdCBpIGJ5dGVzIG9mIG91ciBidWZmZXIgYW5ub3VuY2VzIGFuXG4gIC8vIGluY29tcGxldGUgY2hhci5cbiAgZm9yICg7IGkgPiAwOyBpLS0pIHtcbiAgICB2YXIgYyA9IGJ1ZmZlcltidWZmZXIubGVuZ3RoIC0gaV07XG5cbiAgICAvLyBTZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9VVEYtOCNEZXNjcmlwdGlvblxuXG4gICAgLy8gMTEwWFhYWFhcbiAgICBpZiAoaSA9PSAxICYmIGMgPj4gNSA9PSAweDA2KSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSAyO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gMTExMFhYWFhcbiAgICBpZiAoaSA8PSAyICYmIGMgPj4gNCA9PSAweDBFKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSAzO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gMTExMTBYWFhcbiAgICBpZiAoaSA8PSAzICYmIGMgPj4gMyA9PSAweDFFKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSA0O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gaTtcbn07XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB2YXIgcmVzID0gJyc7XG4gIGlmIChidWZmZXIgJiYgYnVmZmVyLmxlbmd0aClcbiAgICByZXMgPSB0aGlzLndyaXRlKGJ1ZmZlcik7XG5cbiAgaWYgKHRoaXMuY2hhclJlY2VpdmVkKSB7XG4gICAgdmFyIGNyID0gdGhpcy5jaGFyUmVjZWl2ZWQ7XG4gICAgdmFyIGJ1ZiA9IHRoaXMuY2hhckJ1ZmZlcjtcbiAgICB2YXIgZW5jID0gdGhpcy5lbmNvZGluZztcbiAgICByZXMgKz0gYnVmLnNsaWNlKDAsIGNyKS50b1N0cmluZyhlbmMpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIHBhc3NUaHJvdWdoV3JpdGUoYnVmZmVyKSB7XG4gIHJldHVybiBidWZmZXIudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG59XG5cbmZ1bmN0aW9uIHV0ZjE2RGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKSB7XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gYnVmZmVyLmxlbmd0aCAlIDI7XG4gIHRoaXMuY2hhckxlbmd0aCA9IHRoaXMuY2hhclJlY2VpdmVkID8gMiA6IDA7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NERldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcikge1xuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGJ1ZmZlci5sZW5ndGggJSAzO1xuICB0aGlzLmNoYXJMZW5ndGggPSB0aGlzLmNoYXJSZWNlaXZlZCA/IDMgOiAwO1xufVxuIiwiLypnbG9iYWwgdW5lc2NhcGUsIG1vZHVsZSwgZGVmaW5lLCB3aW5kb3csIGdsb2JhbCovXHJcblxyXG4vKlxyXG4gVXJpVGVtcGxhdGUgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTMgRnJhbnogQW50ZXNiZXJnZXIuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbiBBdmFpbGFibGUgdmlhIHRoZSBNSVQgbGljZW5zZS5cclxuKi9cclxuXHJcbihmdW5jdGlvbiAoZXhwb3J0Q2FsbGJhY2spIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIFVyaVRlbXBsYXRlRXJyb3IgPSAoZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIGZ1bmN0aW9uIFVyaVRlbXBsYXRlRXJyb3IgKG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgfVxyXG5cclxuICAgIFVyaVRlbXBsYXRlRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChKU09OICYmIEpTT04uc3RyaW5naWZ5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLm9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBVcmlUZW1wbGF0ZUVycm9yO1xyXG59KCkpO1xyXG5cclxudmFyIG9iamVjdEhlbHBlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBpc0FycmF5ICh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpc1N0cmluZyAodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseSh2YWx1ZSkgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBpc051bWJlciAodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseSh2YWx1ZSkgPT09ICdbb2JqZWN0IE51bWJlcl0nO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBpc0Jvb2xlYW4gKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkodmFsdWUpID09PSAnW29iamVjdCBCb29sZWFuXSc7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIGpvaW4gKGFyciwgc2VwYXJhdG9yKSB7XHJcbiAgICAgICAgdmFyXHJcbiAgICAgICAgICAgIHJlc3VsdCA9ICcnLFxyXG4gICAgICAgICAgICBmaXJzdCA9IHRydWUsXHJcbiAgICAgICAgICAgIGluZGV4O1xyXG4gICAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IGFyci5sZW5ndGg7IGluZGV4ICs9IDEpIHtcclxuICAgICAgICAgICAgaWYgKGZpcnN0KSB7XHJcbiAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHNlcGFyYXRvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXN1bHQgKz0gYXJyW2luZGV4XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBtYXAgKGFyciwgbWFwcGVyKSB7XHJcbiAgICAgICAgdmFyXHJcbiAgICAgICAgICAgIHJlc3VsdCA9IFtdLFxyXG4gICAgICAgICAgICBpbmRleCA9IDA7XHJcbiAgICAgICAgZm9yICg7IGluZGV4IDwgYXJyLmxlbmd0aDsgaW5kZXggKz0gMSkge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChtYXBwZXIoYXJyW2luZGV4XSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGZpbHRlciAoYXJyLCBwcmVkaWNhdGUpIHtcclxuICAgICAgICB2YXJcclxuICAgICAgICAgICAgcmVzdWx0ID0gW10sXHJcbiAgICAgICAgICAgIGluZGV4ID0gMDtcclxuICAgICAgICBmb3IgKDsgaW5kZXggPCBhcnIubGVuZ3RoOyBpbmRleCArPSAxKSB7XHJcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUoYXJyW2luZGV4XSkpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFycltpbmRleF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZGVlcEZyZWV6ZVVzaW5nT2JqZWN0RnJlZXplIChvYmplY3QpIHtcclxuICAgICAgICBpZiAodHlwZW9mIG9iamVjdCAhPT0gXCJvYmplY3RcIiB8fCBvYmplY3QgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgT2JqZWN0LmZyZWV6ZShvYmplY3QpO1xyXG4gICAgICAgIHZhciBwcm9wZXJ0eSwgcHJvcGVydHlOYW1lO1xyXG4gICAgICAgIGZvciAocHJvcGVydHlOYW1lIGluIG9iamVjdCkge1xyXG4gICAgICAgICAgICBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KHByb3BlcnR5TmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIHByb3BlcnR5ID0gb2JqZWN0W3Byb3BlcnR5TmFtZV07XHJcbiAgICAgICAgICAgICAgICAvLyBiZSBhd2FyZSwgYXJyYXlzIGFyZSAnb2JqZWN0JywgdG9vXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb3BlcnR5ID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVlcEZyZWV6ZShwcm9wZXJ0eSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkZWVwRnJlZXplIChvYmplY3QpIHtcclxuICAgICAgICBpZiAodHlwZW9mIE9iamVjdC5mcmVlemUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRlZXBGcmVlemVVc2luZ09iamVjdEZyZWV6ZShvYmplY3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb2JqZWN0O1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGlzQXJyYXk6IGlzQXJyYXksXHJcbiAgICAgICAgaXNTdHJpbmc6IGlzU3RyaW5nLFxyXG4gICAgICAgIGlzTnVtYmVyOiBpc051bWJlcixcclxuICAgICAgICBpc0Jvb2xlYW46IGlzQm9vbGVhbixcclxuICAgICAgICBqb2luOiBqb2luLFxyXG4gICAgICAgIG1hcDogbWFwLFxyXG4gICAgICAgIGZpbHRlcjogZmlsdGVyLFxyXG4gICAgICAgIGRlZXBGcmVlemU6IGRlZXBGcmVlemVcclxuICAgIH07XHJcbn0oKSk7XHJcblxyXG52YXIgY2hhckhlbHBlciA9IChmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgZnVuY3Rpb24gaXNBbHBoYSAoY2hyKSB7XHJcbiAgICAgICAgcmV0dXJuIChjaHIgPj0gJ2EnICYmIGNociA8PSAneicpIHx8ICgoY2hyID49ICdBJyAmJiBjaHIgPD0gJ1onKSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaXNEaWdpdCAoY2hyKSB7XHJcbiAgICAgICAgcmV0dXJuIGNociA+PSAnMCcgJiYgY2hyIDw9ICc5JztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpc0hleERpZ2l0IChjaHIpIHtcclxuICAgICAgICByZXR1cm4gaXNEaWdpdChjaHIpIHx8IChjaHIgPj0gJ2EnICYmIGNociA8PSAnZicpIHx8IChjaHIgPj0gJ0EnICYmIGNociA8PSAnRicpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgaXNBbHBoYTogaXNBbHBoYSxcclxuICAgICAgICBpc0RpZ2l0OiBpc0RpZ2l0LFxyXG4gICAgICAgIGlzSGV4RGlnaXQ6IGlzSGV4RGlnaXRcclxuICAgIH07XHJcbn0oKSk7XHJcblxyXG52YXIgcGN0RW5jb2RlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgdXRmOCA9IHtcclxuICAgICAgICBlbmNvZGU6IGZ1bmN0aW9uIChjaHIpIHtcclxuICAgICAgICAgICAgLy8gc2VlIGh0dHA6Ly9lY21hbmF1dC5ibG9nc3BvdC5kZS8yMDA2LzA3L2VuY29kaW5nLWRlY29kaW5nLXV0ZjgtaW4tamF2YXNjcmlwdC5odG1sXHJcbiAgICAgICAgICAgIHJldHVybiB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoY2hyKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBudW1CeXRlczogZnVuY3Rpb24gKGZpcnN0Q2hhckNvZGUpIHtcclxuICAgICAgICAgICAgaWYgKGZpcnN0Q2hhckNvZGUgPD0gMHg3Rikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoMHhDMiA8PSBmaXJzdENoYXJDb2RlICYmIGZpcnN0Q2hhckNvZGUgPD0gMHhERikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoMHhFMCA8PSBmaXJzdENoYXJDb2RlICYmIGZpcnN0Q2hhckNvZGUgPD0gMHhFRikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoMHhGMCA8PSBmaXJzdENoYXJDb2RlICYmIGZpcnN0Q2hhckNvZGUgPD0gMHhGNCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gbm8gdmFsaWQgZmlyc3Qgb2N0ZXRcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc1ZhbGlkRm9sbG93aW5nQ2hhckNvZGU6IGZ1bmN0aW9uIChjaGFyQ29kZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gMHg4MCA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSAweEJGO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBlbmNvZGVzIGEgY2hhcmFjdGVyLCBpZiBuZWVkZWQgb3Igbm90LlxyXG4gICAgICogQHBhcmFtIGNoclxyXG4gICAgICogQHJldHVybiBwY3QtZW5jb2RlZCBjaGFyYWN0ZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZW5jb2RlQ2hhcmFjdGVyIChjaHIpIHtcclxuICAgICAgICB2YXJcclxuICAgICAgICAgICAgcmVzdWx0ID0gJycsXHJcbiAgICAgICAgICAgIG9jdGV0cyA9IHV0ZjguZW5jb2RlKGNociksXHJcbiAgICAgICAgICAgIG9jdGV0LFxyXG4gICAgICAgICAgICBpbmRleDtcclxuICAgICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBvY3RldHMubGVuZ3RoOyBpbmRleCArPSAxKSB7XHJcbiAgICAgICAgICAgIG9jdGV0ID0gb2N0ZXRzLmNoYXJDb2RlQXQoaW5kZXgpO1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gJyUnICsgKG9jdGV0IDwgMHgxMCA/ICcwJyA6ICcnKSArIG9jdGV0LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucywgd2hldGhlciB0aGUgZ2l2ZW4gdGV4dCBhdCBzdGFydCBpcyBpbiB0aGUgZm9ybSAncGVyY2VudCBoZXgtZGlnaXQgaGV4LWRpZ2l0JywgbGlrZSAnJTNGJ1xyXG4gICAgICogQHBhcmFtIHRleHRcclxuICAgICAqIEBwYXJhbSBzdGFydFxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbnwqfCp9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGlzUGVyY2VudERpZ2l0RGlnaXQgKHRleHQsIHN0YXJ0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRleHQuY2hhckF0KHN0YXJ0KSA9PT0gJyUnICYmIGNoYXJIZWxwZXIuaXNIZXhEaWdpdCh0ZXh0LmNoYXJBdChzdGFydCArIDEpKSAmJiBjaGFySGVscGVyLmlzSGV4RGlnaXQodGV4dC5jaGFyQXQoc3RhcnQgKyAyKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJzZXMgYSBoZXggbnVtYmVyIGZyb20gc3RhcnQgd2l0aCBsZW5ndGggMi5cclxuICAgICAqIEBwYXJhbSB0ZXh0IGEgc3RyaW5nXHJcbiAgICAgKiBAcGFyYW0gc3RhcnQgdGhlIHN0YXJ0IGluZGV4IG9mIHRoZSAyLWRpZ2l0IGhleCBudW1iZXJcclxuICAgICAqIEByZXR1cm4ge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcGFyc2VIZXgyICh0ZXh0LCBzdGFydCkge1xyXG4gICAgICAgIHJldHVybiBwYXJzZUludCh0ZXh0LnN1YnN0cihzdGFydCwgMiksIDE2KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGdpdmVuIGNoYXIgc2VxdWVuY2UgaXMgYSBjb3JyZWN0bHkgcGN0LWVuY29kZWQgc2VxdWVuY2UuXHJcbiAgICAgKiBAcGFyYW0gY2hyXHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpc1BjdEVuY29kZWQgKGNocikge1xyXG4gICAgICAgIGlmICghaXNQZXJjZW50RGlnaXREaWdpdChjaHIsIDApKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGZpcnN0Q2hhckNvZGUgPSBwYXJzZUhleDIoY2hyLCAxKTtcclxuICAgICAgICB2YXIgbnVtQnl0ZXMgPSB1dGY4Lm51bUJ5dGVzKGZpcnN0Q2hhckNvZGUpO1xyXG4gICAgICAgIGlmIChudW1CeXRlcyA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGJ5dGVOdW1iZXIgPSAxOyBieXRlTnVtYmVyIDwgbnVtQnl0ZXM7IGJ5dGVOdW1iZXIgKz0gMSkge1xyXG4gICAgICAgICAgICBpZiAoIWlzUGVyY2VudERpZ2l0RGlnaXQoY2hyLCAzKmJ5dGVOdW1iZXIpIHx8ICF1dGY4LmlzVmFsaWRGb2xsb3dpbmdDaGFyQ29kZShwYXJzZUhleDIoY2hyLCAzKmJ5dGVOdW1iZXIgKyAxKSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGFzIG11Y2ggYXMgbmVlZGVkIGZyb20gdGhlIHRleHQsIGUuZy4gJyUyMCcgb3IgJyVDMyVCNicuIEl0IGRvZXMgbm90IGRlY29kZSFcclxuICAgICAqIEBwYXJhbSB0ZXh0XHJcbiAgICAgKiBAcGFyYW0gc3RhcnRJbmRleFxyXG4gICAgICogQHJldHVybiB0aGUgY2hhcmFjdGVyIG9yIHBjdC1zdHJpbmcgb2YgdGhlIHRleHQgYXQgc3RhcnRJbmRleFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBwY3RDaGFyQXQodGV4dCwgc3RhcnRJbmRleCkge1xyXG4gICAgICAgIHZhciBjaHIgPSB0ZXh0LmNoYXJBdChzdGFydEluZGV4KTtcclxuICAgICAgICBpZiAoIWlzUGVyY2VudERpZ2l0RGlnaXQodGV4dCwgc3RhcnRJbmRleCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNocjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHV0ZjhDaGFyQ29kZSA9IHBhcnNlSGV4Mih0ZXh0LCBzdGFydEluZGV4ICsgMSk7XHJcbiAgICAgICAgdmFyIG51bUJ5dGVzID0gdXRmOC5udW1CeXRlcyh1dGY4Q2hhckNvZGUpO1xyXG4gICAgICAgIGlmIChudW1CeXRlcyA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gY2hyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBieXRlTnVtYmVyID0gMTsgYnl0ZU51bWJlciA8IG51bUJ5dGVzOyBieXRlTnVtYmVyICs9IDEpIHtcclxuICAgICAgICAgICAgaWYgKCFpc1BlcmNlbnREaWdpdERpZ2l0KHRleHQsIHN0YXJ0SW5kZXggKyAzICogYnl0ZU51bWJlcikgfHwgIXV0ZjguaXNWYWxpZEZvbGxvd2luZ0NoYXJDb2RlKHBhcnNlSGV4Mih0ZXh0LCBzdGFydEluZGV4ICsgMyAqIGJ5dGVOdW1iZXIgKyAxKSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjaHI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRleHQuc3Vic3RyKHN0YXJ0SW5kZXgsIDMgKiBudW1CeXRlcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBlbmNvZGVDaGFyYWN0ZXI6IGVuY29kZUNoYXJhY3RlcixcclxuICAgICAgICBpc1BjdEVuY29kZWQ6IGlzUGN0RW5jb2RlZCxcclxuICAgICAgICBwY3RDaGFyQXQ6IHBjdENoYXJBdFxyXG4gICAgfTtcclxufSgpKTtcclxuXHJcbnZhciByZmNDaGFySGVscGVyID0gKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgaWYgYW4gY2hhcmFjdGVyIGlzIGFuIHZhcmNoYXIgY2hhcmFjdGVyIGFjY29yZGluZyAyLjMgb2YgcmZjIDY1NzBcclxuICAgICAqIEBwYXJhbSBjaHJcclxuICAgICAqIEByZXR1cm4gKEJvb2xlYW4pXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGlzVmFyY2hhciAoY2hyKSB7XHJcbiAgICAgICAgcmV0dXJuIGNoYXJIZWxwZXIuaXNBbHBoYShjaHIpIHx8IGNoYXJIZWxwZXIuaXNEaWdpdChjaHIpIHx8IGNociA9PT0gJ18nIHx8IHBjdEVuY29kZXIuaXNQY3RFbmNvZGVkKGNocik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGlmIGNociBpcyBhbiB1bnJlc2VydmVkIGNoYXJhY3RlciBhY2NvcmRpbmcgMS41IG9mIHJmYyA2NTcwXHJcbiAgICAgKiBAcGFyYW0gY2hyXHJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpc1VucmVzZXJ2ZWQgKGNocikge1xyXG4gICAgICAgIHJldHVybiBjaGFySGVscGVyLmlzQWxwaGEoY2hyKSB8fCBjaGFySGVscGVyLmlzRGlnaXQoY2hyKSB8fCBjaHIgPT09ICctJyB8fCBjaHIgPT09ICcuJyB8fCBjaHIgPT09ICdfJyB8fCBjaHIgPT09ICd+JztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgaWYgY2hyIGlzIGFuIHJlc2VydmVkIGNoYXJhY3RlciBhY2NvcmRpbmcgMS41IG9mIHJmYyA2NTcwXHJcbiAgICAgKiBvciB0aGUgcGVyY2VudCBjaGFyYWN0ZXIgbWVudGlvbmVkIGluIDMuMi4xLlxyXG4gICAgICogQHBhcmFtIGNoclxyXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXNSZXNlcnZlZCAoY2hyKSB7XHJcbiAgICAgICAgcmV0dXJuIGNociA9PT0gJzonIHx8IGNociA9PT0gJy8nIHx8IGNociA9PT0gJz8nIHx8IGNociA9PT0gJyMnIHx8IGNociA9PT0gJ1snIHx8IGNociA9PT0gJ10nIHx8IGNociA9PT0gJ0AnIHx8IGNociA9PT0gJyEnIHx8IGNociA9PT0gJyQnIHx8IGNociA9PT0gJyYnIHx8IGNociA9PT0gJygnIHx8XHJcbiAgICAgICAgICAgIGNociA9PT0gJyknIHx8IGNociA9PT0gJyonIHx8IGNociA9PT0gJysnIHx8IGNociA9PT0gJywnIHx8IGNociA9PT0gJzsnIHx8IGNociA9PT0gJz0nIHx8IGNociA9PT0gXCInXCI7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBpc1ZhcmNoYXI6IGlzVmFyY2hhcixcclxuICAgICAgICBpc1VucmVzZXJ2ZWQ6IGlzVW5yZXNlcnZlZCxcclxuICAgICAgICBpc1Jlc2VydmVkOiBpc1Jlc2VydmVkXHJcbiAgICB9O1xyXG5cclxufSgpKTtcclxuXHJcbi8qKlxyXG4gKiBlbmNvZGluZyBvZiByZmMgNjU3MFxyXG4gKi9cclxudmFyIGVuY29kaW5nSGVscGVyID0gKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICBmdW5jdGlvbiBlbmNvZGUgKHRleHQsIHBhc3NSZXNlcnZlZCkge1xyXG4gICAgICAgIHZhclxyXG4gICAgICAgICAgICByZXN1bHQgPSAnJyxcclxuICAgICAgICAgICAgaW5kZXgsXHJcbiAgICAgICAgICAgIGNociA9ICcnO1xyXG4gICAgICAgIGlmICh0eXBlb2YgdGV4dCA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgdGV4dCA9PT0gXCJib29sZWFuXCIpIHtcclxuICAgICAgICAgICAgdGV4dCA9IHRleHQudG9TdHJpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgdGV4dC5sZW5ndGg7IGluZGV4ICs9IGNoci5sZW5ndGgpIHtcclxuICAgICAgICAgICAgY2hyID0gdGV4dC5jaGFyQXQoaW5kZXgpO1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gcmZjQ2hhckhlbHBlci5pc1VucmVzZXJ2ZWQoY2hyKSB8fCAocGFzc1Jlc2VydmVkICYmIHJmY0NoYXJIZWxwZXIuaXNSZXNlcnZlZChjaHIpKSA/IGNociA6IHBjdEVuY29kZXIuZW5jb2RlQ2hhcmFjdGVyKGNocik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZW5jb2RlUGFzc1Jlc2VydmVkICh0ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIGVuY29kZSh0ZXh0LCB0cnVlKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBlbmNvZGVMaXRlcmFsQ2hhcmFjdGVyIChsaXRlcmFsLCBpbmRleCkge1xyXG4gICAgICAgIHZhciBjaHIgPSBwY3RFbmNvZGVyLnBjdENoYXJBdChsaXRlcmFsLCBpbmRleCk7XHJcbiAgICAgICAgaWYgKGNoci5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjaHI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gcmZjQ2hhckhlbHBlci5pc1Jlc2VydmVkKGNocikgfHwgcmZjQ2hhckhlbHBlci5pc1VucmVzZXJ2ZWQoY2hyKSA/IGNociA6IHBjdEVuY29kZXIuZW5jb2RlQ2hhcmFjdGVyKGNocik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGVuY29kZUxpdGVyYWwgKGxpdGVyYWwpIHtcclxuICAgICAgICB2YXJcclxuICAgICAgICAgICAgcmVzdWx0ID0gJycsXHJcbiAgICAgICAgICAgIGluZGV4LFxyXG4gICAgICAgICAgICBjaHIgPSAnJztcclxuICAgICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBsaXRlcmFsLmxlbmd0aDsgaW5kZXggKz0gY2hyLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBjaHIgPSBwY3RFbmNvZGVyLnBjdENoYXJBdChsaXRlcmFsLCBpbmRleCk7XHJcbiAgICAgICAgICAgIGlmIChjaHIubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGNocjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSByZmNDaGFySGVscGVyLmlzUmVzZXJ2ZWQoY2hyKSB8fCByZmNDaGFySGVscGVyLmlzVW5yZXNlcnZlZChjaHIpID8gY2hyIDogcGN0RW5jb2Rlci5lbmNvZGVDaGFyYWN0ZXIoY2hyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZW5jb2RlOiBlbmNvZGUsXHJcbiAgICAgICAgZW5jb2RlUGFzc1Jlc2VydmVkOiBlbmNvZGVQYXNzUmVzZXJ2ZWQsXHJcbiAgICAgICAgZW5jb2RlTGl0ZXJhbDogZW5jb2RlTGl0ZXJhbCxcclxuICAgICAgICBlbmNvZGVMaXRlcmFsQ2hhcmFjdGVyOiBlbmNvZGVMaXRlcmFsQ2hhcmFjdGVyXHJcbiAgICB9O1xyXG5cclxufSgpKTtcclxuXHJcblxyXG4vLyB0aGUgb3BlcmF0b3JzIGRlZmluZWQgYnkgcmZjIDY1NzBcclxudmFyIG9wZXJhdG9ycyA9IChmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyXHJcbiAgICAgICAgYnlTeW1ib2wgPSB7fTtcclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGUgKHN5bWJvbCkge1xyXG4gICAgICAgIGJ5U3ltYm9sW3N5bWJvbF0gPSB7XHJcbiAgICAgICAgICAgIHN5bWJvbDogc3ltYm9sLFxyXG4gICAgICAgICAgICBzZXBhcmF0b3I6IChzeW1ib2wgPT09ICc/JykgPyAnJicgOiAoc3ltYm9sID09PSAnJyB8fCBzeW1ib2wgPT09ICcrJyB8fCBzeW1ib2wgPT09ICcjJykgPyAnLCcgOiBzeW1ib2wsXHJcbiAgICAgICAgICAgIG5hbWVkOiBzeW1ib2wgPT09ICc7JyB8fCBzeW1ib2wgPT09ICcmJyB8fCBzeW1ib2wgPT09ICc/JyxcclxuICAgICAgICAgICAgaWZFbXB0eTogKHN5bWJvbCA9PT0gJyYnIHx8IHN5bWJvbCA9PT0gJz8nKSA/ICc9JyA6ICcnLFxyXG4gICAgICAgICAgICBmaXJzdDogKHN5bWJvbCA9PT0gJysnICkgPyAnJyA6IHN5bWJvbCxcclxuICAgICAgICAgICAgZW5jb2RlOiAoc3ltYm9sID09PSAnKycgfHwgc3ltYm9sID09PSAnIycpID8gZW5jb2RpbmdIZWxwZXIuZW5jb2RlUGFzc1Jlc2VydmVkIDogZW5jb2RpbmdIZWxwZXIuZW5jb2RlLFxyXG4gICAgICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3ltYm9sO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBjcmVhdGUoJycpO1xyXG4gICAgY3JlYXRlKCcrJyk7XHJcbiAgICBjcmVhdGUoJyMnKTtcclxuICAgIGNyZWF0ZSgnLicpO1xyXG4gICAgY3JlYXRlKCcvJyk7XHJcbiAgICBjcmVhdGUoJzsnKTtcclxuICAgIGNyZWF0ZSgnPycpO1xyXG4gICAgY3JlYXRlKCcmJyk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHZhbHVlT2Y6IGZ1bmN0aW9uIChjaHIpIHtcclxuICAgICAgICAgICAgaWYgKGJ5U3ltYm9sW2Nocl0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBieVN5bWJvbFtjaHJdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChcIj0sIUB8XCIuaW5kZXhPZihjaHIpID49IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBieVN5bWJvbFsnJ107XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufSgpKTtcclxuXHJcblxyXG4vKipcclxuICogRGV0ZWN0cywgd2hldGhlciBhIGdpdmVuIGVsZW1lbnQgaXMgZGVmaW5lZCBpbiB0aGUgc2Vuc2Ugb2YgcmZjIDY1NzBcclxuICogU2VjdGlvbiAyLjMgb2YgdGhlIFJGQyBtYWtlcyBjbGVhciBkZWZpbnRpb25zOlxyXG4gKiAqIHVuZGVmaW5lZCBhbmQgbnVsbCBhcmUgbm90IGRlZmluZWQuXHJcbiAqICogdGhlIGVtcHR5IHN0cmluZyBpcyBkZWZpbmVkXHJcbiAqICogYW4gYXJyYXkgKFwibGlzdFwiKSBpcyBkZWZpbmVkLCBpZiBpdCBpcyBub3QgZW1wdHkgKGV2ZW4gaWYgYWxsIGVsZW1lbnRzIGFyZSBub3QgZGVmaW5lZClcclxuICogKiBhbiBvYmplY3QgKFwibWFwXCIpIGlzIGRlZmluZWQsIGlmIGl0IGNvbnRhaW5zIGF0IGxlYXN0IG9uZSBwcm9wZXJ0eSB3aXRoIGRlZmluZWQgdmFsdWVcclxuICogQHBhcmFtIG9iamVjdFxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKi9cclxuZnVuY3Rpb24gaXNEZWZpbmVkIChvYmplY3QpIHtcclxuICAgIHZhclxyXG4gICAgICAgIHByb3BlcnR5TmFtZTtcclxuICAgIGlmIChvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAob2JqZWN0SGVscGVyLmlzQXJyYXkob2JqZWN0KSkge1xyXG4gICAgICAgIC8vIFNlY3Rpb24gMi4zOiBBIHZhcmlhYmxlIGRlZmluZWQgYXMgYSBsaXN0IHZhbHVlIGlzIGNvbnNpZGVyZWQgdW5kZWZpbmVkIGlmIHRoZSBsaXN0IGNvbnRhaW5zIHplcm8gbWVtYmVyc1xyXG4gICAgICAgIHJldHVybiBvYmplY3QubGVuZ3RoID4gMDtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2Ygb2JqZWN0ID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBvYmplY3QgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIG9iamVjdCA9PT0gXCJib29sZWFuXCIpIHtcclxuICAgICAgICAvLyBmYWxzeSB2YWx1ZXMgbGlrZSBlbXB0eSBzdHJpbmdzLCBmYWxzZSBvciAwIGFyZSBcImRlZmluZWRcIlxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgLy8gZWxzZSBPYmplY3RcclxuICAgIGZvciAocHJvcGVydHlOYW1lIGluIG9iamVjdCkge1xyXG4gICAgICAgIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkocHJvcGVydHlOYW1lKSAmJiBpc0RlZmluZWQob2JqZWN0W3Byb3BlcnR5TmFtZV0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5cclxudmFyIExpdGVyYWxFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIExpdGVyYWxFeHByZXNzaW9uIChsaXRlcmFsKSB7XHJcbiAgICAgICAgdGhpcy5saXRlcmFsID0gZW5jb2RpbmdIZWxwZXIuZW5jb2RlTGl0ZXJhbChsaXRlcmFsKTtcclxuICAgIH1cclxuXHJcbiAgICBMaXRlcmFsRXhwcmVzc2lvbi5wcm90b3R5cGUuZXhwYW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxpdGVyYWw7XHJcbiAgICB9O1xyXG5cclxuICAgIExpdGVyYWxFeHByZXNzaW9uLnByb3RvdHlwZS50b1N0cmluZyA9IExpdGVyYWxFeHByZXNzaW9uLnByb3RvdHlwZS5leHBhbmQ7XHJcblxyXG4gICAgcmV0dXJuIExpdGVyYWxFeHByZXNzaW9uO1xyXG59KCkpO1xyXG5cclxudmFyIHBhcnNlID0gKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICBmdW5jdGlvbiBwYXJzZUV4cHJlc3Npb24gKGV4cHJlc3Npb25UZXh0KSB7XHJcbiAgICAgICAgdmFyXHJcbiAgICAgICAgICAgIG9wZXJhdG9yLFxyXG4gICAgICAgICAgICB2YXJzcGVjcyA9IFtdLFxyXG4gICAgICAgICAgICB2YXJzcGVjID0gbnVsbCxcclxuICAgICAgICAgICAgdmFybmFtZVN0YXJ0ID0gbnVsbCxcclxuICAgICAgICAgICAgbWF4TGVuZ3RoU3RhcnQgPSBudWxsLFxyXG4gICAgICAgICAgICBpbmRleCxcclxuICAgICAgICAgICAgY2hyID0gJyc7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGNsb3NlVmFybmFtZSAoKSB7XHJcbiAgICAgICAgICAgIHZhciB2YXJuYW1lID0gZXhwcmVzc2lvblRleHQuc3Vic3RyaW5nKHZhcm5hbWVTdGFydCwgaW5kZXgpO1xyXG4gICAgICAgICAgICBpZiAodmFybmFtZS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBVcmlUZW1wbGF0ZUVycm9yKHtleHByZXNzaW9uVGV4dDogZXhwcmVzc2lvblRleHQsIG1lc3NhZ2U6IFwiYSB2YXJuYW1lIG11c3QgYmUgc3BlY2lmaWVkXCIsIHBvc2l0aW9uOiBpbmRleH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhcnNwZWMgPSB7dmFybmFtZTogdmFybmFtZSwgZXhwbG9kZWQ6IGZhbHNlLCBtYXhMZW5ndGg6IG51bGx9O1xyXG4gICAgICAgICAgICB2YXJuYW1lU3RhcnQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gY2xvc2VNYXhMZW5ndGggKCkge1xyXG4gICAgICAgICAgICBpZiAobWF4TGVuZ3RoU3RhcnQgPT09IGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVXJpVGVtcGxhdGVFcnJvcih7ZXhwcmVzc2lvblRleHQ6IGV4cHJlc3Npb25UZXh0LCBtZXNzYWdlOiBcImFmdGVyIGEgJzonIHlvdSBoYXZlIHRvIHNwZWNpZnkgdGhlIGxlbmd0aFwiLCBwb3NpdGlvbjogaW5kZXh9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXJzcGVjLm1heExlbmd0aCA9IHBhcnNlSW50KGV4cHJlc3Npb25UZXh0LnN1YnN0cmluZyhtYXhMZW5ndGhTdGFydCwgaW5kZXgpLCAxMCk7XHJcbiAgICAgICAgICAgIG1heExlbmd0aFN0YXJ0ID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG9wZXJhdG9yID0gKGZ1bmN0aW9uIChvcGVyYXRvclRleHQpIHtcclxuICAgICAgICAgICAgdmFyIG9wID0gb3BlcmF0b3JzLnZhbHVlT2Yob3BlcmF0b3JUZXh0KTtcclxuICAgICAgICAgICAgaWYgKG9wID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVXJpVGVtcGxhdGVFcnJvcih7ZXhwcmVzc2lvblRleHQ6IGV4cHJlc3Npb25UZXh0LCBtZXNzYWdlOiBcImlsbGVnYWwgdXNlIG9mIHJlc2VydmVkIG9wZXJhdG9yXCIsIHBvc2l0aW9uOiBpbmRleCwgb3BlcmF0b3I6IG9wZXJhdG9yVGV4dH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBvcDtcclxuICAgICAgICB9KGV4cHJlc3Npb25UZXh0LmNoYXJBdCgwKSkpO1xyXG4gICAgICAgIGluZGV4ID0gb3BlcmF0b3Iuc3ltYm9sLmxlbmd0aDtcclxuXHJcbiAgICAgICAgdmFybmFtZVN0YXJ0ID0gaW5kZXg7XHJcblxyXG4gICAgICAgIGZvciAoOyBpbmRleCA8IGV4cHJlc3Npb25UZXh0Lmxlbmd0aDsgaW5kZXggKz0gY2hyLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBjaHIgPSBwY3RFbmNvZGVyLnBjdENoYXJBdChleHByZXNzaW9uVGV4dCwgaW5kZXgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHZhcm5hbWVTdGFydCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgLy8gdGhlIHNwZWMgc2F5czogdmFybmFtZSA9ICB2YXJjaGFyICooIFtcIi5cIl0gdmFyY2hhciApXHJcbiAgICAgICAgICAgICAgICAvLyBzbyBhIGRvdCBpcyBhbGxvd2VkIGV4Y2VwdCBmb3IgdGhlIGZpcnN0IGNoYXJcclxuICAgICAgICAgICAgICAgIGlmIChjaHIgPT09ICcuJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YXJuYW1lU3RhcnQgPT09IGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBVcmlUZW1wbGF0ZUVycm9yKHtleHByZXNzaW9uVGV4dDogZXhwcmVzc2lvblRleHQsIG1lc3NhZ2U6IFwiYSB2YXJuYW1lIE1VU1QgTk9UIHN0YXJ0IHdpdGggYSBkb3RcIiwgcG9zaXRpb246IGluZGV4fSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHJmY0NoYXJIZWxwZXIuaXNWYXJjaGFyKGNocikpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNsb3NlVmFybmFtZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtYXhMZW5ndGhTdGFydCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSBtYXhMZW5ndGhTdGFydCAmJiBjaHIgPT09ICcwJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBVcmlUZW1wbGF0ZUVycm9yKHtleHByZXNzaW9uVGV4dDogZXhwcmVzc2lvblRleHQsIG1lc3NhZ2U6IFwiQSA6cHJlZml4IG11c3Qgbm90IHN0YXJ0IHdpdGggZGlnaXQgMFwiLCBwb3NpdGlvbjogaW5kZXh9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChjaGFySGVscGVyLmlzRGlnaXQoY2hyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCAtIG1heExlbmd0aFN0YXJ0ID49IDQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVyaVRlbXBsYXRlRXJyb3Ioe2V4cHJlc3Npb25UZXh0OiBleHByZXNzaW9uVGV4dCwgbWVzc2FnZTogXCJBIDpwcmVmaXggbXVzdCBoYXZlIG1heCA0IGRpZ2l0c1wiLCBwb3NpdGlvbjogaW5kZXh9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjbG9zZU1heExlbmd0aCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjaHIgPT09ICc6Jykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhcnNwZWMubWF4TGVuZ3RoICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVyaVRlbXBsYXRlRXJyb3Ioe2V4cHJlc3Npb25UZXh0OiBleHByZXNzaW9uVGV4dCwgbWVzc2FnZTogXCJvbmx5IG9uZSA6bWF4TGVuZ3RoIGlzIGFsbG93ZWQgcGVyIHZhcnNwZWNcIiwgcG9zaXRpb246IGluZGV4fSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodmFyc3BlYy5leHBsb2RlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBVcmlUZW1wbGF0ZUVycm9yKHtleHByZXNzaW9uVGV4dDogZXhwcmVzc2lvblRleHQsIG1lc3NhZ2U6IFwiYW4gZXhwbG9lZGVkIHZhcnNwZWMgTVVTVCBOT1QgYmUgdmFyc3BlY2VkXCIsIHBvc2l0aW9uOiBpbmRleH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbWF4TGVuZ3RoU3RhcnQgPSBpbmRleCArIDE7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY2hyID09PSAnKicpIHtcclxuICAgICAgICAgICAgICAgIGlmICh2YXJzcGVjID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVyaVRlbXBsYXRlRXJyb3Ioe2V4cHJlc3Npb25UZXh0OiBleHByZXNzaW9uVGV4dCwgbWVzc2FnZTogXCJleHBsb2RlZCB3aXRob3V0IHZhcnNwZWNcIiwgcG9zaXRpb246IGluZGV4fSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodmFyc3BlYy5leHBsb2RlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBVcmlUZW1wbGF0ZUVycm9yKHtleHByZXNzaW9uVGV4dDogZXhwcmVzc2lvblRleHQsIG1lc3NhZ2U6IFwiZXhwbG9kZWQgdHdpY2VcIiwgcG9zaXRpb246IGluZGV4fSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodmFyc3BlYy5tYXhMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVXJpVGVtcGxhdGVFcnJvcih7ZXhwcmVzc2lvblRleHQ6IGV4cHJlc3Npb25UZXh0LCBtZXNzYWdlOiBcImFuIGV4cGxvZGUgKCopIE1VU1QgTk9UIGZvbGxvdyB0byBhIHByZWZpeFwiLCBwb3NpdGlvbjogaW5kZXh9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhcnNwZWMuZXhwbG9kZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdGhlIG9ubHkgbGVnYWwgY2hhcmFjdGVyIG5vdyBpcyB0aGUgY29tbWFcclxuICAgICAgICAgICAgaWYgKGNociA9PT0gJywnKSB7XHJcbiAgICAgICAgICAgICAgICB2YXJzcGVjcy5wdXNoKHZhcnNwZWMpO1xyXG4gICAgICAgICAgICAgICAgdmFyc3BlYyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB2YXJuYW1lU3RhcnQgPSBpbmRleCArIDE7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVXJpVGVtcGxhdGVFcnJvcih7ZXhwcmVzc2lvblRleHQ6IGV4cHJlc3Npb25UZXh0LCBtZXNzYWdlOiBcImlsbGVnYWwgY2hhcmFjdGVyXCIsIGNoYXJhY3RlcjogY2hyLCBwb3NpdGlvbjogaW5kZXh9KTtcclxuICAgICAgICB9IC8vIGZvciBjaHJcclxuICAgICAgICBpZiAodmFybmFtZVN0YXJ0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNsb3NlVmFybmFtZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWF4TGVuZ3RoU3RhcnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgY2xvc2VNYXhMZW5ndGgoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyc3BlY3MucHVzaCh2YXJzcGVjKTtcclxuICAgICAgICByZXR1cm4gbmV3IFZhcmlhYmxlRXhwcmVzc2lvbihleHByZXNzaW9uVGV4dCwgb3BlcmF0b3IsIHZhcnNwZWNzKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwYXJzZSAodXJpVGVtcGxhdGVUZXh0KSB7XHJcbiAgICAgICAgLy8gYXNzZXJ0IGZpbGxlZCBzdHJpbmdcclxuICAgICAgICB2YXJcclxuICAgICAgICAgICAgaW5kZXgsXHJcbiAgICAgICAgICAgIGNocixcclxuICAgICAgICAgICAgZXhwcmVzc2lvbnMgPSBbXSxcclxuICAgICAgICAgICAgYnJhY2VPcGVuSW5kZXggPSBudWxsLFxyXG4gICAgICAgICAgICBsaXRlcmFsU3RhcnQgPSAwO1xyXG4gICAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHVyaVRlbXBsYXRlVGV4dC5sZW5ndGg7IGluZGV4ICs9IDEpIHtcclxuICAgICAgICAgICAgY2hyID0gdXJpVGVtcGxhdGVUZXh0LmNoYXJBdChpbmRleCk7XHJcbiAgICAgICAgICAgIGlmIChsaXRlcmFsU3RhcnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaHIgPT09ICd9Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBVcmlUZW1wbGF0ZUVycm9yKHt0ZW1wbGF0ZVRleHQ6IHVyaVRlbXBsYXRlVGV4dCwgbWVzc2FnZTogXCJ1bm9wZW5lZCBicmFjZSBjbG9zZWRcIiwgcG9zaXRpb246IGluZGV4fSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hyID09PSAneycpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobGl0ZXJhbFN0YXJ0IDwgaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaChuZXcgTGl0ZXJhbEV4cHJlc3Npb24odXJpVGVtcGxhdGVUZXh0LnN1YnN0cmluZyhsaXRlcmFsU3RhcnQsIGluZGV4KSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBsaXRlcmFsU3RhcnQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyYWNlT3BlbkluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGJyYWNlT3BlbkluZGV4ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBoZXJlIGp1c3QgeyBpcyBmb3JiaWRkZW5cclxuICAgICAgICAgICAgICAgIGlmIChjaHIgPT09ICd7Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBVcmlUZW1wbGF0ZUVycm9yKHt0ZW1wbGF0ZVRleHQ6IHVyaVRlbXBsYXRlVGV4dCwgbWVzc2FnZTogXCJicmFjZSBhbHJlYWR5IG9wZW5lZFwiLCBwb3NpdGlvbjogaW5kZXh9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChjaHIgPT09ICd9Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChicmFjZU9wZW5JbmRleCArIDEgPT09IGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBVcmlUZW1wbGF0ZUVycm9yKHt0ZW1wbGF0ZVRleHQ6IHVyaVRlbXBsYXRlVGV4dCwgbWVzc2FnZTogXCJlbXB0eSBicmFjZXNcIiwgcG9zaXRpb246IGJyYWNlT3BlbkluZGV4fSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2gocGFyc2VFeHByZXNzaW9uKHVyaVRlbXBsYXRlVGV4dC5zdWJzdHJpbmcoYnJhY2VPcGVuSW5kZXggKyAxLCBpbmRleCkpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5wcm90b3R5cGUgPT09IFVyaVRlbXBsYXRlRXJyb3IucHJvdG90eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVXJpVGVtcGxhdGVFcnJvcih7dGVtcGxhdGVUZXh0OiB1cmlUZW1wbGF0ZVRleHQsIG1lc3NhZ2U6IGVycm9yLm9wdGlvbnMubWVzc2FnZSwgcG9zaXRpb246IGJyYWNlT3BlbkluZGV4ICsgZXJyb3Iub3B0aW9ucy5wb3NpdGlvbiwgZGV0YWlsczogZXJyb3Iub3B0aW9uc30pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmFjZU9wZW5JbmRleCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgbGl0ZXJhbFN0YXJ0ID0gaW5kZXggKyAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWFjaGVkIHVucmVhY2hhYmxlIGNvZGUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGJyYWNlT3BlbkluZGV4ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBVcmlUZW1wbGF0ZUVycm9yKHt0ZW1wbGF0ZVRleHQ6IHVyaVRlbXBsYXRlVGV4dCwgbWVzc2FnZTogXCJ1bmNsb3NlZCBicmFjZVwiLCBwb3NpdGlvbjogYnJhY2VPcGVuSW5kZXh9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxpdGVyYWxTdGFydCA8IHVyaVRlbXBsYXRlVGV4dC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaChuZXcgTGl0ZXJhbEV4cHJlc3Npb24odXJpVGVtcGxhdGVUZXh0LnN1YnN0cihsaXRlcmFsU3RhcnQpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgVXJpVGVtcGxhdGUodXJpVGVtcGxhdGVUZXh0LCBleHByZXNzaW9ucyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHBhcnNlO1xyXG59KCkpO1xyXG5cclxudmFyIFZhcmlhYmxlRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvLyBoZWxwZXIgZnVuY3Rpb24gaWYgSlNPTiBpcyBub3QgYXZhaWxhYmxlXHJcbiAgICBmdW5jdGlvbiBwcmV0dHlQcmludCAodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gKEpTT04gJiYgSlNPTi5zdHJpbmdpZnkpID8gSlNPTi5zdHJpbmdpZnkodmFsdWUpIDogdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaXNFbXB0eSAodmFsdWUpIHtcclxuICAgICAgICBpZiAoIWlzRGVmaW5lZCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvYmplY3RIZWxwZXIuaXNTdHJpbmcodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvYmplY3RIZWxwZXIuaXNOdW1iZXIodmFsdWUpIHx8IG9iamVjdEhlbHBlci5pc0Jvb2xlYW4odmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9iamVjdEhlbHBlci5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubGVuZ3RoID09PSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eU5hbWUgaW4gdmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlLmhhc093blByb3BlcnR5KHByb3BlcnR5TmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwcm9wZXJ0eUFycmF5IChvYmplY3QpIHtcclxuICAgICAgICB2YXJcclxuICAgICAgICAgICAgcmVzdWx0ID0gW10sXHJcbiAgICAgICAgICAgIHByb3BlcnR5TmFtZTtcclxuICAgICAgICBmb3IgKHByb3BlcnR5TmFtZSBpbiBvYmplY3QpIHtcclxuICAgICAgICAgICAgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eU5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7bmFtZTogcHJvcGVydHlOYW1lLCB2YWx1ZTogb2JqZWN0W3Byb3BlcnR5TmFtZV19KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIFZhcmlhYmxlRXhwcmVzc2lvbiAodGVtcGxhdGVUZXh0LCBvcGVyYXRvciwgdmFyc3BlY3MpIHtcclxuICAgICAgICB0aGlzLnRlbXBsYXRlVGV4dCA9IHRlbXBsYXRlVGV4dDtcclxuICAgICAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XHJcbiAgICAgICAgdGhpcy52YXJzcGVjcyA9IHZhcnNwZWNzO1xyXG4gICAgfVxyXG5cclxuICAgIFZhcmlhYmxlRXhwcmVzc2lvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGVtcGxhdGVUZXh0O1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBleHBhbmRTaW1wbGVWYWx1ZSh2YXJzcGVjLCBvcGVyYXRvciwgdmFsdWUpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XHJcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xyXG4gICAgICAgIGlmIChvcGVyYXRvci5uYW1lZCkge1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gZW5jb2RpbmdIZWxwZXIuZW5jb2RlTGl0ZXJhbCh2YXJzcGVjLnZhcm5hbWUpO1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gb3BlcmF0b3IuaWZFbXB0eTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzdWx0ICs9ICc9JztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZhcnNwZWMubWF4TGVuZ3RoICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyKDAsIHZhcnNwZWMubWF4TGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0ICs9IG9wZXJhdG9yLmVuY29kZSh2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB2YWx1ZURlZmluZWQgKG5hbWVWYWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBpc0RlZmluZWQobmFtZVZhbHVlLnZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBleHBhbmROb3RFeHBsb2RlZCh2YXJzcGVjLCBvcGVyYXRvciwgdmFsdWUpIHtcclxuICAgICAgICB2YXJcclxuICAgICAgICAgICAgYXJyID0gW10sXHJcbiAgICAgICAgICAgIHJlc3VsdCA9ICcnO1xyXG4gICAgICAgIGlmIChvcGVyYXRvci5uYW1lZCkge1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gZW5jb2RpbmdIZWxwZXIuZW5jb2RlTGl0ZXJhbCh2YXJzcGVjLnZhcm5hbWUpO1xyXG4gICAgICAgICAgICBpZiAoaXNFbXB0eSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBvcGVyYXRvci5pZkVtcHR5O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXN1bHQgKz0gJz0nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob2JqZWN0SGVscGVyLmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIGFyciA9IHZhbHVlO1xyXG4gICAgICAgICAgICBhcnIgPSBvYmplY3RIZWxwZXIuZmlsdGVyKGFyciwgaXNEZWZpbmVkKTtcclxuICAgICAgICAgICAgYXJyID0gb2JqZWN0SGVscGVyLm1hcChhcnIsIG9wZXJhdG9yLmVuY29kZSk7XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSBvYmplY3RIZWxwZXIuam9pbihhcnIsICcsJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhcnIgPSBwcm9wZXJ0eUFycmF5KHZhbHVlKTtcclxuICAgICAgICAgICAgYXJyID0gb2JqZWN0SGVscGVyLmZpbHRlcihhcnIsIHZhbHVlRGVmaW5lZCk7XHJcbiAgICAgICAgICAgIGFyciA9IG9iamVjdEhlbHBlci5tYXAoYXJyLCBmdW5jdGlvbiAobmFtZVZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3BlcmF0b3IuZW5jb2RlKG5hbWVWYWx1ZS5uYW1lKSArICcsJyArIG9wZXJhdG9yLmVuY29kZShuYW1lVmFsdWUudmFsdWUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmVzdWx0ICs9IG9iamVjdEhlbHBlci5qb2luKGFyciwgJywnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBleHBhbmRFeHBsb2RlZE5hbWVkICh2YXJzcGVjLCBvcGVyYXRvciwgdmFsdWUpIHtcclxuICAgICAgICB2YXJcclxuICAgICAgICAgICAgaXNBcnJheSA9IG9iamVjdEhlbHBlci5pc0FycmF5KHZhbHVlKSxcclxuICAgICAgICAgICAgYXJyID0gW107XHJcbiAgICAgICAgaWYgKGlzQXJyYXkpIHtcclxuICAgICAgICAgICAgYXJyID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGFyciA9IG9iamVjdEhlbHBlci5maWx0ZXIoYXJyLCBpc0RlZmluZWQpO1xyXG4gICAgICAgICAgICBhcnIgPSBvYmplY3RIZWxwZXIubWFwKGFyciwgZnVuY3Rpb24gKGxpc3RFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdG1wID0gZW5jb2RpbmdIZWxwZXIuZW5jb2RlTGl0ZXJhbCh2YXJzcGVjLnZhcm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkobGlzdEVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG1wICs9IG9wZXJhdG9yLmlmRW1wdHk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0bXAgKz0gJz0nICsgb3BlcmF0b3IuZW5jb2RlKGxpc3RFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0bXA7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYXJyID0gcHJvcGVydHlBcnJheSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIGFyciA9IG9iamVjdEhlbHBlci5maWx0ZXIoYXJyLCB2YWx1ZURlZmluZWQpO1xyXG4gICAgICAgICAgICBhcnIgPSBvYmplY3RIZWxwZXIubWFwKGFyciwgZnVuY3Rpb24gKG5hbWVWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRtcCA9IGVuY29kaW5nSGVscGVyLmVuY29kZUxpdGVyYWwobmFtZVZhbHVlLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkobmFtZVZhbHVlLnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRtcCArPSBvcGVyYXRvci5pZkVtcHR5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG1wICs9ICc9JyArIG9wZXJhdG9yLmVuY29kZShuYW1lVmFsdWUudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRtcDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvYmplY3RIZWxwZXIuam9pbihhcnIsIG9wZXJhdG9yLnNlcGFyYXRvcik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZXhwYW5kRXhwbG9kZWRVbm5hbWVkIChvcGVyYXRvciwgdmFsdWUpIHtcclxuICAgICAgICB2YXJcclxuICAgICAgICAgICAgYXJyID0gW10sXHJcbiAgICAgICAgICAgIHJlc3VsdCA9ICcnO1xyXG4gICAgICAgIGlmIChvYmplY3RIZWxwZXIuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgYXJyID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGFyciA9IG9iamVjdEhlbHBlci5maWx0ZXIoYXJyLCBpc0RlZmluZWQpO1xyXG4gICAgICAgICAgICBhcnIgPSBvYmplY3RIZWxwZXIubWFwKGFyciwgb3BlcmF0b3IuZW5jb2RlKTtcclxuICAgICAgICAgICAgcmVzdWx0ICs9IG9iamVjdEhlbHBlci5qb2luKGFyciwgb3BlcmF0b3Iuc2VwYXJhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFyciA9IHByb3BlcnR5QXJyYXkodmFsdWUpO1xyXG4gICAgICAgICAgICBhcnIgPSBvYmplY3RIZWxwZXIuZmlsdGVyKGFyciwgZnVuY3Rpb24gKG5hbWVWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzRGVmaW5lZChuYW1lVmFsdWUudmFsdWUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgYXJyID0gb2JqZWN0SGVscGVyLm1hcChhcnIsIGZ1bmN0aW9uIChuYW1lVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvcGVyYXRvci5lbmNvZGUobmFtZVZhbHVlLm5hbWUpICsgJz0nICsgb3BlcmF0b3IuZW5jb2RlKG5hbWVWYWx1ZS52YWx1ZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gb2JqZWN0SGVscGVyLmpvaW4oYXJyLCBvcGVyYXRvci5zZXBhcmF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBWYXJpYWJsZUV4cHJlc3Npb24ucHJvdG90eXBlLmV4cGFuZCA9IGZ1bmN0aW9uICh2YXJpYWJsZXMpIHtcclxuICAgICAgICB2YXJcclxuICAgICAgICAgICAgZXhwYW5kZWQgPSBbXSxcclxuICAgICAgICAgICAgaW5kZXgsXHJcbiAgICAgICAgICAgIHZhcnNwZWMsXHJcbiAgICAgICAgICAgIHZhbHVlLFxyXG4gICAgICAgICAgICB2YWx1ZUlzQXJyLFxyXG4gICAgICAgICAgICBvbmVFeHBsb2RlZCA9IGZhbHNlLFxyXG4gICAgICAgICAgICBvcGVyYXRvciA9IHRoaXMub3BlcmF0b3I7XHJcblxyXG4gICAgICAgIC8vIGV4cGFuZCBlYWNoIHZhcnNwZWMgYW5kIGpvaW4gd2l0aCBvcGVyYXRvcidzIHNlcGFyYXRvclxyXG4gICAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHRoaXMudmFyc3BlY3MubGVuZ3RoOyBpbmRleCArPSAxKSB7XHJcbiAgICAgICAgICAgIHZhcnNwZWMgPSB0aGlzLnZhcnNwZWNzW2luZGV4XTtcclxuICAgICAgICAgICAgdmFsdWUgPSB2YXJpYWJsZXNbdmFyc3BlYy52YXJuYW1lXTtcclxuICAgICAgICAgICAgLy8gaWYgKCFpc0RlZmluZWQodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIC8vIGlmICh2YXJpYWJsZXMuaGFzT3duUHJvcGVydHkodmFyc3BlYy5uYW1lKSkge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHZhcnNwZWMuZXhwbG9kZWQpIHtcclxuICAgICAgICAgICAgICAgIG9uZUV4cGxvZGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YWx1ZUlzQXJyID0gb2JqZWN0SGVscGVyLmlzQXJyYXkodmFsdWUpO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XHJcbiAgICAgICAgICAgICAgICBleHBhbmRlZC5wdXNoKGV4cGFuZFNpbXBsZVZhbHVlKHZhcnNwZWMsIG9wZXJhdG9yLCB2YWx1ZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhcnNwZWMubWF4TGVuZ3RoICYmIGlzRGVmaW5lZCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIDIuNC4xIG9mIHRoZSBzcGVjIHNheXM6IFwiUHJlZml4IG1vZGlmaWVycyBhcmUgbm90IGFwcGxpY2FibGUgdG8gdmFyaWFibGVzIHRoYXQgaGF2ZSBjb21wb3NpdGUgdmFsdWVzLlwiXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ByZWZpeCBtb2RpZmllcnMgYXJlIG5vdCBhcHBsaWNhYmxlIHRvIHZhcmlhYmxlcyB0aGF0IGhhdmUgY29tcG9zaXRlIHZhbHVlcy4gWW91IHRyaWVkIHRvIGV4cGFuZCAnICsgdGhpcyArIFwiIHdpdGggXCIgKyBwcmV0dHlQcmludCh2YWx1ZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCF2YXJzcGVjLmV4cGxvZGVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3BlcmF0b3IubmFtZWQgfHwgIWlzRW1wdHkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwYW5kZWQucHVzaChleHBhbmROb3RFeHBsb2RlZCh2YXJzcGVjLCBvcGVyYXRvciwgdmFsdWUpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc0RlZmluZWQodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3BlcmF0b3IubmFtZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBleHBhbmRlZC5wdXNoKGV4cGFuZEV4cGxvZGVkTmFtZWQodmFyc3BlYywgb3BlcmF0b3IsIHZhbHVlKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBleHBhbmRlZC5wdXNoKGV4cGFuZEV4cGxvZGVkVW5uYW1lZChvcGVyYXRvciwgdmFsdWUpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGV4cGFuZGVkLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvcGVyYXRvci5maXJzdCArIG9iamVjdEhlbHBlci5qb2luKGV4cGFuZGVkLCBvcGVyYXRvci5zZXBhcmF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIFZhcmlhYmxlRXhwcmVzc2lvbjtcclxufSgpKTtcclxuXHJcbnZhciBVcmlUZW1wbGF0ZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBVcmlUZW1wbGF0ZSAodGVtcGxhdGVUZXh0LCBleHByZXNzaW9ucykge1xyXG4gICAgICAgIHRoaXMudGVtcGxhdGVUZXh0ID0gdGVtcGxhdGVUZXh0O1xyXG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbnMgPSBleHByZXNzaW9ucztcclxuICAgICAgICBvYmplY3RIZWxwZXIuZGVlcEZyZWV6ZSh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBVcmlUZW1wbGF0ZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGVtcGxhdGVUZXh0O1xyXG4gICAgfTtcclxuXHJcbiAgICBVcmlUZW1wbGF0ZS5wcm90b3R5cGUuZXhwYW5kID0gZnVuY3Rpb24gKHZhcmlhYmxlcykge1xyXG4gICAgICAgIC8vIHRoaXMuZXhwcmVzc2lvbnMubWFwKGZ1bmN0aW9uIChleHByZXNzaW9uKSB7cmV0dXJuIGV4cHJlc3Npb24uZXhwYW5kKHZhcmlhYmxlcyk7fSkuam9pbignJyk7XHJcbiAgICAgICAgdmFyXHJcbiAgICAgICAgICAgIGluZGV4LFxyXG4gICAgICAgICAgICByZXN1bHQgPSAnJztcclxuICAgICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLmV4cHJlc3Npb25zLmxlbmd0aDsgaW5kZXggKz0gMSkge1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5leHByZXNzaW9uc1tpbmRleF0uZXhwYW5kKHZhcmlhYmxlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIFVyaVRlbXBsYXRlLnBhcnNlID0gcGFyc2U7XHJcbiAgICBVcmlUZW1wbGF0ZS5VcmlUZW1wbGF0ZUVycm9yID0gVXJpVGVtcGxhdGVFcnJvcjtcclxuICAgIHJldHVybiBVcmlUZW1wbGF0ZTtcclxufSgpKTtcclxuXHJcbiAgICBleHBvcnRDYWxsYmFjayhVcmlUZW1wbGF0ZSk7XHJcblxyXG59KGZ1bmN0aW9uIChVcmlUZW1wbGF0ZSkge1xyXG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgICAgIC8vIGV4cG9ydCBVcmlUZW1wbGF0ZSwgd2hlbiBtb2R1bGUgaXMgcHJlc2VudCwgb3IgcGFzcyBpdCB0byB3aW5kb3cgb3IgZ2xvYmFsXHJcbiAgICAgICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBVcmlUZW1wbGF0ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgIGRlZmluZShbXSxmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBVcmlUZW1wbGF0ZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICAgICAgd2luZG93LlVyaVRlbXBsYXRlID0gVXJpVGVtcGxhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBnbG9iYWwuVXJpVGVtcGxhdGUgPSBVcmlUZW1wbGF0ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbikpO1xyXG4iLCJcbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBkZXByZWNhdGU7XG5cbi8qKlxuICogTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbiAqIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS5ub0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50aHJvd0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIHRocm93IGFuIEVycm9yIHdoZW4gaW52b2tlZC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRyYWNlRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgaW52b2tlIGBjb25zb2xlLnRyYWNlKClgIGluc3RlYWQgb2YgYGNvbnNvbGUuZXJyb3IoKWAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSB0aGUgZnVuY3Rpb24gdG8gZGVwcmVjYXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gbXNnIC0gdGhlIHN0cmluZyB0byBwcmludCB0byB0aGUgY29uc29sZSB3aGVuIGBmbmAgaXMgaW52b2tlZFxuICogQHJldHVybnMge0Z1bmN0aW9ufSBhIG5ldyBcImRlcHJlY2F0ZWRcIiB2ZXJzaW9uIG9mIGBmbmBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVwcmVjYXRlIChmbiwgbXNnKSB7XG4gIGlmIChjb25maWcoJ25vRGVwcmVjYXRpb24nKSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKGNvbmZpZygndGhyb3dEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChjb25maWcoJ3RyYWNlRGVwcmVjYXRpb24nKSkge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4obXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGBsb2NhbFN0b3JhZ2VgIGZvciBib29sZWFuIHZhbHVlcyBmb3IgdGhlIGdpdmVuIGBuYW1lYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb25maWcgKG5hbWUpIHtcbiAgLy8gYWNjZXNzaW5nIGdsb2JhbC5sb2NhbFN0b3JhZ2UgY2FuIHRyaWdnZXIgYSBET01FeGNlcHRpb24gaW4gc2FuZGJveGVkIGlmcmFtZXNcbiAgdHJ5IHtcbiAgICBpZiAoIWdsb2JhbC5sb2NhbFN0b3JhZ2UpIHJldHVybiBmYWxzZTtcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdmFsID0gZ2xvYmFsLmxvY2FsU3RvcmFnZVtuYW1lXTtcbiAgaWYgKG51bGwgPT0gdmFsKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBTdHJpbmcodmFsKS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG59XG4iLCIvKipcbiAqIFdyYXBwZXIgZm9yIGJ1aWx0LWluIGh0dHAuanMgdG8gZW11bGF0ZSB0aGUgYnJvd3NlciBYTUxIdHRwUmVxdWVzdCBvYmplY3QuXG4gKlxuICogVGhpcyBjYW4gYmUgdXNlZCB3aXRoIEpTIGRlc2lnbmVkIGZvciBicm93c2VycyB0byBpbXByb3ZlIHJldXNlIG9mIGNvZGUgYW5kXG4gKiBhbGxvdyB0aGUgdXNlIG9mIGV4aXN0aW5nIGxpYnJhcmllcy5cbiAqXG4gKiBVc2FnZTogaW5jbHVkZShcIlhNTEh0dHBSZXF1ZXN0LmpzXCIpIGFuZCB1c2UgWE1MSHR0cFJlcXVlc3QgcGVyIFczQyBzcGVjcy5cbiAqXG4gKiBAYXV0aG9yIERhbiBEZUZlbGlwcGkgPGRhbkBkcml2ZXJkYW4uY29tPlxuICogQGNvbnRyaWJ1dG9yIERhdmlkIEVsbGlzIDxkLmYuZWxsaXNAaWVlZS5vcmc+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG52YXIgVXJsID0gcmVxdWlyZShcInVybFwiKVxuICAsIHNwYXduID0gcmVxdWlyZShcImNoaWxkX3Byb2Nlc3NcIikuc3Bhd25cbiAgLCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5cbmV4cG9ydHMuWE1MSHR0cFJlcXVlc3QgPSBmdW5jdGlvbigpIHtcbiAgLyoqXG4gICAqIFByaXZhdGUgdmFyaWFibGVzXG4gICAqL1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xuICB2YXIgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpO1xuXG4gIC8vIEhvbGRzIGh0dHAuanMgb2JqZWN0c1xuICB2YXIgcmVxdWVzdDtcbiAgdmFyIHJlc3BvbnNlO1xuXG4gIC8vIFJlcXVlc3Qgc2V0dGluZ3NcbiAgdmFyIHNldHRpbmdzID0ge307XG5cbiAgLy8gRGlzYWJsZSBoZWFkZXIgYmxhY2tsaXN0LlxuICAvLyBOb3QgcGFydCBvZiBYSFIgc3BlY3MuXG4gIHZhciBkaXNhYmxlSGVhZGVyQ2hlY2sgPSBmYWxzZTtcblxuICAvLyBTZXQgc29tZSBkZWZhdWx0IGhlYWRlcnNcbiAgdmFyIGRlZmF1bHRIZWFkZXJzID0ge1xuICAgIFwiVXNlci1BZ2VudFwiOiBcIm5vZGUtWE1MSHR0cFJlcXVlc3RcIixcbiAgICBcIkFjY2VwdFwiOiBcIiovKlwiLFxuICB9O1xuXG4gIHZhciBoZWFkZXJzID0gZGVmYXVsdEhlYWRlcnM7XG5cbiAgLy8gVGhlc2UgaGVhZGVycyBhcmUgbm90IHVzZXIgc2V0YWJsZS5cbiAgLy8gVGhlIGZvbGxvd2luZyBhcmUgYWxsb3dlZCBidXQgYmFubmVkIGluIHRoZSBzcGVjOlxuICAvLyAqIHVzZXItYWdlbnRcbiAgdmFyIGZvcmJpZGRlblJlcXVlc3RIZWFkZXJzID0gW1xuICAgIFwiYWNjZXB0LWNoYXJzZXRcIixcbiAgICBcImFjY2VwdC1lbmNvZGluZ1wiLFxuICAgIFwiYWNjZXNzLWNvbnRyb2wtcmVxdWVzdC1oZWFkZXJzXCIsXG4gICAgXCJhY2Nlc3MtY29udHJvbC1yZXF1ZXN0LW1ldGhvZFwiLFxuICAgIFwiY29ubmVjdGlvblwiLFxuICAgIFwiY29udGVudC1sZW5ndGhcIixcbiAgICBcImNvbnRlbnQtdHJhbnNmZXItZW5jb2RpbmdcIixcbiAgICBcImNvb2tpZVwiLFxuICAgIFwiY29va2llMlwiLFxuICAgIFwiZGF0ZVwiLFxuICAgIFwiZXhwZWN0XCIsXG4gICAgXCJob3N0XCIsXG4gICAgXCJrZWVwLWFsaXZlXCIsXG4gICAgXCJvcmlnaW5cIixcbiAgICBcInJlZmVyZXJcIixcbiAgICBcInRlXCIsXG4gICAgXCJ0cmFpbGVyXCIsXG4gICAgXCJ0cmFuc2Zlci1lbmNvZGluZ1wiLFxuICAgIFwidXBncmFkZVwiLFxuICAgIFwidmlhXCJcbiAgXTtcblxuICAvLyBUaGVzZSByZXF1ZXN0IG1ldGhvZHMgYXJlIG5vdCBhbGxvd2VkXG4gIHZhciBmb3JiaWRkZW5SZXF1ZXN0TWV0aG9kcyA9IFtcbiAgICBcIlRSQUNFXCIsXG4gICAgXCJUUkFDS1wiLFxuICAgIFwiQ09OTkVDVFwiXG4gIF07XG5cbiAgLy8gU2VuZCBmbGFnXG4gIHZhciBzZW5kRmxhZyA9IGZhbHNlO1xuICAvLyBFcnJvciBmbGFnLCB1c2VkIHdoZW4gZXJyb3JzIG9jY3VyIG9yIGFib3J0IGlzIGNhbGxlZFxuICB2YXIgZXJyb3JGbGFnID0gZmFsc2U7XG5cbiAgLy8gRXZlbnQgbGlzdGVuZXJzXG4gIHZhciBsaXN0ZW5lcnMgPSB7fTtcblxuICAvKipcbiAgICogQ29uc3RhbnRzXG4gICAqL1xuXG4gIHRoaXMuVU5TRU5UID0gMDtcbiAgdGhpcy5PUEVORUQgPSAxO1xuICB0aGlzLkhFQURFUlNfUkVDRUlWRUQgPSAyO1xuICB0aGlzLkxPQURJTkcgPSAzO1xuICB0aGlzLkRPTkUgPSA0O1xuXG4gIC8qKlxuICAgKiBQdWJsaWMgdmFyc1xuICAgKi9cblxuICAvLyBDdXJyZW50IHN0YXRlXG4gIHRoaXMucmVhZHlTdGF0ZSA9IHRoaXMuVU5TRU5UO1xuXG4gIC8vIGRlZmF1bHQgcmVhZHkgc3RhdGUgY2hhbmdlIGhhbmRsZXIgaW4gY2FzZSBvbmUgaXMgbm90IHNldCBvciBpcyBzZXQgbGF0ZVxuICB0aGlzLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG5cbiAgLy8gUmVzdWx0ICYgcmVzcG9uc2VcbiAgdGhpcy5yZXNwb25zZVRleHQgPSBcIlwiO1xuICB0aGlzLnJlc3BvbnNlWE1MID0gXCJcIjtcbiAgdGhpcy5zdGF0dXMgPSBudWxsO1xuICB0aGlzLnN0YXR1c1RleHQgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBQcml2YXRlIG1ldGhvZHNcbiAgICovXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBzcGVjaWZpZWQgaGVhZGVyIGlzIGFsbG93ZWQuXG4gICAqXG4gICAqIEBwYXJhbSBzdHJpbmcgaGVhZGVyIEhlYWRlciB0byB2YWxpZGF0ZVxuICAgKiBAcmV0dXJuIGJvb2xlYW4gRmFsc2UgaWYgbm90IGFsbG93ZWQsIG90aGVyd2lzZSB0cnVlXG4gICAqL1xuICB2YXIgaXNBbGxvd2VkSHR0cEhlYWRlciA9IGZ1bmN0aW9uKGhlYWRlcikge1xuICAgIHJldHVybiBkaXNhYmxlSGVhZGVyQ2hlY2sgfHwgKGhlYWRlciAmJiBmb3JiaWRkZW5SZXF1ZXN0SGVhZGVycy5pbmRleE9mKGhlYWRlci50b0xvd2VyQ2FzZSgpKSA9PT0gLTEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgc3BlY2lmaWVkIG1ldGhvZCBpcyBhbGxvd2VkLlxuICAgKlxuICAgKiBAcGFyYW0gc3RyaW5nIG1ldGhvZCBSZXF1ZXN0IG1ldGhvZCB0byB2YWxpZGF0ZVxuICAgKiBAcmV0dXJuIGJvb2xlYW4gRmFsc2UgaWYgbm90IGFsbG93ZWQsIG90aGVyd2lzZSB0cnVlXG4gICAqL1xuICB2YXIgaXNBbGxvd2VkSHR0cE1ldGhvZCA9IGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgIHJldHVybiAobWV0aG9kICYmIGZvcmJpZGRlblJlcXVlc3RNZXRob2RzLmluZGV4T2YobWV0aG9kKSA9PT0gLTEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQdWJsaWMgbWV0aG9kc1xuICAgKi9cblxuICAvKipcbiAgICogT3BlbiB0aGUgY29ubmVjdGlvbi4gQ3VycmVudGx5IHN1cHBvcnRzIGxvY2FsIHNlcnZlciByZXF1ZXN0cy5cbiAgICpcbiAgICogQHBhcmFtIHN0cmluZyBtZXRob2QgQ29ubmVjdGlvbiBtZXRob2QgKGVnIEdFVCwgUE9TVClcbiAgICogQHBhcmFtIHN0cmluZyB1cmwgVVJMIGZvciB0aGUgY29ubmVjdGlvbi5cbiAgICogQHBhcmFtIGJvb2xlYW4gYXN5bmMgQXN5bmNocm9ub3VzIGNvbm5lY3Rpb24uIERlZmF1bHQgaXMgdHJ1ZS5cbiAgICogQHBhcmFtIHN0cmluZyB1c2VyIFVzZXJuYW1lIGZvciBiYXNpYyBhdXRoZW50aWNhdGlvbiAob3B0aW9uYWwpXG4gICAqIEBwYXJhbSBzdHJpbmcgcGFzc3dvcmQgUGFzc3dvcmQgZm9yIGJhc2ljIGF1dGhlbnRpY2F0aW9uIChvcHRpb25hbClcbiAgICovXG4gIHRoaXMub3BlbiA9IGZ1bmN0aW9uKG1ldGhvZCwgdXJsLCBhc3luYywgdXNlciwgcGFzc3dvcmQpIHtcbiAgICB0aGlzLmFib3J0KCk7XG4gICAgZXJyb3JGbGFnID0gZmFsc2U7XG5cbiAgICAvLyBDaGVjayBmb3IgdmFsaWQgcmVxdWVzdCBtZXRob2RcbiAgICBpZiAoIWlzQWxsb3dlZEh0dHBNZXRob2QobWV0aG9kKSkge1xuICAgICAgdGhyb3cgXCJTZWN1cml0eUVycm9yOiBSZXF1ZXN0IG1ldGhvZCBub3QgYWxsb3dlZFwiO1xuICAgIH1cblxuICAgIHNldHRpbmdzID0ge1xuICAgICAgXCJtZXRob2RcIjogbWV0aG9kLFxuICAgICAgXCJ1cmxcIjogdXJsLnRvU3RyaW5nKCksXG4gICAgICBcImFzeW5jXCI6ICh0eXBlb2YgYXN5bmMgIT09IFwiYm9vbGVhblwiID8gdHJ1ZSA6IGFzeW5jKSxcbiAgICAgIFwidXNlclwiOiB1c2VyIHx8IG51bGwsXG4gICAgICBcInBhc3N3b3JkXCI6IHBhc3N3b3JkIHx8IG51bGxcbiAgICB9O1xuXG4gICAgc2V0U3RhdGUodGhpcy5PUEVORUQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEaXNhYmxlcyBvciBlbmFibGVzIGlzQWxsb3dlZEh0dHBIZWFkZXIoKSBjaGVjayB0aGUgcmVxdWVzdC4gRW5hYmxlZCBieSBkZWZhdWx0LlxuICAgKiBUaGlzIGRvZXMgbm90IGNvbmZvcm0gdG8gdGhlIFczQyBzcGVjLlxuICAgKlxuICAgKiBAcGFyYW0gYm9vbGVhbiBzdGF0ZSBFbmFibGUgb3IgZGlzYWJsZSBoZWFkZXIgY2hlY2tpbmcuXG4gICAqL1xuICB0aGlzLnNldERpc2FibGVIZWFkZXJDaGVjayA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgZGlzYWJsZUhlYWRlckNoZWNrID0gc3RhdGU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldHMgYSBoZWFkZXIgZm9yIHRoZSByZXF1ZXN0LlxuICAgKlxuICAgKiBAcGFyYW0gc3RyaW5nIGhlYWRlciBIZWFkZXIgbmFtZVxuICAgKiBAcGFyYW0gc3RyaW5nIHZhbHVlIEhlYWRlciB2YWx1ZVxuICAgKi9cbiAgdGhpcy5zZXRSZXF1ZXN0SGVhZGVyID0gZnVuY3Rpb24oaGVhZGVyLCB2YWx1ZSkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT0gdGhpcy5PUEVORUQpIHtcbiAgICAgIHRocm93IFwiSU5WQUxJRF9TVEFURV9FUlI6IHNldFJlcXVlc3RIZWFkZXIgY2FuIG9ubHkgYmUgY2FsbGVkIHdoZW4gc3RhdGUgaXMgT1BFTlwiO1xuICAgIH1cbiAgICBpZiAoIWlzQWxsb3dlZEh0dHBIZWFkZXIoaGVhZGVyKSkge1xuICAgICAgY29uc29sZS53YXJuKCdSZWZ1c2VkIHRvIHNldCB1bnNhZmUgaGVhZGVyIFwiJyArIGhlYWRlciArICdcIicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc2VuZEZsYWcpIHtcbiAgICAgIHRocm93IFwiSU5WQUxJRF9TVEFURV9FUlI6IHNlbmQgZmxhZyBpcyB0cnVlXCI7XG4gICAgfVxuICAgIGhlYWRlcnNbaGVhZGVyXSA9IHZhbHVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIGEgaGVhZGVyIGZyb20gdGhlIHNlcnZlciByZXNwb25zZS5cbiAgICpcbiAgICogQHBhcmFtIHN0cmluZyBoZWFkZXIgTmFtZSBvZiBoZWFkZXIgdG8gZ2V0LlxuICAgKiBAcmV0dXJuIHN0cmluZyBUZXh0IG9mIHRoZSBoZWFkZXIgb3IgbnVsbCBpZiBpdCBkb2Vzbid0IGV4aXN0LlxuICAgKi9cbiAgdGhpcy5nZXRSZXNwb25zZUhlYWRlciA9IGZ1bmN0aW9uKGhlYWRlcikge1xuICAgIGlmICh0eXBlb2YgaGVhZGVyID09PSBcInN0cmluZ1wiXG4gICAgICAmJiB0aGlzLnJlYWR5U3RhdGUgPiB0aGlzLk9QRU5FRFxuICAgICAgJiYgcmVzcG9uc2UuaGVhZGVyc1toZWFkZXIudG9Mb3dlckNhc2UoKV1cbiAgICAgICYmICFlcnJvckZsYWdcbiAgICApIHtcbiAgICAgIHJldHVybiByZXNwb25zZS5oZWFkZXJzW2hlYWRlci50b0xvd2VyQ2FzZSgpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0cyBhbGwgdGhlIHJlc3BvbnNlIGhlYWRlcnMuXG4gICAqXG4gICAqIEByZXR1cm4gc3RyaW5nIEEgc3RyaW5nIHdpdGggYWxsIHJlc3BvbnNlIGhlYWRlcnMgc2VwYXJhdGVkIGJ5IENSK0xGXG4gICAqL1xuICB0aGlzLmdldEFsbFJlc3BvbnNlSGVhZGVycyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPCB0aGlzLkhFQURFUlNfUkVDRUlWRUQgfHwgZXJyb3JGbGFnKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IFwiXCI7XG5cbiAgICBmb3IgKHZhciBpIGluIHJlc3BvbnNlLmhlYWRlcnMpIHtcbiAgICAgIC8vIENvb2tpZSBoZWFkZXJzIGFyZSBleGNsdWRlZFxuICAgICAgaWYgKGkgIT09IFwic2V0LWNvb2tpZVwiICYmIGkgIT09IFwic2V0LWNvb2tpZTJcIikge1xuICAgICAgICByZXN1bHQgKz0gaSArIFwiOiBcIiArIHJlc3BvbnNlLmhlYWRlcnNbaV0gKyBcIlxcclxcblwiO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LnN1YnN0cigwLCByZXN1bHQubGVuZ3RoIC0gMik7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgYSByZXF1ZXN0IGhlYWRlclxuICAgKlxuICAgKiBAcGFyYW0gc3RyaW5nIG5hbWUgTmFtZSBvZiBoZWFkZXIgdG8gZ2V0XG4gICAqIEByZXR1cm4gc3RyaW5nIFJldHVybnMgdGhlIHJlcXVlc3QgaGVhZGVyIG9yIGVtcHR5IHN0cmluZyBpZiBub3Qgc2V0XG4gICAqL1xuICB0aGlzLmdldFJlcXVlc3RIZWFkZXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgLy8gQFRPRE8gTWFrZSB0aGlzIGNhc2UgaW5zZW5zaXRpdmVcbiAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIgJiYgaGVhZGVyc1tuYW1lXSkge1xuICAgICAgcmV0dXJuIGhlYWRlcnNbbmFtZV07XG4gICAgfVxuXG4gICAgcmV0dXJuIFwiXCI7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNlbmRzIHRoZSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIuXG4gICAqXG4gICAqIEBwYXJhbSBzdHJpbmcgZGF0YSBPcHRpb25hbCBkYXRhIHRvIHNlbmQgYXMgcmVxdWVzdCBib2R5LlxuICAgKi9cbiAgdGhpcy5zZW5kID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT0gdGhpcy5PUEVORUQpIHtcbiAgICAgIHRocm93IFwiSU5WQUxJRF9TVEFURV9FUlI6IGNvbm5lY3Rpb24gbXVzdCBiZSBvcGVuZWQgYmVmb3JlIHNlbmQoKSBpcyBjYWxsZWRcIjtcbiAgICB9XG5cbiAgICBpZiAoc2VuZEZsYWcpIHtcbiAgICAgIHRocm93IFwiSU5WQUxJRF9TVEFURV9FUlI6IHNlbmQgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWRcIjtcbiAgICB9XG5cbiAgICB2YXIgc3NsID0gZmFsc2UsIGxvY2FsID0gZmFsc2U7XG4gICAgdmFyIHVybCA9IFVybC5wYXJzZShzZXR0aW5ncy51cmwpO1xuICAgIHZhciBob3N0O1xuICAgIC8vIERldGVybWluZSB0aGUgc2VydmVyXG4gICAgc3dpdGNoICh1cmwucHJvdG9jb2wpIHtcbiAgICAgIGNhc2UgJ2h0dHBzOic6XG4gICAgICAgIHNzbCA9IHRydWU7XG4gICAgICAgIC8vIFNTTCAmIG5vbi1TU0wgYm90aCBuZWVkIGhvc3QsIG5vIGJyZWFrIGhlcmUuXG4gICAgICBjYXNlICdodHRwOic6XG4gICAgICAgIGhvc3QgPSB1cmwuaG9zdG5hbWU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdmaWxlOic6XG4gICAgICAgIGxvY2FsID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgY2FzZSAnJzpcbiAgICAgICAgaG9zdCA9IFwibG9jYWxob3N0XCI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBcIlByb3RvY29sIG5vdCBzdXBwb3J0ZWQuXCI7XG4gICAgfVxuXG4gICAgLy8gTG9hZCBmaWxlcyBvZmYgdGhlIGxvY2FsIGZpbGVzeXN0ZW0gKGZpbGU6Ly8pXG4gICAgaWYgKGxvY2FsKSB7XG4gICAgICBpZiAoc2V0dGluZ3MubWV0aG9kICE9PSBcIkdFVFwiKSB7XG4gICAgICAgIHRocm93IFwiWE1MSHR0cFJlcXVlc3Q6IE9ubHkgR0VUIG1ldGhvZCBpcyBzdXBwb3J0ZWRcIjtcbiAgICAgIH1cblxuICAgICAgaWYgKHNldHRpbmdzLmFzeW5jKSB7XG4gICAgICAgIGZzLnJlYWRGaWxlKHVybC5wYXRobmFtZSwgJ3V0ZjgnLCBmdW5jdGlvbihlcnJvciwgZGF0YSkge1xuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgc2VsZi5oYW5kbGVFcnJvcihlcnJvcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuc3RhdHVzID0gMjAwO1xuICAgICAgICAgICAgc2VsZi5yZXNwb25zZVRleHQgPSBkYXRhO1xuICAgICAgICAgICAgc2V0U3RhdGUoc2VsZi5ET05FKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLnJlc3BvbnNlVGV4dCA9IGZzLnJlYWRGaWxlU3luYyh1cmwucGF0aG5hbWUsICd1dGY4Jyk7XG4gICAgICAgICAgdGhpcy5zdGF0dXMgPSAyMDA7XG4gICAgICAgICAgc2V0U3RhdGUoc2VsZi5ET05FKTtcbiAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdCB0byBwb3J0IDgwLiBJZiBhY2Nlc3NpbmcgbG9jYWxob3N0IG9uIGFub3RoZXIgcG9ydCBiZSBzdXJlXG4gICAgLy8gdG8gdXNlIGh0dHA6Ly9sb2NhbGhvc3Q6cG9ydC9wYXRoXG4gICAgdmFyIHBvcnQgPSB1cmwucG9ydCB8fCAoc3NsID8gNDQzIDogODApO1xuICAgIC8vIEFkZCBxdWVyeSBzdHJpbmcgaWYgb25lIGlzIHVzZWRcbiAgICB2YXIgdXJpID0gdXJsLnBhdGhuYW1lICsgKHVybC5zZWFyY2ggPyB1cmwuc2VhcmNoIDogJycpO1xuXG4gICAgLy8gU2V0IHRoZSBIb3N0IGhlYWRlciBvciB0aGUgc2VydmVyIG1heSByZWplY3QgdGhlIHJlcXVlc3RcbiAgICBoZWFkZXJzW1wiSG9zdFwiXSA9IGhvc3Q7XG4gICAgaWYgKCEoKHNzbCAmJiBwb3J0ID09PSA0NDMpIHx8IHBvcnQgPT09IDgwKSkge1xuICAgICAgaGVhZGVyc1tcIkhvc3RcIl0gKz0gJzonICsgdXJsLnBvcnQ7XG4gICAgfVxuXG4gICAgLy8gU2V0IEJhc2ljIEF1dGggaWYgbmVjZXNzYXJ5XG4gICAgaWYgKHNldHRpbmdzLnVzZXIpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MucGFzc3dvcmQgPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBzZXR0aW5ncy5wYXNzd29yZCA9IFwiXCI7XG4gICAgICB9XG4gICAgICB2YXIgYXV0aEJ1ZiA9IG5ldyBCdWZmZXIoc2V0dGluZ3MudXNlciArIFwiOlwiICsgc2V0dGluZ3MucGFzc3dvcmQpO1xuICAgICAgaGVhZGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSBcIkJhc2ljIFwiICsgYXV0aEJ1Zi50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgICB9XG5cbiAgICAvLyBTZXQgY29udGVudCBsZW5ndGggaGVhZGVyXG4gICAgaWYgKHNldHRpbmdzLm1ldGhvZCA9PT0gXCJHRVRcIiB8fCBzZXR0aW5ncy5tZXRob2QgPT09IFwiSEVBRFwiKSB7XG4gICAgICBkYXRhID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGRhdGEpIHtcbiAgICAgIGhlYWRlcnNbXCJDb250ZW50LUxlbmd0aFwiXSA9IEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSA/IGRhdGEubGVuZ3RoIDogQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSk7XG5cbiAgICAgIGlmICghaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSkge1xuICAgICAgICBoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID0gXCJ0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLThcIjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNldHRpbmdzLm1ldGhvZCA9PT0gXCJQT1NUXCIpIHtcbiAgICAgIC8vIEZvciBhIHBvc3Qgd2l0aCBubyBkYXRhIHNldCBDb250ZW50LUxlbmd0aDogMC5cbiAgICAgIC8vIFRoaXMgaXMgcmVxdWlyZWQgYnkgYnVnZ3kgc2VydmVycyB0aGF0IGRvbid0IG1lZXQgdGhlIHNwZWNzLlxuICAgICAgaGVhZGVyc1tcIkNvbnRlbnQtTGVuZ3RoXCJdID0gMDtcbiAgICB9XG5cbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgIGhvc3Q6IGhvc3QsXG4gICAgICBwb3J0OiBwb3J0LFxuICAgICAgcGF0aDogdXJpLFxuICAgICAgbWV0aG9kOiBzZXR0aW5ncy5tZXRob2QsXG4gICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgYWdlbnQ6IGZhbHNlXG4gICAgfTtcblxuICAgIC8vIFJlc2V0IGVycm9yIGZsYWdcbiAgICBlcnJvckZsYWcgPSBmYWxzZTtcblxuICAgIC8vIEhhbmRsZSBhc3luYyByZXF1ZXN0c1xuICAgIGlmIChzZXR0aW5ncy5hc3luYykge1xuICAgICAgLy8gVXNlIHRoZSBwcm9wZXIgcHJvdG9jb2xcbiAgICAgIHZhciBkb1JlcXVlc3QgPSBzc2wgPyBodHRwcy5yZXF1ZXN0IDogaHR0cC5yZXF1ZXN0O1xuXG4gICAgICAvLyBSZXF1ZXN0IGlzIGJlaW5nIHNlbnQsIHNldCBzZW5kIGZsYWdcbiAgICAgIHNlbmRGbGFnID0gdHJ1ZTtcblxuICAgICAgLy8gQXMgcGVyIHNwZWMsIHRoaXMgaXMgY2FsbGVkIGhlcmUgZm9yIGhpc3RvcmljYWwgcmVhc29ucy5cbiAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudChcInJlYWR5c3RhdGVjaGFuZ2VcIik7XG5cbiAgICAgIC8vIEhhbmRsZXIgZm9yIHRoZSByZXNwb25zZVxuICAgICAgZnVuY3Rpb24gcmVzcG9uc2VIYW5kbGVyKHJlc3ApIHtcbiAgICAgICAgLy8gU2V0IHJlc3BvbnNlIHZhciB0byB0aGUgcmVzcG9uc2Ugd2UgZ290IGJhY2tcbiAgICAgICAgLy8gVGhpcyBpcyBzbyBpdCByZW1haW5zIGFjY2Vzc2FibGUgb3V0c2lkZSB0aGlzIHNjb3BlXG4gICAgICAgIHJlc3BvbnNlID0gcmVzcDtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIHJlZGlyZWN0XG4gICAgICAgIC8vIEBUT0RPIFByZXZlbnQgbG9vcGVkIHJlZGlyZWN0c1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMzAyIHx8IHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDMwMyB8fCByZXNwb25zZS5zdGF0dXNDb2RlID09PSAzMDcpIHtcbiAgICAgICAgICAvLyBDaGFuZ2UgVVJMIHRvIHRoZSByZWRpcmVjdCBsb2NhdGlvblxuICAgICAgICAgIHNldHRpbmdzLnVybCA9IHJlc3BvbnNlLmhlYWRlcnMubG9jYXRpb247XG4gICAgICAgICAgdmFyIHVybCA9IFVybC5wYXJzZShzZXR0aW5ncy51cmwpO1xuICAgICAgICAgIC8vIFNldCBob3N0IHZhciBpbiBjYXNlIGl0J3MgdXNlZCBsYXRlclxuICAgICAgICAgIGhvc3QgPSB1cmwuaG9zdG5hbWU7XG4gICAgICAgICAgLy8gT3B0aW9ucyBmb3IgdGhlIG5ldyByZXF1ZXN0XG4gICAgICAgICAgdmFyIG5ld09wdGlvbnMgPSB7XG4gICAgICAgICAgICBob3N0bmFtZTogdXJsLmhvc3RuYW1lLFxuICAgICAgICAgICAgcG9ydDogdXJsLnBvcnQsXG4gICAgICAgICAgICBwYXRoOiB1cmwucGF0aCxcbiAgICAgICAgICAgIG1ldGhvZDogcmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMzAzID8gJ0dFVCcgOiBzZXR0aW5ncy5tZXRob2QsXG4gICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIElzc3VlIHRoZSBuZXcgcmVxdWVzdFxuICAgICAgICAgIHJlcXVlc3QgPSBkb1JlcXVlc3QobmV3T3B0aW9ucywgcmVzcG9uc2VIYW5kbGVyKS5vbignZXJyb3InLCBlcnJvckhhbmRsZXIpO1xuICAgICAgICAgIHJlcXVlc3QuZW5kKCk7XG4gICAgICAgICAgLy8gQFRPRE8gQ2hlY2sgaWYgYW4gWEhSIGV2ZW50IG5lZWRzIHRvIGJlIGZpcmVkIGhlcmVcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXNwb25zZS5zZXRFbmNvZGluZyhcInV0ZjhcIik7XG5cbiAgICAgICAgc2V0U3RhdGUoc2VsZi5IRUFERVJTX1JFQ0VJVkVEKTtcbiAgICAgICAgc2VsZi5zdGF0dXMgPSByZXNwb25zZS5zdGF0dXNDb2RlO1xuXG4gICAgICAgIHJlc3BvbnNlLm9uKCdkYXRhJywgZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlcmUncyBzb21lIGRhdGFcbiAgICAgICAgICBpZiAoY2h1bmspIHtcbiAgICAgICAgICAgIHNlbGYucmVzcG9uc2VUZXh0ICs9IGNodW5rO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBEb24ndCBlbWl0IHN0YXRlIGNoYW5nZXMgaWYgdGhlIGNvbm5lY3Rpb24gaGFzIGJlZW4gYWJvcnRlZC5cbiAgICAgICAgICBpZiAoc2VuZEZsYWcpIHtcbiAgICAgICAgICAgIHNldFN0YXRlKHNlbGYuTE9BRElORyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXNwb25zZS5vbignZW5kJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKHNlbmRGbGFnKSB7XG4gICAgICAgICAgICAvLyBEaXNjYXJkIHRoZSAnZW5kJyBldmVudCBpZiB0aGUgY29ubmVjdGlvbiBoYXMgYmVlbiBhYm9ydGVkXG4gICAgICAgICAgICBzZXRTdGF0ZShzZWxmLkRPTkUpO1xuICAgICAgICAgICAgc2VuZEZsYWcgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlc3BvbnNlLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgc2VsZi5oYW5kbGVFcnJvcihlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBFcnJvciBoYW5kbGVyIGZvciB0aGUgcmVxdWVzdFxuICAgICAgZnVuY3Rpb24gZXJyb3JIYW5kbGVyKGVycm9yKSB7XG4gICAgICAgIHNlbGYuaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgdGhlIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBkb1JlcXVlc3Qob3B0aW9ucywgcmVzcG9uc2VIYW5kbGVyKS5vbignZXJyb3InLCBlcnJvckhhbmRsZXIpO1xuXG4gICAgICAvLyBOb2RlIDAuNCBhbmQgbGF0ZXIgd29uJ3QgYWNjZXB0IGVtcHR5IGRhdGEuIE1ha2Ugc3VyZSBpdCdzIG5lZWRlZC5cbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIHJlcXVlc3Qud3JpdGUoZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3QuZW5kKCk7XG5cbiAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudChcImxvYWRzdGFydFwiKTtcbiAgICB9IGVsc2UgeyAvLyBTeW5jaHJvbm91c1xuICAgICAgLy8gQ3JlYXRlIGEgdGVtcG9yYXJ5IGZpbGUgZm9yIGNvbW11bmljYXRpb24gd2l0aCB0aGUgb3RoZXIgTm9kZSBwcm9jZXNzXG4gICAgICB2YXIgY29udGVudEZpbGUgPSBcIi5ub2RlLXhtbGh0dHByZXF1ZXN0LWNvbnRlbnQtXCIgKyBwcm9jZXNzLnBpZDtcbiAgICAgIHZhciBzeW5jRmlsZSA9IFwiLm5vZGUteG1saHR0cHJlcXVlc3Qtc3luYy1cIiArIHByb2Nlc3MucGlkO1xuICAgICAgZnMud3JpdGVGaWxlU3luYyhzeW5jRmlsZSwgXCJcIiwgXCJ1dGY4XCIpO1xuICAgICAgLy8gVGhlIGFzeW5jIHJlcXVlc3QgdGhlIG90aGVyIE5vZGUgcHJvY2VzcyBleGVjdXRlc1xuICAgICAgdmFyIGV4ZWNTdHJpbmcgPSBcInZhciBodHRwID0gcmVxdWlyZSgnaHR0cCcpLCBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJyksIGZzID0gcmVxdWlyZSgnZnMnKTtcIlxuICAgICAgICArIFwidmFyIGRvUmVxdWVzdCA9IGh0dHBcIiArIChzc2wgPyBcInNcIiA6IFwiXCIpICsgXCIucmVxdWVzdDtcIlxuICAgICAgICArIFwidmFyIG9wdGlvbnMgPSBcIiArIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpICsgXCI7XCJcbiAgICAgICAgKyBcInZhciByZXNwb25zZVRleHQgPSAnJztcIlxuICAgICAgICArIFwidmFyIHJlcSA9IGRvUmVxdWVzdChvcHRpb25zLCBmdW5jdGlvbihyZXNwb25zZSkge1wiXG4gICAgICAgICsgXCJyZXNwb25zZS5zZXRFbmNvZGluZygndXRmOCcpO1wiXG4gICAgICAgICsgXCJyZXNwb25zZS5vbignZGF0YScsIGZ1bmN0aW9uKGNodW5rKSB7XCJcbiAgICAgICAgKyBcIiAgcmVzcG9uc2VUZXh0ICs9IGNodW5rO1wiXG4gICAgICAgICsgXCJ9KTtcIlxuICAgICAgICArIFwicmVzcG9uc2Uub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1wiXG4gICAgICAgICsgXCJmcy53cml0ZUZpbGVTeW5jKCdcIiArIGNvbnRlbnRGaWxlICsgXCInLCAnTk9ERS1YTUxIVFRQUkVRVUVTVC1TVEFUVVM6JyArIHJlc3BvbnNlLnN0YXR1c0NvZGUgKyAnLCcgKyByZXNwb25zZVRleHQsICd1dGY4Jyk7XCJcbiAgICAgICAgKyBcImZzLnVubGlua1N5bmMoJ1wiICsgc3luY0ZpbGUgKyBcIicpO1wiXG4gICAgICAgICsgXCJ9KTtcIlxuICAgICAgICArIFwicmVzcG9uc2Uub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyb3IpIHtcIlxuICAgICAgICArIFwiZnMud3JpdGVGaWxlU3luYygnXCIgKyBjb250ZW50RmlsZSArIFwiJywgJ05PREUtWE1MSFRUUFJFUVVFU1QtRVJST1I6JyArIEpTT04uc3RyaW5naWZ5KGVycm9yKSwgJ3V0ZjgnKTtcIlxuICAgICAgICArIFwiZnMudW5saW5rU3luYygnXCIgKyBzeW5jRmlsZSArIFwiJyk7XCJcbiAgICAgICAgKyBcIn0pO1wiXG4gICAgICAgICsgXCJ9KS5vbignZXJyb3InLCBmdW5jdGlvbihlcnJvcikge1wiXG4gICAgICAgICsgXCJmcy53cml0ZUZpbGVTeW5jKCdcIiArIGNvbnRlbnRGaWxlICsgXCInLCAnTk9ERS1YTUxIVFRQUkVRVUVTVC1FUlJPUjonICsgSlNPTi5zdHJpbmdpZnkoZXJyb3IpLCAndXRmOCcpO1wiXG4gICAgICAgICsgXCJmcy51bmxpbmtTeW5jKCdcIiArIHN5bmNGaWxlICsgXCInKTtcIlxuICAgICAgICArIFwifSk7XCJcbiAgICAgICAgKyAoZGF0YSA/IFwicmVxLndyaXRlKCdcIiArIGRhdGEucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpICsgXCInKTtcIjpcIlwiKVxuICAgICAgICArIFwicmVxLmVuZCgpO1wiO1xuICAgICAgLy8gU3RhcnQgdGhlIG90aGVyIE5vZGUgUHJvY2VzcywgZXhlY3V0aW5nIHRoaXMgc3RyaW5nXG4gICAgICB2YXIgc3luY1Byb2MgPSBzcGF3bihwcm9jZXNzLmFyZ3ZbMF0sIFtcIi1lXCIsIGV4ZWNTdHJpbmddKTtcbiAgICAgIHZhciBzdGF0dXNUZXh0O1xuICAgICAgd2hpbGUoZnMuZXhpc3RzU3luYyhzeW5jRmlsZSkpIHtcbiAgICAgICAgLy8gV2FpdCB3aGlsZSB0aGUgc3luYyBmaWxlIGlzIGVtcHR5XG4gICAgICB9XG4gICAgICBzZWxmLnJlc3BvbnNlVGV4dCA9IGZzLnJlYWRGaWxlU3luYyhjb250ZW50RmlsZSwgJ3V0ZjgnKTtcbiAgICAgIC8vIEtpbGwgdGhlIGNoaWxkIHByb2Nlc3Mgb25jZSB0aGUgZmlsZSBoYXMgZGF0YVxuICAgICAgc3luY1Byb2Muc3RkaW4uZW5kKCk7XG4gICAgICAvLyBSZW1vdmUgdGhlIHRlbXBvcmFyeSBmaWxlXG4gICAgICBmcy51bmxpbmtTeW5jKGNvbnRlbnRGaWxlKTtcbiAgICAgIGlmIChzZWxmLnJlc3BvbnNlVGV4dC5tYXRjaCgvXk5PREUtWE1MSFRUUFJFUVVFU1QtRVJST1I6LykpIHtcbiAgICAgICAgLy8gSWYgdGhlIGZpbGUgcmV0dXJuZWQgYW4gZXJyb3IsIGhhbmRsZSBpdFxuICAgICAgICB2YXIgZXJyb3JPYmogPSBzZWxmLnJlc3BvbnNlVGV4dC5yZXBsYWNlKC9eTk9ERS1YTUxIVFRQUkVRVUVTVC1FUlJPUjovLCBcIlwiKTtcbiAgICAgICAgc2VsZi5oYW5kbGVFcnJvcihlcnJvck9iaik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiB0aGUgZmlsZSByZXR1cm5lZCBva2F5LCBwYXJzZSBpdHMgZGF0YSBhbmQgbW92ZSB0byB0aGUgRE9ORSBzdGF0ZVxuICAgICAgICBzZWxmLnN0YXR1cyA9IHNlbGYucmVzcG9uc2VUZXh0LnJlcGxhY2UoL15OT0RFLVhNTEhUVFBSRVFVRVNULVNUQVRVUzooWzAtOV0qKSwuKi8sIFwiJDFcIik7XG4gICAgICAgIHNlbGYucmVzcG9uc2VUZXh0ID0gc2VsZi5yZXNwb25zZVRleHQucmVwbGFjZSgvXk5PREUtWE1MSFRUUFJFUVVFU1QtU1RBVFVTOlswLTldKiwoLiopLywgXCIkMVwiKTtcbiAgICAgICAgc2V0U3RhdGUoc2VsZi5ET05FKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGFuIGVycm9yIGlzIGVuY291bnRlcmVkIHRvIGRlYWwgd2l0aCBpdC5cbiAgICovXG4gIHRoaXMuaGFuZGxlRXJyb3IgPSBmdW5jdGlvbihlcnJvcikge1xuICAgIHRoaXMuc3RhdHVzID0gNTAzO1xuICAgIHRoaXMuc3RhdHVzVGV4dCA9IGVycm9yO1xuICAgIHRoaXMucmVzcG9uc2VUZXh0ID0gZXJyb3Iuc3RhY2s7XG4gICAgZXJyb3JGbGFnID0gdHJ1ZTtcbiAgICBzZXRTdGF0ZSh0aGlzLkRPTkUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBYm9ydHMgYSByZXF1ZXN0LlxuICAgKi9cbiAgdGhpcy5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICByZXF1ZXN0LmFib3J0KCk7XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBoZWFkZXJzID0gZGVmYXVsdEhlYWRlcnM7XG4gICAgdGhpcy5yZXNwb25zZVRleHQgPSBcIlwiO1xuICAgIHRoaXMucmVzcG9uc2VYTUwgPSBcIlwiO1xuXG4gICAgZXJyb3JGbGFnID0gdHJ1ZTtcblxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IHRoaXMuVU5TRU5UXG4gICAgICAgICYmICh0aGlzLnJlYWR5U3RhdGUgIT09IHRoaXMuT1BFTkVEIHx8IHNlbmRGbGFnKVxuICAgICAgICAmJiB0aGlzLnJlYWR5U3RhdGUgIT09IHRoaXMuRE9ORSkge1xuICAgICAgc2VuZEZsYWcgPSBmYWxzZTtcbiAgICAgIHNldFN0YXRlKHRoaXMuRE9ORSk7XG4gICAgfVxuICAgIHRoaXMucmVhZHlTdGF0ZSA9IHRoaXMuVU5TRU5UO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyLiBQcmVmZXJyZWQgbWV0aG9kIG9mIGJpbmRpbmcgdG8gZXZlbnRzLlxuICAgKi9cbiAgdGhpcy5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCEoZXZlbnQgaW4gbGlzdGVuZXJzKSkge1xuICAgICAgbGlzdGVuZXJzW2V2ZW50XSA9IFtdO1xuICAgIH1cbiAgICAvLyBDdXJyZW50bHkgYWxsb3dzIGR1cGxpY2F0ZSBjYWxsYmFja3MuIFNob3VsZCBpdD9cbiAgICBsaXN0ZW5lcnNbZXZlbnRdLnB1c2goY2FsbGJhY2spO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gZXZlbnQgY2FsbGJhY2sgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIGJvdW5kLlxuICAgKiBPbmx5IHdvcmtzIG9uIHRoZSBtYXRjaGluZyBmdW5jaXRvbiwgY2Fubm90IGJlIGEgY29weS5cbiAgICovXG4gIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBjYWxsYmFjaykge1xuICAgIGlmIChldmVudCBpbiBsaXN0ZW5lcnMpIHtcbiAgICAgIC8vIEZpbHRlciB3aWxsIHJldHVybiBhIG5ldyBhcnJheSB3aXRoIHRoZSBjYWxsYmFjayByZW1vdmVkXG4gICAgICBsaXN0ZW5lcnNbZXZlbnRdID0gbGlzdGVuZXJzW2V2ZW50XS5maWx0ZXIoZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgcmV0dXJuIGV2ICE9PSBjYWxsYmFjaztcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRGlzcGF0Y2ggYW55IGV2ZW50cywgaW5jbHVkaW5nIGJvdGggXCJvblwiIG1ldGhvZHMgYW5kIGV2ZW50cyBhdHRhY2hlZCB1c2luZyBhZGRFdmVudExpc3RlbmVyLlxuICAgKi9cbiAgdGhpcy5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBpZiAodHlwZW9mIHNlbGZbXCJvblwiICsgZXZlbnRdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHNlbGZbXCJvblwiICsgZXZlbnRdKCk7XG4gICAgfVxuICAgIGlmIChldmVudCBpbiBsaXN0ZW5lcnMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnNbZXZlbnRdLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGxpc3RlbmVyc1tldmVudF1baV0uY2FsbChzZWxmKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENoYW5nZXMgcmVhZHlTdGF0ZSBhbmQgY2FsbHMgb25yZWFkeXN0YXRlY2hhbmdlLlxuICAgKlxuICAgKiBAcGFyYW0gaW50IHN0YXRlIE5ldyBzdGF0ZVxuICAgKi9cbiAgdmFyIHNldFN0YXRlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBpZiAoc2VsZi5yZWFkeVN0YXRlICE9PSBzdGF0ZSkge1xuICAgICAgc2VsZi5yZWFkeVN0YXRlID0gc3RhdGU7XG5cbiAgICAgIGlmIChzZXR0aW5ncy5hc3luYyB8fCBzZWxmLnJlYWR5U3RhdGUgPCBzZWxmLk9QRU5FRCB8fCBzZWxmLnJlYWR5U3RhdGUgPT09IHNlbGYuRE9ORSkge1xuICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoXCJyZWFkeXN0YXRlY2hhbmdlXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZi5yZWFkeVN0YXRlID09PSBzZWxmLkRPTkUgJiYgIWVycm9yRmxhZykge1xuICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoXCJsb2FkXCIpO1xuICAgICAgICAvLyBAVE9ETyBmaWd1cmUgb3V0IEluc3BlY3Rvckluc3RydW1lbnRhdGlvbjo6ZGlkTG9hZFhIUihjb29raWUpXG4gICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudChcImxvYWRlbmRcIik7XG4gICAgICB9XG4gICAgfVxuICB9O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZXh0ZW5kXG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIGV4dGVuZCgpIHtcbiAgICB2YXIgdGFyZ2V0ID0ge31cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV1cblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0XG59XG4iLCIvKipcbiAqIEFjY2VwdHMgYW4gYXJyYXkgb2Ygc3RyaW5ncyB0aGF0IHJlcHJlc2VudCBhIHJlZmVyZW5jZSB0byBhIHZhbHVlIG9uIGFuXG4gKiBvYmplY3QuIFN1cHBvcnRzIHBhc3NpbmcgYW4gb3B0aW9uYWwgc2V0dGVyLCB0byBzZXQgdGhlIHZhbHVlLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gb2JqZWN0XG4gKiBAcGFyYW0gIHtBcnJheX0gIHBhdGhcbiAqIEBwYXJhbSAgeyp9ICAgICAgW3NldHRlcl1cbiAqIEByZXR1cm4geyp9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgcGF0aCwgc2V0dGVyKSB7XG4gIHZhciBpc1NldHRlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wID0gcGF0aFtpXTtcblxuICAgIGlmIChpc1NldHRlcikge1xuICAgICAgaWYgKGkgPT09IHBhdGgubGVuZ3RoIC0gMSkge1xuICAgICAgICBvYmplY3RbcHJvcF0gPSBzZXR0ZXI7XG4gICAgICB9IGVsc2UgaWYgKCEocHJvcCBpbiBvYmplY3QpKSB7XG4gICAgICAgIG9iamVjdFtwcm9wXSA9IHt9O1xuICAgICAgfVxuICAgIH1cblxuICAgIG9iamVjdCA9IG9iamVjdFtwcm9wXTtcbiAgfVxuXG4gIC8vIFJldHVybiB0aGUgdXBkYXRlZCBvYmplY3QgcmVmZXJlbmNlLlxuICByZXR1cm4gb2JqZWN0O1xufTtcbiIsIi8qIGdsb2JhbCBBcHAgKi9cbnZhciBfICAgICAgICA9IEFwcC5MaWJyYXJ5Ll87XG52YXIgYXN5bmMgICAgPSBBcHAuTGlicmFyeS5hc3luYztcbnZhciB0ZW1wbGF0ZSA9IHJlcXVpcmUoJy4vY2xpZW50LWdlbmVyYXRvci90ZW1wbGF0ZScpO1xuXG4vKipcbiAqIE1hcCBhdXRoZW50aWNhdGlvbiB0eXBlcyB0byBhdXRvbWF0aWMgcHJlZmVyZW5jZS5cbiAqXG4gKiBAdHlwZSB7QXJyYXl9XG4gKi9cbnZhciBPUkRFUl9QUkVGRVJFTkNFID0gWydPQXV0aCAyLjAnLCAnT0F1dGggMS4wJywgJ0Jhc2ljIEF1dGhlbnRpY2F0aW9uJ107XG5cbi8qKlxuICogUmVxdWlyZWQgYXV0aGVudGljYXRpb24ga2V5cyB1c2VkIHRvIGNoZWNrIHRoZSBvcHRpb25zIG9iamVjdC5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgREVGQVVMVF9SRVFVSVJFRF9GSUVMRFMgPSB7XG4gICdPQXV0aCAxLjAnOiB7XG4gICAgY29uc3VtZXJLZXk6ICAgIHRydWUsXG4gICAgY29uc3VtZXJTZWNyZXQ6IHRydWVcbiAgfSxcbiAgJ09BdXRoIDIuMCc6IHtcbiAgICBjbGllbnRJZDogICAgIHRydWUsXG4gICAgY2xpZW50U2VjcmV0OiB0cnVlXG4gIH0sXG4gICdCYXNpYyBBdXRoZW50aWNhdGlvbic6IHtcbiAgICB1c2VybmFtZTogdHJ1ZSxcbiAgICBwYXNzd29yZDogdHJ1ZVxuICB9XG59O1xuXG4vKipcbiAqIFBvc3NpYmxlIHRva2VucyB0byBiZSBmaWxsZWQgb3V0IGJ5IHRoZSB1c2VyLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZhciBERUZBVUxUX1BPU1NJQkxFX0ZJRUxEUyA9IHtcbiAgJ09BdXRoIDEuMCc6ICAgICAgICAgICAgWydjb25zdW1lcktleScsICdjb25zdW1lclNlY3JldCddLFxuICAnT0F1dGggMi4wJzogICAgICAgICAgICBbJ2NsaWVudElkJywgJ2NsaWVudFNlY3JldCcsICdzY29wZXMnXSxcbiAgJ0Jhc2ljIEF1dGhlbnRpY2F0aW9uJzogWyd1c2VybmFtZScsICdwYXNzd29yZCddXG59O1xuXG4vKipcbiAqIERlZmF1bHQgYXV0aGVudGljYXRpb24gcHJvbXB0IHRpdGxlcy5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgREVGQVVMVF9QUk9NUFRfVElUTEVTID0ge1xuICAnT0F1dGggMS4wJzogICAgICAgICAgICAnUGxlYXNlIEVudGVyIFlvdXIgT0F1dGggMS4wIEtleXMnLFxuICAnT0F1dGggMi4wJzogICAgICAgICAgICAnUGxlYXNlIEVudGVyIFlvdXIgT0F1dGggMi4wIEtleXMnLFxuICAnQmFzaWMgQXV0aGVudGljYXRpb24nOiAnUGxlYXNlIEVudGVyIFlvdXIgVXNlcm5hbWUgYW5kIFBhc3N3b3JkJ1xufTtcblxuLyoqXG4gKiBNYXAgb2Ygb2JqZWN0IGtleXMgdG8gdGhlaXIgcmVhZGFibGUgbmFtZXMuXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqL1xudmFyIERFRkFVTFRfRklFTERfTkFNRVMgPSB7XG4gIGNvbnN1bWVyS2V5OiAgICAnQ29uc3VtZXIgS2V5JyxcbiAgY29uc3VtZXJTZWNyZXQ6ICdDb25zdW1lciBTZWNyZXQnLFxuICBjbGllbnRJZDogICAgICAgJ0NsaWVudCBJRCcsXG4gIGNsaWVudFNlY3JldDogICAnQ2xpZW50IFNlY3JldCcsXG4gIHNjb3BlczogICAgICAgICAnUGVybWlzc2lvbnMnLFxuICB1c2VybmFtZTogICAgICAgJ1VzZXJuYW1lJyxcbiAgcGFzc3dvcmQ6ICAgICAgICdQYXNzd29yZCdcbn07XG5cbi8qKlxuICogVGhlc2UgZmllbGRzIG11c3QgYmUgaGlkZGVuIGluIHRoZSBVSS5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgU0VDUkVUX0ZJRUxEUyA9IHtcbiAgY2xpZW50U2VjcmV0OiB0cnVlLFxuICBjb25zdW1lclNlY3JldDogdHJ1ZSxcbiAgcGFzc3dvcmQ6IHRydWVcbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBvYmplY3Qgb2YgYXZhaWxhYmxlIGtleXMgYW5kIHdoZXRoZXIgdGhleSBhcmUgcmVxdWlyZWQuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBzY2hlbWVcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xudmFyIHJlcXVpcmVkVG9rZW5zID0gZnVuY3Rpb24gKHNjaGVtZSkge1xuICB2YXIga2V5cyA9IF8uZXh0ZW5kKHt9LCBERUZBVUxUX1JFUVVJUkVEX0ZJRUxEU1tzY2hlbWUudHlwZV0pO1xuXG4gIC8vIFNwZWNpYWwgY2FzZSBpcyByZXF1aXJlZCBmb3IgT0F1dGgyIGltcGxpY2l0IGF1dGggZmxvdy5cbiAgaWYgKHNjaGVtZS50eXBlID09PSAnT0F1dGggMi4wJykge1xuICAgIGtleXMuY2xpZW50U2VjcmV0ID0gIV8uY29udGFpbnMoXG4gICAgICBzY2hlbWUuc2V0dGluZ3MuYXV0aG9yaXphdGlvbkdyYW50cywgJ3Rva2VuJ1xuICAgICk7XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn07XG5cbi8qKlxuICogU2FuaXRpemUgc2NvcGVzIHRvIGJlIGFuIGFycmF5LlxuICpcbiAqIEBwYXJhbSAgeyp9ICAgICBzY29wZXNcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG52YXIgc2FuaXRpemVTY29wZSA9IGZ1bmN0aW9uIChzY29wZXMpIHtcbiAgaWYgKF8uaXNTdHJpbmcoc2NvcGVzKSkge1xuICAgIHJldHVybiBzY29wZXMuc3BsaXQoJyAnKTtcbiAgfVxuXG4gIGlmICghQXJyYXkuaXNBcnJheShzY29wZXMpKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgcmV0dXJuIHNjb3Blcztcbn07XG5cbi8qKlxuICogQ2hlY2sgdGhlIHRva2VucyBvYmplY3QgYWdhaW5zdCB0aGUgcmVxdWlyZWQgdG9rZW5zLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gIHNjaGVtZVxuICogQHBhcmFtICB7T2JqZWN0fSAgdG9rZW5zXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG52YXIgaGFzUmVxdWlyZWRUb2tlbnMgPSBmdW5jdGlvbiAoc2NoZW1lLCB0b2tlbnMpIHtcbiAgLy8gSXRlcmF0ZSBvdmVyIHRoZSByZXF1aXJlZCB0b2tlbnMgYW5kIGNoZWNrIHRoYXQgdGhlIHRva2VuIGlzIGRlZmluZWQuXG4gIHJldHVybiBfLmV2ZXJ5KHJlcXVpcmVkVG9rZW5zKHNjaGVtZSksIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgcmV0dXJuIHZhbHVlID8gdG9rZW5zW2tleV0gOiB0cnVlO1xuICB9KTtcbn07XG5cbi8qKlxuICogUHJvbXB0IHRoZSB1c2VyIGZvciBhdXRoZW50aWNhdGlvbiB0b2tlbnMgYmFzZWQgb24gYSBzY2hlbWUuIFdlIGNhbiBwYXNzIGluXG4gKiB0aGUgY3VycmVudCBvcHRpb25zIG9iamVjdCB0byBoZWxwIGRlY2lkZSB3aGF0IGRhdGEgdG8gZGlzcGxheSB0byB0aGUgdXNlci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gICBzY2hlbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSAgIG9wdGlvbnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAqL1xudmFyIHByb21wdFRva2VucyA9IGZ1bmN0aW9uIChzY2hlbWUsIG9wdGlvbnMsIGRvbmUpIHtcbiAgdmFyIGNhbmNlbGxlZCAgID0gdHJ1ZTtcbiAgdmFyIG5lZWRzVG9rZW5zID0gcmVxdWlyZWRUb2tlbnMoc2NoZW1lKTtcblxuICAvLyBHZW5lcmF0ZSBhbiBhcnJheSBvZiB0aGUgdG9rZW5zIHRvIHVzZSB3aXRoIG91ciBwcm9tcHQgYW5kIGZpbHRlclxuICAvLyBleHBsaWNpdGx5IG5vdCByZXF1aXJlZCB0b2tlbnMuXG4gIHZhciBwb3NzaWJsZVRva2VucyA9IF8uZmlsdGVyKFxuICAgIERFRkFVTFRfUE9TU0lCTEVfRklFTERTW3NjaGVtZS50eXBlXSxcbiAgICBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgIHJldHVybiBuZWVkc1Rva2Vuc1t0b2tlbl0gIT09IGZhbHNlO1xuICAgIH1cbiAgKTtcblxuICAvLyBNdWx0aXBsZSB3YXlzIG9mIHNldHRpbmcgdGhlIHNjb3BlIG9wdGlvbi5cbiAgb3B0aW9ucy5zY29wZXMgPSBzYW5pdGl6ZVNjb3BlKG9wdGlvbnMuc2NvcGUgfHwgb3B0aW9ucy5zY29wZXMpO1xuICBkZWxldGUgb3B0aW9ucy5zY29wZTtcblxuICAvLyBHZW5lcmF0ZSB0aGUgZm9ybSB0byBwcm9tcHQgdGhlIHVzZXIgd2l0aC5cbiAgdmFyIHByb21wdEZvcm0gPSBfLm1hcChwb3NzaWJsZVRva2VucywgZnVuY3Rpb24gKGtleSkge1xuICAgIGlmIChrZXkgPT09ICdzY29wZXMnKSB7XG4gICAgICB2YXIgc2NvcGVzID0gc2FuaXRpemVTY29wZShzY2hlbWUuc2V0dGluZ3Muc2NvcGVzKTtcblxuICAgICAgLy8gSWdub3JlIHRoZSBzY29wZXMgc2VsZWN0aW9uIHdoZW4gbm90aGluZyBpcyBhdmFpbGFibGUgZm9yIHNlbGVjdGlvbi5cbiAgICAgIGlmICghc2NvcGVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG5cbiAgICAgIC8vIE1hcCBzY29wZXMgdG8gY2hlY2tib3ggc2VsZWN0aW9ucy5cbiAgICAgIHZhciBzY29wZU9wdGlvbnMgPSBfLm1hcChzY29wZXMsIGZ1bmN0aW9uIChzY29wZSkge1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgc2NvcGUgaXMgYWxyZWFkeSBpbiB0aGUgc2VsZWN0ZWQgc2NvcGVzLiBJZiB0aGVyZSBpc1xuICAgICAgICAvLyBvbmx5IG9uZSBwb3NzaWJsZSBzY29wZSwganVzdCBzZWxlY3QgaXQgYnkgZGVmYXVsdCBhbnl3YXkuXG4gICAgICAgIHZhciBoYXNTY29wZSA9IF8uY29udGFpbnMob3B0aW9ucy5zY29wZXMsIHNjb3BlKSB8fCBzY29wZXMubGVuZ3RoID09PSAxO1xuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgJzxkaXYgY2xhc3M9XCJjaGVja2JveFwiPicsXG4gICAgICAgICAgJzxsYWJlbD4nLFxuICAgICAgICAgICc8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgaWQ9XCJzY29wZXNcIiB2YWx1ZT1cIicgKyBzY29wZSArICdcIiAnICtcbiAgICAgICAgICAgIChoYXNTY29wZSA/ICdjaGVja2VkJyA6ICcnKSArICc+JyxcbiAgICAgICAgICBzY29wZSxcbiAgICAgICAgICAnPC9sYWJlbD4nLFxuICAgICAgICAgICc8L2Rpdj4nXG4gICAgICAgIF0uam9pbignJyk7XG4gICAgICB9KS5qb2luKCdcXG4nKTtcblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgJzxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwXCI+JyxcbiAgICAgICAgJzxsYWJlbCBjbGFzcz1cImZvcm0tbGFiZWxcIj4nICsgREVGQVVMVF9GSUVMRF9OQU1FU1trZXldICsgJzwvbGFiZWw+JyxcbiAgICAgICAgJzxkaXYgY2xhc3M9XCJmb3JtLWNvbnRlbnRcIj4nICsgc2NvcGVPcHRpb25zICsgJzwvZGl2PicsXG4gICAgICAgICc8L2Rpdj4nXG4gICAgICBdLmpvaW4oJ1xcbicpO1xuICAgIH1cblxuICAgIC8vIEJ5IGRlZmF1bHQgd2Ugc2hvdyB0aGUgdXNlciBhbiBpbnB1dCBmaWVsZCB0byBpbnB1dCB0aGVpciBrZXlzLlxuICAgIHJldHVybiBbXG4gICAgICAnPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIj4nLFxuICAgICAgJzxsYWJlbCBmb3I9XCInICsga2V5ICsgJ1wiIGNsYXNzPVwiZm9ybS1sYWJlbFwiPicsXG4gICAgICBERUZBVUxUX0ZJRUxEX05BTUVTW2tleV0sXG4gICAgICAnPC9sYWJlbD4nLFxuICAgICAgJzxkaXYgY2xhc3M9XCJmb3JtLWNvbnRlbnRcIj4nLFxuICAgICAgJzxpbnB1dCBpZD1cIicgKyBrZXkgKyAnXCIgdmFsdWU9XCInICsgKG9wdGlvbnNba2V5XSB8fCAnJykgKyAnXCInICtcbiAgICAgICAgKFNFQ1JFVF9GSUVMRFNba2V5XSA/ICcgdHlwZT1cInBhc3N3b3JkXCInIDogJycpICsgJz4nLFxuICAgICAgJzwvZGl2PicsXG4gICAgICAnPC9kaXY+J1xuICAgIF0uam9pbignJyk7XG4gIH0pLmpvaW4oJ1xcbicpO1xuXG4gIHJldHVybiBBcHAubWlkZGxld2FyZS50cmlnZ2VyKCd1aTptb2RhbCcsIHtcbiAgICB0aXRsZTogREVGQVVMVF9QUk9NUFRfVElUTEVTW3NjaGVtZS50eXBlXSxcbiAgICBjb250ZW50OiBbXG4gICAgICAnPHA+JyxcbiAgICAgICdUaGlzIEFQSSByZXF1aXJlcyBhdXRoZW50aWNhdGlvbi4gUGxlYXNlIGVudGVyIHlvdXIgYXBwbGljYXRpb24ga2V5cy4nLFxuICAgICAgJzwvcD4nLFxuICAgICAgJzxwPjxlbT5XZSBkbyBub3Qgc3RvcmUgeW91ciBrZXlzLjwvZW0+PC9wPicsXG4gICAgICAnPGZvcm0+JyxcbiAgICAgIHByb21wdEZvcm0sXG4gICAgICAnPGRpdiBjbGFzcz1cImZvcm0tZm9vdGVyXCI+JyxcbiAgICAgICc8YnV0dG9uIHR5cGU9XCJzdWJtaXRcIiBjbGFzcz1cImJ0biBidG4tcHJpbWFyeVwiPlN1Ym1pdDwvYnV0dG9uPicsXG4gICAgICAnPC9kaXY+JyxcbiAgICAgICc8L2Zvcm0+J1xuICAgIF0uam9pbignXFxuJyksXG4gICAgc2hvdzogZnVuY3Rpb24gKG1vZGFsKSB7XG4gICAgICBtb2RhbC5lbC5xdWVyeVNlbGVjdG9yKCdmb3JtJylcbiAgICAgICAgLmFkZEV2ZW50TGlzdGVuZXIoJ3N1Ym1pdCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgXy5lYWNoKHRoaXMucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQnKSwgZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IGVsLmdldEF0dHJpYnV0ZSgnaWQnKTtcblxuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdzY29wZXMnKSB7XG4gICAgICAgICAgICAgIHZhciBpbmRleE9mID0gXy5pbmRleE9mKG9wdGlvbnMuc2NvcGVzLCBlbC52YWx1ZSk7XG5cbiAgICAgICAgICAgICAgaWYgKGVsLmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXhPZiA8IDApIHtcbiAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc2NvcGVzLnB1c2goZWwudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXhPZiA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICBvcHRpb25zLnNjb3Blcy5zcGxpY2UoaW5kZXhPZiwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvcHRpb25zW25hbWVdID0gZWwudmFsdWUudHJpbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICAgICAgbW9kYWwuY2xvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgcmV0dXJuIGRvbmUoZXJyIHx8IChjYW5jZWxsZWQgPyBuZXcgRXJyb3IoJ01vZGFsIGNsb3NlZCcpIDogbnVsbCksIG9wdGlvbnMpO1xuICB9KTtcbn07XG5cbi8qKlxuICogQXV0aGVudGljYXRlIHVzaW5nIGFuIGF1dGhlbnRpY2F0aW9uIHNjaGVtZSBhbmQgcGFzc2VkIGluIG9wdGlvbnMuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSAgIHNjaGVtZVxuICogQHBhcmFtICB7T2JqZWN0fSAgIG9wdGlvbnNcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBkb25lXG4gKi9cbnZhciBhdXRoZW50aWNhdGUgPSBmdW5jdGlvbiAoc2NoZW1lLCBvcHRpb25zLCBkb25lKSB7XG4gIHZhciBvcHRzID0gXy5kZWZhdWx0cyh7XG4gICAgdHlwZTogc2NoZW1lLnR5cGVcbiAgfSwgb3B0aW9ucywgc2NoZW1lLnNldHRpbmdzKTtcblxuICAvLyBJbnRlcnBvbGF0ZSBhbGwgdXJpIHBhcmFtZXRlcnMuXG4gIF8uZWFjaChbXG4gICAgJ2FjY2Vzc1Rva2VuVXJpJyxcbiAgICAnYXV0aG9yaXphdGlvblVyaScsXG4gICAgJ3JlcXVlc3RUb2tlblVyaScsXG4gICAgJ2F1dGhvcml6YXRpb25VcmknLFxuICAgICd0b2tlbkNyZWRlbnRpYWxzVXJpJ1xuICBdLCBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICBvcHRzW3BhcmFtXSA9IHRlbXBsYXRlKG9wdHNbcGFyYW1dLCBvcHRzLmJhc2VVcmlQYXJhbWV0ZXJzKTtcbiAgfSk7XG5cbiAgLy8gVHJpZ2dlciB0aGUgYXV0aGVudGljYXRpb24gZmxvdy5cbiAgQXBwLm1pZGRsZXdhcmUudHJpZ2dlcignYXV0aGVudGljYXRlJywgb3B0cywgZnVuY3Rpb24gKGVyciwgdG9rZW5zKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgcmV0dXJuIGRvbmUoZXJyKTtcbiAgICB9XG5cbiAgICBpZiAoIXRva2Vucykge1xuICAgICAgcmV0dXJuIGRvbmUobmV3IEVycm9yKCdBdXRoZW50aWNhdGlvbiBmYWlsZWQnKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRvbmUobnVsbCwgc2NoZW1lLCBvcHRpb25zLCB0b2tlbnMpO1xuICB9LCB0cnVlKTtcbn07XG5cbi8qKlxuICogUmVxdWVzdCBhdXRoZW50aWNhdGlvbiBjcmVkZW50aWFscyBmcm9tIGEgdGhpcmQtcGFydHkgc291cmNlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSAgIHNjaGVtZVxuICogQHBhcmFtIHtPYmplY3R9ICAgb3B0aW9uc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICovXG52YXIgcmVxdWVzdFRva2VucyA9IGZ1bmN0aW9uIChzY2hlbWUsIG9wdGlvbnMsIGRvbmUpIHtcbiAgdmFyIGNiID0gZnVuY3Rpb24gKGVyciwgdG9rZW5zKSB7XG4gICAgcmV0dXJuIGRvbmUoZXJyLCBfLmV4dGVuZCh7fSwgdG9rZW5zLCBvcHRpb25zKSk7XG4gIH07XG5cbiAgcmV0dXJuIEFwcC5taWRkbGV3YXJlLnRyaWdnZXIoJ3JhbWxDbGllbnQ6dG9rZW4nLCBzY2hlbWUsIGNiLCB0cnVlKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBwcmVmZXJyZWQgc2NoZW1lIG9wdGlvbiBmcm9tIGFuIG9iamVjdCBvZiBldmVyeSBzY2hlbWUuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBzY2hlbWVzXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbnZhciBwcmVmZXJyZWRTY2hlbWUgPSBmdW5jdGlvbiAoc2NoZW1lcykge1xuICAvLyBGaXggYHVuZGVmaW5lZGAgc2NoZW1lcyBpc3N1ZXMuXG4gIGlmICghc2NoZW1lcyB8fCAhT2JqZWN0LmtleXMoc2NoZW1lcykubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG1ldGhvZCA9IF8uaW50ZXJzZWN0aW9uKE9SREVSX1BSRUZFUkVOQ0UsIF8ucGx1Y2soc2NoZW1lcywgJ3R5cGUnKSlbMF07XG5cbiAgLy8gUmV0dXJuIGFuIGVzc2VudGlhbGx5IHJhbmRvbSBidXQgY29uc2lzdGVudCBzY2hlbWUuXG4gIGlmICghbWV0aG9kKSB7XG4gICAgcmV0dXJuIHNjaGVtZXNbXy5rZXlzKHNjaGVtZXMpWzBdXTtcbiAgfVxuXG4gIC8vIEZpbmQgdGhlIHNjaGVtZSB0aGF0IG1hdGNoZWQgb3VyIHByZWZlcnJlZCBtZXRob2QuXG4gIHJldHVybiBfLmZpbmQoc2NoZW1lcywgZnVuY3Rpb24gKHNjaGVtZSkge1xuICAgIHJldHVybiBzY2hlbWUudHlwZSA9PT0gbWV0aG9kO1xuICB9KTtcbn07XG5cbi8qKlxuICogUmV0cmlldmUgYXV0aGVudGljYXRpb24gdG9rZW5zIGFuZCBtZXRob2QgYW55IHdheSBwb3NzaWJsZS4gSXQgd2lsbCBhdHRlbXB0XG4gKiB0byByZXNvbHZlIGF1dG9tYXRpY2FsbHkuIElmIHRoYXQgaXMgbm90IHBvc3NpYmxlLCBpdCB3aWxsIGRlZmVyIHRvXG4gKiBwcm9tcHRpbmcgdGhlIHVzZXIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9ICAgc2NoZW1lc1xuICogQHBhcmFtIHtPYmplY3R9ICAgb3B0aW9uc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICovXG52YXIgcmV0cmlldmVUb2tlbnMgPSBmdW5jdGlvbiAoc2NoZW1lcywgb3B0aW9ucywgZG9uZSkge1xuICB2YXIgdG9rZW5zO1xuXG4gIC8vIEF0dGVtcHQgdG8gZ2V0IHRoZSBmaXJzdCByZXNvbHZpbmcgc2V0IG9mIGFjY2VzcyB0b2tlbnMuXG4gIGFzeW5jLmRldGVjdFNlcmllcyhfLm1hcChzY2hlbWVzLCBmdW5jdGlvbiAoc2VjdXJlZCwgbWV0aG9kKSB7XG4gICAgcmV0dXJuIHNjaGVtZXNbbWV0aG9kXTtcbiAgfSksIGZ1bmN0aW9uIChzY2hlbWUsIGNiKSB7XG4gICAgcmV0dXJuIHJlcXVlc3RUb2tlbnMoc2NoZW1lLCBvcHRpb25zLCBmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAgICBpZiAoZXJyIHx8ICFkYXRhIHx8ICFoYXNSZXF1aXJlZFRva2VucyhzY2hlbWUsIGRhdGEpKSB7XG4gICAgICAgIHJldHVybiBjYihmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjYih0b2tlbnMgPSBkYXRhKTtcbiAgICB9KTtcbiAgfSwgZnVuY3Rpb24gKHNjaGVtZSkge1xuICAgIGlmICghc2NoZW1lKSB7XG4gICAgICBzY2hlbWUgPSBwcmVmZXJyZWRTY2hlbWUoc2NoZW1lcyk7XG5cbiAgICAgIGlmICghc2NoZW1lKSB7XG4gICAgICAgIHJldHVybiBkb25lKG5ldyBFcnJvcignTm8gc2NoZW1lcyBhdmFpbGFibGUnKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcm9tcHRUb2tlbnMoc2NoZW1lLCBvcHRpb25zLCBmdW5jdGlvbiAoZXJyLCB0b2tlbnMpIHtcbiAgICAgICAgcmV0dXJuIGRvbmUoZXJyLCBzY2hlbWUsIHRva2Vucyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZG9uZShudWxsLCBzY2hlbWUsIHRva2Vucyk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBBdHRlbXB0IHRvIG1hZ2ljYWxseSByZXNvbHZlIHRvIHRoZSBmaXJzdCB3b3JraW5nIGF1dGhlbnRpY2F0aW9uIG1ldGhvZC4gSWZcbiAqIHdlIGZhaWwsIHdlIG5lZWQgdG8gZmFsbCBiYWNrIHRvIG1hbnVhbCBhdXRoZW50aWNhdGlvbiBvcHRpb25zIHdpdGggdGhlXG4gKiBvcHRpbWFsIGF1dGhlbnRpY2F0aW9uIHNjaGVtZSBhdmFpbGFibGUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9ICAgc2NoZW1lc1xuICogQHBhcmFtIHtPYmplY3R9ICAgb3B0aW9uc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICovXG52YXIgcmVzb2x2ZVNjaGVtZSA9IGZ1bmN0aW9uIChzY2hlbWVzLCBvcHRpb25zLCBkb25lKSB7XG4gIHJldHVybiByZXRyaWV2ZVRva2VucyhzY2hlbWVzLCBvcHRpb25zLCBmdW5jdGlvbiAoZXJyLCBzY2hlbWUsIHRva2Vucykge1xuICAgIGlmIChlcnIpIHsgcmV0dXJuIGRvbmUoZXJyKTsgfVxuXG4gICAgcmV0dXJuIGF1dGhlbnRpY2F0ZShzY2hlbWUsIHRva2VucywgZG9uZSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBFeHBvcnQgYSBmdW5jdGlvbiB0aGF0IHdpbGwgY29udGFpbiBhbGwgdGhlIGxvZ2ljIGZvciBhdXRvbWFnaWNhbGx5XG4gKiBzZWxlY3RpbmcgYW4gYXBwcm9wcmlhdGUgYXV0aGVudGljYXRpb24gbWV0aG9kIGFuZCBwcm9tcHRpbmcgdGhlIHVzZXJcbiAqIGZvciB0aGUgZm9sbG93aW5nIHN0ZXBzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSAgIHNjaGVtZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSAgIG1ldGhvZFxuICogQHBhcmFtIHtPYmplY3R9ICAgb3B0aW9uc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICovXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2NoZW1lcywgbWV0aG9kLCBvcHRpb25zLCBkb25lKSB7XG4gIHZhciBhdXRoID0gXy5leHRlbmQoe30sIG9wdGlvbnMpO1xuXG4gIC8vIElmIG5vIGF1dGhlbnRpY2F0aW9uIG1ldGhvZCBoYXMgYmVlbiBwYXNzZWQgaW4sIGF0dGVtcHQgdG8gcGljayBvdXIgb3duLlxuICBpZiAoIW1ldGhvZCkge1xuICAgIHJldHVybiByZXNvbHZlU2NoZW1lKHNjaGVtZXMsIGF1dGgsIGRvbmUpO1xuICB9XG5cbiAgLy8gRW5zdXJlIHdlIGFyZSBhdHRlbXB0aW5nIHRvIGF1dGhlbnRpY2F0ZSB3aXRoIGEgdmFsaWQgbWV0aG9kLlxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzY2hlbWVzLCBtZXRob2QpKSB7XG4gICAgcmV0dXJuIGRvbmUobmV3IEVycm9yKFxuICAgICAgJ1RoZSBvbmx5IGF2YWlsYWJsZSBhdXRoZW50aWNhdGlvbiBtZXRob2RzIGFyZTogJyArXG4gICAgICBfLmtleXMoc2NoZW1lcykubWFwKEpTT04uc3RyaW5naWZ5KS5qb2luKCcsICcpXG4gICAgKSk7XG4gIH1cblxuICB2YXIgc2NoZW1lID0gc2NoZW1lc1ttZXRob2RdO1xuXG4gIC8vIElmIHdlIGRvbid0IGhhdmUgYWxsIHRoZSByZXF1aXJlZCB0b2tlbnMgYXZhaWxhYmxlLCBwcm9tcHQgdGhlIHVzZXIgdG9cbiAgLy8gaW5wdXQgdG9rZW5zIGFuZCBjb250aW51ZSBhdXRoZW50aWNhdGluZy5cbiAgaWYgKCFoYXNSZXF1aXJlZFRva2VucyhzY2hlbWUsIGF1dGgpKSB7XG4gICAgcmV0dXJuIHJlcXVlc3RUb2tlbnMoc2NoZW1lLCBhdXRoLCBmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAgICBpZiAoZXJyKSB7IHJldHVybiBkb25lKGVycik7IH1cblxuICAgICAgLy8gRG9uJ3QgcHJvbXB0IGZvciB0aGUgdG9rZW5zIGlmIHdlIG1hbmFnZWQgdG8gcmV0cmlldmUgdGhlbSBhbnl3YXkuXG4gICAgICBpZiAoaGFzUmVxdWlyZWRUb2tlbnMoc2NoZW1lLCBfLmRlZmF1bHRzKGF1dGgsIGRhdGEpKSkge1xuICAgICAgICByZXR1cm4gYXV0aGVudGljYXRlKHNjaGVtZSwgYXV0aCwgZG9uZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcm9tcHRUb2tlbnMoc2NoZW1lLCBhdXRoLCBmdW5jdGlvbiAoZXJyLCB0b2tlbnMpIHtcbiAgICAgICAgaWYgKGVycikgeyByZXR1cm4gZG9uZShlcnIpOyB9XG5cbiAgICAgICAgcmV0dXJuIGF1dGhlbnRpY2F0ZShzY2hlbWUsIHRva2VucywgZG9uZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIEZpbmFsbHkgd2UgaGF2ZSBldmVyeXRoaW5nIHdlIG5lZWQgYW5kIGNhbiBpbml0aWF0ZSBhdXRoZW50aWNhdGlvbi5cbiAgcmV0dXJuIGF1dGhlbnRpY2F0ZShzY2hlbWUsIGF1dGgsIGRvbmUpO1xufTtcblxuLyoqXG4gKiBFeHBvc2Ugc2VjcmV0IGZpZWxkIG5hbWVzLlxuICovXG5leHBvcnRzLlNFQ1JFVF9GSUVMRFMgPSBTRUNSRVRfRklFTERTO1xuIiwiLyogZ2xvYmFsIEFwcCAqL1xudmFyIF8gICAgICAgICAgID0gQXBwLkxpYnJhcnkuXztcbnZhciBxcyAgICAgICAgICA9IEFwcC5MaWJyYXJ5LnFzO1xudmFyIHRlbXBsYXRlICAgID0gcmVxdWlyZSgnLi90ZW1wbGF0ZScpO1xudmFyIHNhbml0aXplQVNUID0gcmVxdWlyZSgnLi9zYW5pdGl6ZS1hc3QnKTtcblxudmFyIENPTkZJR19QUk9QRVJUWSA9ICchY29uZmlnJztcbnZhciBDTElFTlRfUFJPUEVSVFkgPSAnIWNsaWVudCc7XG5cbnZhciBKU09OX1JFR0VYUCA9IC9eYXBwbGljYXRpb25cXC8oW1xcdyEjXFwkJSZcXCpgXFwtXFwuXFxefl0qXFwrKT9qc29uJC9pO1xuXG52YXIgSFRUUF9NRVRIT0RTICAgICAgICAgPSBbJ2dldCcsICdoZWFkJywgJ3B1dCcsICdwb3N0JywgJ3BhdGNoJywgJ2RlbGV0ZSddO1xudmFyIFJFVFVSTl9QUk9QRVJUWSAgICAgID0gJyFyZXR1cm4nO1xudmFyIERFU0NSSVBUSU9OX1BST1BFUlRZID0gJyFkZXNjcmlwdGlvbic7XG52YXIgQ09ORklHX09QVElPTlMgICAgICAgPSBbXG4gICdib2R5JyxcbiAgJ3Byb3h5JyxcbiAgJ3VyaVBhcmFtZXRlcnMnLFxuICAnYmFzZVVyaScsXG4gICdiYXNlVXJpUGFyYW1ldGVycycsXG4gICdoZWFkZXJzJyxcbiAgJ3F1ZXJ5JyxcbiAgJ2JlZm9yZVNlbmQnXG5dO1xudmFyIE9WRVJSSURBQkxFX0NPTkZJR19PUFRJT05TID0gXy5vYmplY3QoXG4gIFsnYm9keScsICdwcm94eScsICdiYXNlVXJpJywgJ2JlZm9yZVNlbmQnXSwgdHJ1ZVxuKTtcblxuLyoqXG4gKiBTdGF0aWMgZGVzY3JpcHRpb24gb2YgdGhlIG1lZGlhIHR5cGUgZXh0ZW5zaW9uIGZ1bmN0aW9uLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZhciBFWFRFTlNJT05fREVTQ1JJUFRJT04gPSB7XG4gICchdHlwZSc6ICdmbihleHRlbnNpb24pJyxcbiAgJyFhcmdzJzogW3tcbiAgICAnIXR5cGUnOiAnc3RyaW5nJyxcbiAgICAnIWRvYyc6ICAnU2V0IHRoZSBmaWxlIGV4dGVuc2lvbiB3aXRoIHJlbGV2YW50IGBBY2NlcHRgIGhlYWRlci4nXG4gIH1dLFxuICAnIWRvYyc6IFtcbiAgICAnU2V0IHRoZSBwYXRoIGV4dGVuc2lvbiBhbmQgY29ycmVzcG9uZGluZyBhY2NlcHQgaGVhZGVyLidcbiAgXS5qb2luKCcgJylcbn07XG5cbi8qKlxuICogU3RhdGljIGRlc2NyaXB0aW9uIG9mIHRoZSBjbGllbnQgb2JqZWN0LlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZhciBDTElFTlRfREVTQ1JJUFRJT04gPSB7XG4gICchdHlwZSc6ICdmbih1cmwsIGRhdGE/KScsXG4gICchYXJncyc6IFt7XG4gICAgJyF0eXBlJzogJ3N0cmluZycsXG4gICAgJyFkb2MnOiAgJ1Byb3ZpZGUgYSB1cmwgcmVsYXRpdmUgdG8gdGhlIGJhc2UgdXJpLidcbiAgfSwge1xuICAgICchdHlwZSc6ICdvYmplY3QnLFxuICAgICchZG9jJzogICdQcm92aWRlIGEgZGF0YSBvYmplY3QgdG8gcmVwbGFjZSB0ZW1wbGF0ZSB0YWdzIGluIHRoZSBgdXJsYC4nXG4gIH1dLFxuICAnIWRvYyc6IFtcbiAgICAnTWFrZSBhbiBBUEkgcmVxdWVzdCB0byBhIGN1c3RvbSBVUkwuJ1xuICBdLmpvaW4oJyAnKVxufTtcblxuLyoqXG4gKiBNYXAgdGhlIHN1cHBvcnRlZCBhdXRoIHR5cGVzIHRvIHRoZSBrbm93biB0cmlnZ2Vycy5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgYXV0aE1hcCA9IHtcbiAgJ09BdXRoIDEuMCc6ICAgICAgICAgICAgJ29hdXRoMScsXG4gICdPQXV0aCAyLjAnOiAgICAgICAgICAgICdvYXV0aDInLFxuICAnQmFzaWMgQXV0aGVudGljYXRpb24nOiAnYmFzaWNBdXRoJ1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBkYXRhIG9iamVjdCBpbnRvIGEgZm9ybSBkYXRhIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gICBkYXRhXG4gKiBAcmV0dXJuIHtGb3JtRGF0YX1cbiAqL1xudmFyIHRvRm9ybURhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB2YXIgZm9ybSA9IG5ldyBGb3JtRGF0YSgpO1xuXG4gIC8vIEl0ZXJhdGUgb3ZlciBldmVyeSBwaWVjZSBvZiBkYXRhIGFuZCBhcHBlbmQgdG8gdGhlIGZvcm0gZGF0YSBvYmplY3QuXG4gIF8uZWFjaChkYXRhLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgIGZvcm0uYXBwZW5kKGtleSwgdmFsdWUpO1xuICB9KTtcblxuICByZXR1cm4gZm9ybTtcbn07XG5cbi8qKlxuICogTWFwIG1pbWUgdHlwZXMgdG8gdGhlaXIgcGFyc2Vycy5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgcGFyc2UgPSBbXG4gIFtKU09OX1JFR0VYUCwgSlNPTi5wYXJzZV0sXG4gIFsnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJywgcXMucGFyc2VdXG5dO1xuXG4vKipcbiAqIE1hcCBtaW1lIHR5cGVzIHRvIHRoZWlyIHNlcmlhbGl6ZXJzLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZhciBzZXJpYWxpemUgPSBbXG4gIFtKU09OX1JFR0VYUCwgSlNPTi5zdHJpbmdpZnldLFxuICBbJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsIHFzLnN0cmluZ2lmeV0sXG4gIFsnbXVsdGlwYXJ0L2Zvcm0tZGF0YScsIHRvRm9ybURhdGFdXG5dO1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbiBhcnJheSBvZiBtYXRjaCBhbmQgcmVzdWx0IHZhbHVlcywgYW5kIHJldHVybiB0aGVcbiAqIGZpcnN0IG1hdGNoaW5nIHZhbHVlLlxuICpcbiAqIEBwYXJhbSAge0FycmF5fSAgICBhcnJheVxuICogQHBhcmFtICB7U3RyaW5nfSAgIHRlc3RcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG52YXIgZ2V0TWF0Y2ggPSBmdW5jdGlvbiAoYXJyYXksIHRlc3QpIHtcbiAgdmFyIG1hdGNoID0gXy5maW5kKGFycmF5LCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgY2hlY2sgPSB2YWx1ZVswXTtcblxuICAgIGlmIChfLmlzUmVnRXhwKGNoZWNrKSkge1xuICAgICAgcmV0dXJuIGNoZWNrLnRlc3QodGVzdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoZWNrID09PSB0ZXN0O1xuICB9KTtcblxuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbMV07XG59O1xuXG4vKipcbiAqIFNvcnQgbWltZXMgYnkgcHJlZmVyZW5jZS5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IG1pbWVcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xudmFyIG1pbWVQcmVmZXJlbmNlID0gZnVuY3Rpb24gKG1pbWUpIHtcbiAgcmV0dXJuIGdldE1hdGNoKFtcbiAgICBbSlNPTl9SRUdFWFAsIDNdLFxuICAgIFsnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJywgMl0sXG4gICAgWydtdWx0aXBhcnQvZm9ybS1kYXRhJywgMV1cbiAgXSwgbWltZSkgfHwgMDtcbn07XG5cbi8qKlxuICogVHVybiBhIHN0cmluZyBpbnRvIGlubGluZSBjb2RlLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbnZhciBjb2RpZnlNYXJrZG93biA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuICdgJyArIHN0ciArICdgJztcbn07XG5cbi8qKlxuICogQ29udmVydCBhIHJhbWwgYm9keSBvYmplY3QgdG8gYSBtYXJrZG93biBkb2N1bWVudGF0aW9uIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IGJvZHlcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xudmFyIHJhbWxCb2R5VG9NYXJrZG93biA9IGZ1bmN0aW9uIChib2R5KSB7XG4gIHZhciBtaW1lcyAgICAgICAgID0gXy5rZXlzKGJvZHkpLnNvcnQobWltZVByZWZlcmVuY2UpO1xuICB2YXIgZG9jdW1lbnRhdGlvbiA9IFtdO1xuXG4gIC8vIElmIG11bHRpcGxlIG1pbWUgdHlwZXMgYXJlIHN1cHBvcnRlZCwgYWRkIGEgZGVmYXVsdCBtaW1lIHR5cGUgdXNhZ2Ugbm90ZS5cbiAgaWYgKG1pbWVzLmxlbmd0aCA+IDEpIHtcbiAgICBkb2N1bWVudGF0aW9uLnB1c2goXG4gICAgICAnVGhlIGJvZHkgZm9yIHRoaXMgcmVzb3VyY2Ugc3VwcG9ydHMgbXVsdGlwbGUgY29udGVudCB0eXBlcy4gQnkgJyArXG4gICAgICAnZGVmYXVsdCwgJyArIGNvZGlmeU1hcmtkb3duKG1pbWVzWzBdKSArICcgd2lsbCBiZSB1c2VkLiBIb3dldmVyLCB5b3UgJyArXG4gICAgICAnY2FuIGVhc2lseSBzcGVjaWZ5IGFub3RoZXIgYENvbnRlbnQtVHlwZWAgdG8gYmUgdXNlZC4nXG4gICAgKTtcbiAgfVxuXG4gIC8vIEl0ZXJhdGUgb3ZlciBlYWNoIG1pbWUgdHlwZSBhbmQgYXBwZW5kIGRvY3VtZW50YXRpb24uXG4gIF8uZWFjaChtaW1lcywgZnVuY3Rpb24gKG1pbWUpIHtcbiAgICB2YXIgY29udGVudFR5cGUgPSBib2R5W21pbWVdO1xuXG4gICAgLy8gQXZvaWQgYnVpbGRpbmcgZG9jdW1lbnRhdGlvbiBpZiBpdCdzIG5vdCBhbiBvYmplY3QuXG4gICAgaWYgKCFfLmlzT2JqZWN0KGNvbnRlbnRUeXBlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXJlIGFyZSBtdWx0aXBsZSBhdmFpbGFibGUgbWltZSB0eXBlcywgd2UgbmVlZCB0byBwcmVmaXggZWFjaFxuICAgIC8vIGRlZmluaXRpb24gd2l0aCBzb21lIHRleHQgYWJvdXQgdGhlIGN1cnJlbnQgbWltZSB0eXBlLlxuICAgIGlmIChtaW1lcy5sZW5ndGggPiAxKSB7XG4gICAgICBkb2N1bWVudGF0aW9uLnB1c2goXG4gICAgICAgICdXaGVuIHRoZSBjb250ZW50IHR5cGUgaXMgJyArIGNvZGlmeU1hcmtkb3duKG1pbWUpICsgJzonXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIEFwcGVuZCB0aGUgYXZhaWxhYmxlIGZvcm0gcGFyYW1ldGVycyB0byB0aGUgbWFya2Rvd24gY29udGVudC5cbiAgICBpZiAoY29udGVudFR5cGUuZm9ybVBhcmFtZXRlcnMpIHtcbiAgICAgIC8vIEl0ZXJhdGUgb3ZlciBlYWNoIGZvcm0gcGFyYW1ldGVyIGFuZCBnZW5lcmF0ZSBiYXNpYyBkb2N1bWVudGF0aW9uLlxuICAgICAgXy5lYWNoKGNvbnRlbnRUeXBlLmZvcm1QYXJhbWV0ZXJzLCBmdW5jdGlvbiAocGFyYW0sIGtleSkge1xuICAgICAgICBkb2N1bWVudGF0aW9uLnB1c2goXG4gICAgICAgICAgJyogKionICsga2V5ICsgKHBhcmFtLnJlcXVpcmVkID8gJycgOiAnPycpICsgJzoqKiAnICtcbiAgICAgICAgICAnKicgKyBwYXJhbS50eXBlICsgJyogJyArIHBhcmFtLmRlc2NyaXB0aW9uXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBQdXNoIHRoZSBleGFtcGxlIG9udG8gdGhlIGRlc2NyaXB0aW9uIGZvciByZWZlcmVuY2UuXG4gICAgaWYgKGNvbnRlbnRUeXBlLmV4YW1wbGUgfHwgY29udGVudFR5cGUuZXhhbXBsZXMpIHtcbiAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBleGFtcGxlID0gY29udGVudFR5cGUuZXhhbXBsZSB8fCB1c2VyZnJpZW5kbGlmeUV4YW1wbGVzKGNvbnRlbnRUeXBlLmV4YW1wbGVzKTtcbiAgICAgICAgaWYgKHR5cGVvZiBleGFtcGxlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIGV4YW1wbGUgPSBKU09OLnN0cmluZ2lmeShleGFtcGxlLCBudWxsLCAyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvY3VtZW50YXRpb24ucHVzaChcbiAgICAgICAgICAnKipFeGFtcGxlKHMpOioqJyxcbiAgICAgICAgICAnYGBgXFxuJyArIGV4YW1wbGUgKyAnXFxuYGBgJ1xuICAgICAgICApO1xuICAgICAgfSkoKTtcbiAgICB9XG5cbiAgICAvLyBQdXNoIHRoZSBzY2hlbWEgb250byB0aGUgZGVzY3JpcHRpb24gZm9yIHJlZmVyZW5jZS5cbiAgICBpZiAoY29udGVudFR5cGUuc2NoZW1hKSB7XG4gICAgICBkb2N1bWVudGF0aW9uLnB1c2goXG4gICAgICAgICcqKlNjaGVtYToqKicsXG4gICAgICAgICdgYGBcXG4nICsgY29udGVudFR5cGUuc2NoZW1hICsgJ1xcbmBgYCdcbiAgICAgICk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZG9jdW1lbnRhdGlvbi5qb2luKCdcXG5cXG4nKTtcbn07XG5cbnZhciB1c2VyZnJpZW5kbGlmeUV4YW1wbGVzID0gZnVuY3Rpb24gKGV4YW1wbGVzKSB7XG4gIHZhciBuZXdFeGFtcGxlcyA9IHt9O1xuXG4gIGV4YW1wbGVzLmZvckVhY2goZnVuY3Rpb24gKGV4YW1wbGUsIGluZGV4KSB7XG4gICAgbmV3RXhhbXBsZXNbZXhhbXBsZS5uYW1lIHx8ICgnRXhhbXBsZSAjJyArIGluZGV4ICsgMSldID0gZXhhbXBsZS52YWx1ZS5jb250ZW50IHx8IGV4YW1wbGUudmFsdWU7XG4gIH0pO1xuXG4gIHJldHVybiBuZXdFeGFtcGxlcztcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBtZXRob2QgaXMgYSBxdWVyeSBtZXRob2QgKG5vdCBhIGJvZHkgYXMgdGhlIGFyZ3VtZW50KS5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICBtZXRob2RcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbnZhciBpc1F1ZXJ5TWV0aG9kID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuICByZXR1cm4gbWV0aG9kID09PSAnZ2V0JyB8fCBtZXRob2QgPT09ICdoZWFkJztcbn07XG5cbi8qKlxuICogTWFwIG9mIG1ldGhvZHMgdG8gdGhlaXIgdG9vbHRpcCBkZXNjcmlwdGlvbiBvYmplY3RzLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZhciBNRVRIT0RfREVTQ1JJUFRJT04gPSBfLm9iamVjdChfLm1hcChIVFRQX01FVEhPRFMsIGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgdmFyIGJvZHkgPSBpc1F1ZXJ5TWV0aG9kKG1ldGhvZCkgPyAncXVlcnk/JyA6ICdib2R5Pyc7XG5cbiAgcmV0dXJuIFttZXRob2QsIHtcbiAgICAnIXR5cGUnOiAnZm4oJyArIGJvZHkgKyAnLCBvcHRpb25zPywgYXN5bmM/KSdcbiAgfV07XG59KSk7XG5cbi8qKlxuICogQ29udmVydCBhIHJhbWwgb2JqZWN0IGludG8gYSBkb2N1bWVudGF0aW9uIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG52YXIgcmFtbFRvRG9jdW1lbnRhdGlvbkZvcm1hdCA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgdmFyIGRvY3VtZW50YXRpb24gPSB7fTtcblxuICAvLyBJdGVyYXRlIG92ZXIgZWFjaCBrZXkgYW5kIHdpcGUgb3V0IHdpcGUgYSBjbGVhbiBkb2N1bWVudGF0aW9uIG9iamVjdC5cbiAgXy5lYWNoKG9iamVjdCwgZnVuY3Rpb24gKG9iamVjdCwga2V5KSB7XG4gICAgZG9jdW1lbnRhdGlvbltrZXldID0ge1xuICAgICAgJyFkb2MnOiAgICAgIG9iamVjdC5kZXNjcmlwdGlvbixcbiAgICAgICchdHlwZSc6ICAgICBvYmplY3QudHlwZSxcbiAgICAgICchcmVxdWlyZWQnOiBvYmplY3QucmVxdWlyZWRcbiAgICB9O1xuICB9KTtcblxuICByZXR1cm4gZG9jdW1lbnRhdGlvbjtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtIGEgUkFNTCBtZXRob2Qgb2JqZWN0IGludG8gYSB0b29sdGlwIGRvY3VtZW50YXRpb24gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSAge0FycmF5fSAgbm9kZXNcbiAqIEBwYXJhbSAge09iamVjdH0gbWV0aG9kXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbnZhciB0b01ldGhvZERlc2NyaXB0aW9uID0gZnVuY3Rpb24gKG5vZGVzLCBtZXRob2QpIHtcbiAgdmFyIGlzUXVlcnkgICAgICAgPSBpc1F1ZXJ5TWV0aG9kKG1ldGhvZC5tZXRob2QpO1xuICB2YXIgY29uZmlnT3B0aW9ucyA9IHsgJyF0eXBlJzogJ29iamVjdCcgfTtcbiAgdmFyIGJvZHlPcHRpb25zICAgPSB7ICchdHlwZSc6ICdvYmplY3QnIH07XG5cbiAgdmFyIGNhbGxiYWNrT3B0aW9ucyA9IHtcbiAgICAnIWRvYyc6ICAnUGFzcyBhIGZ1bmN0aW9uIHRvIG1ha2UgdGhlIHJlcXVlc3QgZXhlY3V0ZSBhc3luY2hvbm91c2x5LicsXG4gICAgJyF0eXBlJzogJ2ZuKGVycm9yLCByZXNwb25zZSknXG4gIH07XG5cbiAgLy8gQWRkIGRvY3VtZW50YXRpb24gb24gdGhlIHByb3h5LlxuICBjb25maWdPcHRpb25zLnByb3h5ID0ge1xuICAgICchdHlwZSc6ICdzdHJpbmd8Ym9vbGVhbicsXG4gICAgJyFkb2MnOiAgJ0Rpc2FibGUgb3Igc2V0IGEgY3VzdG9tIHByb3h5IHVybCBmb3IgdGhlIGN1cnJlbnQgcmVxdWVzdC4nXG4gIH07XG5cbiAgLy8gRG9jdW1lbnQgdGhlIGBiZWZvcmVTZW5kYCBhYmlsaXR5LlxuICBjb25maWdPcHRpb25zLmJlZm9yZVNlbmQgPSB7XG4gICAgJyF0eXBlJzogJ2ZuKHhociknLFxuICAgICchZG9jJzogICdNb2RpZnkgdGhlIGBYTUxIdHRwUmVxdWVzdGAgYmVmb3JlIGl0IGdldHMgc2VudC4nXG4gIH07XG5cbiAgLy8gQWRkIGRvY3VtZW50YXRpb24gb24gaGVhZGVyIHBhcmFtZXRlcnMuXG4gIGNvbmZpZ09wdGlvbnMuaGVhZGVycyA9IF8uZXh0ZW5kKHtcbiAgICAnIXR5cGUnOiAnb2JqZWN0J1xuICB9LCByYW1sVG9Eb2N1bWVudGF0aW9uRm9ybWF0KG1ldGhvZC5oZWFkZXJzKSk7XG5cbiAgLy8gSWYgdGhlIG1ldGhvZCBpcyBhIHF1ZXJ5IG1ldGhvZCAoR0VUL0hFQUQpLCBzZXQgdGhlIGJvZHkgYXMgYSBjb25maWcgb3B0aW9uXG4gIC8vIGFuZCB2aXNlIHZlcnNhLlxuICBpZiAoaXNRdWVyeSkge1xuICAgIF8uZXh0ZW5kKGJvZHlPcHRpb25zLCByYW1sVG9Eb2N1bWVudGF0aW9uRm9ybWF0KG1ldGhvZC5xdWVyeVBhcmFtZXRlcnMpKTtcblxuICAgIGNvbmZpZ09wdGlvbnMuYm9keSA9IHtcbiAgICAgICchdHlwZSc6ICdvYmplY3QnLFxuICAgICAgJyFkb2MnOiAgcmFtbEJvZHlUb01hcmtkb3duKG1ldGhvZC5ib2R5KVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgYm9keU9wdGlvbnMgPSB7XG4gICAgICAnIXR5cGUnOiAnb2JqZWN0fHN0cmluZycsXG4gICAgICAnIWRvYyc6ICByYW1sQm9keVRvTWFya2Rvd24obWV0aG9kLmJvZHkpLFxuICAgIH07XG5cbiAgICBjb25maWdPcHRpb25zLnF1ZXJ5ID0gXy5leHRlbmQoe1xuICAgICAgJyF0eXBlJzogJ29iamVjdCdcbiAgICB9LCByYW1sVG9Eb2N1bWVudGF0aW9uRm9ybWF0KG1ldGhvZC5xdWVyeVBhcmFtZXRlcnMpKTtcbiAgfVxuXG4gIC8vIElmIHRoZSBjdXJyZW50IG5vZGUgaGFzIGJhc2VVcmlQYXJhbWV0ZXJzLCBzaG93IGl0IGluIHRoZSBkb2N1bWVudGF0aW9uLlxuICBpZiAobm9kZXMuY2xpZW50LmJhc2VVcmlQYXJhbWV0ZXJzKSB7XG4gICAgY29uZmlnT3B0aW9ucy5iYXNlVXJpUGFyYW1ldGVycyA9IF8uZXh0ZW5kKHtcbiAgICAgICchdHlwZSc6ICdvYmplY3QnXG4gICAgfSwgcmFtbFRvRG9jdW1lbnRhdGlvbkZvcm1hdChub2Rlcy5jbGllbnQuYmFzZVVyaVBhcmFtZXRlcnMpKTtcbiAgfVxuXG4gIHJldHVybiBfLmV4dGVuZCh7XG4gICAgJyFkb2MnOiAgbWV0aG9kLmRlc2NyaXB0aW9uLFxuICAgICchYXJncyc6IFtib2R5T3B0aW9ucywgY29uZmlnT3B0aW9ucywgY2FsbGJhY2tPcHRpb25zXVxuICB9LCBNRVRIT0RfREVTQ1JJUFRJT05bbWV0aG9kLm1ldGhvZF0pO1xufTtcblxuLyoqXG4gKiBMaXN0IG9mIGFsbCBwbGFpbiBIVFRQIG1ldGhvZHMgaW4gdGhlIGZvcm1hdCBmcm9tIHRoZSBBU1QuXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqL1xudmFyIGFsbEh0dHBNZXRob2RzID0gXy5jaGFpbihIVFRQX01FVEhPRFMpLm1hcChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgcmV0dXJuIFttZXRob2QsIHtcbiAgICAgIG1ldGhvZDogbWV0aG9kXG4gICAgfV07XG4gIH0pLm9iamVjdCgpLnZhbHVlKCk7XG5cbi8qKlxuICogUGFyc2UgYW4gWEhSIHJlcXVlc3QgZm9yIHJlc3BvbnNlIGhlYWRlcnMgYW5kIHJldHVybiBhcyBhbiBvYmplY3QuIFBhc3MgYW5cbiAqIGFkZGl0aW9uYWwgZmxhZyB0byBmaWx0ZXIgYW55IHBvdGVudGlhbCBkdXBsaWNhdGUgaGVhZGVycyAoRS5nLiBkaWZmZXJlbnRcbiAqIGNhc2VzKS5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IHhoclxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG52YXIgZ2V0QWxsUmVwb25zZUhlYWRlcnMgPSBmdW5jdGlvbiAoeGhyKSB7XG4gIHZhciByZXNwb25zZUhlYWRlcnMgPSB7fTtcblxuICBfLmVhY2goeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpLnNwbGl0KCdcXG4nKSwgZnVuY3Rpb24gKGhlYWRlcikge1xuICAgIGhlYWRlciA9IGhlYWRlci5zcGxpdCgnOicpO1xuXG4gICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgYm90aCBwYXJ0cyBvZiB0aGUgaGVhZGVyLlxuICAgIGlmIChoZWFkZXIubGVuZ3RoID4gMSkge1xuICAgICAgdmFyIG5hbWUgID0gaGVhZGVyLnNoaWZ0KCk7XG4gICAgICB2YXIgdmFsdWUgPSBoZWFkZXIuam9pbignOicpLnRyaW0oKTtcblxuICAgICAgcmVzcG9uc2VIZWFkZXJzW25hbWUudG9Mb3dlckNhc2UoKV0gPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiByZXNwb25zZUhlYWRlcnM7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgeGhyIHJlc3BvbnNlIG1pbWUgdHlwZS5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGNvbnRlbnRUeXBlXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbnZhciBnZXRNaW1lID0gZnVuY3Rpb24gKGNvbnRlbnRUeXBlKSB7XG4gIHJldHVybiBjb250ZW50VHlwZSA9PSBudWxsID8gbnVsbCA6IFN0cmluZyhjb250ZW50VHlwZSkuc3BsaXQoJzsnKVswXTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gb2JqZWN0IGlzIGEgaG9zdCBvYmplY3QgYW5kIGF2b2lkIHNlcmlhbGl6aW5nLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gIG9ialxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzSG9zdCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHN0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopO1xuXG4gIHN3aXRjaCAoc3RyKSB7XG4gICAgY2FzZSAnW29iamVjdCBGaWxlXSc6XG4gICAgY2FzZSAnW29iamVjdCBCbG9iXSc6XG4gICAgY2FzZSAnW29iamVjdCBTdHJpbmddJzpcbiAgICBjYXNlICdbb2JqZWN0IE51bWJlcl0nOlxuICAgIGNhc2UgJ1tvYmplY3QgQm9vbGVhbl0nOlxuICAgIGNhc2UgJ1tvYmplY3QgRm9ybURhdGFdJzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8qKlxuICogU2FuaXRpemUgYSBzcGVjaWZpYyBjb25maWd1cmF0aW9uIG9wdGlvbi5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgc2FuaXRpemVPcHRpb24gPSB7XG4gIHF1ZXJ5OiBmdW5jdGlvbiAocXVlcnkpIHtcbiAgICBpZiAoXy5pc1N0cmluZyhxdWVyeSkpIHtcbiAgICAgIHJldHVybiBxcy5wYXJzZShxdWVyeSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHF1ZXJ5O1xuICB9XG59O1xuXG4vKipcbiAqIEdldHMgYSBoZWFkZXIgZnJvbSB0aGUgaGVhZGVyIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9ICBoZWFkZXJzXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICBoZWFkZXJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbnZhciBmaW5kSGVhZGVyID0gZnVuY3Rpb24gKGhlYWRlcnMsIGhlYWRlcikge1xuICBoZWFkZXIgPSBoZWFkZXIudG9Mb3dlckNhc2UoKTtcblxuICByZXR1cm4gXy5maW5kKGhlYWRlcnMsIGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSkge1xuICAgIHJldHVybiBuYW1lLnRvTG93ZXJDYXNlKCkgPT09IGhlYWRlcjtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFNhbml0aXplIHRoZSBYSFIgcmVxdWVzdCBpbnRvIHRoZSBkZXNpcmVkIGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0gIHtYTUxIdHRwUmVxdWVzdH0geGhyXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbnZhciBzYW5pdGl6ZVhIUiA9IGZ1bmN0aW9uICh4aHIpIHtcbiAgaWYgKCF4aHIpIHsgcmV0dXJuIHhocjsgfVxuXG4gIHZhciBtaW1lICAgID0gZ2V0TWltZSh4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ0NvbnRlbnQtVHlwZScpKTtcbiAgdmFyIGJvZHkgICAgPSB4aHIucmVzcG9uc2VUZXh0LnRyaW0oKTtcbiAgdmFyIGhlYWRlcnMgPSBnZXRBbGxSZXBvbnNlSGVhZGVycyh4aHIpO1xuXG4gIC8vIEF1dG9tYXRpY2FsbHkgcGFyc2UgYWxsIHJlc3BvbnNlIGJvZGllcy4gT25seSBwYXJzZSB3aGVuIHdlIGhhdmUgcmVzcG9uc2VcbiAgLy8gYm9keSBjb250ZW50LiBFcnJvcnMgdGhhdCBvY2N1ciBwYXJzaW5nIHdpbGwgYmUgcHJvcGFnYXRlZCB0byB0aGUgY2xpZW50LlxuICBib2R5ID0gYm9keSA/IChnZXRNYXRjaChwYXJzZSwgbWltZSkgfHwgXy5pZGVudGl0eSkoYm9keSkgOiB1bmRlZmluZWQ7XG5cbiAgcmV0dXJuIHtcbiAgICBib2R5OiAgICBib2R5LFxuICAgIHN0YXR1czogIHhoci5zdGF0dXMsXG4gICAgaGVhZGVyczogaGVhZGVyc1xuICB9O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBtYWtlIGFqYXggcmVxdWVzdHMuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSAgIHVybFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cbnZhciBodHRwUmVxdWVzdCA9IGZ1bmN0aW9uIChub2RlcywgbWV0aG9kKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoYm9keSwgY29uZmlnLCBkb25lKSB7XG4gICAgLy8gQWxsb3cgY29uZmlnIHRvIGJlIG9taXR0ZWQgZnJvbSBhcmd1bWVudHMuXG4gICAgaWYgKF8uaXNGdW5jdGlvbihhcmd1bWVudHNbMV0pKSB7XG4gICAgICBkb25lICAgPSBhcmd1bWVudHNbMV07XG4gICAgICBjb25maWcgPSBudWxsO1xuICAgIH1cblxuICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblxuICAgIC8vIE1hcCBjb25maWd1cmF0aW9uIG9wdGlvbnMgYW5kIG1lcmdlIHdpdGggdGhlIHBhc3NlZCBpbiBvYmplY3QuXG4gICAgY29uZmlnID0gXy5vYmplY3QoQ09ORklHX09QVElPTlMsIF8ubWFwKENPTkZJR19PUFRJT05TLCBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICBpZiAoXy5oYXMoT1ZFUlJJREFCTEVfQ09ORklHX09QVElPTlMsIG9wdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIF8uaGFzKGNvbmZpZywgb3B0aW9uKSA/IGNvbmZpZ1tvcHRpb25dIDogbm9kZXMuY29uZmlnW29wdGlvbl07XG4gICAgICB9XG5cbiAgICAgIHZhciBub2RlT3B0aW9uICAgPSBub2Rlcy5jb25maWdbb3B0aW9uXTtcbiAgICAgIHZhciBjb25maWdPcHRpb24gPSBjb25maWcgJiYgY29uZmlnW29wdGlvbl07XG4gICAgICB2YXIgc2FuaXRpemUgICAgID0gc2FuaXRpemVPcHRpb25bb3B0aW9uXSB8fCBfLmlkZW50aXR5O1xuXG4gICAgICByZXR1cm4gXy5leHRlbmQoe30sIHNhbml0aXplKG5vZGVPcHRpb24pLCBzYW5pdGl6ZShjb25maWdPcHRpb24pKTtcbiAgICB9KSk7XG5cbiAgICB2YXIgYXN5bmMgICA9ICEhZG9uZTtcbiAgICB2YXIgcmVxdWVzdCA9ICdhamF4JztcbiAgICB2YXIgbWltZSAgICA9IGdldE1pbWUoZmluZEhlYWRlcihjb25maWcuaGVhZGVycywgJ0NvbnRlbnQtVHlwZScpKTtcbiAgICB2YXIgYmFzZVVyaSA9IHRlbXBsYXRlKGNvbmZpZy5iYXNlVXJpLCBjb25maWcuYmFzZVVyaVBhcmFtZXRlcnMpO1xuICAgIHZhciBmdWxsVXJpID0gYmFzZVVyaS5yZXBsYWNlKC9cXC8rJC8sICcnKSArICcvJyArIG5vZGVzLmpvaW4oJy8nKTtcblxuICAgIC8vIElmIHRoZSByZXF1ZXN0IGlzIGFzeW5jLCBzZXQgdGhlIHJlbGV2YW50IGZ1bmN0aW9uIGNhbGxiYWNrcy5cbiAgICBpZiAoYXN5bmMpIHtcbiAgICAgIEFwcC5fZXhlY3V0ZUNvbnRleHQudGltZW91dChJbmZpbml0eSk7XG5cbiAgICAgIGlmICghXy5pc0Z1bmN0aW9uKGRvbmUpKSB7XG4gICAgICAgIGRvbmUgPSBBcHAuX2V4ZWN1dGVDb250ZXh0LmFzeW5jKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN5bmNocm9ub3VzIGVycm9yIGFuZCByZXNwb25zZSBoYW5kbGluZy5cbiAgICAgIGRvbmUgPSBmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIEdFVCBhbmQgSEVBRCByZXF1ZXN0cyBhY2NlcHQgdGhlIHF1ZXJ5IHN0cmluZyBhcyB0aGUgZmlyc3QgYXJndW1lbnQuXG4gICAgaWYgKGlzUXVlcnlNZXRob2QobWV0aG9kLm1ldGhvZCkpIHtcbiAgICAgIF8uZXh0ZW5kKGNvbmZpZy5xdWVyeSwgc2FuaXRpemVPcHRpb24ucXVlcnkoYm9keSkpO1xuICAgICAgYm9keSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU2V0IHRoZSBjb25maWcgb2JqZWN0IGJvZHkgdG8gdGhlIHBhc3NlZCBpbiBib2R5LlxuICAgIGlmIChib2R5ICE9IG51bGwpIHtcbiAgICAgIGNvbmZpZy5ib2R5ID0gYm9keTtcbiAgICB9XG5cbiAgICAvLyBBcHBlbmQgdGhlIHF1ZXJ5IHN0cmluZyBpZiBvbmUgaXMgYXZhaWxhYmxlLlxuICAgIGlmIChfLmtleXMoY29uZmlnLnF1ZXJ5KS5sZW5ndGgpIHtcbiAgICAgIGZ1bGxVcmkgKz0gJz8nICsgcXMuc3RyaW5naWZ5KGNvbmZpZy5xdWVyeSk7XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgaGF2ZSBubyBhY2NlcHQgaGVhZGVyIHNldCBhbHJlYWR5LCBkZWZhdWx0IHRvIGFjY2VwdGluZ1xuICAgIC8vIGV2ZXJ5dGhpbmcuIFRoaXMgaXMgcmVxdWlyZWQgYmVjYXVzZSBGaXJlZm94IHNldHMgdGhlIGJhc2UgYWNjZXB0XG4gICAgLy8gaGVhZGVyIHRvIGVzc2VudGlhbGx5IGJlIGBodG1sL3htbGAuXG4gICAgaWYgKCFmaW5kSGVhZGVyKGNvbmZpZy5oZWFkZXJzLCAnYWNjZXB0JykpIHtcbiAgICAgIGNvbmZpZy5oZWFkZXJzLmFjY2VwdCA9ICcqLyonO1xuICAgIH1cblxuICAgIC8vIElmIHdlIHdlcmUgcGFzc2VkIGluIGRhdGEsIGF0dGVtcHQgdG8gc2FuaXRpemUgaXQgdG8gdGhlIGNvcnJlY3QgdHlwZS5cbiAgICBpZiAoIWlzSG9zdChjb25maWcuYm9keSkpIHtcbiAgICAgIC8vIFNldCB0aGUgY29ycmVjdCBgQ29udGVudC1UeXBlYCBoZWFkZXIsIGlmIG5vbmUgZXhpc3RzLiBLaW5kIG9mIHJhbmRvbVxuICAgICAgLy8gaWYgbW9yZSB0aGFuIG9uZSBleGlzdHMgLSBJIHdvdWxkIHN1Z2dlc3Qgc2V0dGluZyBpdCB5b3Vyc2VsZi5cbiAgICAgIGlmIChtaW1lID09IG51bGwpIHtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIG1ldGhvZCBib2R5IG9iamVjdCwgc29ydCB0aGUgbWV0aG9kIHR5cGVzIGJ5IG1vc3RcbiAgICAgICAgLy8gZGVzaXJhYmxlIGFuZCBmYWxsYmFjayB0byBhIHJhbmRvbSBjb250ZW50IHR5cGUuXG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kLmJvZHkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgbWltZSA9IF8ua2V5cyhtZXRob2QuYm9keSkuc29ydChtaW1lUHJlZmVyZW5jZSkucG9wKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgdGhlIGNvbmZpZyB0byB0aGUgdXBkYXRlZCBtaW1lIHR5cGUgaGVhZGVyLiBJZiBub25lIGV4aXN0cywgdXNlXG4gICAgICAgIC8vIGBhcHBsaWNhdGlvbi9qc29uYCBieSBkZWZhdWx0LlxuICAgICAgICBjb25maWcuaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSBtaW1lID0gbWltZSB8fCAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICB9XG5cbiAgICAgIC8vIEF1dG9tYXRpY2FsbHkgYXR0ZW1wdCB0byBzZXJpYWxpemUgdGhlIGJvZHkuXG4gICAgICB2YXIgc2VyaWFsaXplciA9IGdldE1hdGNoKHNlcmlhbGl6ZSwgbWltZSk7XG5cbiAgICAgIGlmICghc2VyaWFsaXplcikge1xuICAgICAgICByZXR1cm4gZG9uZShcbiAgICAgICAgICBuZXcgVHlwZUVycm9yKCdDYW4gbm90IHNlcmlhbGl6ZSBjb250ZW50IHR5cGUgb2YgXCInICsgbWltZSArICdcIicpXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbmZpZy5ib2R5ID0gc2VyaWFsaXplcihjb25maWcuYm9keSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBkb25lKG5ldyBUeXBlRXJyb3IoJ0NvdWxkIG5vdCBzZXJpYWxpemUgYm9keTogJyArIGUubWVzc2FnZSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgdXJsOiAgICAgICAgZnVsbFVyaSxcbiAgICAgIGRhdGE6ICAgICAgIGNvbmZpZy5ib2R5LFxuICAgICAgYXN5bmM6ICAgICAgYXN5bmMsXG4gICAgICBwcm94eTogICAgICBjb25maWcucHJveHksXG4gICAgICBtZXRob2Q6ICAgICBtZXRob2QubWV0aG9kLFxuICAgICAgaGVhZGVyczogICAgY29uZmlnLmhlYWRlcnMsXG4gICAgICBiZWZvcmVTZW5kOiBjb25maWcuYmVmb3JlU2VuZFxuICAgIH07XG5cbiAgICAvLyBJdGVyYXRlIHRocm91Z2ggYHNlY3VyZWRCeWAgbWV0aG9kcyBhbmQgYWNjZXB0IHRoZSBmaXJzdCBvbmUgd2UgYXJlXG4gICAgLy8gYWxyZWFkeSBhdXRoZW50aWNhdGVkIGZvci5cbiAgICBfLnNvbWUobWV0aG9kLnNlY3VyZWRCeSB8fCBub2Rlcy5jbGllbnQuc2VjdXJlZEJ5LCBmdW5jdGlvbiAoc2VjdXJlZCwga2V5KSB7XG4gICAgICB2YXIgc2NoZW1lID0gbm9kZXMuY2xpZW50LnNlY3VyaXR5U2NoZW1lc1trZXldO1xuXG4gICAgICAvLyBTY2hlbWUgaXMgbm90IGRvY3VtZW50ZWQgaW4gdGhlIFJBTUwgc2VjdXJpdHkgc2NoZW1lcy5cbiAgICAgIGlmICghc2NoZW1lKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGF1dGhlbnRpY2F0ZWQgPSBub2Rlcy5jbGllbnQuYXV0aGVudGljYXRpb25bc2NoZW1lLnR5cGVdO1xuICAgICAgdmFyIGF1dGhUeXBlICAgICAgPSBhdXRoTWFwW3NjaGVtZS50eXBlXTtcblxuICAgICAgaWYgKGF1dGhlbnRpY2F0ZWQpIHtcbiAgICAgICAgb3B0aW9uc1thdXRoVHlwZV0gPSBhdXRoZW50aWNhdGVkO1xuXG4gICAgICAgIHJldHVybiAocmVxdWVzdCA9ICdhamF4OicgKyBhdXRoVHlwZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBBd2t3YXJkIHN5bmMgYW5kIGFzeW5jIGNvZGUgbWl4aW5nLlxuICAgIHZhciByZXNwb25zZSwgZXJyb3I7XG5cbiAgICAvLyBUcmlnZ2VyIHRoZSBhamF4IG1pZGRsZXdhcmUgc28gcGx1Z2lucyBjYW4gaG9vayBvbnRvIHRoZSByZXF1ZXN0cy4gSWZcbiAgICAvLyB0aGUgZnVuY3Rpb24gaXMgYXN5bmMgd2UgbmVlZCB0byByZWdpc3RlciBhIGNhbGxiYWNrIGZvciB0aGUgbWlkZGxld2FyZS5cbiAgICBBcHAubWlkZGxld2FyZS50cmlnZ2VyKHJlcXVlc3QsIG9wdGlvbnMsIGZ1bmN0aW9uIChlcnIsIHhocikge1xuICAgICAgZXJyb3IgPSBlcnI7XG5cbiAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXNwb25zZSA9IHNhbml0aXplWEhSKHhocik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBUeXBlRXJyb3IoJ0NvdWxkIG5vdCBwYXJzZSByZXNwb25zZTogJyArIGUubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFzeW5jICYmIGRvbmUoZXJyb3IsIHJlc3BvbnNlKTtcbiAgICB9KTtcblxuICAgIC8vIElmIHRoZSByZXF1ZXN0IHdhcyBzeW5jaHJvbm91cywgcmV0dXJuIHRoZSBzYW5pdGl6ZWQgWEhSIHJlc3BvbnNlIGRhdGEuXG4gICAgaWYgKCFhc3luYykge1xuICAgICAgcmV0dXJuIGRvbmUoZXJyb3IsIHJlc3BvbnNlKTtcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIEF0dGFjaGVzIFhIUiByZXF1ZXN0IG1ldGhvZHMgdG8gdGhlIGNvbnRleHQgb2JqZWN0IGZvciBlYWNoIGF2YWlsYWJsZSBtZXRob2QuXG4gKlxuICogQHBhcmFtICB7QXJyYXl9ICBub2Rlc1xuICogQHBhcmFtICB7T2JqZWN0fSBjb250ZXh0XG4gKiBAcGFyYW0gIHtPYmplY3R9IG1ldGhvZHNcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xudmFyIGF0dGFjaE1ldGhvZHMgPSBmdW5jdGlvbiAobm9kZXMsIGNvbnRleHQsIG1ldGhvZHMpIHtcbiAgLy8gQXR0YWNoIHRoZSBhdmFpbGFibGUgbWV0aG9kcyB0byB0aGUgY3VycmVudCBjb250ZXh0LlxuICBfLmVhY2gobWV0aG9kcywgZnVuY3Rpb24gKG1ldGhvZCwgdmVyYikge1xuICAgIGNvbnRleHRbdmVyYl0gPSBodHRwUmVxdWVzdChub2RlcywgbWV0aG9kKTtcbiAgICBjb250ZXh0W3ZlcmJdW0RFU0NSSVBUSU9OX1BST1BFUlRZXSA9IHRvTWV0aG9kRGVzY3JpcHRpb24obm9kZXMsIG1ldGhvZCk7XG4gIH0pO1xuXG4gIHJldHVybiBjb250ZXh0O1xufTtcblxuLyoqXG4gKiBBdHRhY2ggYSBzcGVjaWFsIG1lZGlhIGV4dGVuc2lvbiBoYW5kbGVyLlxuICpcbiAqIEBwYXJhbSAge0FycmF5fSAgbm9kZXNcbiAqIEBwYXJhbSAge09iamVjdH0gY29udGV4dFxuICogQHBhcmFtICB7T2JqZWN0fSByZXNvdXJjZVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG52YXIgYXR0YWNoTWVkaWFUeXBlRXh0ZW5zaW9uID0gZnVuY3Rpb24gKG5vZGVzLCBjb250ZXh0LCByZXNvdXJjZSkge1xuICAvKipcbiAgICogUHVzaCB0aGUgZXh0ZW5zaW9uIG9udG8gdGhlIGN1cnJlbnQgcm91dGUgYW5kIHNldCByZWxldmFudCBoZWFkZXJzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGV4dGVuc2lvblxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBjb250ZXh0LmV4dGVuc2lvbiA9IGZ1bmN0aW9uIChleHRlbnNpb24pIHtcbiAgICBleHRlbnNpb24gPSBleHRlbnNpb24gPT0gbnVsbCA/ICcnIDogU3RyaW5nKGV4dGVuc2lvbik7XG5cbiAgICAvLyBQcmVwZW5kIGEgcGVyaW9kIHRvIHRoZSBleHRlbnNpb24gYmVmb3JlIGFkZGluZyB0byB0aGUgcm91dGUuXG4gICAgaWYgKGV4dGVuc2lvbiAmJiBleHRlbnNpb24uY2hhckF0KDApICE9PSAnLicpIHtcbiAgICAgIGV4dGVuc2lvbiA9ICcuJyArIGV4dGVuc2lvbjtcbiAgICB9XG5cbiAgICB2YXIgbmV3Q29udGV4dCA9IHt9O1xuICAgIHZhciByb3V0ZU5vZGVzID0gXy5leHRlbmQoW10sIG5vZGVzKTtcblxuICAgIC8vIEFwcGVuZCB0aGUgZXh0ZW5zaW9uIHRvIHRoZSBjdXJyZW50IHJvdXRlLlxuICAgIHJvdXRlTm9kZXNbcm91dGVOb2Rlcy5sZW5ndGggLSAxXSArPSBleHRlbnNpb247XG5cbiAgICBhdHRhY2hNZXRob2RzKHJvdXRlTm9kZXMsIG5ld0NvbnRleHQsIHJlc291cmNlLm1ldGhvZHMpO1xuICAgIGF0dGFjaFJlc291cmNlcyhyb3V0ZU5vZGVzLCBuZXdDb250ZXh0LCByZXNvdXJjZS5yZXNvdXJjZXMpO1xuXG4gICAgcmV0dXJuIG5ld0NvbnRleHQ7XG4gIH07XG5cbiAgLy8gQXR0YWNoIGEgZGVzY3JpcHRpb24gYW5kIHJldHVybiBwcm9wZXJ0eS5cbiAgY29udGV4dC5leHRlbnNpb25bUkVUVVJOX1BST1BFUlRZXSAgICAgID0gY29udGV4dC5leHRlbnNpb24oJycpO1xuICBjb250ZXh0LmV4dGVuc2lvbltERVNDUklQVElPTl9QUk9QRVJUWV0gPSBFWFRFTlNJT05fREVTQ1JJUFRJT047XG5cbiAgLy8gSWYgdGhlIG1lZGlhIHR5cGUgZXh0ZW5zaW9uIGlzIG5vdCByZXF1aXJlZCwgYWxsb3cgZGlyZWN0IGludm9jYXRpb24gb2ZcbiAgLy8gdGhlIHJlcXVlc3QgbWV0aG9kLlxuICBpZiAocmVzb3VyY2UudXJpUGFyYW1ldGVycy5tZWRpYVR5cGVFeHRlbnNpb24ucmVxdWlyZWQgPT09IGZhbHNlKSB7XG4gICAgYXR0YWNoTWV0aG9kcyhub2RlcywgY29udGV4dCwgcmVzb3VyY2UubWV0aG9kcyk7XG4gIH1cblxuICAvLyBJdGVyYXRlIG92ZXIgdGhlIGVudW0gb3B0aW9ucyBhbmQgYXV0b21hdGljYWxseSBhdHRhY2ggdG8gdGhlIGNvbnRleHQuXG4gIF8uZWFjaChyZXNvdXJjZS51cmlQYXJhbWV0ZXJzLm1lZGlhVHlwZUV4dGVuc2lvbi5lbnVtLCBmdW5jdGlvbiAoZXh0ZW5zaW9uKSB7XG4gICAgaWYgKGV4dGVuc2lvbi5jaGFyQXQoMCkgPT09ICcuJykge1xuICAgICAgZXh0ZW5zaW9uID0gZXh0ZW5zaW9uLnN1YnN0cigxKTtcbiAgICB9XG5cbiAgICBjb250ZXh0W2V4dGVuc2lvbl0gPSBjb250ZXh0LmV4dGVuc2lvbihleHRlbnNpb24pO1xuICB9KTtcblxuICByZXR1cm4gY29udGV4dDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgYSBjb250ZXh0IG9yIGF0dGFjaCBtZXRob2RzIGFuZCByZXNvdXJjZXMgdG8gYW4gZXhpc3RpbmcgY29udGV4dC5cbiAqXG4gKiBAcGFyYW0gIHtBcnJheX0gICBub2Rlc1xuICogQHBhcmFtICB7T2JqZWN0fSAgcmVzb3VyY2VcbiAqIEBwYXJhbSAge0Jvb2xlYW59IGhhc01lZGlhRXh0ZW5zaW9uXG4gKiBAcGFyYW0gIHtPYmplY3R9ICBjb250ZXh0XG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbnZhciBuZXdDb250ZXh0ID0gZnVuY3Rpb24gKG5vZGVzLCByZXNvdXJjZSwgaGFzTWVkaWFFeHRlbnNpb24sIGNvbnRleHQpIHtcbiAgY29udGV4dCA9IGNvbnRleHQgfHwge307XG5cbiAgaWYgKGhhc01lZGlhRXh0ZW5zaW9uKSB7XG4gICAgYXR0YWNoTWVkaWFUeXBlRXh0ZW5zaW9uKG5vZGVzLCBjb250ZXh0LCByZXNvdXJjZSk7XG4gIH0gZWxzZSB7XG4gICAgYXR0YWNoTWV0aG9kcyhub2RlcywgY29udGV4dCwgcmVzb3VyY2UubWV0aG9kcyk7XG4gICAgYXR0YWNoUmVzb3VyY2VzKG5vZGVzLCBjb250ZXh0LCByZXNvdXJjZS5yZXNvdXJjZXMpO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRleHQ7XG59O1xuXG4vKipcbiAqIFJlY3Vyc2VzIHRocm91Z2ggYSByZXNvdXJjZSBvYmplY3QgaW4gdGhlIFJBTUwgQVNULCBnZW5lcmF0aW5nIGEgZHluYW1pY1xuICogRFNMIHRoYXQgb25seSBhbGxvd3MgbWV0aG9kcyB0aGF0IHdlcmUgZGVmaW5lZCBpbiB0aGUgUkFNTCBzcGVjLlxuICpcbiAqIEBwYXJhbSAge0FycmF5fSAgbm9kZXNcbiAqIEBwYXJhbSAge09iamVjdH0gY29udGV4dFxuICogQHBhcmFtICB7T2JqZWN0fSByZXNvdXJjZXNcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG4vKiBqc2hpbnQgLVcwMDMgKi9cbnZhciBhdHRhY2hSZXNvdXJjZXMgPSBmdW5jdGlvbiAobm9kZXMsIGNvbnRleHQsIHJlc291cmNlcykge1xuICBfLmVhY2gocmVzb3VyY2VzLCBmdW5jdGlvbiAocmVzb3VyY2UsIHJvdXRlKSB7XG4gICAgdmFyIHJvdXRlTm9kZXMgICAgICAgID0gXy5leHRlbmQoW10sIG5vZGVzKTtcbiAgICB2YXIgcm91dGVOYW1lICAgICAgICAgPSByb3V0ZTtcbiAgICB2YXIgaGFzTWVkaWFFeHRlbnNpb24gPSByb3V0ZS5zdWJzdHIoLTIwKSA9PT0gJ3ttZWRpYVR5cGVFeHRlbnNpb259JztcblxuICAgIC8vIElnbm9yZSBtZWRpYSB0eXBlIGV4dGVuc2lvbnMgaW4gcm91dGUgZ2VuZXJhdGlvbi5cbiAgICBpZiAoaGFzTWVkaWFFeHRlbnNpb24pIHtcbiAgICAgIHJvdXRlID0gcm91dGVOYW1lID0gcm91dGUuc2xpY2UoMCwgLTIwKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayB0aGUgcm91dGUgYWdhaW5zdCBvdXIgdmFsaWQgdXJpIHBhcmFtZXRlcnMuXG4gICAgdmFyIHRlbXBsYXRlVGFncyA9IHJvdXRlLm1hdGNoKHRlbXBsYXRlLlJFR0VYUCk7XG5cbiAgICAvLyBQdXNoIHRoZSBjdXJyZW50IHJvdXRlIGludG8gdGhlIHJvdXRlIGFycmF5LlxuICAgIHJvdXRlTm9kZXMucHVzaChyb3V0ZSk7XG5cbiAgICAvLyBJZiB3ZSBoYXZlIHRlbXBsYXRlIHRhZ3MgYXZhaWxhYmxlLCBhdHRhY2ggYSBkeW5hbWljIHJvdXRlLlxuICAgIGlmICh0ZW1wbGF0ZVRhZ3MpIHtcbiAgICAgIHZhciByb3V0ZVN1ZmZpeCA9IHRlbXBsYXRlVGFncy5qb2luKCcnKTtcblxuICAgICAgLy8gVGhlIHJvdXRlIG11c3QgZW5kIHdpdGggdGhlIGNoYWluZWQgdGVtcGxhdGUgdGFncyBhbmQgaGF2ZSBub1xuICAgICAgLy8gdGV4dCBiZXR3ZWVuIHRhZ3MuXG4gICAgICBpZiAocm91dGUuc3Vic3RyKC1yb3V0ZVN1ZmZpeC5sZW5ndGgpICE9PSByb3V0ZVN1ZmZpeCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSByb3V0ZSBpcyBvbmx5IGEgdGVtcGxhdGUgdGFnIHdpdGggbm8gc3RhdGljIHRleHQsIHVzZSB0aGVcbiAgICAgIC8vIHRlbXBsYXRlIHRhZyB0ZXh0IGFzIHRoZSBtZXRob2QgbmFtZS5cbiAgICAgIGlmICh0ZW1wbGF0ZVRhZ3MubGVuZ3RoID09PSAxICYmIHJvdXRlID09PSB0ZW1wbGF0ZVRhZ3NbMF0pIHtcbiAgICAgICAgcm91dGVOYW1lID0gdGVtcGxhdGVUYWdzWzBdLnNsaWNlKDEsIC0xKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvdXRlTmFtZSA9IHJvdXRlLnN1YnN0cigwLCByb3V0ZS5pbmRleE9mKCd7JykpO1xuICAgICAgfVxuXG4gICAgICAvLyBBdm9pZCBhZGRpbmcgZW1wdHkgcm91dGUgbmFtZSBjYXNlcy4gVGhpcyBjYW4gb2NjdXIgd2hlbiB3ZSBoYXZlXG4gICAgICAvLyBtdWx0aXBsZSB0YWcgbmFtZXMgYW5kIG5vIGZyb250IHRleHQuIEZvciBleGFtcGxlLCBge3RoaXN9e3RoYXR9YC5cbiAgICAgIC8vIFRoaXMgY291bGQgYWxzbyBvY2N1ciBpZiBmb3Igc29tZSByZWFzb24gd2UgYXJlIHBhc3NpbmcgaW4gYSByb3V0ZSB0aGF0XG4gICAgICAvLyBpc24ndCBkeW5hbWljLlxuICAgICAgaWYgKCFyb3V0ZU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBHZXQgdGhlIG9yZGVyZWQgdGFnIG5hbWVzIGZvciBjb21wbGV0aW9uLlxuICAgICAgdmFyIHRhZ3MgPSBfLm1hcCh0ZW1wbGF0ZVRhZ3MsIGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICByZXR1cm4gcmVzb3VyY2UudXJpUGFyYW1ldGVyc1twYXJhbS5zbGljZSgxLCAtMSldO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFRoZSByb3V0ZSBpcyBkeW5hbWljLCBzbyB3ZSBzZXQgdGhlIHJvdXRlIG5hbWUgdG8gYmUgYSBmdW5jdGlvblxuICAgICAgLy8gd2hpY2ggYWNjZXB0cyB0aGUgdGVtcGxhdGUgYXJndW1lbnRzIGFuZCB1cGRhdGVzIHRoZSBwYXRoIGZyYWdtZW50LlxuICAgICAgLy8gV2UnbGwgZXh0ZW5kIGFueSByb3V0ZSBhbHJlYWR5IGF0IHRoZSBzYW1lIG5hbWVzcGFjZSBzbyB3ZSBjYW4gZG9cbiAgICAgIC8vIHRoaW5ncyBsaWtlIHVzZSBib3RoIGAve3JvdXRlfWAgYW5kIGAvcm91dGVgLCBpZiBuZWVkZWQuXG4gICAgICBjb250ZXh0W3JvdXRlTmFtZV0gPSBfLmV4dGVuZChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuXG4gICAgICAgIC8vIE1hcCB0aGUgdGFncyB0byB0aGUgYXJndW1lbnRzIG9yIGRlZmF1bHQgYXJndW1lbnRzLlxuICAgICAgICB2YXIgcGFydHMgPSBfLm1hcCh0YWdzLCBmdW5jdGlvbiAodGFnLCBpbmRleCkge1xuICAgICAgICAgIC8vIEluamVjdCBlbnVtIHBhcmFtZXRlcnMgaWYgdGhlcmUgaXMgb25seSBvbmUgYXZhaWxhYmxlIGVudW0uXG4gICAgICAgICAgLy8gVE9ETzogV2hlbi9pZiB3ZSBhZGQgdmFsaWRhdGlvbiBiYWNrLCBoYXZlIHRoZXNlIHJvdXRlc1xuICAgICAgICAgIC8vIGJlIGdlbmVyYXRlZCBpbnN0ZWFkIG9mIHR5cGVkIG91dC5cbiAgICAgICAgICBpZiAoYXJnc1tpbmRleF0gPT0gbnVsbCAmJiB0YWcuZW51bSAmJiB0YWcuZW51bS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0YWcuZW51bVswXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBVc2UgYW55IHBhc3NlZCBpbiBhcmd1bWVudCAtIGV2ZW4gaXQncyBmYWxzeS5cbiAgICAgICAgICBpZiAoaW5kZXggaW4gYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3NbaW5kZXhdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBwYXJhbSA9IHRlbXBsYXRlVGFnc1tpbmRleF0uc2xpY2UoMSwgLTEpO1xuXG4gICAgICAgICAgLy8gRmFsbGJhY2sgdG8gaW5qZWN0aW5nIHRoZSBmYWxsYmFjayBjb25maWd1cmF0aW9uIHVyaSBwYXJhbWV0ZXIuXG4gICAgICAgICAgcmV0dXJuIHJvdXRlTm9kZXMuY29uZmlnICYmIHJvdXRlTm9kZXMuY29uZmlnLnVyaVBhcmFtZXRlcnNbcGFyYW1dO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDaGFuZ2UgdGhlIGxhc3QgcGF0aCBmcmFnbWVudCB0byB0aGUgcHJvcGVyIHRlbXBsYXRlIHRleHQuXG4gICAgICAgIHJvdXRlTm9kZXNbcm91dGVOb2Rlcy5sZW5ndGggLSAxXSA9IHRlbXBsYXRlKHJvdXRlLCBwYXJ0cyk7XG5cbiAgICAgICAgcmV0dXJuIG5ld0NvbnRleHQocm91dGVOb2RlcywgcmVzb3VyY2UsIGhhc01lZGlhRXh0ZW5zaW9uKTtcbiAgICAgIH0sIGNvbnRleHRbcm91dGVOYW1lXSk7XG5cbiAgICAgIC8vIEdlbmVyYXRlIHRoZSBkZXNjcmlwdGlvbiBvYmplY3QgZm9yIGhlbHBpbmcgdG9vbHRpcCBkaXNwbGF5LlxuICAgICAgY29udGV4dFtyb3V0ZU5hbWVdW0RFU0NSSVBUSU9OX1BST1BFUlRZXSA9IHtcbiAgICAgICAgJyF0eXBlJzogJ2ZuKCcgKyBfLm1hcCh0YWdzLCBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgICAgICByZXR1cm4gcGFyYW0uZGlzcGxheU5hbWUgKyAocGFyYW0ucmVxdWlyZWQgPyAnJyA6ICc/Jyk7XG4gICAgICAgIH0pLmpvaW4oJywgJykgKyAnKScsXG4gICAgICAgICchYXJncyc6IF8ubWFwKHRhZ3MsIGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnIXR5cGUnOiBwYXJhbS50eXBlLFxuICAgICAgICAgICAgJyFkb2MnOiAgcGFyYW0uZGVzY3JpcHRpb25cbiAgICAgICAgICB9O1xuICAgICAgICB9KSxcbiAgICAgICAgJyFkb2MnOiAnRHluYW1pY2FsbHkgaW5qZWN0IHZhcmlhYmxlcyBpbnRvIHRoZSByZXF1ZXN0IHBhdGguJ1xuICAgICAgfTtcblxuICAgICAgLy8gR2VuZXJhdGUgdGhlIHJldHVybiBwcm9wZXJ0eSBmb3IgaGVscGluZyBhdXRvY29tcGxldGlvbi5cbiAgICAgIGNvbnRleHRbcm91dGVOYW1lXVtSRVRVUk5fUFJPUEVSVFldID0gbmV3Q29udGV4dChcbiAgICAgICAgcm91dGVOb2RlcywgcmVzb3VyY2UsIGhhc01lZGlhRXh0ZW5zaW9uXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gY29udGV4dFtyb3V0ZU5hbWVdO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSByb290IGAvYCByZXNvdXJjZXMuXG4gICAgaWYgKCFyb3V0ZU5hbWUpIHtcbiAgICAgIGNvbnRleHQgPSBuZXdDb250ZXh0KHJvdXRlTm9kZXMsIHJlc291cmNlLCBoYXNNZWRpYUV4dGVuc2lvbiwgY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHRbcm91dGVOYW1lXSA9IG5ld0NvbnRleHQoXG4gICAgICAgIHJvdXRlTm9kZXMsIHJlc291cmNlLCBoYXNNZWRpYUV4dGVuc2lvbiwgY29udGV4dFtyb3V0ZU5hbWVdXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGNvbnRleHQ7XG59O1xuLyoganNoaW50ICtXMDAzICovXG5cbi8qKlxuICogR2VuZXJhdGUgdGhlIGNsaWVudCBvYmplY3QgZnJvbSBhIHNhbml0aXplZCBBU1Qgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gYXN0IFBhc3NlZCB0aHJvdWdoIGBzYW5pdGl6ZUFTVGBcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xudmFyIGdlbmVyYXRlQ2xpZW50ID0gZnVuY3Rpb24gKGFzdCwgY29uZmlnKSB7XG4gIC8vIEdlbmVyYXRlIHRoZSBiYXNlIHVyaSBwYXJhbWV0ZXJzIGFuZCBkZWZhdWx0cy5cbiAgdmFyIGJhc2VVcmlQYXJhbWV0ZXJzID0gXy5leHRlbmQoXG4gICAge30sIF8ucGljayhhc3QsICd2ZXJzaW9uJyksIGNvbmZpZy5iYXNlVXJpUGFyYW1ldGVyc1xuICApO1xuXG4gIC8vIEdlbmVyYXRlIHRoZSByb290IG5vZGUgYXJyYXkuIFNldCBwcm9wZXJ0aWVzIGRpcmVjdGx5IG9uIHRoaXMgYXJyYXkgdG8gYmVcbiAgLy8gY29waWVkIHRvIHRoZSBuZXh0IGV4ZWN1dGlvbiBwYXJ0LiBXZSBoYXZlIGEgZ2xvYmFsIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gIC8vIHdoaWNoIGNhbiBiZSBhbHRlcmVkIGV4dGVybmFsbHkgYXQgYW55IHBvaW50LCBhcyB3ZWxsIGFzIHdoZW4gd2UgZmluYWxseVxuICAvLyBtYWtlIGEgcmVxdWVzdC4gRm9yIHRoaXMgcmVhc29uLCBpdCdzIGltcG9ydGFudCB0aGF0IHdlIHVzZSBvYmplY3RzIHdoaWNoXG4gIC8vIGFyZSBwYXNzZWQgYnkgcmVmZXJlbmNlLlxuICB2YXIgbm9kZXMgPSBfLmV4dGVuZChbXSwge1xuICAgIGNvbmZpZzogXy5leHRlbmQoe1xuICAgICAgYmFzZVVyaTogYXN0LmJhc2VVcmlcbiAgICB9LCBjb25maWcsIHtcbiAgICAgIGJhc2VVcmlQYXJhbWV0ZXJzOiBiYXNlVXJpUGFyYW1ldGVyc1xuICAgIH0pLFxuICAgIGNsaWVudDoge1xuICAgICAgc2VjdXJlZEJ5OiAgICAgICAgIGFzdC5zZWN1cmVkQnksXG4gICAgICBhdXRoZW50aWNhdGlvbjogICAge30sXG4gICAgICBzZWN1cml0eVNjaGVtZXM6ICAgYXN0LnNlY3VyaXR5U2NoZW1lcyxcbiAgICAgIGJhc2VVcmlQYXJhbWV0ZXJzOiBhc3QuYmFzZVVyaVBhcmFtZXRlcnNcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFRocm93IGFuIGVycm9yIGlmIHRoZSBiYXNlVXJpIHN0cmluZyBpcyBtaXNzaW5nLlxuICBpZiAoIV8uaXNTdHJpbmcobm9kZXMuY29uZmlnLmJhc2VVcmkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBIFwiYmFzZVVyaVwiIHN0cmluZyBpcyByZXF1aXJlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSByb290IGNsaWVudCBpbXBsZW1lbnRhdGlvbiBpcyBzaW1wbHkgYSBmdW5jdGlvbi4gVGhpcyBhbGxvd3MgdXMgdG9cbiAgICogZW50ZXIgYSBjdXN0b20gcGF0aCB0aGF0IG1heSBub3QgYmUgc3VwcG9ydGVkIGJ5IHRoZSBEU0wgYW5kIHJ1biBhbnlcbiAgICogbWV0aG9kIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciBpdCB3YXMgZGVmaW5lZCBpbiB0aGUgc3BlYy5cbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSBwYXRoXG4gICAqIEBwYXJhbSAge09iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICB2YXIgY2xpZW50ID0gZnVuY3Rpb24gKHBhdGgsIGNvbnRleHQpIHtcbiAgICB2YXIgcm91dGUgPSB0ZW1wbGF0ZShcbiAgICAgIHBhdGggfHwgJycsIGNvbnRleHQgfHwge31cbiAgICApLnJlcGxhY2UoL15cXC8rLywgJycpLnNwbGl0KCcvJyk7XG5cbiAgICByZXR1cm4gYXR0YWNoTWV0aG9kcyhfLmV4dGVuZChbXSwgbm9kZXMsIHJvdXRlKSwge30sIGFsbEh0dHBNZXRob2RzKTtcbiAgfTtcblxuICBjbGllbnRbQ09ORklHX1BST1BFUlRZXSAgICAgID0gbm9kZXMuY29uZmlnO1xuICBjbGllbnRbQ0xJRU5UX1BST1BFUlRZXSAgICAgID0gbm9kZXMuY2xpZW50O1xuICBjbGllbnRbREVTQ1JJUFRJT05fUFJPUEVSVFldID0gQ0xJRU5UX0RFU0NSSVBUSU9OO1xuICBjbGllbnRbUkVUVVJOX1BST1BFUlRZXSAgICAgID0gYXR0YWNoTWV0aG9kcyhub2Rlcywge30sIGFsbEh0dHBNZXRob2RzKTtcblxuICBhdHRhY2hSZXNvdXJjZXMobm9kZXMsIGNsaWVudCwgYXN0LnJlc291cmNlcyk7XG5cbiAgcmV0dXJuIGNsaWVudDtcbn07XG5cbi8qKlxuICogRXhwb3J0cyB0aGUgY2xpZW50IGdlbmVyYXRvciwgd2hpY2ggYWNjZXB0cyB0aGUgQVNUIG9mIGEgUkFNTCBkb2N1bWVudC5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IER5bmFtaWMgb2JqZWN0IGZvciBjb25zdHJ1Y3RpbmcgQVBJIHJlcXVlc3RzIGZyb20gdGhlIEFTVC5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXN0LCBjb25maWcpIHtcbiAgcmV0dXJuIGdlbmVyYXRlQ2xpZW50KHNhbml0aXplQVNUKGFzdCksIGNvbmZpZyk7XG59O1xuIiwiLyogZ2xvYmFsIEFwcCAqL1xudmFyIF8gPSBBcHAuTGlicmFyeS5fO1xuXG4vKipcbiAqIFNhbml0aXplIHRoZSBzZWN1cmVkIGJ5IGludG8gYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSAge0FycmF5fSAgc2VjdXJlZFxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG52YXIgc2FuaXRpemVTZWN1cmVkQnkgPSBmdW5jdGlvbiAoc2VjdXJlZCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoc2VjdXJlZCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBzZWN1cmVkQnkgPSB7fTtcblxuICAvLyBTaW5jZSBgc2VjdXJlZEJ5YCBjYW4gZWl0aGVyIGJlIGFuIGFycmF5IG9mIHN0cmluZ3Mgb3IgYXJyYXkgb2Ygb2JqZWN0c1xuICAvLyB3aXRoIG9ubHkgYSBzaW5nbGUga2V5LCB3ZSBtZXJnZSBpdCBkb3duIHRvIGFuIG9iamVjdC5cbiAgXy5lYWNoKHNlY3VyZWQsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm47IC8vIElnbm9yZSBgbnVsbGAgYXJyYXkgdmFsdWVzLCBzaG91bGRuJ3QgYmUgdXNlZnVsIHRvIG1lLlxuICAgIH1cblxuICAgIGlmIChfLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHNlY3VyZWRCeVt2YWx1ZV0gPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBfLmV4dGVuZChzZWN1cmVkQnksIHZhbHVlKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHNlY3VyZWRCeTtcbn07XG5cbi8qKlxuICogU2FuaXRpemUgdGhlIEFTVCBmcm9tIHRoZSBSQU1MIHBhcnNlciBpbnRvIHNvbWV0aGluZyBlYXNpZXIgdG8gd29yayB3aXRoLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gYXN0XG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFzdCkge1xuICAvLyBDcmVhdGUgdGhlIGJhc2Ugc2FuaXRpemVkIGFzdCB3aXRoIG9ubHkgdGhlIHByb3BlcnRpZXMgd2Ugd2FudC5cbiAgdmFyIHNhbml0aXplZEFzdCA9IF8ucGljayhhc3QsIFtcbiAgICAndGl0bGUnLFxuICAgICd2ZXJzaW9uJyxcbiAgICAnYmFzZVVyaScsXG4gICAgJ2Jhc2VVcmlQYXJhbWV0ZXJzJ1xuICBdKTtcblxuICAvLyBNZXJnZSBhbiBhcnJheSBvZiBvYmplY3RzIGludG8gYSBzaW5nbGUgb2JqZWN0IHVzaW5nIGBfLmV4dGVuZGAgYW5kXG4gIC8vIGBhcHBseWAgKHNpbmNlIGBfLmV4dGVuZGAgYWNjZXB0cyB1bmxpbWl0ZWQgbnVtYmVyIG9mIGFyZ3VtZW50cykuXG4gIGlmIChhc3Quc2VjdXJpdHlTY2hlbWVzKSB7XG4gICAgc2FuaXRpemVkQXN0LnNlY3VyaXR5U2NoZW1lcyA9IF8uZXh0ZW5kLmFwcGx5KF8sIGFzdC5zZWN1cml0eVNjaGVtZXMpO1xuICB9XG5cbiAgLy8gU2FuaXRpemUgc2VjdXJlZCBieSB3aGljaCBpcyBhIGJpdCBtb3JlIGNvbXBsaWNhdGVkIHRoYW4gZXh0ZW5kaW5nLlxuICBpZiAoYXN0LnNlY3VyZWRCeSkge1xuICAgIHNhbml0aXplZEFzdC5zZWN1cmVkQnkgPSBzYW5pdGl6ZVNlY3VyZWRCeShhc3Quc2VjdXJlZEJ5KTtcbiAgfVxuXG4gIC8vIFJlY3Vyc2UgdGhyb3VnaCB0aGUgcmVzb3VyY2VzIGFuZCBtb3ZlIFVSSXMgdG8gYmUgdGhlIGtleSBuYW1lcy5cbiAgc2FuaXRpemVkQXN0LnJlc291cmNlcyA9IChmdW5jdGlvbiBmbGF0dGVuUmVzb3VyY2VzIChyZXNvdXJjZXMpIHtcbiAgICB2YXIgbWFwID0ge307XG5cbiAgICAvLyBSZXNvdXJjZXMgYXJlIHByb3ZpZGVkIGFzIGFuIGFycmF5LCB3ZSdsbCBtb3ZlIHRoZW0gdG8gYmUgYW4gb2JqZWN0LlxuICAgIF8uZWFjaChyZXNvdXJjZXMsIGZ1bmN0aW9uIChyZXNvdXJjZSkge1xuICAgICAgdmFyIHNhbml0aXplZFJlc291cmNlID0ge307XG5cbiAgICAgIC8vIE1ldGhvZHMgYXJlIGltcGxlbWVudGVkIGFzIGFycmF5cyBvZiBvYmplY3RzIHRvbywgYnV0IG5vdCByZWN1cnNpdmVseS5cbiAgICAgIC8vIFRPRE86IElmIHRoZSBlbmRwb2ludCBpcyB0aGUgZmluYWwgcm91dGUgYW5kIGhhcyBubyBtZXRob2RzLCBpbXBsZW1lbnRcbiAgICAgIC8vIGJhY2t0cmFja2luZyBhbmQgcmVtb3ZlIGFjY2VzcyB0byBpdCBmcm9tIHRoZSBBU1QuXG4gICAgICBpZiAocmVzb3VyY2UubWV0aG9kcykge1xuICAgICAgICBzYW5pdGl6ZWRSZXNvdXJjZS5tZXRob2RzID0gXy5vYmplY3QoXG4gICAgICAgICAgXy5wbHVjayhyZXNvdXJjZS5tZXRob2RzLCAnbWV0aG9kJyksXG4gICAgICAgICAgXy5tYXAocmVzb3VyY2UubWV0aG9kcywgZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBzYW5pdGl6ZWQgbWV0aG9kIGJ5IGluY2x1ZGluZyB0aGUgcHJvcGVydGllcyB3ZSB3YW50LlxuICAgICAgICAgICAgdmFyIHNhbml0aXplZE1ldGhvZCA9IF8ucGljayhtZXRob2QsIFtcbiAgICAgICAgICAgICAgJ21ldGhvZCcsXG4gICAgICAgICAgICAgICdib2R5JyxcbiAgICAgICAgICAgICAgJ2hlYWRlcnMnLFxuICAgICAgICAgICAgICAnZGVzY3JpcHRpb24nLFxuICAgICAgICAgICAgICAncXVlcnlQYXJhbWV0ZXJzJ1xuICAgICAgICAgICAgXSk7XG5cbiAgICAgICAgICAgIC8vIFNhbml0aXplIHRoZSBgc2VjdXJlZEJ5YCBtZXRob2QuXG4gICAgICAgICAgICBpZiAobWV0aG9kLnNlY3VyZWRCeSkge1xuICAgICAgICAgICAgICBzYW5pdGl6ZWRNZXRob2Quc2VjdXJlZEJ5ID0gc2FuaXRpemVTZWN1cmVkQnkobWV0aG9kLnNlY3VyZWRCeSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzYW5pdGl6ZWRNZXRob2Q7XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlc291cmNlLnJlc291cmNlcykge1xuICAgICAgICBzYW5pdGl6ZWRSZXNvdXJjZS5yZXNvdXJjZXMgPSBmbGF0dGVuUmVzb3VyY2VzKHJlc291cmNlLnJlc291cmNlcyk7XG4gICAgICB9XG5cbiAgICAgIChmdW5jdGlvbiBhdHRhY2hSZXNvdXJjZSAobWFwLCBzZWdtZW50cykge1xuICAgICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzLnNoaWZ0KCk7XG4gICAgICAgIHZhciBwYXJ0ICAgID0gbWFwW3NlZ21lbnRdID0gbWFwW3NlZ21lbnRdIHx8IHt9O1xuXG4gICAgICAgIC8vIEN1cnJlbnRseSBvbiB0aGUgbGFzdCB1cmwgc2VnbWVudCwgZW1iZWQgdGhlIGZ1bGwgcmVzb3VyY2UuXG4gICAgICAgIGlmICghc2VnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcGFydCA9IG1hcFtzZWdtZW50XSA9IHNhbml0aXplZFJlc291cmNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUHVsbCBhbnkgcG9zc2libGUgdGFncyBvdXQgb2YgdGhlIHJlbGF0aXZlIHVyaSBwYXJ0LlxuICAgICAgICB2YXIgdGFncyA9IF8ubWFwKHNlZ21lbnQubWF0Y2goL1xceyhbXlxcfV0rKVxcfS9nKSwgZnVuY3Rpb24gKHRhZykge1xuICAgICAgICAgIHJldHVybiB0YWcuc2xpY2UoMSwgLTEpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBBZGQgb25seSB0aGUgdXNlZCB0YWdzIHRvIHRoZSBjdXJyZW50IHJlc291cmNlIHNlZ21lbnQuXG4gICAgICAgIGlmICh0YWdzLmxlbmd0aCkge1xuICAgICAgICAgIHBhcnQudXJpUGFyYW1ldGVycyA9IF8ucGljayhyZXNvdXJjZS51cmlQYXJhbWV0ZXJzLCB0YWdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHdlIGhhdmUgbW9yZSBzZWdtZW50IHBhcnRzIGxlZnQsIHJlY3Vyc2l2ZWx5IGVtYmVkIHJlc291cmNlcy5cbiAgICAgICAgaWYgKHNlZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHBhcnQucmVzb3VyY2VzID0gcGFydC5yZXNvdXJjZXMgfHwge307XG5cbiAgICAgICAgICByZXR1cm4gYXR0YWNoUmVzb3VyY2UocGFydC5yZXNvdXJjZXMsIHNlZ21lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfSkobWFwLCByZXNvdXJjZS5yZWxhdGl2ZVVyaS5zdWJzdHIoMSkuc3BsaXQoJy8nKSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbWFwO1xuICB9KShhc3QucmVzb3VyY2VzKTtcblxuICByZXR1cm4gc2FuaXRpemVkQXN0O1xufTtcbiIsIi8qIGdsb2JhbCBBcHAgKi9cbnZhciBfID0gQXBwLkxpYnJhcnkuXztcblxuLyoqXG4gKiBNYXRjaCByYW1sIHVyaSBwYXJhbWV0ZXJzIGluIGEgdXJpLlxuICpcbiAqIEB0eXBlIHtSZWdFeHB9XG4gKi9cbnZhciBVUklfUEFSQU1fUkVHRVhQID0gL3tbXn1dK30vZztcblxuLyoqXG4gKiBTaW1wbGUgXCJ0ZW1wbGF0ZVwiIGZ1bmN0aW9uIGZvciB3b3JraW5nIHdpdGggdGhlIHVyaSBwYXJhbSB2YXJpYWJsZXMuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSAgICAgICAgIHRlbXBsYXRlXG4gKiBAcGFyYW0gIHsoT2JqZWN0fEFycmF5KX0gY29udGV4dFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyaW5nLCBjb250ZXh0KSB7XG4gIGNvbnRleHQgPSBjb250ZXh0IHx8IHt9O1xuXG4gIC8vIE5vIHVyaSBzdHJpbmcgaGFzIGJlZW4gc3BlY2lmaWVkLlxuICBpZiAoc3RyaW5nID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIElmIHRoZSBjb250ZXh0IGlzIGFuIGFycmF5LCB3ZSBuZWVkIHRvIHRyYW5zZm9ybSB0aGUgcmVwbGFjZW1lbnRzIGludG9cbiAgLy8gaW5kZXggYmFzZWQgcG9zaXRpb25zIGZvciB0aGUgdXJpIHRlbXBsYXRlIHBhcnNlci5cbiAgaWYgKF8uaXNBcnJheShjb250ZXh0KSkge1xuICAgIHZhciBpbmRleCA9IDA7XG5cbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoVVJJX1BBUkFNX1JFR0VYUCwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChjb250ZXh0W2luZGV4KytdIHx8ICcnKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShVUklfUEFSQU1fUkVHRVhQLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KGNvbnRleHRbbWF0Y2guc2xpY2UoMSwgLTEpXSB8fCAnJyk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBFeHBvcnQgdGhlIHJlcGxhY2VtZW50IHJlZ2V4cC5cbiAqL1xuZXhwb3J0cy5SRUdFWFAgPSBVUklfUEFSQU1fUkVHRVhQO1xuIiwiLyogZ2xvYmFsIEFwcCAqL1xudmFyIF8gICAgICAgICAgICAgICA9IEFwcC5fO1xudmFyIHJhbWxQYXJzZXIgICAgICA9IHJlcXVpcmUoJ3JhbWwtcGFyc2VyJyk7XG52YXIgYXV0aGVudGljYXRlICAgID0gcmVxdWlyZSgnLi9hdXRoZW50aWNhdGUnKTtcbnZhciBjbGllbnRHZW5lcmF0b3IgPSByZXF1aXJlKCcuL2NsaWVudC1nZW5lcmF0b3InKTtcbnZhciBmcm9tUGF0aCAgICAgICAgPSByZXF1aXJlKCcuLi8uLi9saWIvZnJvbS1wYXRoJyk7XG5cbi8qKlxuICogSW1wbGVtZW50YXRpb24gaGVscGVycy5cbiAqL1xucmVxdWlyZSgnLi9pbmplY3QtYXBpLWtleXMnKTtcbnJlcXVpcmUoJy4vaW5zZXJ0LWFwaS1jbGllbnQnKTtcblxuLyoqXG4gKiBQcm92aWRlZCBhIHNwZWNpYWwgZG9jdW1lbnRhdGlvbiBwcm9wZXJ0eSBmb3IgZnVuY3Rpb25zdyB3aXRoIGFub3RoZXIgcGx1Z2luLlxuICpcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKi9cbnZhciBERVNDUklQVElPTl9QUk9QRVJUWSA9ICchZGVzY3JpcHRpb24nO1xuXG4vKipcbiAqIEN1c3RvbSBmaWxlIHJlYWRlciBmb3IgUkFNTCBzcGVjcy5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICB1cmxcbiAqIEByZXR1cm4ge1EuZGVmZXJ9XG4gKi9cbnZhciBjcmVhdGVSZWFkZXIgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gIHJldHVybiBuZXcgcmFtbFBhcnNlci5GaWxlUmVhZGVyKGZ1bmN0aW9uICh1cmwpIHtcbiAgICB2YXIgZGVmZXJyZWQgPSB0aGlzLnEuZGVmZXIoKTtcblxuICAgIEFwcC5taWRkbGV3YXJlLnRyaWdnZXIoJ2FqYXgnLCB7XG4gICAgICB1cmw6IHVybCxcbiAgICAgIHByb3h5OiBjb25maWcucHJveHksXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vcmFtbCt5YW1sLCAqLyonXG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKGVyciwgeGhyKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5yZWplY3QoZXJyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKE1hdGguZmxvb3IoeGhyLnN0YXR1cyAvIDEwMCkgIT09IDIpIHtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnJlamVjdChcbiAgICAgICAgICBuZXcgRXJyb3IoJ1JlY2VpdmVkIHN0YXR1cyBjb2RlICcgKyB4aHIuc3RhdHVzICsgJyBsb2FkaW5nICcgKyB1cmwpXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZWZlcnJlZC5yZXNvbHZlKHhoci5yZXNwb25zZVRleHQpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBUaGUgQXBpIG9iamVjdCBpcyB1c2VkIGluIHRoZSBleGVjdXRpb24gY29udGV4dC5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgQVBJID0ge307XG5cbi8qKlxuICogUmVzcG9uc2libGUgZm9yIGxvYWRpbmcgUkFNTCBkb2N1bWVudHMgYW5kIHJldHVybiBBUEkgY2xpZW50cy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gICBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gICB1cmlcbiAqIEBwYXJhbSB7T2JqZWN0fSAgIFtjb25maWddXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gKi9cbkFQSS5jcmVhdGVDbGllbnQgPSBmdW5jdGlvbiAobmFtZSwgdXJpLCBjb25maWcsIGRvbmUpIHtcbiAgaWYgKCFfLmlzU3RyaW5nKG5hbWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQcm92aWRlIGEgbmFtZSBmb3IgdGhlIGdlbmVyYXRlZCBjbGllbnQnKTtcbiAgfVxuXG4gIGlmICghXy5pc1N0cmluZyh1cmkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQcm92aWRlIGEgVVJMIGZvciB0aGUgJyArIG5hbWUgKyAnIFJBTUwgZG9jdW1lbnQnKTtcbiAgfVxuXG4gIC8vIEFsbG93IHRoZSBjb25maWcgb2JqZWN0IHRvIGJlIHNraXBwZWQuXG4gIGlmICh0eXBlb2YgY29uZmlnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZG9uZSAgID0gYXJndW1lbnRzWzJdO1xuICAgIGNvbmZpZyA9IHt9O1xuICB9XG5cbiAgQXBwLl9leGVjdXRlQ29udGV4dC50aW1lb3V0KEluZmluaXR5KTtcbiAgZG9uZSAgID0gZG9uZSAgIHx8IEFwcC5fZXhlY3V0ZUNvbnRleHQuYXN5bmMoKTtcbiAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhbmQgYXR0YWNoIHRoZSBSQU1MIGNsaWVudCBmcm9tIHRoZSBBU1QuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gYXN0XG4gICAqL1xuICB2YXIgY3JlYXRlQ2xpZW50ID0gZnVuY3Rpb24gKGFzdCkge1xuICAgIHRyeSB7XG4gICAgICBmcm9tUGF0aChcbiAgICAgICAgQXBwLl9leGVjdXRlV2luZG93LCBuYW1lLnNwbGl0KCcuJyksIGNsaWVudEdlbmVyYXRvcihhc3QsIGNvbmZpZylcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGRvbmUoZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRvbmUoXG4gICAgICBudWxsLFxuICAgICAgJ0NyZWF0ZSBhIG5ldyBjb2RlIGNlbGwgYW5kIHR5cGUgXCInICsgbmFtZSArICcuXCIgdG8gZXhwbG9yZSB0aGlzIEFQSS4nXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogTWFudWFsbHkgaW5pdGlhbGlzZSB0aGUgZmlyc3QgYWpheCByZXF1ZXN0IHRvIHN1cHBvcnQgSlNPTiByZXNwb25zZXMuXG4gICAqL1xuICByZXR1cm4gQXBwLm1pZGRsZXdhcmUudHJpZ2dlcignYWpheCcsIHtcbiAgICB1cmw6ICAgdXJpLFxuICAgIHByb3h5OiBjb25maWcucHJveHksXG4gICAgaGVhZGVyczoge1xuICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9yYW1sK3lhbWwsIGFwcGxpY2F0aW9uL2pzb24sICovKidcbiAgICB9XG4gIH0sIGZ1bmN0aW9uIChlcnIsIHhocikge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBkb25lKGVycik7XG4gICAgfVxuXG4gICAgaWYgKE1hdGguZmxvb3IoeGhyLnN0YXR1cyAvIDEwMCkgIT09IDIpIHtcbiAgICAgIHJldHVybiBkb25lKG5ldyBFcnJvcignSFRUUCAnICsgeGhyLnN0YXR1cykpO1xuICAgIH1cblxuICAgIC8vIFN1cHBvcnQgSlNPTiByZXNwb25zZXMuIE9yaWdpbmFsbHkgdGhpcyBjaGVja2VkIHRoZSByZXNwb25zZSBjb250ZW50XG4gICAgLy8gdHlwZXMsIGV0Yy4gYnV0IGl0J3MganVzdCBhcyBlYXN5IHRvIGF0dGVtcHQgcGFyc2luZyBhcyBKU09OIGFuZCBpZiBpdFxuICAgIC8vIGZhaWxzIHBhc3MgaXQgb250byB0aGUgcmFtbCBwYXJzZXIuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjcmVhdGVDbGllbnQoSlNPTi5wYXJzZSh4aHIucmVzcG9uc2VUZXh0KSk7XG4gICAgfSBjYXRjaCAoZSkge31cblxuICAgIC8vIFBhc3Mgb3VyIHVybCB0byB0aGUgUkFNTCBwYXJzZXIgZm9yIHByb2Nlc3NpbmcgYW5kIHRyYW5zZm9ybSB0aGUgcHJvbWlzZVxuICAgIC8vIGJhY2sgaW50byBhIGNhbGxiYWNrIGZvcm1hdC5cbiAgICByZXR1cm4gcmFtbFBhcnNlci5sb2FkKHhoci5yZXNwb25zZVRleHQsIHVyaSwge1xuICAgICAgcmVhZGVyOiBjcmVhdGVSZWFkZXIoY29uZmlnKVxuICAgIH0pLnRoZW4oY3JlYXRlQ2xpZW50LCBkb25lKTtcbiAgfSk7XG5cbn07XG5cbi8qKlxuICogRGVzY3JpcHRpb24gb2YgdGhlIGNyZWF0ZSBjbGllbnQgZnVuY3Rpb24uXG4gKi9cbkFQSS5jcmVhdGVDbGllbnRbREVTQ1JJUFRJT05fUFJPUEVSVFldID0ge1xuICAnIXR5cGUnOiAnZm4oYWxpYXMsIHVybCwgb3B0aW9ucz8sIGNiPyknLFxuICAnIWFyZ3MnOiBbe1xuICAgICchdHlwZSc6ICdzdHJpbmcnXG4gIH0sIHtcbiAgICAnIXR5cGUnOiAnc3RyaW5nJ1xuICB9LCB7XG4gICAgJyF0eXBlJzogJ29iamVjdCcsXG4gICAgJyFkb2MnOiBbXG4gICAgICAnSW5pdGlhbGl6ZSB0aGUgY2xpZW50IHdpdGggZGVmYXVsdCBjb25maWcgb3B0aW9ucy4gVmFsaWQgb3B0aW9uczonLFxuICAgICAgJyogKipwcm94eSoqOiBTZXQgdG8gYSBjdXN0b20gcHJveHkgb3IgYGZhbHNlYCB0byBkaXNhYmxlIGVudGlyZWx5JyxcbiAgICAgICcqICoqYm9keSoqOiBTZXQgYSBmYWxsYmFjayByZXF1ZXN0IGJvZHknLFxuICAgICAgJyogKip1cmlQYXJhbWV0ZXJzKio6IFNldCBmYWxsYmFjayB1cmkgcGFyYW1ldGVycyB0byBpbmplY3QnLFxuICAgICAgJyogKipiYXNlVXJpOioqIE92ZXJyaWRlIHRoZSBiYXNlIHVyaScsXG4gICAgICAnKiAqKmJhc2VVcmlQYXJhbWV0ZXJzKio6IEluamVjdCBiYXNlIHVyaSBwYXJhbWV0ZXJzIHRvIG92ZXJyaWRlJyxcbiAgICAgICcqICoqaGVhZGVycyoqOiBTZXQgZGVmYXVsdCBoZWFkZXJzIHRvIHNlbmQgd2l0aCBldmVyeSByZXF1ZXN0JyxcbiAgICAgICcqICoqcXVlcnkqKjogU2V0IGEgZGVmYXVsdCBxdWVyeSBzdHJpbmcgdG8gc2VuZCB3aXRoIGV2ZXJ5IHJlcXVlc3QnXG4gICAgXS5qb2luKCdcXG4nKVxuICB9LCB7XG4gICAgJyF0eXBlJzogJ2ZuKGVycm9yLCBjbGllbnQpJyxcbiAgICAnIWRvYyc6IFtcbiAgICAgICdQYXNzIGluIGEgY3VzdG9tIGNhbGxiYWNrIHRvIHJ1biB3aGVuIHRoZSBjbGllbnQgaGFzIGxvYWRlZC4nXG4gICAgXS5qb2luKCdcXG4nKVxuICB9XSxcbiAgJyFkb2MnOiBbXG4gICAgJ0dlbmVyYXRlIGFuIEFQSSBjbGllbnQgZnJvbSBhIFJBTUwgZG9jdW1lbnQgYW5kIGFsaWFzIGl0IG9uIHRoZSB3aW5kb3cuJ1xuICBdLmpvaW4oJyAnKVxufTtcblxuLyoqXG4gKiBTZXQgYSBjb25maWd1cmF0aW9uIHZhbHVlIG9uIGEgY2xpZW50LlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNsaWVudFxuICogQHBhcmFtIHtTdHJpbmd9ICAga2V5XG4gKiBAcGFyYW0geyp9ICAgICAgICB2YWx1ZVxuICovXG5BUEkuc2V0ID0gZnVuY3Rpb24gKGNsaWVudCwga2V5LCB2YWx1ZSkge1xuICAvLyBJZiB3ZSBkb24ndCBoYXZlIGVub3VnaCBhcmd1bWVudHMgZm9yIGEga2V5IGFuZCB2YWx1ZSwgYXNzdW1lIHdlIGhhdmVcbiAgLy8gYSBmcmVzaCBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG4gICAgcmV0dXJuIF8uZXh0ZW5kKGNsaWVudFsnIWNvbmZpZyddLCBrZXkpO1xuICB9XG5cbiAgcmV0dXJuIGNsaWVudFsnIWNvbmZpZyddW2tleV0gPSB2YWx1ZTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgQVBJIGNsaWVudCBjb25maWd1cmF0aW9uIHNldHRlci5cbiAqL1xuQVBJLnNldFtERVNDUklQVElPTl9QUk9QRVJUWV0gPSB7XG4gICchdHlwZSc6ICdmbihjbGllbnQsIGtleSwgdmFsdWUpJyxcbiAgJyFhcmdzJzogW3tcbiAgICAnIXR5cGUnOiAnZm4oKScsXG4gICAgJyFkb2MnOiAnQSBmdW5jdGlvbiBnZW5lcmF0ZWQgYnkgYEFQSS5jcmVhdGVDbGllbnRgLidcbiAgfSwge1xuICAgICchdHlwZSc6ICdzdHJpbmcnXG4gIH1dLFxuICAnIWRvYyc6ICdTZXQgYSBjb25maWd1cmF0aW9uIG9wdGlvbiBvZiBhIFJBTUwgQVBJIGNsaWVudC4nXG59O1xuXG4vKipcbiAqIFJldHJpZXZlIGEgdmFsdWUgZnJvbSB0aGUgY2xpZW50IGNvbmZpZyBvYmplY3QuXG4gKlxuICogQHBhcmFtICB7RnVuY3Rpb259IGNsaWVudFxuICogQHBhcmFtICB7U3RyaW5nfSAgIGtleVxuICogQHJldHVybiB7Kn1cbiAqL1xuQVBJLmdldCA9IGZ1bmN0aW9uIChjbGllbnQsIGtleSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICByZXR1cm4gY2xpZW50WychY29uZmlnJ107XG4gIH1cblxuICByZXR1cm4gY2xpZW50WychY29uZmlnJ11ba2V5XTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgQVBJIGNsaWVudCBjb25maWd1cmF0aW9uIGdldHRlci5cbiAqL1xuQVBJLmdldFtERVNDUklQVElPTl9QUk9QRVJUWV0gPSB7XG4gICchdHlwZSc6ICdmbihjbGllbnQsIGtleSknLFxuICAnIWFyZ3MnOiBbe1xuICAgICchdHlwZSc6ICdmbigpJyxcbiAgICAnIWRvYyc6ICdBIGZ1bmN0aW9uIGdlbmVyYXRlZCBieSBgQVBJLmNyZWF0ZUNsaWVudGAuJ1xuICB9LCB7XG4gICAgJyF0eXBlJzogJ3N0cmluZydcbiAgfV0sXG4gICchZG9jJzogJ0dldCBhIGNvbmZpZ3VyYXRpb24gb3B0aW9uIGZyb20gYSBSQU1MIEFQSSBjbGllbnQuJ1xufTtcblxuLyoqXG4gKiBVbnNldCBhIGtleSBmcm9tIHRoZSBjbGllbnQgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2xpZW50XG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAga2V5XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5BUEkudW5zZXQgPSBmdW5jdGlvbiAoY2xpZW50LCBrZXkpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgXy5lYWNoKGNsaWVudFsnIWNvbmZpZyddLCBmdW5jdGlvbiAodmFsdWUsIGtleSwgb2JqKSB7XG4gICAgICBkZWxldGUgb2JqW2tleV07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBkZWxldGUgY2xpZW50WychY29uZmlnJ11ba2V5XTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgQVBJIGNsaWVudCBjb25maWd1cmF0aW9uIHVuc2V0dGVyLlxuICovXG5BUEkudW5zZXRbREVTQ1JJUFRJT05fUFJPUEVSVFldID0ge1xuICAnIXR5cGUnOiAnZm4oY2xpZW50LCBrZXkpJyxcbiAgJyFhcmdzJzogW3tcbiAgICAnIXR5cGUnOiAnZm4oKScsXG4gICAgJyFkb2MnOiAnQSBmdW5jdGlvbiBnZW5lcmF0ZWQgYnkgYEFQSS5jcmVhdGVDbGllbnRgLidcbiAgfSwge1xuICAgICchdHlwZSc6ICdzdHJpbmcnXG4gIH1dLFxuICAnIWRvYyc6ICdVbnNldCBhIGNvbmZpZ3VyYXRpb24gb3B0aW9uIGZyb20gYSBSQU1MIEFQSSBjbGllbnQuJ1xufTtcblxuLyoqXG4gKiBBdXRoZW50aWNhdGUgYSBSQU1MIEFQSSBjbGllbnQgcGFzc2luZyBhbiBvcHRpb25hbCBtZXRob2QgYW5kIGFjY29tcGFueWluZ1xuICogb3B0aW9ucyBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2xpZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gICBtZXRob2RcbiAqIEBwYXJhbSB7T2JqZWN0fSAgIG9wdGlvbnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAqL1xuQVBJLmF1dGhlbnRpY2F0ZSA9IGZ1bmN0aW9uIChjbGllbnQsIG1ldGhvZCwgb3B0aW9ucywgZG9uZSkge1xuICBBcHAuX2V4ZWN1dGVDb250ZXh0LnRpbWVvdXQoMTAgKiA2MCAqIDEwMDApO1xuICBkb25lID0gZG9uZSB8fCBBcHAuX2V4ZWN1dGVDb250ZXh0LmFzeW5jKCk7XG5cbiAgdmFyIGNsaWVudE9wdGlvbiAgICA9IGNsaWVudFsnIWNsaWVudCddO1xuICB2YXIgc2VjdXJpdHlTY2hlbWVzID0gY2xpZW50T3B0aW9uLnNlY3VyaXR5U2NoZW1lcztcblxuICAvLyBFeHRlbmQgcGFzc2VkIGluIG9wdGlvbnMgd2l0aCBnbG9iYWwgb3B0aW9ucyAoZm9yIGBiYXNlVXJpUGFyYW1ldGVyc2ApLlxuICBvcHRpb25zID0gXy5leHRlbmQoe30sIG9wdGlvbnMsIGNsaWVudFsnIWNvbmZpZyddKTtcblxuICAvKipcbiAgICogVGhlIGNhbGxiYWNrIGlzIHVzZWQgdG8gaGFuZGxlIHRoZSBwZXJzaXN0ZW5jZSBvZiBkYXRhIHRvIHRoZSBjbGllbnQuXG4gICAqXG4gICAqIEBwYXJhbSAge0Vycm9yfSAgICBlcnJcbiAgICogQHBhcmFtICB7T2JqZWN0fSAgIHNjaGVtZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgb3B0aW9uc1xuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgdG9rZW5zXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgKi9cbiAgdmFyIGNiID0gZnVuY3Rpb24gKGVyciwgc2NoZW1lLCBvcHRpb25zLCB0b2tlbnMpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICByZXR1cm4gZG9uZShlcnIpO1xuICAgIH1cblxuICAgIC8vIEFsaWFzIG9udG8gdGhlIGNsaWVudCBvYmplY3QgZm9yIGZ1dHVyZSB1c2UuXG4gICAgY2xpZW50T3B0aW9uLmF1dGhlbnRpY2F0aW9uW3NjaGVtZS50eXBlXSA9IF8uZXh0ZW5kKHt9LCBvcHRpb25zLCB0b2tlbnMpO1xuXG4gICAgLy8gU2V0IHByaXZhdGUgZmllbGRzIHRvIGFzdGVyaXNrcyBvZiBhbiBhcmJpdHJhcnkgbGVuZ3RoLlxuICAgIF8uZWFjaCh0b2tlbnMsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICBpZiAoYXV0aGVudGljYXRlLlNFQ1JFVF9GSUVMRFNba2V5XSkge1xuICAgICAgICB0b2tlbnNba2V5XSA9IG5ldyBBcnJheShNYXRoLmNlaWwodmFsdWUubGVuZ3RoIC8gNSkgKiA1KS5qb2luKCcqJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZG9uZShudWxsLCB0b2tlbnMpO1xuICB9O1xuXG4gIHJldHVybiBhdXRoZW50aWNhdGUoc2VjdXJpdHlTY2hlbWVzLCBtZXRob2QsIG9wdGlvbnMsIGNiKTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgQVBJIGNsaWVudCBhdXRoZW50aWNhdG9yLlxuICovXG5BUEkuYXV0aGVudGljYXRlW0RFU0NSSVBUSU9OX1BST1BFUlRZXSA9IHtcbiAgJyF0eXBlJzogW1xuICAgICdmbihjbGllbnQsIG1ldGhvZD8sIG9wdGlvbnM/LCBjYj8pJ1xuICBdLmpvaW4oJycpLFxuICAnIWFyZ3MnOiBbe1xuICAgICchdHlwZSc6ICdmbigpJyxcbiAgICAnIWRvYyc6ICdBIGZ1bmN0aW9uIGdlbmVyYXRlZCBieSBgQVBJLmNyZWF0ZUNsaWVudGAuJ1xuICB9LCB7XG4gICAgJyF0eXBlJzogJ3N0cmluZycsXG4gICAgJyFkb2MnOiAnU2VsZWN0IGFuIGF1dGhlbnRpY2F0aW9uIG1ldGhvZCBkZWZpbmVkIGluIHRoZSBSQU1MIGZpbGUuJ1xuICB9LCB7XG4gICAgJyF0eXBlJzogJ29iamVjdCcsXG4gICAgJyFkb2MnOiAnT3ZlcnJpZGUgdGhlIGRlZmF1bHQgc2VsZWN0ZWQgYXV0aGVudGljYXRpb24gbWV0aG9kIG9wdGlvbnMuJ1xuICB9LCB7XG4gICAgJyF0eXBlJzogJ2ZuKGVycm9yLCByZXNwb25zZSknXG4gIH1dLFxuICAnIWRvYyc6IFtcbiAgICAnQXV0aGVudGljYXRpb24gcGFyYW1ldGVycyBhcmUgb3B0aW9uYWwuIEZvciBwb3B1bGFyIEFQSXMsIHdlIHByb3ZpZGUnLFxuICAgICdrZXlzLiBJZiB3ZSBuZWVkIHlvdXIga2V5cyB3ZSB3aWxsIHByb21wdCB5b3UgdmlhIGEgbW9kYWwuIE5ldmVyIGVudGVyJyxcbiAgICAna2V5cyBkaXJlY3RseSBpbnRvIGEgbm90ZWJvb2sgdW5sZXNzIHlvdSBleHBsaWNpdGx5IGludGVuZCB0byBzaGFyZScsXG4gICAgJ3RoZW0uIElmIHlvdSB3b3VsZCBsaWtlIHRvIGtub3cgbW9yZSBhYm91dCBhdXRoZW50aWNhdGluZycsXG4gICAgJ3dpdGggdGhpcyBBUEksIHNlZSBcXCdzZWN1cml0eVNjaGVtZS5zZXR0aW5nc1xcJyBpbiB0aGUgUkFNTCBmaWxlLidcbiAgXS5qb2luKCcgJylcbn07XG5cbi8qKlxuICogQWx0ZXIgdGhlIGNvbnRleHQgdG8gaW5jbHVkZSB0aGUgUkFNTCBjbGllbnQgZ2VuZXJhdG9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSAgIGRhdGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG5leHRcbiAqL1xuZXhwb3J0c1snc2FuZGJveDpjb250ZXh0J10gPSBmdW5jdGlvbiAoY29udGV4dCwgbmV4dCkge1xuICAvLyBUaGlzIGlzIGV4dHJlbWVseSBqYW5reSwgYnV0IGlzIHJlcXVpcmVkIGZvciBTYWZhcmkgNy4wIHdoaWNoIHNlZW1zIHRvXG4gIC8vIGJlIGlnbm9yaW5nIGRpcmVjdCBwcm9wZXJ0eSBhc3NpZ25tZW50cyB1bmRlciBjZXJ0YWluIGNvbmRpdGlvbnMuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb250ZXh0LCAnQVBJJywgeyB2YWx1ZTogQVBJIH0pO1xuICByZXR1cm4gbmV4dCgpO1xufTtcbiIsIi8qIGdsb2JhbCBBcHAgKi9cbnZhciBhcGlLZXlzID0ge1wiZ2l0aHViXCI6e1wiY2xpZW50SWRcIjpcInN0ZXBoYW5lc2FuXCIsXCJjbGllbnRTZWNyZXRcIjpcIi4uLlwifX0ucmFtbENsaWVudDtcblxuLyoqXG4gKiBDaGVjayBhZ2FpbnN0IG91ciBPQXV0aCB0b2tlbnMgYW5kIGluamVjdCB0aGUgdG9rZW5zIHdlIGhhdmUgYXZhaWxhYmxlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSAgIGRhdGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG5leHRcbiAqL1xuQXBwLm1pZGRsZXdhcmUucmVnaXN0ZXIoJ3JhbWxDbGllbnQ6dG9rZW4nLCBmdW5jdGlvbiAoc2NoZW1lLCBuZXh0LCBkb25lKSB7XG4gIHZhciBhdXRoVXJpID0gc2NoZW1lLnNldHRpbmdzLmF1dGhvcml6YXRpb25Vcmk7XG5cbiAgaWYgKHNjaGVtZS50eXBlID09PSAnT0F1dGggMS4wJyAmJiBhcGlLZXlzLm9hdXRoMVthdXRoVXJpXSkge1xuICAgIHJldHVybiBkb25lKG51bGwsIGFwaUtleXMub2F1dGgxW2F1dGhVcmldKTtcbiAgfVxuXG4gIGlmIChzY2hlbWUudHlwZSA9PT0gJ09BdXRoIDIuMCcgJiYgYXBpS2V5cy5vYXV0aDJbYXV0aFVyaV0pIHtcbiAgICByZXR1cm4gZG9uZShudWxsLCBhcGlLZXlzLm9hdXRoMlthdXRoVXJpXSk7XG4gIH1cblxuICByZXR1cm4gbmV4dCgpO1xufSk7XG4iLCIvKiBnbG9iYWwgQXBwICovXG52YXIgXyAgICAgICAgICA9IEFwcC5MaWJyYXJ5Ll87XG52YXIgcXMgICAgICAgICA9IEFwcC5MaWJyYXJ5LnFzO1xudmFyIGRvbWlmeSAgICAgPSBBcHAuTGlicmFyeS5kb21pZnk7XG52YXIgQmFja2JvbmUgICA9IEFwcC5MaWJyYXJ5LkJhY2tib25lO1xudmFyIGNoYW5nZUNhc2UgPSBBcHAuTGlicmFyeS5jaGFuZ2VDYXNlO1xuXG52YXIgQkFTRV9VUkkgPSAnaHR0cHM6Ly9hbnlwb2ludC5tdWxlc29mdC5jb20vYXBpcGxhdGZvcm0vcmVwb3NpdG9yeS92MicgK1xuICAnL3B1YmxpYy9hcGlzJztcbnZhciBJVEVNU19QRVJfUEFHRSA9IDEwO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBhcGkgY2xpZW50IGNlbGwgdGhhdCBjYW4gbG9hZCB0aGUgc2VsZWN0ZWQgYXBpIGRvY3VtZW50LlxuICpcbiAqIEBwYXJhbSAge0NlbGx9ICAgICBjZWxsXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgaW52b2tlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xudmFyIGNyZWF0ZUFwaUNsaWVudENlbGwgPSBmdW5jdGlvbiAoY2VsbCwgaW52b2tlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZXJyLCBhcGksIHZlcnNpb24pIHtcbiAgICBpZiAoZXJyKSB7IHJldHVybjsgfVxuXG4gICAgLy8gQ29udmVydCB0aGUgQVBJIG5hbWUgaW50byBhIHZhcmlhYmxlIGZvciB1c2UuXG4gICAgdmFyIHZhcmlhYmxlID0gY2hhbmdlQ2FzZS5jYW1lbENhc2UoYXBpLm5hbWUpO1xuXG4gICAgLy8gQ3JlYXRlIHRoZSB2aWV3IHdpdGggYXBpIGNyZWF0aW9uIGRldGFpbHMuXG4gICAgdmFyIHZpZXcgPSBjZWxsLm5vdGVib29rW2ludm9rZSArICdDb2RlVmlldyddKGNlbGwuZWwsIFtcbiAgICAgICcvLyBSZWFkIGFib3V0IHRoZSAnICsgYXBpLm5hbWUgKyAnIGF0ICcgKyB2ZXJzaW9uLnBvcnRhbFVybCxcbiAgICAgICdBUEkuY3JlYXRlQ2xpZW50KFxcJycgKyB2YXJpYWJsZSArICdcXCcsIFxcJycgKyB2ZXJzaW9uLnJhbWxVcmwgKyAnXFwnKTsnXG4gICAgXS5qb2luKCdcXG4nKSkuZXhlY3V0ZSgpO1xuXG4gICAgY2VsbC5mb2N1cygpO1xuXG4gICAgLy8gVHJpZ2dlciBhIHJhbWwgY2xpZW50IGluc2VydGlvbiBtZXNzYWdlLlxuICAgIEFwcC5tZXNzYWdlcy50cmlnZ2VyKCdyYW1sQ2xpZW50Omluc2VydCcpO1xuXG4gICAgcmV0dXJuIHZpZXc7XG4gIH07XG59O1xuXG4vKipcbiAqIFNob3cgUkFNTCBkZWZpbml0aW9ucyB0byB1c2VycyBpbiBhIG1vZGFsLCBhbmQgdXBvbiBzZWxlY3Rpb24gcGFzcyB0aGVcbiAqIHNlbGVjdGVkIGRlZmluaXRpb24gYmFjayB0byB0aGUgY2FsbGJhY2suXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICovXG52YXIgc2VsZWN0QVBJRGVmaW5pdGlvbiA9IGZ1bmN0aW9uIChkb25lKSB7XG4gIC8vIFRyaWdnZXIgbW9kYWwgZGlzcGxheSBtZXNzYWdlcy5cbiAgQXBwLm1lc3NhZ2VzLnRyaWdnZXIoJ3JhbWxDbGllbnQ6bW9kYWwnKTtcblxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgc2VhcmNoIHNwZWNpZmljYXRpb24gb2JqZWN0LCBwYXNzZWQgdG8gdGhlIG1pZGRsZXdhcmUgbGF5ZXIuXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICB2YXIgc2VhcmNoU3BlYyA9IHtcbiAgICBvZmZzZXQ6IDAsXG4gICAgbGltaXQ6ICBJVEVNU19QRVJfUEFHRSxcbiAgICBxdWVyeTogICcnXG4gIH07XG5cbiAgcmV0dXJuIEFwcC5taWRkbGV3YXJlLnRyaWdnZXIoJ3VpOm1vZGFsJywge1xuICAgIHRpdGxlOiAnSW5zZXJ0IGFuIEFQSSBDbGllbnQnLFxuICAgIGNvbnRlbnQ6IGZ1bmN0aW9uIChkb25lKSB7XG4gICAgICByZXR1cm4gZG9uZShudWxsLCAnPGRpdiBjbGFzcz1cIm1vZGFsLWluc3RydWN0aW9uc1wiPicgK1xuICAgICAgICAnSW5zZXJ0IGFuIEFQSSBjbGllbnQgZnJvbSBhIFJBTUwgc3BlY2lmaWNhdGlvbi4gQW4gQVBJIGNsaWVudCBpcyAnICtcbiAgICAgICAgJ2EgSmF2YVNjcmlwdCByZXByZXNlbnRhdGlvbiBvZiBhbiBBUEkgdGhhdCB5b3UgY2FuIHVzZSB0byBleHBsb3JlICcgK1xuICAgICAgICAnYXZhaWxhYmxlIGVuZHBvaW50cyBhbmQgdGhlaXIgcGFyYW1ldGVycy4gJyArXG4gICAgICAgICc8YSBocmVmPVwiaHR0cDovL3JhbWwub3JnL1wiIHRhcmdldD1cIl9ibGFua1wiPicgK1xuICAgICAgICAnTGVhcm4gbW9yZSBhYm91dCBSQU1MPC9hPi4nICtcbiAgICAgICAgJzwvZGl2PicgK1xuICAgICAgICAnPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIj4nICtcbiAgICAgICAgJzxpbnB1dCBjbGFzcz1cIml0ZW0tc2VhcmNoXCIgcGxhY2Vob2xkZXI9XCJTZWFyY2hcIj4nICtcbiAgICAgICAgJzwvZGl2PicgK1xuICAgICAgICAnPGRpdiBjbGFzcz1cIml0ZW1zLWxvYWRpbmdcIiAnICtcbiAgICAgICAgJ3N0eWxlPVwidGV4dC1hbGlnbjogY2VudGVyOyBmb250LXNpemU6IDNlbTtcIj4nICtcbiAgICAgICAgJzxpIGNsYXNzPVwiaWNvbi1hcnJvd3MtY3cgYW5pbWF0ZS1zcGluXCI+PC9pPicgK1xuICAgICAgICAnPC9kaXY+JyArXG4gICAgICAgICc8ZGl2IGNsYXNzPVwiaXRlbXMtY29udGFpbmVyIGNsZWFyZml4XCI+JyArXG4gICAgICAgICc8ZGl2IGNsYXNzPVwiaXRlbXMtY29udGFpbmVyLXRvdGFsXCI+PC9kaXY+JyArXG4gICAgICAgICc8dWwgY2xhc3M9XCJpdGVtcy1saXN0XCI+PC91bD4nICtcbiAgICAgICAgJzxidXR0b24gY2xhc3M9XCJidG4tc2Vjb25kYXJ5IGl0ZW1zLXByZXYtYnRuXCIgc3R5bGU9XCJmbG9hdDogbGVmdFwiPicgK1xuICAgICAgICAnUHJldmlvdXM8L2J1dHRvbj4nICtcbiAgICAgICAgJzxidXR0b24gY2xhc3M9XCJidG4tc2Vjb25kYXJ5IGl0ZW1zLW5leHQtYnRuXCIgc3R5bGU9XCJmbG9hdDogcmlnaHRcIj4nICtcbiAgICAgICAgJ05leHQ8L2J1dHRvbj4nICtcbiAgICAgICAgJzwvZGl2PicgK1xuICAgICAgICAnPHAgY2xhc3M9XCJpdGVtcy11bmF2YWlsYWJsZVwiPk5vIG1hdGNoaW5nIEFQSXMgZm91bmQuPC9wPidcbiAgICAgICk7XG4gICAgfSxcbiAgICBzaG93OiBmdW5jdGlvbiAobW9kYWwpIHtcbiAgICAgIHZhciBpdGVtc0VsICAgICAgICAgICAgPSBtb2RhbC5lbC5xdWVyeVNlbGVjdG9yKCcuaXRlbXMtY29udGFpbmVyJyk7XG4gICAgICB2YXIgaXRlbXNMaXN0RWwgICAgICAgID0gaXRlbXNFbC5xdWVyeVNlbGVjdG9yKCcuaXRlbXMtbGlzdCcpO1xuICAgICAgdmFyIGl0ZW1zTG9hZGluZ0VsICAgICA9IG1vZGFsLmVsLnF1ZXJ5U2VsZWN0b3IoJy5pdGVtcy1sb2FkaW5nJyk7XG4gICAgICB2YXIgaXRlbXNOZXh0QnRuRWwgICAgID0gaXRlbXNFbC5xdWVyeVNlbGVjdG9yKCcuaXRlbXMtbmV4dC1idG4nKTtcbiAgICAgIHZhciBpdGVtc1ByZXZCdG5FbCAgICAgPSBpdGVtc0VsLnF1ZXJ5U2VsZWN0b3IoJy5pdGVtcy1wcmV2LWJ0bicpO1xuICAgICAgdmFyIGl0ZW1zVW5hdmFpbGFibGVFbCA9IG1vZGFsLmVsLnF1ZXJ5U2VsZWN0b3IoJy5pdGVtcy11bmF2YWlsYWJsZScpO1xuICAgICAgdmFyIHRvdGFsSXRlbXNFbCAgICAgICA9IG1vZGFsLmVsLnF1ZXJ5U2VsZWN0b3IoJy5pdGVtcy1jb250YWluZXItdG90YWwnKTtcbiAgICAgIHZhciBzZWFyY2hJZDtcblxuICAgICAgLyoqXG4gICAgICAgKiBMb2FkIGFsbCB0aGUgQVBJIGRlZmluaXRpb25zIGFuZCByZXR1cm4gdGhlIGl0ZW1zIGFzIGFuIGFycmF5LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICAgICAqL1xuICAgICAgdmFyIGxvYWRBUElEZWZpbml0aW9ucyA9IGZ1bmN0aW9uIChzZWFyY2gsIGRvbmUpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRTZWFyY2hJZCA9IE1hdGgucmFuZG9tKCk7XG5cbiAgICAgICAgLy8gVHJhY2sgY3VycmVudCBzZWFyY2ggaW5kZXguXG4gICAgICAgIHNlYXJjaElkID0gY3VycmVudFNlYXJjaElkO1xuXG4gICAgICAgIC8vIFJlc2V0IGVsZW1lbnQgc3RhdGVzIGFuZCBzaG93IGEgbG9hZGluZyBpbmRpY2F0b3IuXG4gICAgICAgIGl0ZW1zRWwuY2xhc3NMaXN0LmFkZCgnaGlkZScpO1xuICAgICAgICBpdGVtc1VuYXZhaWxhYmxlRWwuY2xhc3NMaXN0LmFkZCgnaGlkZScpO1xuICAgICAgICBpdGVtc0xvYWRpbmdFbC5jbGFzc0xpc3QucmVtb3ZlKCdoaWRlJyk7XG5cbiAgICAgICAgLy8gU2V0IGJvdGggYnV0dG9ucyB0byBkaXNhYmxlZCBmb3Igbm93LlxuICAgICAgICBpdGVtc05leHRCdG5FbC5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgJ2Rpc2FibGVkJyk7XG4gICAgICAgIGl0ZW1zUHJldkJ0bkVsLnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCAnZGlzYWJsZWQnKTtcblxuICAgICAgICByZXR1cm4gQXBwLm1pZGRsZXdhcmUudHJpZ2dlcihcbiAgICAgICAgICAncmFtbENsaWVudDpzZWFyY2gnLFxuICAgICAgICAgIHNlYXJjaCxcbiAgICAgICAgICBmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAgICAgICAgICAvLyBTa2lwIHVwZGF0ZXMgd2hlbiB0aGUgSUQgaGFzIGNoYW5nZWQuXG4gICAgICAgICAgICBpZiAoY3VycmVudFNlYXJjaElkICE9PSBzZWFyY2hJZCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBkb25lKGVyciwgZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBSZW5kZXIgdGhlIHNlYXJjaCByZXN1bHRzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7RXJyb3J9ICBlcnJcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZXN1bHRcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSByZXN1bHQudG90YWxcbiAgICAgICAqIEBwYXJhbSB7QXJyYXl9ICByZXN1bHQuaXRlbXNcbiAgICAgICAqL1xuICAgICAgdmFyIHVwZGF0ZVJlc3VsdHMgPSBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcbiAgICAgICAgLy8gQWx3YXlzIHJlbW92ZSB0aGUgbG9hZGluZyBpbmRpY2F0b3IuXG4gICAgICAgIGl0ZW1zTG9hZGluZ0VsLmNsYXNzTGlzdC5hZGQoJ2hpZGUnKTtcblxuICAgICAgICAvLyBFbXB0eSB0aGUgbGlzdCBiZWZvcmUgd2UgcG9wdWxhdGUgaXQgYWdhaW4uXG4gICAgICAgIGl0ZW1zTGlzdEVsLmlubmVySFRNTCA9ICcnO1xuICAgICAgICB0b3RhbEl0ZW1zRWwuaW5uZXJIVE1MID0gJyc7XG5cbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiBkb25lKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0Lml0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBpdGVtc1VuYXZhaWxhYmxlRWwuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdG90YWxJdGVtc0VsLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFxuICAgICAgICAgICdTaG93aW5nICcgKyByZXN1bHQuaXRlbXMubGVuZ3RoICsgJyBvZiAnICsgcmVzdWx0LnRvdGFsICsgJyByZXN1bHRzJ1xuICAgICAgICApKTtcblxuICAgICAgICBpdGVtc0VsLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGUnKTtcblxuICAgICAgICAvLyBJZiB0aGUgb2Zmc2V0IGlzIHBhc3QgdGhlIGZpcnN0IHBhZ2UsIGFsbG93IGdvaW5nIGJhY2suXG4gICAgICAgIGlmIChzZWFyY2hTcGVjLm9mZnNldCA+IDApIHtcbiAgICAgICAgICBpdGVtc1ByZXZCdG5FbC5yZW1vdmVBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgb2Zmc2V0IGNhbiBzdGlsbCBtb3ZlIGJlZm9yZSBoaXR0aW5nIHRoZSBsYXN0IHJlc3VsdCwgYWxsb3cuXG4gICAgICAgIGlmIChzZWFyY2hTcGVjLm9mZnNldCA8IHJlc3VsdC50b3RhbCAtIHNlYXJjaFNwZWMubGltaXQpIHtcbiAgICAgICAgICBpdGVtc05leHRCdG5FbC5yZW1vdmVBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJdGVyYXRlIG92ZXIgZWFjaCB2ZXJzaW9uIGFuZCBhcHBlbmQgdG8gdGhlIGl0ZW0gbGlzdC5cbiAgICAgICAgXy5lYWNoKHJlc3VsdC5pdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICB2YXIgbmFtZSA9IF8uZXNjYXBlKGl0ZW0ubmFtZSk7XG4gICAgICAgICAgdmFyIG1hc3Rlck9yZyA9IF8uZXNjYXBlKGl0ZW0udmVyc2lvbnNbMF0ubWFzdGVyT3JnYW5pemF0aW9uTmFtZSk7XG5cbiAgICAgICAgICB2YXIgZWwgPSBkb21pZnkoW1xuICAgICAgICAgICAgJzxsaT4nLFxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJpdGVtLWluZm8gY2xlYXJmaXhcIj4nLFxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJpdGVtLWFjdGlvblwiPicsXG4gICAgICAgICAgICAnPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tcHJpbWFyeSBidG4tc21hbGwgaXRlbS1hZGRcIj5BZGQ8L2J1dHRvbj4nLFxuICAgICAgICAgICAgJzwvZGl2PicsXG4gICAgICAgICAgICAnPGEgaHJlZj1cIiNcIiBjbGFzcz1cIml0ZW0tbGlua1wiPkFsbCB2ZXJzaW9uczwvYT4nLFxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJpdGVtLW5hbWVcIj4nICtcbiAgICAgICAgICAgIG5hbWUgKyAnIDxzbWFsbD4nICsgbWFzdGVyT3JnICsgJzwvc21hbGw+JyArXG4gICAgICAgICAgICAnPC9kaXY+JyxcbiAgICAgICAgICAgICc8L2Rpdj4nLFxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJpdGVtLXZlcnNpb25zXCI+JyxcbiAgICAgICAgICAgIF8ubWFwKGl0ZW0udmVyc2lvbnMsIGZ1bmN0aW9uICh2ZXJzaW9uLCBpbmRleCkge1xuICAgICAgICAgICAgICB2YXIgbmFtZSAgICAgICAgPSBfLmVzY2FwZSh2ZXJzaW9uLm5hbWUpO1xuICAgICAgICAgICAgICB2YXIgZGVzY3JpcHRpb24gPSBfLmVzY2FwZSh2ZXJzaW9uLmRlc2NyaXB0aW9uKS50cmltKCk7XG4gICAgICAgICAgICAgIHZhciBwb3J0YWxVcmwgICA9IF8uZXNjYXBlKHZlcnNpb24ucG9ydGFsVXJsKTtcblxuICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiaXRlbS12ZXJzaW9uIGNsZWFyZml4XCI+JyxcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cIml0ZW0tYWN0aW9uXCI+JyxcbiAgICAgICAgICAgICAgICAnPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tcHJpbWFyeSBidG4tc21hbGwgaXRlbS1hZGRcIiAnICtcbiAgICAgICAgICAgICAgICAnZGF0YS1pbmRleD1cIicgKyBpbmRleCArICdcIj4nLFxuICAgICAgICAgICAgICAgICdTZWxlY3QnLFxuICAgICAgICAgICAgICAgICc8L2J1dHRvbj4nLFxuICAgICAgICAgICAgICAgICc8L2Rpdj4nLFxuICAgICAgICAgICAgICAgICc8YSBocmVmPVwiJyArIHBvcnRhbFVybCArICdcIiBjbGFzcz1cIml0ZW0tbGluayAnICtcbiAgICAgICAgICAgICAgICAnaXRlbS1yZWFkLW1vcmVcIiB0YXJnZXQ9XCJfYmxhbmtcIj5SZWFkIG1vcmU8L2E+JyxcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cIml0ZW0tbmFtZVwiPicsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb24gP1xuICAgICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwiaGludC0tdG9wXCIgZGF0YS1oaW50PVwiJyArIGRlc2NyaXB0aW9uICsgJ1wiPicgOlxuICAgICAgICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbiA/ICc8L3NwYW4+JyA6ICcnLFxuICAgICAgICAgICAgICAgICc8L2Rpdj4nLFxuICAgICAgICAgICAgICAgICc8L2Rpdj4nXG4gICAgICAgICAgICAgIF0uam9pbignXFxuJyk7XG4gICAgICAgICAgICB9KS5qb2luKCdcXG4nKSxcbiAgICAgICAgICAgICc8L2Rpdj4nLFxuICAgICAgICAgICAgJzwvbGk+J1xuICAgICAgICAgIF0uam9pbignXFxuJykpO1xuXG4gICAgICAgICAgaXRlbXNMaXN0RWwuYXBwZW5kQ2hpbGQoZWwpO1xuXG4gICAgICAgICAgLy8gV2hlbiB0aGUgZWxlbWVudCBpcyBjbGlja2VkLCByZW5kZXIgdGhlIGNvZGUgY2VsbC5cbiAgICAgICAgICBCYWNrYm9uZS4kKGVsKVxuICAgICAgICAgICAgLm9uKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIC8vIERvIG5vdGhpbmcgaWYgdGhlIHJlYWQgbW9yZSBsaW5rIGlzIGNsaWNrZWQuXG4gICAgICAgICAgICAgIGlmIChlLnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ2l0ZW0tcmVhZC1tb3JlJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBQcmV2ZW50IGZvbGxvd2luZyBvZiBsaW5rcy5cbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICAgIHZhciBtZXRob2QgPSAnYWRkJztcblxuICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGF0dHJpYnV0ZSBpZiBpdCBleGlzdHMuXG4gICAgICAgICAgICAgIGlmIChlbC5jbGFzc0xpc3QuY29udGFpbnMoJ2l0ZW0tdmlzaWJsZScpKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gJ3JlbW92ZSc7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBlbC5jbGFzc0xpc3RbbWV0aG9kXSgnaXRlbS12aXNpYmxlJyk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdjbGljaycsICcuaXRlbS1hZGQnLCBmdW5jdGlvbiAoZSwgZWwpIHtcbiAgICAgICAgICAgICAgbW9kYWwuY2xvc2UoKTtcbiAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgICAvLyBSZXNvbHZlIHRvIHRoZSBjbGlja2VkIEFQSSB2ZXJzaW9uLCBvciBcImxhdGVzdFwiLlxuICAgICAgICAgICAgICB2YXIgdmVyc2lvbiA9IGl0ZW0udmVyc2lvbnNbZWwuZ2V0QXR0cmlidXRlKCdkYXRhLWluZGV4JykgfHwgMF07XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGRvbmUobnVsbCwgaXRlbSwgdmVyc2lvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBCYWNrYm9uZS4kKG1vZGFsLmVsKVxuICAgICAgICAub24oJ2NsaWNrJywgJy5pdGVtcy1uZXh0LWJ0bicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gbG9hZEFQSURlZmluaXRpb25zKF8uZXh0ZW5kKHNlYXJjaFNwZWMsIHtcbiAgICAgICAgICAgIG9mZnNldDogc2VhcmNoU3BlYy5vZmZzZXQgKyBJVEVNU19QRVJfUEFHRVxuICAgICAgICAgIH0pLCB1cGRhdGVSZXN1bHRzKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdjbGljaycsICcuaXRlbXMtcHJldi1idG4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGxvYWRBUElEZWZpbml0aW9ucyhfLmV4dGVuZChzZWFyY2hTcGVjLCB7XG4gICAgICAgICAgICBvZmZzZXQ6IHNlYXJjaFNwZWMub2Zmc2V0IC0gSVRFTVNfUEVSX1BBR0VcbiAgICAgICAgICB9KSwgdXBkYXRlUmVzdWx0cyk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbigna2V5dXAnLCAnLml0ZW0tc2VhcmNoJywgXy50aHJvdHRsZShmdW5jdGlvbiAoZSwgZWwpIHtcbiAgICAgICAgICAvLyBBdm9pZCB1cGRhdGluZyB3aGVuIHRoZSB2YWx1ZSBoYXNuJ3QgY2hhbmdlZC5cbiAgICAgICAgICBpZiAoc2VhcmNoU3BlYy5xdWVyeSA9PT0gZWwudmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbG9hZEFQSURlZmluaXRpb25zKF8uZXh0ZW5kKHNlYXJjaFNwZWMsIHtcbiAgICAgICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgICAgIHF1ZXJ5OiAgZWwudmFsdWVcbiAgICAgICAgICB9KSwgdXBkYXRlUmVzdWx0cyk7XG4gICAgICAgIH0sIDcwMCkpO1xuXG4gICAgICByZXR1cm4gbG9hZEFQSURlZmluaXRpb25zKHNlYXJjaFNwZWMsIHVwZGF0ZVJlc3VsdHMpO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIEluc2VydHMgYSBuZXcgY29kZSBjZWxsIGFib3ZlIHdpdGggYSBSQU1MIEFQSSBjbGllbnQgYW5kIGV4ZWN1dGVzIGl0LlxuICovXG5BcHAuVmlldy5FZGl0b3JDZWxsLnByb3RvdHlwZS5uZXdSQU1MQWJvdmUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBzZWxlY3RBUElEZWZpbml0aW9uKGNyZWF0ZUFwaUNsaWVudENlbGwodGhpcywgJ3ByZXBlbmQnKSk7XG59O1xuXG4vKipcbiAqIEluc2VydHMgYSBuZXcgY29kZSBjZWxsIGJlbG93IHdpdGggYSBSQU1MIEFQSSBjbGllbnQgYW5kIGV4ZWN1dGVzIGl0LlxuICovXG5BcHAuVmlldy5FZGl0b3JDZWxsLnByb3RvdHlwZS5uZXdSQU1MQmVsb3cgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBzZWxlY3RBUElEZWZpbml0aW9uKGNyZWF0ZUFwaUNsaWVudENlbGwodGhpcywgJ2FwcGVuZCcpKTtcbn07XG5cbi8qKlxuICogSW5zZXJ0IGEgUkFNTCBkb2N1bWVudCBieSB1c2luZyB0aGUgY2VsbCBib3JkZXIgYnV0dG9ucy5cbiAqL1xuQXBwLlZpZXcuQ2VsbEJ1dHRvbnMuY29udHJvbHMucHVzaCh7XG4gIGxhYmVsOiAgICdJbnNlcnQgQVBJIENsaWVudCcsXG4gIGNvbW1hbmQ6ICduZXdSQU1MJ1xufSk7XG5cbi8qKlxuICogSW5zZXJ0IGEgUkFNTCBkb2N1bWVudCBieSB1c2luZyB0aGUgY2VsbCBtZW51IGJ1dHRvbnMuXG4gKi9cbkFwcC5WaWV3LkNvZGVDZWxsLnByb3RvdHlwZS5jZWxsQ29udHJvbHMucHVzaCh7XG4gIGxhYmVsOiAgICdJbnNlcnQgQVBJIENsaWVudCcsXG4gIGNvbW1hbmQ6ICduZXdSQU1MQmVsb3cnXG59KTtcblxuLyoqXG4gKiBSZWdpc3RlciB0aGUgYmFzaWMgcmFtbCBjbGllbnQgc2VhcmNoIG1pZGRsZXdhcmUuXG4gKi9cbkFwcC5taWRkbGV3YXJlLnJlZ2lzdGVyKCdyYW1sQ2xpZW50OnNlYXJjaCcsIGZ1bmN0aW9uIChzZWFyY2gsIG5leHQsIGRvbmUpIHtcbiAgdmFyIHVybCA9IEJBU0VfVVJJICsgJz8nICsgcXMuc3RyaW5naWZ5KHtcbiAgICBzb3J0OiAgICAgICAgJ25hbWUnLFxuICAgIGFzY2VuZGluZzogICB0cnVlLFxuICAgIHJlcXVpcmVSYW1sOiB0cnVlLFxuICAgIGxpbWl0OiAgICAgICBzZWFyY2gubGltaXQsXG4gICAgb2Zmc2V0OiAgICAgIHNlYXJjaC5vZmZzZXQsXG4gICAgcXVlcnk6ICAgICAgIHNlYXJjaC5xdWVyeVxuICB9KTtcblxuICByZXR1cm4gQXBwLm1pZGRsZXdhcmUudHJpZ2dlcignYWpheCcsIHtcbiAgICB1cmw6IHVybFxuICB9LCBmdW5jdGlvbiAoZXJyLCB4aHIpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIHZhciBkYXRhID0ge307XG5cbiAgICBpZiAoZXJyKSB7XG4gICAgICByZXR1cm4gZG9uZShlcnIpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBkb25lKGUpO1xuICAgIH1cblxuICAgIGRhdGEuaXRlbXMgPSByZXN1bHQuYXBpcztcbiAgICBkYXRhLnRvdGFsID0gcmVzdWx0LnRvdGFsO1xuXG4gICAgcmV0dXJuIGRvbmUobnVsbCwgZGF0YSk7XG4gIH0pO1xufSk7XG4iXX0=
